<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_class_s_v_f_1_1_cond_p_t_a_impl" xml:lang="en-US">
<title>SVF::CondPTAImpl&lt; Cond &gt; Class Template Reference</title>
<indexterm><primary>SVF::CondPTAImpl&lt; Cond &gt;</primary></indexterm>
<para>
<computeroutput>#include &lt;PointerAnalysisImpl.h&gt;</computeroutput>
</para>
<para>Inheritance diagram for SVF::CondPTAImpl&lt; Cond &gt;:    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="class_s_v_f_1_1_cond_p_t_a_impl.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
<simplesect>
    <title>Public Types    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1af71b4ec9844701582d997466c2e4d94f"/>typedef <link linkend="_class_s_v_f_1_1_cond_var">CondVar</link>&lt; Cond &gt; <emphasis role="strong">CVar</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a3f2f48fc122c07ff9eb1382aa7a3f966"/>typedef <link linkend="_class_s_v_f_1_1_cond_std_set">CondStdSet</link>&lt; <link linkend="_class_s_v_f_1_1_cond_var">CVar</link> &gt; <emphasis role="strong">CPtSet</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1aca28ac25c0c3ca6bebbec2535c175230"/>typedef <link linkend="_class_s_v_f_1_1_p_t_data">PTData</link>&lt; <link linkend="_class_s_v_f_1_1_cond_var">CVar</link>, <link linkend="_class_s_v_f_1_1_cond_var">CVar</link>, <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &gt; <emphasis role="strong">PTDataTy</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1abc91ac8ebca1c22d08ddb357889d0fa8"/>typedef <link linkend="_class_s_v_f_1_1_mutable_p_t_data">MutablePTData</link>&lt; <link linkend="_class_s_v_f_1_1_cond_var">CVar</link>, <link linkend="_class_s_v_f_1_1_cond_var">CVar</link>, <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &gt; <emphasis role="strong">MutPTDataTy</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1aba828ca8e2aa2bd71b78be8b45a48c9b"/>typedef Map&lt; NodeID, PointsTo &gt; <emphasis role="strong">PtrToBVPtsMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a838c3f2be39d278072f7a9df7c0bcb4d"/>typedef Map&lt; NodeID, NodeSet &gt; <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a838c3f2be39d278072f7a9df7c0bcb4d">PtrToNSMap</link></para>

<para>map a pointer to its BitVector points-to representation </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a5043e9d9255d31777d038c48c809bb09"/>typedef Map&lt; NodeID, <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &gt; <emphasis role="strong">PtrToCPtsMap</emphasis></para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Public Member Functions    </title>
        <itemizedlist>
            <listitem><para><link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1adc5d33698377dc22aa1ae1151da13675">CondPTAImpl</link> (<link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> *<link linkend="_class_s_v_f_1_1_pointer_analysis_1a8771956f7595b66d825b3dc459d1ae49">pag</link>, <link linkend="_class_s_v_f_1_1_pointer_analysis_1a0b182ac680cce0547dbe7714c870ca85">PointerAnalysis::PTATY</link> type)</para>

<para>map a pointer to its conditional points-to set </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a01f64600bf6581403836019e4e5ae741"/>virtual <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a01f64600bf6581403836019e4e5ae741">~CondPTAImpl</link> ()</para>

<para>Destructor. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a5fa3d986e4ef710a2148b2854167c3ed"/>void <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a5fa3d986e4ef710a2148b2854167c3ed">destroy</link> ()</para>

<para>Release memory. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a35cb1fd6e18cdc8e8466ee94846bc553"/><link linkend="_class_s_v_f_1_1_p_t_data">PTDataTy</link> * <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a35cb1fd6e18cdc8e8466ee94846bc553">getPTDataTy</link> () const</para>

<para>Get points-to data. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1ab582d46731c06a7fa022bf301d6008c1"/><link linkend="_class_s_v_f_1_1_mutable_p_t_data">MutPTDataTy</link> * <emphasis role="strong">getMutPTDataTy</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a597e9c4e76f358c36d4b820c4d69ebc6"/>bool <emphasis role="strong">hasPtsMap</emphasis> (void) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a979486e35b529fbc62b2974899627113"/>const MutPTDataTy::PtsMap &amp; <emphasis role="strong">getPtsMap</emphasis> () const</para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Static Public Member Functions    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1ae76fb767c13ca39baa0fbec55a7780fe"/>static bool <emphasis role="strong">classof</emphasis> (const <link linkend="_class_s_v_f_1_1_pointer_analysis">PointerAnalysis</link> *pta)</para>
</listitem>
        </itemizedlist>
</simplesect>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1af960c10e49932ea5e9dcdd299ff300ce"/><link linkend="_class_s_v_f_1_1_p_t_data">PTDataTy</link> * <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1af960c10e49932ea5e9dcdd299ff300ce">ptD</link></para>

<para>Points-to data. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1ab4115f25e2e477bfd73d01f069f47241"/>bool <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1ab4115f25e2e477bfd73d01f069f47241">normalized</link></para>

<para>Normalized flag. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a30b9ee7b1dcd04285f92cf7accd05b2e"/>PtrToBVPtsMap <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a30b9ee7b1dcd04285f92cf7accd05b2e">ptrToBVPtsMap</link></para>

<para>Normal points-to representation (without conditions) </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a22c23f3ba1ee7e0aaccf0b8a1b58e33e"/><link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a838c3f2be39d278072f7a9df7c0bcb4d">PtrToNSMap</link> <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a22c23f3ba1ee7e0aaccf0b8a1b58e33e">objToNSRevPtsMap</link></para>

<para>Normal points-to representation (without conditions) </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a61167fcdb2005090de1b38e53450431a"/>PtrToCPtsMap <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a61167fcdb2005090de1b38e53450431a">ptrToCPtsMap</link></para>

<para>Conditional points-to representation (with conditions) </para>
</listitem>
            <listitem><para>virtual const <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &amp; <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a63fa2b3a96696ffc67a119c1ba5ce748">getPts</link> (<link linkend="_class_s_v_f_1_1_cond_var">CVar</link> id)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a0da0602c5b260afaba4bef1abcbcf7b3"/>virtual const Set&lt; <link linkend="_class_s_v_f_1_1_cond_var">CVar</link> &gt; &amp; <emphasis role="strong">getRevPts</emphasis> (<link linkend="_class_s_v_f_1_1_cond_var">CVar</link> nodeId)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1adfae199dfbe05c9c20052e0fc204e6de"/>virtual void <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1adfae199dfbe05c9c20052e0fc204e6de">clearPts</link> ()</para>

<para>Clear all data. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1adf0acbb0c605278e43d88787d651bbd8"/>bool <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1adf0acbb0c605278e43d88787d651bbd8">overlap</link> (const <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &amp;cpts1, const <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &amp;cpts2) const</para>

<para>Whether cpts1 and cpts2 have overlap points-to targets. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a87b48287d7edb97fc120200fe0e5218d"/>void <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a87b48287d7edb97fc120200fe0e5218d">expandFIObjs</link> (const <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &amp;cpts, <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &amp;expandedCpts)</para>

<para>Expand all fields of an aggregate in all points-to sets. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1aa260a3275fbec7061295306a58763d24"/>virtual void <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1aa260a3275fbec7061295306a58763d24">dumpCPts</link> ()</para>

<para>Print out conditional pts. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a94f3e4d073b8c5bab3c46058ddba3f43"/>virtual PointsTo <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a94f3e4d073b8c5bab3c46058ddba3f43">getBVPointsTo</link> (const <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &amp;cpts) const</para>

<para>Given a conditional pts return its bit vector points-to. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a0b96ba98239186d6d676f9540da9e590"/>virtual PointsTo &amp; <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a0b96ba98239186d6d676f9540da9e590">getPts</link> (NodeID ptr)</para>

<para>Given a pointer return its bit vector points-to. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a454a998ef5a866f2a6f270e3283c6ebd"/>virtual const <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &amp; <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a454a998ef5a866f2a6f270e3283c6ebd">getCondPointsTo</link> (NodeID ptr)</para>

<para>Given a pointer return its conditional points-to. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1aa266eef30817c557882de19aefe135a9"/>virtual NodeSet &amp; <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1aa266eef30817c557882de19aefe135a9">getRevPts</link> (NodeID obj)</para>

<para>Given an object return all pointers points to this object. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1afa6dffc1ac7e8dada1ff9e75b8cfd187"/>virtual AliasResult <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1afa6dffc1ac7e8dada1ff9e75b8cfd187">alias</link> (const MemoryLocation &amp;LocA, const MemoryLocation &amp;LocB)</para>

<para>Interface expose to users of our pointer analysis, given Location infos. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a171918ada9b679b0114b27476caa5ee6"/>virtual AliasResult <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a171918ada9b679b0114b27476caa5ee6">alias</link> (const Value *V1, const Value *V2)</para>

<para>Interface expose to users of our pointer analysis, given Value infos. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1ac18e1dc9c6fc8cc952f67a93c2491876"/>virtual AliasResult <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1ac18e1dc9c6fc8cc952f67a93c2491876">alias</link> (NodeID node1, NodeID node2)</para>

<para>Interface expose to users of our pointer analysis, given two pointers. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1adb1ed3728d53a13c94402392155e9913"/>virtual AliasResult <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1adb1ed3728d53a13c94402392155e9913">alias</link> (const <link linkend="_class_s_v_f_1_1_cond_var">CVar</link> &amp;var1, const <link linkend="_class_s_v_f_1_1_cond_var">CVar</link> &amp;var2)</para>

<para>Interface expose to users of our pointer analysis, given conditional variables. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a8e48e9fe6f7e21da49a155f8f6893944"/>virtual AliasResult <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a8e48e9fe6f7e21da49a155f8f6893944">alias</link> (const <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &amp;pts1, const <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &amp;pts2)</para>

<para>Interface expose to users of our pointer analysis, given two conditional points-to sets. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a8cd7b08bd978513cb0faacc47bbaf578"/>bool <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a8cd7b08bd978513cb0faacc47bbaf578">containBlackHoleNode</link> (const <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &amp;cpts)</para>

<para>Test blk node for cpts. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a3a10f3327d6473c348df5b62a5d6683f"/>bool <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a3a10f3327d6473c348df5b62a5d6683f">containConstantNode</link> (const <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &amp;cpts)</para>

<para>Test constant node for cpts. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a6b746c30161c7dab86510895e0032935"/>virtual bool <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a6b746c30161c7dab86510895e0032935">isCondCompatible</link> (const Cond &amp;cxt1, const Cond &amp;cxt2, bool singleton) const =0</para>

<para>Whether two conditions are compatible (to be implemented by child class) </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a80daa422e0dacf75aceb4fe5b4687c04"/>void <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a80daa422e0dacf75aceb4fe5b4687c04">dumpTopLevelPtsTo</link> ()</para>

<para>Dump points-to information of top-level pointers. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a9bdc3a50c695029a28371116ddc3ef8d"/>virtual void <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a9bdc3a50c695029a28371116ddc3ef8d">finalize</link> ()</para>

<para>Finalization of pointer analysis, and normalize points-to information to Bit Vector representation. </para>
</listitem>
            <listitem><para>virtual bool <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a1a95d1d6ac48157c896d9895cff697b4">unionPts</link> (<link linkend="_class_s_v_f_1_1_cond_var">CVar</link> id, const <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &amp;target)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a4ad5da56c8b7bc75bf2dc30a1bcf1552"/>virtual bool <emphasis role="strong">unionPts</emphasis> (<link linkend="_class_s_v_f_1_1_cond_var">CVar</link> id, <link linkend="_class_s_v_f_1_1_cond_var">CVar</link> ptd)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a08037f32b927fe2e6be47a61a060463c"/>virtual bool <emphasis role="strong">addPts</emphasis> (<link linkend="_class_s_v_f_1_1_cond_var">CVar</link> id, <link linkend="_class_s_v_f_1_1_cond_var">CVar</link> ptd)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a3b5877fec52bbfa7c83bab6c9bc95684"/>bool <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a3b5877fec52bbfa7c83bab6c9bc95684">mustAlias</link> (const <link linkend="_class_s_v_f_1_1_cond_var">CVar</link> &amp;var1, const <link linkend="_class_s_v_f_1_1_cond_var">CVar</link> &amp;var2)</para>

<para>Internal interface to be used for conditional points-to set queries. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a5af00bb26800882ab96c470ee9fc4632"/>bool <emphasis role="strong">contains</emphasis> (const <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &amp;cpts1, const <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &amp;cpts2)</para>
</listitem>
            <listitem><para>bool <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a7a1be735c76ba4a6b235264fe8ec6c28">isSameVar</link> (const <link linkend="_class_s_v_f_1_1_cond_var">CVar</link> &amp;var1, const <link linkend="_class_s_v_f_1_1_cond_var">CVar</link> &amp;var2) const</para>

<para>Whether two pointers/objects are the same one by considering their conditions. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a9452d65894864446d8288639435382d7"/>virtual void <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl_1a9452d65894864446d8288639435382d7">NormalizePointsTo</link> ()</para>

<para>Normalize points-to information to BitVector/conditional representation. </para>
</listitem>
        </itemizedlist>
<simplesect>
    <title>Additional Inherited Members    </title>
</simplesect>
<section>
<title>Detailed Description</title>
<simplesect><title>template&lt;class Cond&gt;
class SVF::CondPTAImpl&lt; Cond &gt;</title></simplesect>


<para>Pointer analysis implementation which uses conditional points-to map data structure (context/path sensitive analysis) </para>
</section>
<section>
<title>Constructor &amp; Destructor Documentation</title>
<anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1adc5d33698377dc22aa1ae1151da13675"/>    <section>
    <title>CondPTAImpl()</title>
<indexterm><primary>CondPTAImpl</primary><secondary>SVF::CondPTAImpl&lt; Cond &gt;</secondary></indexterm>
<indexterm><primary>SVF::CondPTAImpl&lt; Cond &gt;</primary><secondary>CondPTAImpl</secondary></indexterm>
<computeroutput>template&lt;class Cond &gt; </computeroutput><para><computeroutput><link linkend="_class_s_v_f_1_1_cond_p_t_a_impl">SVF::CondPTAImpl</link>&lt; Cond &gt;::<link linkend="_class_s_v_f_1_1_cond_p_t_a_impl">CondPTAImpl</link> (<link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> * pag, <link linkend="_class_s_v_f_1_1_pointer_analysis_1a0b182ac680cce0547dbe7714c870ca85">PointerAnalysis::PTATY</link> type)<computeroutput>[inline]</computeroutput></computeroutput></para><para>

<para>map a pointer to its conditional points-to set </para>
</para>

<para>Constructor </para>
</section>
</section>
<section>
<title>Member Function Documentation</title>
<anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a63fa2b3a96696ffc67a119c1ba5ce748"/>    <section>
    <title>getPts()</title>
<indexterm><primary>getPts</primary><secondary>SVF::CondPTAImpl&lt; Cond &gt;</secondary></indexterm>
<indexterm><primary>SVF::CondPTAImpl&lt; Cond &gt;</primary><secondary>getPts</secondary></indexterm>
<computeroutput>template&lt;class Cond &gt; </computeroutput><para><computeroutput>virtual const <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link>&amp; <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl">SVF::CondPTAImpl</link>&lt; Cond &gt;::getPts (<link linkend="_class_s_v_f_1_1_cond_var">CVar</link> id)<computeroutput>[inline]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para>
<para>Get points-to and reverse points-to </para>
    </section><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a7a1be735c76ba4a6b235264fe8ec6c28"/>    <section>
    <title>isSameVar()</title>
<indexterm><primary>isSameVar</primary><secondary>SVF::CondPTAImpl&lt; Cond &gt;</secondary></indexterm>
<indexterm><primary>SVF::CondPTAImpl&lt; Cond &gt;</primary><secondary>isSameVar</secondary></indexterm>
<computeroutput>template&lt;class Cond &gt; </computeroutput><para><computeroutput>bool <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl">SVF::CondPTAImpl</link>&lt; Cond &gt;::isSameVar (const <link linkend="_class_s_v_f_1_1_cond_var">CVar</link> &amp; var1, const <link linkend="_class_s_v_f_1_1_cond_var">CVar</link> &amp; var2) const<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Whether two pointers/objects are the same one by considering their conditions. </para>
</para>

<para>we distinguish context sensitive memory allocation here</para>
    </section><anchor xml:id="_class_s_v_f_1_1_cond_p_t_a_impl_1a1a95d1d6ac48157c896d9895cff697b4"/>    <section>
    <title>unionPts()</title>
<indexterm><primary>unionPts</primary><secondary>SVF::CondPTAImpl&lt; Cond &gt;</secondary></indexterm>
<indexterm><primary>SVF::CondPTAImpl&lt; Cond &gt;</primary><secondary>unionPts</secondary></indexterm>
<computeroutput>template&lt;class Cond &gt; </computeroutput><para><computeroutput>virtual bool <link linkend="_class_s_v_f_1_1_cond_p_t_a_impl">SVF::CondPTAImpl</link>&lt; Cond &gt;::unionPts (<link linkend="_class_s_v_f_1_1_cond_var">CVar</link> id, const <link linkend="_class_s_v_f_1_1_cond_std_set">CPtSet</link> &amp; target)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para>
<para>Union/add points-to, and add the reverse points-to for node collapse purpose To be noted that adding reverse pts might incur 10% total overhead during solving </para>
</section>
<para>
The documentation for this class was generated from the following file:</para>
include/MemoryModel/PointerAnalysisImpl.h</section>
</section>
