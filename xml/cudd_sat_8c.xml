<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="cudd_sat_8c" kind="file" language="C++">
    <compoundname>cuddSat.c</compoundname>
    <includes refid="util_8h" local="yes">CUDD/util.h</includes>
    <includes refid="cudd_int_8h" local="yes">CUDD/cuddInt.h</includes>
    <incdepgraph>
      <node id="8">
        <label>cudd.h</label>
        <link refid="cudd_8h_source"/>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
      </node>
      <node id="9">
        <label>mtr.h</label>
        <link refid="mtr_8h_source"/>
      </node>
      <node id="11">
        <label>st.h</label>
        <link refid="st_8h_source"/>
      </node>
      <node id="6">
        <label>CUDD/cuddInt.h</label>
        <link refid="cudd_int_8h_source"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>CUDD/util.h</label>
        <link refid="util_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>lib/CUDD/cuddSat.c</label>
        <link refid="cudd_sat_8c"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
      <node id="10">
        <label>epd.h</label>
        <link refid="epd_8h_source"/>
      </node>
      <node id="3">
        <label>unistd.h</label>
      </node>
      <node id="7">
        <label>math.h</label>
      </node>
      <node id="5">
        <label>ctype.h</label>
      </node>
      <node id="4">
        <label>stdio.h</label>
      </node>
    </incdepgraph>
    <innerclass refid="structcudd_path_pair" prot="public">cuddPathPair</innerclass>
      <sectiondef kind="define">
      <memberdef kind="define" id="cudd_sat_8c_1a6994699d7a2a82b8f838e9d8d408095a" prot="public" static="no">
        <name>DD_BIGGY</name>
        <initializer>100000000</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>CFile***********************************************************************</para>
<para>FileName [cuddSat.c]</para>
<para>PackageName [cudd]</para>
<para>Synopsis [Functions for the solution of satisfiability related problems.]</para>
<para>Description [External procedures included in this file: <itemizedlist>
<listitem>
<para>Cudd_Eval() </para>
</listitem>
<listitem>
<para>Cudd_ShortestPath() </para>
</listitem>
<listitem>
<para>Cudd_LargestCube() </para>
</listitem>
<listitem>
<para>Cudd_ShortestLength() </para>
</listitem>
<listitem>
<para>Cudd_Decreasing() </para>
</listitem>
<listitem>
<para>Cudd_Increasing() </para>
</listitem>
<listitem>
<para>Cudd_EquivDC() </para>
</listitem>
<listitem>
<para>Cudd_bddLeqUnless() </para>
</listitem>
<listitem>
<para>Cudd_EqualSupNorm() </para>
</listitem>
<listitem>
<para>Cudd_bddMakePrime() </para>
</listitem>
<listitem>
<para>Cudd_bddMaximallyExpand() </para>
</listitem>
<listitem>
<para>Cudd_bddLargestPrimeUnate() </para>
</listitem>
</itemizedlist>
Internal procedures included in this module: <itemizedlist>
<listitem>
<para>cuddBddMakePrime() </para>
</listitem>
</itemizedlist>
Static procedures included in this module: <itemizedlist>
<listitem>
<para>freePathPair() </para>
</listitem>
<listitem>
<para>getShortest() </para>
</listitem>
<listitem>
<para>getPath() </para>
</listitem>
<listitem>
<para>getLargest() </para>
</listitem>
<listitem>
<para>getCube() </para>
</listitem>
<listitem>
<para>ddBddMaximallyExpand() </para>
</listitem>
<listitem>
<para>ddShortestPathUnate() </para>
</listitem>
</itemizedlist>
]</para>
<para>Author [Seh-Woong Jeong, Fabio Somenzi]</para>
<para>Copyright [Copyright (c) 1995-2012, Regents of the University of Colorado</para>
<para>All rights reserved.</para>
<para>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</para>
<para>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</para>
<para>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</para>
<para>Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</para>
<para>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="82" column="9" bodyfile="lib/CUDD/cuddSat.c" bodystart="82" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="cudd_sat_8c_1aa0c21b2677d4dc06dfd0dd175bb1a718" prot="public" static="no">
        <name>WEIGHT</name>
        <param><defname>weight</defname></param>
        <param><defname>col</defname></param>
        <initializer>((weight) == NULL ? 1 : weight[col])</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="111" column="9" bodyfile="lib/CUDD/cuddSat.c" bodystart="111" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="cudd_sat_8c_1ac5066de084f960740de3c973cdcc4be3" prot="public" static="no">
        <type>struct <ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref></type>
        <definition>typedef struct cuddPathPair cuddPathPair</definition>
        <argsstring></argsstring>
        <name>cuddPathPair</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="95" column="14"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="cudd_sat_8c_1a15755406c65f1ac3ea34ce661b57b54e" prot="public" static="yes" mutable="no">
        <type>char rcsid[]</type>
        <definition>char rcsid [] DD_UNUSED</definition>
        <argsstring></argsstring>
        <name>DD_UNUSED</name>
        <initializer>= &quot;$Id: cuddSat.c,v 1.39 2012/02/05 01:07:19 fabio Exp $&quot;</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="102" column="19" bodyfile="lib/CUDD/cuddSat.c" bodystart="102" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="cudd_sat_8c_1a49e3c7508be54a84ae83273ed240e31c" prot="public" static="yes" mutable="no">
        <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
        <definition>DdNode* one</definition>
        <argsstring></argsstring>
        <name>one</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="105" column="13" bodyfile="lib/CUDD/cuddSat.c" bodystart="105" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="cudd_sat_8c_1a559a95c469bb341bde49e5950629e726" prot="public" static="yes" mutable="no">
        <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
        <definition>DdNode * zero</definition>
        <argsstring></argsstring>
        <name>zero</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="105" column="17" bodyfile="lib/CUDD/cuddSat.c" bodystart="105" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="cudd_sat_8c_1a498f7e0ebf19b278dd9e7d9651b82eef" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>enum st_retval</type>
        <definition>static enum st_retval freePathPair</definition>
        <argsstring>(char *key, char *value, char *arg)</argsstring>
        <name>freePathPair</name>
        <param>
          <type>char *</type>
          <declname>key</declname>
        </param>
        <param>
          <type>char *</type>
          <declname>value</declname>
        </param>
        <param>
          <type>char *</type>
          <declname>arg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>AutomaticStart</para>
<para>Function********************************************************************</para>
<para>Synopsis [Frees the entries of the visited symbol table.]</para>
<para>Description [Frees the entries of the visited symbol table. Returns ST_CONTINUE.]</para>
<para>SideEffects [None] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="995" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="1060" bodyend="1071" declfile="lib/CUDD/cuddSat.c" declline="105" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1a048492e5cad979aad3c0540ff82a4824" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref></type>
        <definition>static cuddPathPair getShortest</definition>
        <argsstring>(DdNode *root, int *cost, int *support, st_table *visited)</argsstring>
        <name>getShortest</name>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>root</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>cost</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>support</declname>
        </param>
        <param>
          <type><ref refid="structst__table" kindref="compound">st_table</ref> *</type>
          <declname>visited</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Finds the length of the shortest path(s) in a DD.]</para>
<para>Description [Finds the length of the shortest path(s) in a DD. Uses a local symbol table to store the lengths for each node. Only the lengths for the regular nodes are entered in the table, because those for the complement nodes are simply obtained by swapping the two lenghts. Returns a pair of lengths: the length of the shortest path to 1; and the length of the shortest path to 0. This is done so as to take complement arcs into account.]</para>
<para>SideEffects [Accumulates the support of the DD in support.]</para>
<para>SeeAlso [] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="1093" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="1093" bodyend="1167" declfile="lib/CUDD/cuddSat.c" declline="124" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1a363b8f8f2ebf1380b0279d4aac4f2b41" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
        <definition>static DdNode * getPath</definition>
        <argsstring>(DdManager *manager, st_table *visited, DdNode *f, int *weight, int cost)</argsstring>
        <name>getPath</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>manager</declname>
        </param>
        <param>
          <type><ref refid="structst__table" kindref="compound">st_table</ref> *</type>
          <declname>visited</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>weight</declname>
        </param>
        <param>
          <type>int</type>
          <declname>cost</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Build a BDD for a shortest path of f.]</para>
<para>Description [Build a BDD for a shortest path of f. Given the minimum length from the root, and the minimum lengths for each node (in visited), apply triangulation at each node. Of the two children of each node on a shortest path, at least one is on a shortest path. In case of ties the procedure chooses the THEN children. Returns a pointer to the cube BDD representing the path if successful; NULL otherwise.]</para>
<para>SideEffects [None]</para>
<para>SeeAlso [] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="1189" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="1189" bodyend="1258" declfile="lib/CUDD/cuddSat.c" declline="125" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1a6506f1ae80b0f85d1e01da0db4a4f31a" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref></type>
        <definition>static cuddPathPair getLargest</definition>
        <argsstring>(DdNode *root, st_table *visited)</argsstring>
        <name>getLargest</name>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>root</declname>
        </param>
        <param>
          <type><ref refid="structst__table" kindref="compound">st_table</ref> *</type>
          <declname>visited</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Finds the size of the largest cube(s) in a DD.]</para>
<para>Description [Finds the size of the largest cube(s) in a DD. This problem is translated into finding the shortest paths from a node when both THEN and ELSE arcs have unit lengths. Uses a local symbol table to store the lengths for each node. Only the lengths for the regular nodes are entered in the table, because those for the complement nodes are simply obtained by swapping the two lenghts. Returns a pair of lengths: the length of the shortest path to 1; and the length of the shortest path to 0. This is done so as to take complement arcs into account.]</para>
<para>SideEffects [none]</para>
<para>SeeAlso [] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="1282" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="1282" bodyend="1348" declfile="lib/CUDD/cuddSat.c" declline="126" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1ac4564d7da48b5f6457d7adca5e619b4c" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
        <definition>static DdNode * getCube</definition>
        <argsstring>(DdManager *manager, st_table *visited, DdNode *f, int cost)</argsstring>
        <name>getCube</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>manager</declname>
        </param>
        <param>
          <type><ref refid="structst__table" kindref="compound">st_table</ref> *</type>
          <declname>visited</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>cost</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Build a BDD for a largest cube of f.]</para>
<para>Description [Build a BDD for a largest cube of f. Given the minimum length from the root, and the minimum lengths for each node (in visited), apply triangulation at each node. Of the two children of each node on a shortest path, at least one is on a shortest path. In case of ties the procedure chooses the THEN children. Returns a pointer to the cube BDD representing the path if successful; NULL otherwise.]</para>
<para>SideEffects [None]</para>
<para>SeeAlso [] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="1370" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="1370" bodyend="1438" declfile="lib/CUDD/cuddSat.c" declline="127" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1a4234aacbccc17b321b44725b3d83e70e" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
        <definition>static DdNode * ddBddMaximallyExpand</definition>
        <argsstring>(DdManager *dd, DdNode *lb, DdNode *ub, DdNode *f)</argsstring>
        <name>ddBddMaximallyExpand</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>dd</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>lb</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>ub</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Performs the recursive step of Cudd_bddMaximallyExpand.]</para>
<para>Description [Performs the recursive step of Cudd_bddMaximallyExpand. Returns set of primes or zero BDD if successful; NULL otherwise. On entry to this function, ub and lb should be different from the zero BDD. The function then maintains this invariant.]</para>
<para>SideEffects [None]</para>
<para>SeeAlso [] </para>
        </detaileddescription>
        <inbodydescription>
<para>There are three major terminal cases in theory: ub -&gt; f : return ub lb == f : return lb not(lb -&gt; f): return zero Only the second case can be checked exactly in constant time. For the others, we check for sufficient conditions.</para>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="1456" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="1456" bodyend="1646" declfile="lib/CUDD/cuddSat.c" declline="128" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1a9c44cbf963f2d7b8989c1fbe85c37d0b" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int ddBddShortestPathUnate</definition>
        <argsstring>(DdManager *dd, DdNode *f, int *phases, st_table *table)</argsstring>
        <name>ddBddShortestPathUnate</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>dd</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>phases</declname>
        </param>
        <param>
          <type><ref refid="structst__table" kindref="compound">st_table</ref> *</type>
          <declname>table</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Performs shortest path computation on a unate function.]</para>
<para>Description [Performs shortest path computation on a unate function. Returns the length of the shortest path to one if successful; CUDD_OUT_OF_MEM otherwise. This function is based on the observation that in the BDD of a unate function no node except the constant is reachable from the root via paths of different parity.]</para>
<para>SideEffects [None]</para>
<para>SeeAlso [getShortest] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="1665" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="1665" bodyend="1701" declfile="lib/CUDD/cuddSat.c" declline="129" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1a72e35db53369c8342573b441608b5d66" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
        <definition>static DdNode * ddGetLargestCubeUnate</definition>
        <argsstring>(DdManager *dd, DdNode *f, int *phases, st_table *table)</argsstring>
        <name>ddGetLargestCubeUnate</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>dd</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>phases</declname>
        </param>
        <param>
          <type><ref refid="structst__table" kindref="compound">st_table</ref> *</type>
          <declname>table</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Extracts largest prime of a unate function.]</para>
<para>Description [Extracts largest prime of a unate function. Returns the BDD of the prime if successful; NULL otherwise.]</para>
<para>SideEffects [None]</para>
<para>SeeAlso [getPath] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="1717" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="1717" bodyend="1774" declfile="lib/CUDD/cuddSat.c" declline="130" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1a0f11262fedecf0c0f4376432b478e6e8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
        <definition>DdNode* Cudd_Eval</definition>
        <argsstring>(DdManager *dd, DdNode *f, int *inputs)</argsstring>
        <name>Cudd_Eval</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>dd</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>inputs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>AutomaticEnd Function********************************************************************</para>
<para>Synopsis [Returns the value of a DD for a given variable assignment.]</para>
<para>Description [Finds the value of a DD for a given variable assignment. The variable assignment is passed in an array of int&apos;s, that should specify a zero or a one for each variable in the support of the function. Returns a pointer to a constant node. No new nodes are produced.]</para>
<para>SideEffects [None]</para>
<para>SeeAlso [Cudd_bddLeq Cudd_addEvalConst] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="159" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="159" bodyend="180"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1a78e2d36d1fdfa3d917ad345867bd4596" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
        <definition>DdNode* Cudd_ShortestPath</definition>
        <argsstring>(DdManager *manager, DdNode *f, int *weight, int *support, int *length)</argsstring>
        <name>Cudd_ShortestPath</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>manager</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>weight</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>support</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>length</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Finds a shortest path in a DD.]</para>
<para>Description [Finds a shortest path in a DD. f is the DD we want to get the shortest path for; weight[i] is the weight of the THEN arc coming from the node whose index is i. If weight is NULL, then unit weights are assumed for all THEN arcs. All ELSE arcs have 0 weight. If non-NULL, both weight and support should point to arrays with at least as many entries as there are variables in the manager. Returns the shortest path as the BDD of a cube.]</para>
<para>SideEffects [support contains on return the true support of f. If support is NULL on entry, then Cudd_ShortestPath does not compute the true support info. length contains the length of the path.]</para>
<para>SeeAlso [Cudd_ShortestLength Cudd_LargestCube] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="203" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="203" bodyend="267"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1a5722a5bf76d99cd30783ad87ba03bf96" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
        <definition>DdNode* Cudd_LargestCube</definition>
        <argsstring>(DdManager *manager, DdNode *f, int *length)</argsstring>
        <name>Cudd_LargestCube</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>manager</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>length</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Finds a largest cube in a DD.]</para>
<para>Description [Finds a largest cube in a DD. f is the DD we want to get the largest cube for. The problem is translated into the one of finding a shortest path in f, when both THEN and ELSE arcs are assumed to have unit length. This yields a largest cube in the disjoint cover corresponding to the DD. Therefore, it is not necessarily the largest implicant of f. Returns the largest cube as a BDD.]</para>
<para>SideEffects [The number of literals of the cube is returned in the location pointed by length if it is non-null.]</para>
<para>SeeAlso [Cudd_ShortestPath] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="288" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="288" bodyend="344"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1addfc0e508dfd1d0bd0c74104a3dd15e8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int Cudd_ShortestLength</definition>
        <argsstring>(DdManager *manager, DdNode *f, int *weight)</argsstring>
        <name>Cudd_ShortestLength</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>manager</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>weight</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Find the length of the shortest path(s) in a DD.]</para>
<para>Description [Find the length of the shortest path(s) in a DD. f is the DD we want to get the shortest path for; weight[i] is the weight of the THEN edge coming from the node whose index is i. All ELSE edges have 0 weight. Returns the length of the shortest path(s) if such a path is found; a large number if the function is identically 0, and CUDD_OUT_OF_MEM in case of failure.]</para>
<para>SideEffects [None]</para>
<para>SeeAlso [Cudd_ShortestPath] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="364" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="364" bodyend="405"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1a66a70b011fca8b95fbc3953e8b1be1fe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
        <definition>DdNode* Cudd_Decreasing</definition>
        <argsstring>(DdManager *dd, DdNode *f, int i)</argsstring>
        <name>Cudd_Decreasing</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>dd</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Determines whether a BDD is negative unate in a variable.]</para>
<para>Description [Determines whether the function represented by BDD f is negative unate (monotonic decreasing) in variable i. Returns the constant one is f is unate and the (logical) constant zero if it is not. This function does not generate any new nodes.]</para>
<para>SideEffects [None]</para>
<para>SeeAlso [Cudd_Increasing] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="424" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="424" bodyend="485"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1a4f87b23df844d48727ee53f75d868be6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
        <definition>DdNode* Cudd_Increasing</definition>
        <argsstring>(DdManager *dd, DdNode *f, int i)</argsstring>
        <name>Cudd_Increasing</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>dd</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Determines whether a BDD is positive unate in a variable.]</para>
<para>Description [Determines whether the function represented by BDD f is positive unate (monotonic increasing) in variable i. It is based on Cudd_Decreasing and the fact that f is monotonic increasing in i if and only if its complement is monotonic decreasing in i.]</para>
<para>SideEffects [None]</para>
<para>SeeAlso [Cudd_Decreasing] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="504" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="504" bodyend="511"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1a3e078600dd9087c623e1bdfea00d599d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int Cudd_EquivDC</definition>
        <argsstring>(DdManager *dd, DdNode *F, DdNode *G, DdNode *D)</argsstring>
        <name>Cudd_EquivDC</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>dd</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>F</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>G</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>D</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Tells whether F and G are identical wherever D is 0.]</para>
<para>Description [Tells whether F and G are identical wherever D is 0. F and G are either two ADDs or two BDDs. D is either a 0-1 ADD or a BDD. The function returns 1 if F and G are equivalent, and 0 otherwise. No new nodes are created.]</para>
<para>SideEffects [None]</para>
<para>SeeAlso [Cudd_bddLeqUnless] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="529" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="529" bodyend="612"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1a5dcbf450b32f6937bc6dba252474638d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int Cudd_bddLeqUnless</definition>
        <argsstring>(DdManager *dd, DdNode *f, DdNode *g, DdNode *D)</argsstring>
        <name>Cudd_bddLeqUnless</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>dd</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>g</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>D</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Tells whether f is less than of equal to G unless D is 1.]</para>
<para>Description [Tells whether f is less than of equal to G unless D is<orderedlist>
<listitem><para>f, g, and D are BDDs. The function returns 1 if f is less than of equal to G, and 0 otherwise. No new nodes are created.]</para>
</listitem></orderedlist>
</para>
<para>SideEffects [None]</para>
<para>SeeAlso [Cudd_EquivDC Cudd_bddLeq Cudd_bddIteConstant] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="629" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="629" bodyend="783"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1abe0be57ead326db49e00a51d7acf75f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int Cudd_EqualSupNorm</definition>
        <argsstring>(DdManager *dd, DdNode *f, DdNode *g, CUDD_VALUE_TYPE tolerance, int pr)</argsstring>
        <name>Cudd_EqualSupNorm</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>dd</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>g</declname>
        </param>
        <param>
          <type>CUDD_VALUE_TYPE</type>
          <declname>tolerance</declname>
        </param>
        <param>
          <type>int</type>
          <declname>pr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Compares two ADDs for equality within tolerance.]</para>
<para>Description [Compares two ADDs for equality within tolerance. Two ADDs are reported to be equal if the maximum difference between them (the sup norm of their difference) is less than or equal to the tolerance parameter. Returns 1 if the two ADDs are equal (within tolerance); 0 otherwise. If parameter <computeroutput>pr</computeroutput> is positive the first failure is reported to the standard output.]</para>
<para>SideEffects [None]</para>
<para>SeeAlso [] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="803" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="803" bodyend="854"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1a7b924211354f5d356009a7c804be2340" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
        <definition>DdNode* Cudd_bddMakePrime</definition>
        <argsstring>(DdManager *dd, DdNode *cube, DdNode *f)</argsstring>
        <name>Cudd_bddMakePrime</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>dd</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>cube</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Expands cube to a prime implicant of f.]</para>
<para>Description [Expands cube to a prime implicant of f. Returns the prime if successful; NULL otherwise. In particular, NULL is returned if cube is not a real cube or is not an implicant of f.]</para>
<para>SideEffects [None]</para>
<para>SeeAlso [Cudd_bddMaximallyExpand] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="871" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="871" bodyend="886"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1accb9bb89f75fe6176be961c73a19be09" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
        <definition>DdNode* Cudd_bddMaximallyExpand</definition>
        <argsstring>(DdManager *dd, DdNode *lb, DdNode *ub, DdNode *f)</argsstring>
        <name>Cudd_bddMaximallyExpand</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>dd</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>lb</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>ub</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Expands lb to prime implicants of (f and ub).]</para>
<para>Description [Expands lb to all prime implicants of (f and ub) that contain lb. Assumes that lb is contained in ub. Returns the disjunction of the primes if lb is contained in f; returns the zero BDD if lb is not contained in f; returns NULL in case of failure. In particular, NULL is returned if cube is not a real cube or is not an implicant of f. Returning the disjunction of all prime implicants works because the resulting function is unate.]</para>
<para>SideEffects [None]</para>
<para>SeeAlso [Cudd_bddMakePrime] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="906" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="906" bodyend="922"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1a3a45afd92abdea6f969399e7c0eb5c8f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
        <definition>DdNode* Cudd_bddLargestPrimeUnate</definition>
        <argsstring>(DdManager *dd, DdNode *f, DdNode *phaseBdd)</argsstring>
        <name>Cudd_bddLargestPrimeUnate</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>dd</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>phaseBdd</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Find a largest prime of a unate function.]</para>
<para>Description [Find a largest prime implicant of a unate function. Returns the BDD for the prime if succesful; NULL otherwise. The behavior is undefined if f is not unate. The third argument is used to determine whether f is unate positive (increasing) or negative (decreasing) in each of the variables in its support.]</para>
<para>SideEffects [None]</para>
<para>SeeAlso [Cudd_bddMaximallyExpand] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="941" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="941" bodyend="974"/>
      </memberdef>
      <memberdef kind="function" id="cudd_sat_8c_1aad1ef5892f9b1b85a2766956fca9761c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
        <definition>DdNode* cuddBddMakePrime</definition>
        <argsstring>(DdManager *dd, DdNode *cube, DdNode *f)</argsstring>
        <name>cuddBddMakePrime</name>
        <param>
          <type><ref refid="struct_dd_manager" kindref="compound">DdManager</ref> *</type>
          <declname>dd</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>cube</declname>
        </param>
        <param>
          <type><ref refid="struct_dd_node" kindref="compound">DdNode</ref> *</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function********************************************************************</para>
<para>Synopsis [Performs the recursive step of Cudd_bddMakePrime.]</para>
<para>Description [Performs the recursive step of Cudd_bddMakePrime. Returns the prime if successful; NULL otherwise.]</para>
<para>SideEffects [None]</para>
<para>SeeAlso [] </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="lib/CUDD/cuddSat.c" line="995" column="1" bodyfile="lib/CUDD/cuddSat.c" bodystart="995" bodyend="1041"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="normal"></highlight></codeline>
<codeline lineno="75"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;CUDD/util.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="76"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;CUDD/cuddInt.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="77"><highlight class="normal"></highlight></codeline>
<codeline lineno="78"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="79"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Constant<sp/>declarations<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="80"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="81"><highlight class="normal"></highlight></codeline>
<codeline lineno="82"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>DD_BIGGY<sp/><sp/><sp/><sp/>100000000</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="83"><highlight class="normal"></highlight></codeline>
<codeline lineno="84"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="85"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Stucture<sp/>declarations<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="86"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="87"><highlight class="normal"></highlight></codeline>
<codeline lineno="88"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="89"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Type<sp/>declarations<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="90"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="91"><highlight class="normal"></highlight></codeline>
<codeline lineno="92" refid="structcudd_path_pair" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref><sp/>{</highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>pos;</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>neg;</highlight></codeline>
<codeline lineno="95"><highlight class="normal">}<sp/><ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref>;</highlight></codeline>
<codeline lineno="96"><highlight class="normal"></highlight></codeline>
<codeline lineno="97"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="98"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Variable<sp/>declarations<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="99"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="100"><highlight class="normal"></highlight></codeline>
<codeline lineno="101"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>lint</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="102"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>rcsid[]<sp/>DD_UNUSED<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;$Id:<sp/>cuddSat.c,v<sp/>1.39<sp/>2012/02/05<sp/>01:07:19<sp/>fabio<sp/>Exp<sp/>$&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="103"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="104"><highlight class="normal"></highlight></codeline>
<codeline lineno="105"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/><sp/>*one,<sp/>*zero;</highlight></codeline>
<codeline lineno="106"><highlight class="normal"></highlight></codeline>
<codeline lineno="107"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="108"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Macro<sp/>declarations<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="109"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="110"><highlight class="normal"></highlight></codeline>
<codeline lineno="111"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>WEIGHT(weight,<sp/>col)<sp/>((weight)<sp/>==<sp/>NULL<sp/>?<sp/>1<sp/>:<sp/>weight[col])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="112"><highlight class="normal"></highlight></codeline>
<codeline lineno="113"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="115"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="116"><highlight class="normal"></highlight></codeline>
<codeline lineno="119"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="120"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Static<sp/>function<sp/>prototypes<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="121"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="122"><highlight class="normal"></highlight></codeline>
<codeline lineno="123"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>st_retval<sp/>freePathPair<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*key,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*value,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*arg);</highlight></codeline>
<codeline lineno="124"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref><sp/>getShortest<sp/>(<ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*root,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*cost,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*support,<sp/><ref refid="structst__table" kindref="compound">st_table</ref><sp/>*visited);</highlight></codeline>
<codeline lineno="125"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>getPath<sp/>(<ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*manager,<sp/><ref refid="structst__table" kindref="compound">st_table</ref><sp/>*visited,<sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*f,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*weight,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>cost);</highlight></codeline>
<codeline lineno="126"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref><sp/>getLargest<sp/>(<ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*root,<sp/><ref refid="structst__table" kindref="compound">st_table</ref><sp/>*visited);</highlight></codeline>
<codeline lineno="127"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>getCube<sp/>(<ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*manager,<sp/><ref refid="structst__table" kindref="compound">st_table</ref><sp/>*visited,<sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*f,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>cost);</highlight></codeline>
<codeline lineno="128"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>ddBddMaximallyExpand(<ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*dd,<sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*lb,<sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*ub,<sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*f);</highlight></codeline>
<codeline lineno="129"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ddBddShortestPathUnate(<ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*dd,<sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*f,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*phases,<sp/><ref refid="structst__table" kindref="compound">st_table</ref><sp/>*table);</highlight></codeline>
<codeline lineno="130"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>ddGetLargestCubeUnate(<ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*dd,<sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*f,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*phases,<sp/><ref refid="structst__table" kindref="compound">st_table</ref><sp/>*table);</highlight></codeline>
<codeline lineno="131"><highlight class="normal"></highlight></codeline>
<codeline lineno="134"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="135"><highlight class="normal">}</highlight></codeline>
<codeline lineno="136"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="137"><highlight class="normal"></highlight></codeline>
<codeline lineno="138"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="139"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Definition<sp/>of<sp/>exported<sp/>functions<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="140"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="141"><highlight class="normal"></highlight></codeline>
<codeline lineno="142"><highlight class="normal"></highlight></codeline>
<codeline lineno="158"><highlight class="normal"><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*</highlight></codeline>
<codeline lineno="159"><highlight class="normal">Cudd_Eval(</highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*<sp/>dd,</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>f,</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>inputs)</highlight></codeline>
<codeline lineno="163"><highlight class="normal">{</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>comple;</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*ptr;</highlight></codeline>
<codeline lineno="166"><highlight class="normal"></highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/><sp/><sp/>comple<sp/>=<sp/>Cudd_IsComplement(f);</highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/>ptr<sp/>=<sp/>Cudd_Regular(f);</highlight></codeline>
<codeline lineno="169"><highlight class="normal"></highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(!cuddIsConstant(ptr))<sp/>{</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(inputs[ptr-&gt;index]<sp/>==<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ptr<sp/>=<sp/>cuddT(ptr);</highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>comple<sp/>^=<sp/>Cudd_IsComplement(cuddE(ptr));</highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ptr<sp/>=<sp/>Cudd_Regular(cuddE(ptr));</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(Cudd_NotCond(ptr,comple));</highlight></codeline>
<codeline lineno="179"><highlight class="normal"></highlight></codeline>
<codeline lineno="180"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>Cudd_Eval<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="181"><highlight class="normal"></highlight></codeline>
<codeline lineno="182"><highlight class="normal"></highlight></codeline>
<codeline lineno="202"><highlight class="normal"><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*</highlight></codeline>
<codeline lineno="203"><highlight class="normal">Cudd_ShortestPath(</highlight></codeline>
<codeline lineno="204"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*<sp/>manager,</highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>f,</highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>weight,</highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>support,</highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>length)</highlight></codeline>
<codeline lineno="209"><highlight class="normal">{</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/><sp/>*F;</highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structst__table" kindref="compound">st_table</ref><sp/><sp/><sp/><sp/>*visited;</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/><sp/>*sol;</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref><sp/>*rootPair;</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>complement,<sp/>cost;</highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>i;</highlight></codeline>
<codeline lineno="216"><highlight class="normal"></highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/>one<sp/>=<sp/>DD_ONE(manager);</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/>zero<sp/>=<sp/>DD_ZERO(manager);</highlight></codeline>
<codeline lineno="219"><highlight class="normal"></highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Initialize<sp/>support.<sp/>Support<sp/>does<sp/>not<sp/>depend<sp/>on<sp/>variable<sp/>order.</highlight></codeline>
<codeline lineno="221"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>Hence,<sp/>it<sp/>does<sp/>not<sp/>need<sp/>to<sp/>be<sp/>reinitialized<sp/>if<sp/>reordering<sp/>occurs.</highlight></codeline>
<codeline lineno="222"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(support)<sp/>{</highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>manager-&gt;size;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/>support[i]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="227"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="228"><highlight class="normal"></highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f<sp/>==<sp/>Cudd_Not(one)<sp/>||<sp/>f<sp/>==<sp/>zero)<sp/>{</highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>*length<sp/>=<sp/>DD_BIGGY;</highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(Cudd_Not(one));</highlight></codeline>
<codeline lineno="232"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="233"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>From<sp/>this<sp/>point<sp/>on,<sp/>a<sp/>path<sp/>exists.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="234"><highlight class="normal"></highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/>manager-&gt;reordered<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="237"><highlight class="normal"></highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Initialize<sp/>visited<sp/>table.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/>visited<sp/>=<sp/>st_init_table(st_ptrcmp,<sp/>st_ptrhash);</highlight></codeline>
<codeline lineno="240"><highlight class="normal"></highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Now<sp/>get<sp/>the<sp/>length<sp/>of<sp/>the<sp/>shortest<sp/>path(s)<sp/>from<sp/>f<sp/>to<sp/>1.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)<sp/>getShortest(f,<sp/>weight,<sp/>support,<sp/>visited);</highlight></codeline>
<codeline lineno="243"><highlight class="normal"></highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/><sp/><sp/>complement<sp/>=<sp/>Cudd_IsComplement(f);</highlight></codeline>
<codeline lineno="245"><highlight class="normal"></highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/>F<sp/>=<sp/>Cudd_Regular(f);</highlight></codeline>
<codeline lineno="247"><highlight class="normal"></highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!st_lookup(visited,<sp/>F,<sp/>&amp;rootPair))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="249"><highlight class="normal"></highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(complement)<sp/>{</highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cost<sp/>=<sp/>rootPair-&gt;neg;</highlight></codeline>
<codeline lineno="252"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cost<sp/>=<sp/>rootPair-&gt;pos;</highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="255"><highlight class="normal"></highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Recover<sp/>an<sp/>actual<sp/>shortest<sp/>path.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/>sol<sp/>=<sp/>getPath(manager,visited,f,weight,cost);</highlight></codeline>
<codeline lineno="258"><highlight class="normal"></highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/>st_foreach(visited,<sp/>freePathPair,<sp/>NULL);</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/>st_free_table(visited);</highlight></codeline>
<codeline lineno="261"><highlight class="normal"></highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(manager-&gt;reordered<sp/>==<sp/>1);</highlight></codeline>
<codeline lineno="263"><highlight class="normal"></highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/><sp/>*length<sp/>=<sp/>cost;</highlight></codeline>
<codeline lineno="265"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(sol);</highlight></codeline>
<codeline lineno="266"><highlight class="normal"></highlight></codeline>
<codeline lineno="267"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>Cudd_ShortestPath<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="268"><highlight class="normal"></highlight></codeline>
<codeline lineno="269"><highlight class="normal"></highlight></codeline>
<codeline lineno="287"><highlight class="normal"><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*</highlight></codeline>
<codeline lineno="288"><highlight class="normal">Cudd_LargestCube(</highlight></codeline>
<codeline lineno="289"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*<sp/>manager,</highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>f,</highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>length)</highlight></codeline>
<codeline lineno="292"><highlight class="normal">{</highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">register</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/><sp/>*F;</highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structst__table" kindref="compound">st_table</ref><sp/><sp/><sp/><sp/>*visited;</highlight></codeline>
<codeline lineno="295"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/><sp/>*sol;</highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref><sp/>*rootPair;</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>complement,<sp/>cost;</highlight></codeline>
<codeline lineno="298"><highlight class="normal"></highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/>one<sp/>=<sp/>DD_ONE(manager);</highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/>zero<sp/>=<sp/>DD_ZERO(manager);</highlight></codeline>
<codeline lineno="301"><highlight class="normal"></highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f<sp/>==<sp/>Cudd_Not(one)<sp/>||<sp/>f<sp/>==<sp/>zero)<sp/>{</highlight></codeline>
<codeline lineno="303"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(length<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*length<sp/>=<sp/>DD_BIGGY;</highlight></codeline>
<codeline lineno="305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="306"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(Cudd_Not(one));</highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="308"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>From<sp/>this<sp/>point<sp/>on,<sp/>a<sp/>path<sp/>exists.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="309"><highlight class="normal"></highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="311"><highlight class="normal"><sp/><sp/><sp/><sp/>manager-&gt;reordered<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="312"><highlight class="normal"></highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Initialize<sp/>visited<sp/>table.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="314"><highlight class="normal"><sp/><sp/><sp/><sp/>visited<sp/>=<sp/>st_init_table(st_ptrcmp,<sp/>st_ptrhash);</highlight></codeline>
<codeline lineno="315"><highlight class="normal"></highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Now<sp/>get<sp/>the<sp/>length<sp/>of<sp/>the<sp/>shortest<sp/>path(s)<sp/>from<sp/>f<sp/>to<sp/>1.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)<sp/>getLargest(f,<sp/>visited);</highlight></codeline>
<codeline lineno="318"><highlight class="normal"></highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/><sp/><sp/>complement<sp/>=<sp/>Cudd_IsComplement(f);</highlight></codeline>
<codeline lineno="320"><highlight class="normal"></highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/><sp/><sp/>F<sp/>=<sp/>Cudd_Regular(f);</highlight></codeline>
<codeline lineno="322"><highlight class="normal"></highlight></codeline>
<codeline lineno="323"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!st_lookup(visited,<sp/>F,<sp/>&amp;rootPair))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="324"><highlight class="normal"></highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(complement)<sp/>{</highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cost<sp/>=<sp/>rootPair-&gt;neg;</highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>cost<sp/>=<sp/>rootPair-&gt;pos;</highlight></codeline>
<codeline lineno="329"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="330"><highlight class="normal"></highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Recover<sp/>an<sp/>actual<sp/>shortest<sp/>path.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="332"><highlight class="normal"><sp/><sp/><sp/><sp/>sol<sp/>=<sp/>getCube(manager,visited,f,cost);</highlight></codeline>
<codeline lineno="333"><highlight class="normal"></highlight></codeline>
<codeline lineno="334"><highlight class="normal"><sp/><sp/><sp/><sp/>st_foreach(visited,<sp/>freePathPair,<sp/>NULL);</highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/><sp/><sp/>st_free_table(visited);</highlight></codeline>
<codeline lineno="336"><highlight class="normal"></highlight></codeline>
<codeline lineno="337"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(manager-&gt;reordered<sp/>==<sp/>1);</highlight></codeline>
<codeline lineno="338"><highlight class="normal"></highlight></codeline>
<codeline lineno="339"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(length<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*length<sp/>=<sp/>cost;</highlight></codeline>
<codeline lineno="341"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="342"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(sol);</highlight></codeline>
<codeline lineno="343"><highlight class="normal"></highlight></codeline>
<codeline lineno="344"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>Cudd_LargestCube<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="345"><highlight class="normal"></highlight></codeline>
<codeline lineno="346"><highlight class="normal"></highlight></codeline>
<codeline lineno="363"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="364"><highlight class="normal">Cudd_ShortestLength(</highlight></codeline>
<codeline lineno="365"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*<sp/>manager,</highlight></codeline>
<codeline lineno="366"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>f,</highlight></codeline>
<codeline lineno="367"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>weight)</highlight></codeline>
<codeline lineno="368"><highlight class="normal">{</highlight></codeline>
<codeline lineno="369"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">register</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/><sp/>*F;</highlight></codeline>
<codeline lineno="370"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structst__table" kindref="compound">st_table</ref><sp/><sp/><sp/><sp/>*visited;</highlight></codeline>
<codeline lineno="371"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref><sp/>*my_pair;</highlight></codeline>
<codeline lineno="372"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>complement,<sp/>cost;</highlight></codeline>
<codeline lineno="373"><highlight class="normal"></highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/><sp/><sp/>one<sp/>=<sp/>DD_ONE(manager);</highlight></codeline>
<codeline lineno="375"><highlight class="normal"><sp/><sp/><sp/><sp/>zero<sp/>=<sp/>DD_ZERO(manager);</highlight></codeline>
<codeline lineno="376"><highlight class="normal"></highlight></codeline>
<codeline lineno="377"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f<sp/>==<sp/>Cudd_Not(one)<sp/>||<sp/>f<sp/>==<sp/>zero)<sp/>{</highlight></codeline>
<codeline lineno="378"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(DD_BIGGY);</highlight></codeline>
<codeline lineno="379"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="380"><highlight class="normal"></highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>From<sp/>this<sp/>point<sp/>on,<sp/>a<sp/>path<sp/>exists.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Initialize<sp/>visited<sp/>table<sp/>and<sp/>support.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="383"><highlight class="normal"><sp/><sp/><sp/><sp/>visited<sp/>=<sp/>st_init_table(st_ptrcmp,<sp/>st_ptrhash);</highlight></codeline>
<codeline lineno="384"><highlight class="normal"></highlight></codeline>
<codeline lineno="385"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Now<sp/>get<sp/>the<sp/>length<sp/>of<sp/>the<sp/>shortest<sp/>path(s)<sp/>from<sp/>f<sp/>to<sp/>1.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)<sp/>getShortest(f,<sp/>weight,<sp/>NULL,<sp/>visited);</highlight></codeline>
<codeline lineno="387"><highlight class="normal"></highlight></codeline>
<codeline lineno="388"><highlight class="normal"><sp/><sp/><sp/><sp/>complement<sp/>=<sp/>Cudd_IsComplement(f);</highlight></codeline>
<codeline lineno="389"><highlight class="normal"></highlight></codeline>
<codeline lineno="390"><highlight class="normal"><sp/><sp/><sp/><sp/>F<sp/>=<sp/>Cudd_Regular(f);</highlight></codeline>
<codeline lineno="391"><highlight class="normal"></highlight></codeline>
<codeline lineno="392"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!st_lookup(visited,<sp/>F,<sp/>&amp;my_pair))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(CUDD_OUT_OF_MEM);</highlight></codeline>
<codeline lineno="393"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="394"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(complement)<sp/>{</highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/>cost<sp/>=<sp/>my_pair-&gt;neg;</highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="397"><highlight class="normal"><sp/><sp/><sp/><sp/>cost<sp/>=<sp/>my_pair-&gt;pos;</highlight></codeline>
<codeline lineno="398"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="399"><highlight class="normal"></highlight></codeline>
<codeline lineno="400"><highlight class="normal"><sp/><sp/><sp/><sp/>st_foreach(visited,<sp/>freePathPair,<sp/>NULL);</highlight></codeline>
<codeline lineno="401"><highlight class="normal"><sp/><sp/><sp/><sp/>st_free_table(visited);</highlight></codeline>
<codeline lineno="402"><highlight class="normal"></highlight></codeline>
<codeline lineno="403"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(cost);</highlight></codeline>
<codeline lineno="404"><highlight class="normal"></highlight></codeline>
<codeline lineno="405"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>Cudd_ShortestLength<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="406"><highlight class="normal"></highlight></codeline>
<codeline lineno="407"><highlight class="normal"></highlight></codeline>
<codeline lineno="423"><highlight class="normal"><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*</highlight></codeline>
<codeline lineno="424"><highlight class="normal">Cudd_Decreasing(</highlight></codeline>
<codeline lineno="425"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*<sp/>dd,</highlight></codeline>
<codeline lineno="426"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>f,</highlight></codeline>
<codeline lineno="427"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/>i)</highlight></codeline>
<codeline lineno="428"><highlight class="normal">{</highlight></codeline>
<codeline lineno="429"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>topf,<sp/>level;</highlight></codeline>
<codeline lineno="430"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*F,<sp/>*fv,<sp/>*fvn,<sp/>*res;</highlight></codeline>
<codeline lineno="431"><highlight class="normal"><sp/><sp/><sp/><sp/>DD_CTFP<sp/>cacheOp;</highlight></codeline>
<codeline lineno="432"><highlight class="normal"></highlight></codeline>
<codeline lineno="433"><highlight class="normal"><sp/><sp/><sp/><sp/>statLine(dd);</highlight></codeline>
<codeline lineno="434"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DD_DEBUG</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="435"><highlight class="normal"><sp/><sp/><sp/><sp/>assert(0<sp/>&lt;=<sp/>i<sp/>&amp;&amp;<sp/>i<sp/>&lt;<sp/>dd-&gt;size);</highlight></codeline>
<codeline lineno="436"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="437"><highlight class="normal"></highlight></codeline>
<codeline lineno="438"><highlight class="normal"><sp/><sp/><sp/><sp/>F<sp/>=<sp/>Cudd_Regular(f);</highlight></codeline>
<codeline lineno="439"><highlight class="normal"><sp/><sp/><sp/><sp/>topf<sp/>=<sp/>cuddI(dd,F-&gt;index);</highlight></codeline>
<codeline lineno="440"><highlight class="normal"></highlight></codeline>
<codeline lineno="441"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>terminal<sp/>case.<sp/>If<sp/>topf<sp/>&gt;<sp/>i,<sp/>f<sp/>does<sp/>not<sp/>depend<sp/>on<sp/>var.</highlight></codeline>
<codeline lineno="442"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>Therefore,<sp/>f<sp/>is<sp/>unate<sp/>in<sp/>i.</highlight></codeline>
<codeline lineno="443"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="444"><highlight class="normal"><sp/><sp/><sp/><sp/>level<sp/>=<sp/>(unsigned)<sp/>dd-&gt;perm[i];</highlight></codeline>
<codeline lineno="445"><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(topf<sp/>&gt;<sp/>level)<sp/>{</highlight></codeline>
<codeline lineno="446"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(DD_ONE(dd));</highlight></codeline>
<codeline lineno="447"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="448"><highlight class="normal"></highlight></codeline>
<codeline lineno="449"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>From<sp/>now<sp/>on,<sp/>f<sp/>is<sp/>not<sp/>constant.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="450"><highlight class="normal"></highlight></codeline>
<codeline lineno="451"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>cache.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="452"><highlight class="normal"><sp/><sp/><sp/><sp/>cacheOp<sp/>=<sp/>(DD_CTFP)<sp/>Cudd_Decreasing;</highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/>res<sp/>=<sp/>cuddCacheLookup2(dd,cacheOp,f,dd-&gt;vars[i]);</highlight></codeline>
<codeline lineno="454"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="455"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(res);</highlight></codeline>
<codeline lineno="456"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="457"><highlight class="normal"></highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>cofactors.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/>fv<sp/>=<sp/>cuddT(F);<sp/>fvn<sp/>=<sp/>cuddE(F);</highlight></codeline>
<codeline lineno="460"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(F<sp/>!=<sp/>f)<sp/>{</highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/>fv<sp/>=<sp/>Cudd_Not(fv);</highlight></codeline>
<codeline lineno="462"><highlight class="normal"><sp/><sp/><sp/><sp/>fvn<sp/>=<sp/>Cudd_Not(fvn);</highlight></codeline>
<codeline lineno="463"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="464"><highlight class="normal"></highlight></codeline>
<codeline lineno="465"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(topf<sp/>==<sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal">)<sp/>level)<sp/>{</highlight></codeline>
<codeline lineno="466"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Special<sp/>case:<sp/>if<sp/>fv<sp/>is<sp/>regular,<sp/>fv(1,...,1)<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="467"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>If<sp/>in<sp/>addition<sp/>fvn<sp/>is<sp/>complemented,<sp/>fvn(1,...,1)<sp/>=<sp/>0.</highlight></codeline>
<codeline lineno="468"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>But<sp/>then<sp/>f(1,1,...,1)<sp/>&gt;<sp/>f(0,1,...,1).<sp/>Hence<sp/>f<sp/>is<sp/>not</highlight></codeline>
<codeline lineno="469"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>monotonic<sp/>decreasing<sp/>in<sp/>i.</highlight></codeline>
<codeline lineno="470"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="471"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Cudd_IsComplement(fv)<sp/>&amp;&amp;<sp/>Cudd_IsComplement(fvn))<sp/>{</highlight></codeline>
<codeline lineno="472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(Cudd_Not(DD_ONE(dd)));</highlight></codeline>
<codeline lineno="473"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="474"><highlight class="normal"><sp/><sp/><sp/><sp/>res<sp/>=<sp/>Cudd_bddLeq(dd,fv,fvn)<sp/>?<sp/>DD_ONE(dd)<sp/>:<sp/>Cudd_Not(DD_ONE(dd));</highlight></codeline>
<codeline lineno="475"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="476"><highlight class="normal"><sp/><sp/><sp/><sp/>res<sp/>=<sp/>Cudd_Decreasing(dd,fv,i);</highlight></codeline>
<codeline lineno="477"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>==<sp/>DD_ONE(dd))<sp/>{</highlight></codeline>
<codeline lineno="478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>Cudd_Decreasing(dd,fvn,i);</highlight></codeline>
<codeline lineno="479"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="480"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="481"><highlight class="normal"></highlight></codeline>
<codeline lineno="482"><highlight class="normal"><sp/><sp/><sp/><sp/>cuddCacheInsert2(dd,cacheOp,f,dd-&gt;vars[i],res);</highlight></codeline>
<codeline lineno="483"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(res);</highlight></codeline>
<codeline lineno="484"><highlight class="normal"></highlight></codeline>
<codeline lineno="485"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>Cudd_Decreasing<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="486"><highlight class="normal"></highlight></codeline>
<codeline lineno="487"><highlight class="normal"></highlight></codeline>
<codeline lineno="503"><highlight class="normal"><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*</highlight></codeline>
<codeline lineno="504"><highlight class="normal">Cudd_Increasing(</highlight></codeline>
<codeline lineno="505"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*<sp/>dd,</highlight></codeline>
<codeline lineno="506"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>f,</highlight></codeline>
<codeline lineno="507"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/>i)</highlight></codeline>
<codeline lineno="508"><highlight class="normal">{</highlight></codeline>
<codeline lineno="509"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(Cudd_Decreasing(dd,Cudd_Not(f),i));</highlight></codeline>
<codeline lineno="510"><highlight class="normal"></highlight></codeline>
<codeline lineno="511"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>Cudd_Increasing<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="512"><highlight class="normal"></highlight></codeline>
<codeline lineno="513"><highlight class="normal"></highlight></codeline>
<codeline lineno="528"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="529"><highlight class="normal">Cudd_EquivDC(</highlight></codeline>
<codeline lineno="530"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*<sp/>dd,</highlight></codeline>
<codeline lineno="531"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>F,</highlight></codeline>
<codeline lineno="532"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>G,</highlight></codeline>
<codeline lineno="533"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>D)</highlight></codeline>
<codeline lineno="534"><highlight class="normal">{</highlight></codeline>
<codeline lineno="535"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*tmp,<sp/>*One,<sp/>*Gr,<sp/>*Dr;</highlight></codeline>
<codeline lineno="536"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*Fv,<sp/>*Fvn,<sp/>*Gv,<sp/>*Gvn,<sp/>*Dv,<sp/>*Dvn;</highlight></codeline>
<codeline lineno="537"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="538"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>flevel,<sp/>glevel,<sp/>dlevel,<sp/>top;</highlight></codeline>
<codeline lineno="539"><highlight class="normal"></highlight></codeline>
<codeline lineno="540"><highlight class="normal"><sp/><sp/><sp/><sp/>One<sp/>=<sp/>DD_ONE(dd);</highlight></codeline>
<codeline lineno="541"><highlight class="normal"></highlight></codeline>
<codeline lineno="542"><highlight class="normal"><sp/><sp/><sp/><sp/>statLine(dd);</highlight></codeline>
<codeline lineno="543"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>terminal<sp/>cases.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="544"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(D<sp/>==<sp/>One<sp/>||<sp/>F<sp/>==<sp/>G)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(1);</highlight></codeline>
<codeline lineno="545"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(D<sp/>==<sp/>Cudd_Not(One)<sp/>||<sp/>D<sp/>==<sp/>DD_ZERO(dd)<sp/>||<sp/>F<sp/>==<sp/>Cudd_Not(G))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(0);</highlight></codeline>
<codeline lineno="546"><highlight class="normal"></highlight></codeline>
<codeline lineno="547"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>From<sp/>now<sp/>on,<sp/>D<sp/>is<sp/>non-constant.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="548"><highlight class="normal"></highlight></codeline>
<codeline lineno="549"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Normalize<sp/>call<sp/>to<sp/>increase<sp/>cache<sp/>efficiency.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="550"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(F<sp/>&gt;<sp/>G)<sp/>{</highlight></codeline>
<codeline lineno="551"><highlight class="normal"><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>F;</highlight></codeline>
<codeline lineno="552"><highlight class="normal"><sp/><sp/><sp/><sp/>F<sp/>=<sp/>G;</highlight></codeline>
<codeline lineno="553"><highlight class="normal"><sp/><sp/><sp/><sp/>G<sp/>=<sp/>tmp;</highlight></codeline>
<codeline lineno="554"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="555"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cudd_IsComplement(F))<sp/>{</highlight></codeline>
<codeline lineno="556"><highlight class="normal"><sp/><sp/><sp/><sp/>F<sp/>=<sp/>Cudd_Not(F);</highlight></codeline>
<codeline lineno="557"><highlight class="normal"><sp/><sp/><sp/><sp/>G<sp/>=<sp/>Cudd_Not(G);</highlight></codeline>
<codeline lineno="558"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="559"><highlight class="normal"></highlight></codeline>
<codeline lineno="560"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>From<sp/>now<sp/>on,<sp/>F<sp/>is<sp/>regular.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="561"><highlight class="normal"></highlight></codeline>
<codeline lineno="562"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>cache.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="563"><highlight class="normal"><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>cuddCacheLookup(dd,DD_EQUIV_DC_TAG,F,G,D);</highlight></codeline>
<codeline lineno="564"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(tmp<sp/>!=<sp/>NULL)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(tmp<sp/>==<sp/>One);</highlight></codeline>
<codeline lineno="565"><highlight class="normal"></highlight></codeline>
<codeline lineno="566"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Find<sp/>splitting<sp/>variable.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="567"><highlight class="normal"><sp/><sp/><sp/><sp/>flevel<sp/>=<sp/>cuddI(dd,F-&gt;index);</highlight></codeline>
<codeline lineno="568"><highlight class="normal"><sp/><sp/><sp/><sp/>Gr<sp/>=<sp/>Cudd_Regular(G);</highlight></codeline>
<codeline lineno="569"><highlight class="normal"><sp/><sp/><sp/><sp/>glevel<sp/>=<sp/>cuddI(dd,Gr-&gt;index);</highlight></codeline>
<codeline lineno="570"><highlight class="normal"><sp/><sp/><sp/><sp/>top<sp/>=<sp/>ddMin(flevel,glevel);</highlight></codeline>
<codeline lineno="571"><highlight class="normal"><sp/><sp/><sp/><sp/>Dr<sp/>=<sp/>Cudd_Regular(D);</highlight></codeline>
<codeline lineno="572"><highlight class="normal"><sp/><sp/><sp/><sp/>dlevel<sp/>=<sp/>dd-&gt;perm[Dr-&gt;index];</highlight></codeline>
<codeline lineno="573"><highlight class="normal"><sp/><sp/><sp/><sp/>top<sp/>=<sp/>ddMin(top,dlevel);</highlight></codeline>
<codeline lineno="574"><highlight class="normal"></highlight></codeline>
<codeline lineno="575"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>cofactors.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="576"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(top<sp/>==<sp/>flevel)<sp/>{</highlight></codeline>
<codeline lineno="577"><highlight class="normal"><sp/><sp/><sp/><sp/>Fv<sp/>=<sp/>cuddT(F);</highlight></codeline>
<codeline lineno="578"><highlight class="normal"><sp/><sp/><sp/><sp/>Fvn<sp/>=<sp/>cuddE(F);</highlight></codeline>
<codeline lineno="579"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="580"><highlight class="normal"><sp/><sp/><sp/><sp/>Fv<sp/>=<sp/>Fvn<sp/>=<sp/>F;</highlight></codeline>
<codeline lineno="581"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="582"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(top<sp/>==<sp/>glevel)<sp/>{</highlight></codeline>
<codeline lineno="583"><highlight class="normal"><sp/><sp/><sp/><sp/>Gv<sp/>=<sp/>cuddT(Gr);</highlight></codeline>
<codeline lineno="584"><highlight class="normal"><sp/><sp/><sp/><sp/>Gvn<sp/>=<sp/>cuddE(Gr);</highlight></codeline>
<codeline lineno="585"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(G<sp/>!=<sp/>Gr)<sp/>{</highlight></codeline>
<codeline lineno="586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Gv<sp/>=<sp/>Cudd_Not(Gv);</highlight></codeline>
<codeline lineno="587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Gvn<sp/>=<sp/>Cudd_Not(Gvn);</highlight></codeline>
<codeline lineno="588"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="589"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="590"><highlight class="normal"><sp/><sp/><sp/><sp/>Gv<sp/>=<sp/>Gvn<sp/>=<sp/>G;</highlight></codeline>
<codeline lineno="591"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="592"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(top<sp/>==<sp/>dlevel)<sp/>{</highlight></codeline>
<codeline lineno="593"><highlight class="normal"><sp/><sp/><sp/><sp/>Dv<sp/>=<sp/>cuddT(Dr);</highlight></codeline>
<codeline lineno="594"><highlight class="normal"><sp/><sp/><sp/><sp/>Dvn<sp/>=<sp/>cuddE(Dr);</highlight></codeline>
<codeline lineno="595"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(D<sp/>!=<sp/>Dr)<sp/>{</highlight></codeline>
<codeline lineno="596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dv<sp/>=<sp/>Cudd_Not(Dv);</highlight></codeline>
<codeline lineno="597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Dvn<sp/>=<sp/>Cudd_Not(Dvn);</highlight></codeline>
<codeline lineno="598"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="599"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="600"><highlight class="normal"><sp/><sp/><sp/><sp/>Dv<sp/>=<sp/>Dvn<sp/>=<sp/>D;</highlight></codeline>
<codeline lineno="601"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="602"><highlight class="normal"></highlight></codeline>
<codeline lineno="603"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Solve<sp/>recursively.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="604"><highlight class="normal"><sp/><sp/><sp/><sp/>res<sp/>=<sp/>Cudd_EquivDC(dd,Fv,Gv,Dv);</highlight></codeline>
<codeline lineno="605"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="606"><highlight class="normal"><sp/><sp/><sp/><sp/>res<sp/>=<sp/>Cudd_EquivDC(dd,Fvn,Gvn,Dvn);</highlight></codeline>
<codeline lineno="607"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="608"><highlight class="normal"><sp/><sp/><sp/><sp/>cuddCacheInsert(dd,DD_EQUIV_DC_TAG,F,G,D,(res)<sp/>?<sp/>One<sp/>:<sp/>Cudd_Not(One));</highlight></codeline>
<codeline lineno="609"><highlight class="normal"></highlight></codeline>
<codeline lineno="610"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(res);</highlight></codeline>
<codeline lineno="611"><highlight class="normal"></highlight></codeline>
<codeline lineno="612"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>Cudd_EquivDC<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="613"><highlight class="normal"></highlight></codeline>
<codeline lineno="614"><highlight class="normal"></highlight></codeline>
<codeline lineno="628"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="629"><highlight class="normal">Cudd_bddLeqUnless(</highlight></codeline>
<codeline lineno="630"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*dd,</highlight></codeline>
<codeline lineno="631"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*f,</highlight></codeline>
<codeline lineno="632"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*g,</highlight></codeline>
<codeline lineno="633"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*D)</highlight></codeline>
<codeline lineno="634"><highlight class="normal">{</highlight></codeline>
<codeline lineno="635"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*tmp,<sp/>*One,<sp/>*F,<sp/>*G;</highlight></codeline>
<codeline lineno="636"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*Ft,<sp/>*Fe,<sp/>*Gt,<sp/>*Ge,<sp/>*Dt,<sp/>*De;</highlight></codeline>
<codeline lineno="637"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>res;</highlight></codeline>
<codeline lineno="638"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>flevel,<sp/>glevel,<sp/>dlevel,<sp/>top;</highlight></codeline>
<codeline lineno="639"><highlight class="normal"></highlight></codeline>
<codeline lineno="640"><highlight class="normal"><sp/><sp/><sp/><sp/>statLine(dd);</highlight></codeline>
<codeline lineno="641"><highlight class="normal"></highlight></codeline>
<codeline lineno="642"><highlight class="normal"><sp/><sp/><sp/><sp/>One<sp/>=<sp/>DD_ONE(dd);</highlight></codeline>
<codeline lineno="643"><highlight class="normal"></highlight></codeline>
<codeline lineno="644"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>terminal<sp/>cases.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="645"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f<sp/>==<sp/>g<sp/>||<sp/>g<sp/>==<sp/>One<sp/>||<sp/>f<sp/>==<sp/>Cudd_Not(One)<sp/>||<sp/>D<sp/>==<sp/>One<sp/>||</highlight></codeline>
<codeline lineno="646"><highlight class="normal"><sp/><sp/><sp/><sp/>D<sp/>==<sp/>f<sp/>||<sp/>D<sp/>==<sp/>Cudd_Not(g))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(1);</highlight></codeline>
<codeline lineno="647"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>for<sp/>two-operand<sp/>cases.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="648"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(D<sp/>==<sp/>Cudd_Not(One)<sp/>||<sp/>D<sp/>==<sp/>g<sp/>||<sp/>D<sp/>==<sp/>Cudd_Not(f))</highlight></codeline>
<codeline lineno="649"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(Cudd_bddLeq(dd,f,g));</highlight></codeline>
<codeline lineno="650"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(g<sp/>==<sp/>Cudd_Not(One)<sp/>||<sp/>g<sp/>==<sp/>Cudd_Not(f))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(Cudd_bddLeq(dd,f,D));</highlight></codeline>
<codeline lineno="651"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f<sp/>==<sp/>One)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(Cudd_bddLeq(dd,Cudd_Not(g),D));</highlight></codeline>
<codeline lineno="652"><highlight class="normal"></highlight></codeline>
<codeline lineno="653"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>From<sp/>now<sp/>on,<sp/>f,<sp/>g,<sp/>and<sp/>D<sp/>are<sp/>non-constant,<sp/>distinct,<sp/>and</highlight></codeline>
<codeline lineno="654"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>non-complementary.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="655"><highlight class="normal"></highlight></codeline>
<codeline lineno="656"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Normalize<sp/>call<sp/>to<sp/>increase<sp/>cache<sp/>efficiency.<sp/><sp/>We<sp/>rely<sp/>on<sp/>the</highlight></codeline>
<codeline lineno="657"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>fact<sp/>that<sp/>f<sp/>&lt;=<sp/>g<sp/>unless<sp/>D<sp/>is<sp/>equivalent<sp/>to<sp/>not(g)<sp/>&lt;=<sp/>not(f)</highlight></codeline>
<codeline lineno="658"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>unless<sp/>D<sp/>and<sp/>to<sp/>f<sp/>&lt;=<sp/>D<sp/>unless<sp/>g.<sp/><sp/>We<sp/>make<sp/>sure<sp/>that<sp/>D<sp/>is</highlight></codeline>
<codeline lineno="659"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>regular,<sp/>and<sp/>that<sp/>at<sp/>most<sp/>one<sp/>of<sp/>f<sp/>and<sp/>g<sp/>is<sp/>complemented.<sp/><sp/>We<sp/>also</highlight></codeline>
<codeline lineno="660"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>ensure<sp/>that<sp/>when<sp/>two<sp/>operands<sp/>can<sp/>be<sp/>swapped,<sp/>the<sp/>one<sp/>with<sp/>the</highlight></codeline>
<codeline lineno="661"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>lowest<sp/>address<sp/>comes<sp/>first.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="662"><highlight class="normal"></highlight></codeline>
<codeline lineno="663"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cudd_IsComplement(D))<sp/>{</highlight></codeline>
<codeline lineno="664"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cudd_IsComplement(g))<sp/>{</highlight></codeline>
<codeline lineno="665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Special<sp/>case:<sp/>if<sp/>f<sp/>is<sp/>regular<sp/>and<sp/>g<sp/>is<sp/>complemented,</highlight></codeline>
<codeline lineno="666"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>**<sp/>f(1,...,1)<sp/>=<sp/>1<sp/>&gt;<sp/>0<sp/>=<sp/>g(1,...,1).<sp/><sp/>If<sp/>D(1,...,1)<sp/>=<sp/>0,<sp/>return<sp/>0.</highlight></codeline>
<codeline lineno="667"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Cudd_IsComplement(f))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(0);</highlight></codeline>
<codeline lineno="669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>!g<sp/>&lt;=<sp/>D<sp/>unless<sp/>!f<sp/><sp/>or<sp/><sp/>!D<sp/>&lt;=<sp/>g<sp/>unless<sp/>!f<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>D;</highlight></codeline>
<codeline lineno="671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>D<sp/>=<sp/>Cudd_Not(f);</highlight></codeline>
<codeline lineno="672"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(g<sp/>&lt;<sp/>tmp)<sp/>{</highlight></codeline>
<codeline lineno="673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>f<sp/>=<sp/>Cudd_Not(g);</highlight></codeline>
<codeline lineno="674"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>g<sp/>=<sp/>tmp;</highlight></codeline>
<codeline lineno="675"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="676"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>f<sp/>=<sp/>Cudd_Not(tmp);</highlight></codeline>
<codeline lineno="677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="678"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cudd_IsComplement(f))<sp/>{</highlight></codeline>
<codeline lineno="680"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>!D<sp/>&lt;=<sp/>!f<sp/>unless<sp/>g<sp/><sp/>or<sp/><sp/>!D<sp/>&lt;=<sp/>g<sp/>unless<sp/>!f<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>f;</highlight></codeline>
<codeline lineno="682"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>f<sp/>=<sp/>Cudd_Not(D);</highlight></codeline>
<codeline lineno="683"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(tmp<sp/>&lt;<sp/>g)<sp/>{</highlight></codeline>
<codeline lineno="684"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>D<sp/>=<sp/>g;</highlight></codeline>
<codeline lineno="685"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>g<sp/>=<sp/>Cudd_Not(tmp);</highlight></codeline>
<codeline lineno="686"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>D<sp/>=<sp/>Cudd_Not(tmp);</highlight></codeline>
<codeline lineno="688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="690"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>f<sp/>&lt;=<sp/>D<sp/>unless<sp/>g<sp/><sp/>or<sp/><sp/>!D<sp/>&lt;=<sp/>!f<sp/>unless<sp/>g<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>D;</highlight></codeline>
<codeline lineno="692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>D<sp/>=<sp/>g;</highlight></codeline>
<codeline lineno="693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(tmp<sp/>&lt;<sp/>f)<sp/>{</highlight></codeline>
<codeline lineno="694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>g<sp/>=<sp/>Cudd_Not(f);</highlight></codeline>
<codeline lineno="695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>f<sp/>=<sp/>Cudd_Not(tmp);</highlight></codeline>
<codeline lineno="696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="697"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>g<sp/>=<sp/>tmp;</highlight></codeline>
<codeline lineno="698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="700"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="701"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="702"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cudd_IsComplement(g))<sp/>{</highlight></codeline>
<codeline lineno="703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cudd_IsComplement(f))<sp/>{</highlight></codeline>
<codeline lineno="704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>!g<sp/>&lt;=<sp/>!f<sp/>unless<sp/>D<sp/><sp/>or<sp/><sp/>!g<sp/>&lt;=<sp/>D<sp/>unless<sp/>!f<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="705"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>f;</highlight></codeline>
<codeline lineno="706"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>f<sp/>=<sp/>Cudd_Not(g);</highlight></codeline>
<codeline lineno="707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(D<sp/>&lt;<sp/>tmp)<sp/>{</highlight></codeline>
<codeline lineno="708"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>g<sp/>=<sp/>D;</highlight></codeline>
<codeline lineno="709"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>D<sp/>=<sp/>Cudd_Not(tmp);</highlight></codeline>
<codeline lineno="710"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>g<sp/>=<sp/>Cudd_Not(tmp);</highlight></codeline>
<codeline lineno="712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>f<sp/>&lt;=<sp/>g<sp/>unless<sp/>D<sp/><sp/>or<sp/><sp/>!g<sp/>&lt;=<sp/>!f<sp/>unless<sp/>D<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="715"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(g<sp/>&lt;<sp/>f)<sp/>{</highlight></codeline>
<codeline lineno="716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>g;</highlight></codeline>
<codeline lineno="717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>g<sp/>=<sp/>Cudd_Not(f);</highlight></codeline>
<codeline lineno="718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>f<sp/>=<sp/>Cudd_Not(tmp);</highlight></codeline>
<codeline lineno="719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="721"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>f<sp/>&lt;=<sp/>g<sp/>unless<sp/>D<sp/><sp/>or<sp/><sp/>f<sp/>&lt;=<sp/>D<sp/>unless<sp/>g<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(D<sp/>&lt;<sp/>g)<sp/>{</highlight></codeline>
<codeline lineno="724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>D;</highlight></codeline>
<codeline lineno="725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>D<sp/>=<sp/>g;</highlight></codeline>
<codeline lineno="726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>g<sp/>=<sp/>tmp;</highlight></codeline>
<codeline lineno="727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="728"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="729"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="730"><highlight class="normal"></highlight></codeline>
<codeline lineno="731"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>From<sp/>now<sp/>on,<sp/>D<sp/>is<sp/>regular.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="732"><highlight class="normal"></highlight></codeline>
<codeline lineno="733"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>cache.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="734"><highlight class="normal"><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>cuddCacheLookup(dd,DD_BDD_LEQ_UNLESS_TAG,f,g,D);</highlight></codeline>
<codeline lineno="735"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(tmp<sp/>!=<sp/>NULL)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(tmp<sp/>==<sp/>One);</highlight></codeline>
<codeline lineno="736"><highlight class="normal"></highlight></codeline>
<codeline lineno="737"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Find<sp/>splitting<sp/>variable.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="738"><highlight class="normal"><sp/><sp/><sp/><sp/>F<sp/>=<sp/>Cudd_Regular(f);</highlight></codeline>
<codeline lineno="739"><highlight class="normal"><sp/><sp/><sp/><sp/>flevel<sp/>=<sp/>dd-&gt;perm[F-&gt;index];</highlight></codeline>
<codeline lineno="740"><highlight class="normal"><sp/><sp/><sp/><sp/>G<sp/>=<sp/>Cudd_Regular(g);</highlight></codeline>
<codeline lineno="741"><highlight class="normal"><sp/><sp/><sp/><sp/>glevel<sp/>=<sp/>dd-&gt;perm[G-&gt;index];</highlight></codeline>
<codeline lineno="742"><highlight class="normal"><sp/><sp/><sp/><sp/>top<sp/>=<sp/>ddMin(flevel,glevel);</highlight></codeline>
<codeline lineno="743"><highlight class="normal"><sp/><sp/><sp/><sp/>dlevel<sp/>=<sp/>dd-&gt;perm[D-&gt;index];</highlight></codeline>
<codeline lineno="744"><highlight class="normal"><sp/><sp/><sp/><sp/>top<sp/>=<sp/>ddMin(top,dlevel);</highlight></codeline>
<codeline lineno="745"><highlight class="normal"></highlight></codeline>
<codeline lineno="746"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>cofactors.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="747"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(top<sp/>==<sp/>flevel)<sp/>{</highlight></codeline>
<codeline lineno="748"><highlight class="normal"><sp/><sp/><sp/><sp/>Ft<sp/>=<sp/>cuddT(F);</highlight></codeline>
<codeline lineno="749"><highlight class="normal"><sp/><sp/><sp/><sp/>Fe<sp/>=<sp/>cuddE(F);</highlight></codeline>
<codeline lineno="750"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(F<sp/>!=<sp/>f)<sp/>{</highlight></codeline>
<codeline lineno="751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ft<sp/>=<sp/>Cudd_Not(Ft);</highlight></codeline>
<codeline lineno="752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Fe<sp/>=<sp/>Cudd_Not(Fe);</highlight></codeline>
<codeline lineno="753"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="754"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="755"><highlight class="normal"><sp/><sp/><sp/><sp/>Ft<sp/>=<sp/>Fe<sp/>=<sp/>f;</highlight></codeline>
<codeline lineno="756"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="757"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(top<sp/>==<sp/>glevel)<sp/>{</highlight></codeline>
<codeline lineno="758"><highlight class="normal"><sp/><sp/><sp/><sp/>Gt<sp/>=<sp/>cuddT(G);</highlight></codeline>
<codeline lineno="759"><highlight class="normal"><sp/><sp/><sp/><sp/>Ge<sp/>=<sp/>cuddE(G);</highlight></codeline>
<codeline lineno="760"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(G<sp/>!=<sp/>g)<sp/>{</highlight></codeline>
<codeline lineno="761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Gt<sp/>=<sp/>Cudd_Not(Gt);</highlight></codeline>
<codeline lineno="762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ge<sp/>=<sp/>Cudd_Not(Ge);</highlight></codeline>
<codeline lineno="763"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="764"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="765"><highlight class="normal"><sp/><sp/><sp/><sp/>Gt<sp/>=<sp/>Ge<sp/>=<sp/>g;</highlight></codeline>
<codeline lineno="766"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="767"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(top<sp/>==<sp/>dlevel)<sp/>{</highlight></codeline>
<codeline lineno="768"><highlight class="normal"><sp/><sp/><sp/><sp/>Dt<sp/>=<sp/>cuddT(D);</highlight></codeline>
<codeline lineno="769"><highlight class="normal"><sp/><sp/><sp/><sp/>De<sp/>=<sp/>cuddE(D);</highlight></codeline>
<codeline lineno="770"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="771"><highlight class="normal"><sp/><sp/><sp/><sp/>Dt<sp/>=<sp/>De<sp/>=<sp/>D;</highlight></codeline>
<codeline lineno="772"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="773"><highlight class="normal"></highlight></codeline>
<codeline lineno="774"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Solve<sp/>recursively.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="775"><highlight class="normal"><sp/><sp/><sp/><sp/>res<sp/>=<sp/>Cudd_bddLeqUnless(dd,Ft,Gt,Dt);</highlight></codeline>
<codeline lineno="776"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="777"><highlight class="normal"><sp/><sp/><sp/><sp/>res<sp/>=<sp/>Cudd_bddLeqUnless(dd,Fe,Ge,De);</highlight></codeline>
<codeline lineno="778"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="779"><highlight class="normal"><sp/><sp/><sp/><sp/>cuddCacheInsert(dd,DD_BDD_LEQ_UNLESS_TAG,f,g,D,Cudd_NotCond(One,!res));</highlight></codeline>
<codeline lineno="780"><highlight class="normal"></highlight></codeline>
<codeline lineno="781"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(res);</highlight></codeline>
<codeline lineno="782"><highlight class="normal"></highlight></codeline>
<codeline lineno="783"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>Cudd_bddLeqUnless<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="784"><highlight class="normal"></highlight></codeline>
<codeline lineno="785"><highlight class="normal"></highlight></codeline>
<codeline lineno="802"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="803"><highlight class="normal">Cudd_EqualSupNorm(</highlight></codeline>
<codeline lineno="804"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*<sp/>dd<sp/></highlight><highlight class="comment">/*<sp/>manager<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="805"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>f<sp/></highlight><highlight class="comment">/*<sp/>first<sp/>ADD<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="806"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>g<sp/></highlight><highlight class="comment">/*<sp/>second<sp/>ADD<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="807"><highlight class="normal"><sp/><sp/>CUDD_VALUE_TYPE<sp/><sp/>tolerance<sp/></highlight><highlight class="comment">/*<sp/>maximum<sp/>allowed<sp/>difference<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="808"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/>pr<sp/></highlight><highlight class="comment">/*<sp/>verbosity<sp/>level<sp/>*/</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="809"><highlight class="normal">{</highlight></codeline>
<codeline lineno="810"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*fv,<sp/>*fvn,<sp/>*gv,<sp/>*gvn,<sp/>*r;</highlight></codeline>
<codeline lineno="811"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>topf,<sp/>topg;</highlight></codeline>
<codeline lineno="812"><highlight class="normal"></highlight></codeline>
<codeline lineno="813"><highlight class="normal"><sp/><sp/><sp/><sp/>statLine(dd);</highlight></codeline>
<codeline lineno="814"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>terminal<sp/>cases.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="815"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f<sp/>==<sp/>g)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(1);</highlight></codeline>
<codeline lineno="816"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cudd_IsConstant(f)<sp/>&amp;&amp;<sp/>Cudd_IsConstant(g))<sp/>{</highlight></codeline>
<codeline lineno="817"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ddEqualVal(cuddV(f),cuddV(g),tolerance))<sp/>{</highlight></codeline>
<codeline lineno="818"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(1);</highlight></codeline>
<codeline lineno="819"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="820"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pr&gt;0)<sp/>{</highlight></codeline>
<codeline lineno="821"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(void)<sp/>fprintf(dd-&gt;out,</highlight><highlight class="stringliteral">&quot;Offending<sp/>nodes:\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="822"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(void)<sp/>fprintf(dd-&gt;out,</highlight></codeline>
<codeline lineno="823"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;f:<sp/>address<sp/>=<sp/>%p\t<sp/>value<sp/>=<sp/>%40.30f\n&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="824"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)<sp/>f,<sp/>cuddV(f));</highlight></codeline>
<codeline lineno="825"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(void)<sp/>fprintf(dd-&gt;out,</highlight></codeline>
<codeline lineno="826"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;g:<sp/>address<sp/>=<sp/>%p\t<sp/>value<sp/>=<sp/>%40.30f\n&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)<sp/>g,<sp/>cuddV(g));</highlight></codeline>
<codeline lineno="828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="829"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(0);</highlight></codeline>
<codeline lineno="830"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="831"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="832"><highlight class="normal"></highlight></codeline>
<codeline lineno="833"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>We<sp/>only<sp/>insert<sp/>the<sp/>result<sp/>in<sp/>the<sp/>cache<sp/>if<sp/>the<sp/>comparison<sp/>is</highlight></codeline>
<codeline lineno="834"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>successful.<sp/>Therefore,<sp/>if<sp/>we<sp/>hit<sp/>we<sp/>return<sp/>1.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="835"><highlight class="normal"><sp/><sp/><sp/><sp/>r<sp/>=<sp/>cuddCacheLookup2(dd,(DD_CTFP)Cudd_EqualSupNorm,f,g);</highlight></codeline>
<codeline lineno="836"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(r<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="837"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(1);</highlight></codeline>
<codeline lineno="838"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="839"><highlight class="normal"></highlight></codeline>
<codeline lineno="840"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>the<sp/>cofactors<sp/>and<sp/>solve<sp/>the<sp/>recursive<sp/>subproblems.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="841"><highlight class="normal"><sp/><sp/><sp/><sp/>topf<sp/>=<sp/>cuddI(dd,f-&gt;index);</highlight></codeline>
<codeline lineno="842"><highlight class="normal"><sp/><sp/><sp/><sp/>topg<sp/>=<sp/>cuddI(dd,g-&gt;index);</highlight></codeline>
<codeline lineno="843"><highlight class="normal"></highlight></codeline>
<codeline lineno="844"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(topf<sp/>&lt;=<sp/>topg)<sp/>{fv<sp/>=<sp/>cuddT(f);<sp/>fvn<sp/>=<sp/>cuddE(f);}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{fv<sp/>=<sp/>fvn<sp/>=<sp/>f;}</highlight></codeline>
<codeline lineno="845"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(topg<sp/>&lt;=<sp/>topf)<sp/>{gv<sp/>=<sp/>cuddT(g);<sp/>gvn<sp/>=<sp/>cuddE(g);}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{gv<sp/>=<sp/>gvn<sp/>=<sp/>g;}</highlight></codeline>
<codeline lineno="846"><highlight class="normal"></highlight></codeline>
<codeline lineno="847"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Cudd_EqualSupNorm(dd,fv,gv,tolerance,pr))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(0);</highlight></codeline>
<codeline lineno="848"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Cudd_EqualSupNorm(dd,fvn,gvn,tolerance,pr))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(0);</highlight></codeline>
<codeline lineno="849"><highlight class="normal"></highlight></codeline>
<codeline lineno="850"><highlight class="normal"><sp/><sp/><sp/><sp/>cuddCacheInsert2(dd,(DD_CTFP)Cudd_EqualSupNorm,f,g,DD_ONE(dd));</highlight></codeline>
<codeline lineno="851"><highlight class="normal"></highlight></codeline>
<codeline lineno="852"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(1);</highlight></codeline>
<codeline lineno="853"><highlight class="normal"></highlight></codeline>
<codeline lineno="854"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>Cudd_EqualSupNorm<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="855"><highlight class="normal"></highlight></codeline>
<codeline lineno="856"><highlight class="normal"></highlight></codeline>
<codeline lineno="870"><highlight class="normal"><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*</highlight></codeline>
<codeline lineno="871"><highlight class="normal">Cudd_bddMakePrime(</highlight></codeline>
<codeline lineno="872"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*dd<sp/></highlight><highlight class="comment">/*<sp/>manager<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="873"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*cube<sp/></highlight><highlight class="comment">/*<sp/>cube<sp/>to<sp/>be<sp/>expanded<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="874"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*f<sp/></highlight><highlight class="comment">/*<sp/>function<sp/>of<sp/>which<sp/>the<sp/>cube<sp/>is<sp/>to<sp/>be<sp/>made<sp/>a<sp/>prime<sp/>*/</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="875"><highlight class="normal">{</highlight></codeline>
<codeline lineno="876"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*res;</highlight></codeline>
<codeline lineno="877"><highlight class="normal"></highlight></codeline>
<codeline lineno="878"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Cudd_bddLeq(dd,cube,f))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="879"><highlight class="normal"></highlight></codeline>
<codeline lineno="880"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="881"><highlight class="normal"><sp/><sp/><sp/><sp/>dd-&gt;reordered<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="882"><highlight class="normal"><sp/><sp/><sp/><sp/>res<sp/>=<sp/>cuddBddMakePrime(dd,cube,f);</highlight></codeline>
<codeline lineno="883"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(dd-&gt;reordered<sp/>==<sp/>1);</highlight></codeline>
<codeline lineno="884"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(res);</highlight></codeline>
<codeline lineno="885"><highlight class="normal"></highlight></codeline>
<codeline lineno="886"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>Cudd_bddMakePrime<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="887"><highlight class="normal"></highlight></codeline>
<codeline lineno="888"><highlight class="normal"></highlight></codeline>
<codeline lineno="905"><highlight class="normal"><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*</highlight></codeline>
<codeline lineno="906"><highlight class="normal">Cudd_bddMaximallyExpand(</highlight></codeline>
<codeline lineno="907"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*dd<sp/></highlight><highlight class="comment">/*<sp/>manager<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="908"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*lb<sp/></highlight><highlight class="comment">/*<sp/>cube<sp/>to<sp/>be<sp/>expanded<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="909"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*ub<sp/></highlight><highlight class="comment">/*<sp/>upper<sp/>bound<sp/>cube<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="910"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*f<sp/></highlight><highlight class="comment">/*<sp/>function<sp/>against<sp/>which<sp/>to<sp/>expand<sp/>*/</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="911"><highlight class="normal">{</highlight></codeline>
<codeline lineno="912"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*res;</highlight></codeline>
<codeline lineno="913"><highlight class="normal"></highlight></codeline>
<codeline lineno="914"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Cudd_bddLeq(dd,lb,ub))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="915"><highlight class="normal"></highlight></codeline>
<codeline lineno="916"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="917"><highlight class="normal"><sp/><sp/><sp/><sp/>dd-&gt;reordered<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="918"><highlight class="normal"><sp/><sp/><sp/><sp/>res<sp/>=<sp/>ddBddMaximallyExpand(dd,lb,ub,f);</highlight></codeline>
<codeline lineno="919"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(dd-&gt;reordered<sp/>==<sp/>1);</highlight></codeline>
<codeline lineno="920"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(res);</highlight></codeline>
<codeline lineno="921"><highlight class="normal"></highlight></codeline>
<codeline lineno="922"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>Cudd_bddMaximallyExpand<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="923"><highlight class="normal"></highlight></codeline>
<codeline lineno="924"><highlight class="normal"></highlight></codeline>
<codeline lineno="940"><highlight class="normal"><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*</highlight></codeline>
<codeline lineno="941"><highlight class="normal">Cudd_bddLargestPrimeUnate(</highlight></codeline>
<codeline lineno="942"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*dd<sp/></highlight><highlight class="comment">/*<sp/>manager<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="943"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*f<sp/></highlight><highlight class="comment">/*<sp/>unate<sp/>function<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="944"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*phaseBdd<sp/></highlight><highlight class="comment">/*<sp/>cube<sp/>of<sp/>the<sp/>phases<sp/>*/</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="945"><highlight class="normal">{</highlight></codeline>
<codeline lineno="946"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*res;</highlight></codeline>
<codeline lineno="947"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*phases;</highlight></codeline>
<codeline lineno="948"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>retval;</highlight></codeline>
<codeline lineno="949"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structst__table" kindref="compound">st_table</ref><sp/>*table;</highlight></codeline>
<codeline lineno="950"><highlight class="normal"></highlight></codeline>
<codeline lineno="951"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Extract<sp/>phase<sp/>vector<sp/>for<sp/>quick<sp/>access.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="952"><highlight class="normal"><sp/><sp/><sp/><sp/>phases<sp/>=<sp/>ALLOC(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">,<sp/>dd-&gt;size);</highlight></codeline>
<codeline lineno="953"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(phases<sp/>==<sp/>NULL)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="954"><highlight class="normal"><sp/><sp/><sp/><sp/>retval<sp/>=<sp/>Cudd_BddToCubeArray(dd,<sp/>phaseBdd,<sp/>phases);</highlight></codeline>
<codeline lineno="955"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(retval<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="956"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FREE(phases);</highlight></codeline>
<codeline lineno="957"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="958"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="959"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="960"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dd-&gt;reordered<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="961"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>table<sp/>=<sp/>st_init_table(st_ptrcmp,st_ptrhash);</highlight></codeline>
<codeline lineno="962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(table<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FREE(phases);</highlight></codeline>
<codeline lineno="964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="965"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="966"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)<sp/>ddBddShortestPathUnate(dd,<sp/>f,<sp/>phases,<sp/>table);</highlight></codeline>
<codeline lineno="967"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>ddGetLargestCubeUnate(dd,<sp/>f,<sp/>phases,<sp/>table);</highlight></codeline>
<codeline lineno="968"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>st_free_table(table);</highlight></codeline>
<codeline lineno="969"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(dd-&gt;reordered<sp/>==<sp/>1);</highlight></codeline>
<codeline lineno="970"><highlight class="normal"></highlight></codeline>
<codeline lineno="971"><highlight class="normal"><sp/><sp/><sp/><sp/>FREE(phases);</highlight></codeline>
<codeline lineno="972"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(res);</highlight></codeline>
<codeline lineno="973"><highlight class="normal"></highlight></codeline>
<codeline lineno="974"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>Cudd_bddLargestPrimeUnate<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="975"><highlight class="normal"></highlight></codeline>
<codeline lineno="976"><highlight class="normal"></highlight></codeline>
<codeline lineno="977"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="978"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Definition<sp/>of<sp/>internal<sp/>functions<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="979"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="980"><highlight class="normal"></highlight></codeline>
<codeline lineno="981"><highlight class="normal"></highlight></codeline>
<codeline lineno="994"><highlight class="normal"><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*</highlight></codeline>
<codeline lineno="995"><highlight class="normal">cuddBddMakePrime(</highlight></codeline>
<codeline lineno="996"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*dd<sp/></highlight><highlight class="comment">/*<sp/>manager<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="997"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*cube<sp/></highlight><highlight class="comment">/*<sp/>cube<sp/>to<sp/>be<sp/>expanded<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="998"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*f<sp/></highlight><highlight class="comment">/*<sp/>function<sp/>of<sp/>which<sp/>the<sp/>cube<sp/>is<sp/>to<sp/>be<sp/>made<sp/>a<sp/>prime<sp/>*/</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="999"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1000"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*scan;</highlight></codeline>
<codeline lineno="1001"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*t,<sp/>*e;</highlight></codeline>
<codeline lineno="1002"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*res<sp/>=<sp/>cube;</highlight></codeline>
<codeline lineno="1003"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*zero<sp/>=<sp/>Cudd_Not(DD_ONE(dd));</highlight></codeline>
<codeline lineno="1004"><highlight class="normal"></highlight></codeline>
<codeline lineno="1005"><highlight class="normal"><sp/><sp/><sp/><sp/>Cudd_Ref(res);</highlight></codeline>
<codeline lineno="1006"><highlight class="normal"><sp/><sp/><sp/><sp/>scan<sp/>=<sp/>cube;</highlight></codeline>
<codeline lineno="1007"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(!Cudd_IsConstant(scan))<sp/>{</highlight></codeline>
<codeline lineno="1008"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*reg<sp/>=<sp/>Cudd_Regular(scan);</highlight></codeline>
<codeline lineno="1009"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*var<sp/>=<sp/>dd-&gt;vars[reg-&gt;index];</highlight></codeline>
<codeline lineno="1010"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*expanded<sp/>=<sp/>Cudd_bddExistAbstract(dd,res,var);</highlight></codeline>
<codeline lineno="1011"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(expanded<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_RecursiveDeref(dd,res);</highlight></codeline>
<codeline lineno="1013"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1014"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1015"><highlight class="normal"><sp/><sp/><sp/><sp/>Cudd_Ref(expanded);</highlight></codeline>
<codeline lineno="1016"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cudd_bddLeq(dd,expanded,f))<sp/>{</highlight></codeline>
<codeline lineno="1017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_RecursiveDeref(dd,res);</highlight></codeline>
<codeline lineno="1018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>expanded;</highlight></codeline>
<codeline lineno="1019"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1020"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_RecursiveDeref(dd,expanded);</highlight></codeline>
<codeline lineno="1021"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1022"><highlight class="normal"><sp/><sp/><sp/><sp/>cuddGetBranches(scan,&amp;t,&amp;e);</highlight></codeline>
<codeline lineno="1023"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(t<sp/>==<sp/>zero)<sp/>{</highlight></codeline>
<codeline lineno="1024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scan<sp/>=<sp/>e;</highlight></codeline>
<codeline lineno="1025"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(e<sp/>==<sp/>zero)<sp/>{</highlight></codeline>
<codeline lineno="1026"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scan<sp/>=<sp/>t;</highlight></codeline>
<codeline lineno="1027"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_RecursiveDeref(dd,res);</highlight></codeline>
<codeline lineno="1029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);<sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>cube<sp/>is<sp/>not<sp/>a<sp/>cube<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1030"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1031"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1032"><highlight class="normal"></highlight></codeline>
<codeline lineno="1033"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(scan<sp/>==<sp/>DD_ONE(dd))<sp/>{</highlight></codeline>
<codeline lineno="1034"><highlight class="normal"><sp/><sp/><sp/><sp/>Cudd_Deref(res);</highlight></codeline>
<codeline lineno="1035"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(res);</highlight></codeline>
<codeline lineno="1036"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1037"><highlight class="normal"><sp/><sp/><sp/><sp/>Cudd_RecursiveDeref(dd,res);</highlight></codeline>
<codeline lineno="1038"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1039"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1040"><highlight class="normal"></highlight></codeline>
<codeline lineno="1041"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>cuddBddMakePrime<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1042"><highlight class="normal"></highlight></codeline>
<codeline lineno="1043"><highlight class="normal"></highlight></codeline>
<codeline lineno="1044"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1045"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Definition<sp/>of<sp/>static<sp/>functions<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1046"><highlight class="normal"></highlight><highlight class="comment">/*---------------------------------------------------------------------------*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1047"><highlight class="normal"></highlight></codeline>
<codeline lineno="1048"><highlight class="normal"></highlight></codeline>
<codeline lineno="1059"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>st_retval</highlight></codeline>
<codeline lineno="1060"><highlight class="normal">freePathPair(</highlight></codeline>
<codeline lineno="1061"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*<sp/>key,</highlight></codeline>
<codeline lineno="1062"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*<sp/>value,</highlight></codeline>
<codeline lineno="1063"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*<sp/>arg)</highlight></codeline>
<codeline lineno="1064"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1065"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref><sp/>*pair;</highlight></codeline>
<codeline lineno="1066"><highlight class="normal"></highlight></codeline>
<codeline lineno="1067"><highlight class="normal"><sp/><sp/><sp/><sp/>pair<sp/>=<sp/>(<ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref><sp/>*)<sp/>value;</highlight></codeline>
<codeline lineno="1068"><highlight class="normal"><sp/><sp/><sp/><sp/>FREE(pair);</highlight></codeline>
<codeline lineno="1069"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(ST_CONTINUE);</highlight></codeline>
<codeline lineno="1070"><highlight class="normal"></highlight></codeline>
<codeline lineno="1071"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>freePathPair<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1072"><highlight class="normal"></highlight></codeline>
<codeline lineno="1073"><highlight class="normal"></highlight></codeline>
<codeline lineno="1092"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref></highlight></codeline>
<codeline lineno="1093"><highlight class="normal">getShortest(</highlight></codeline>
<codeline lineno="1094"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>root,</highlight></codeline>
<codeline lineno="1095"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>cost,</highlight></codeline>
<codeline lineno="1096"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>support,</highlight></codeline>
<codeline lineno="1097"><highlight class="normal"><sp/><sp/><ref refid="structst__table" kindref="compound">st_table</ref><sp/>*<sp/>visited)</highlight></codeline>
<codeline lineno="1098"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1099"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref><sp/>*my_pair,<sp/>res_pair,<sp/>pair_T,<sp/>pair_E;</highlight></codeline>
<codeline lineno="1100"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/><sp/>*my_root,<sp/>*T,<sp/>*E;</highlight></codeline>
<codeline lineno="1101"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>weight;</highlight></codeline>
<codeline lineno="1102"><highlight class="normal"></highlight></codeline>
<codeline lineno="1103"><highlight class="normal"><sp/><sp/><sp/><sp/>my_root<sp/>=<sp/>Cudd_Regular(root);</highlight></codeline>
<codeline lineno="1104"><highlight class="normal"></highlight></codeline>
<codeline lineno="1105"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(st_lookup(visited,<sp/>my_root,<sp/>&amp;my_pair))<sp/>{</highlight></codeline>
<codeline lineno="1106"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cudd_IsComplement(root))<sp/>{</highlight></codeline>
<codeline lineno="1107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.pos<sp/>=<sp/>my_pair-&gt;neg;</highlight></codeline>
<codeline lineno="1108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.neg<sp/>=<sp/>my_pair-&gt;pos;</highlight></codeline>
<codeline lineno="1109"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.pos<sp/>=<sp/>my_pair-&gt;pos;</highlight></codeline>
<codeline lineno="1111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.neg<sp/>=<sp/>my_pair-&gt;neg;</highlight></codeline>
<codeline lineno="1112"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1113"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(res_pair);</highlight></codeline>
<codeline lineno="1114"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1115"><highlight class="normal"></highlight></codeline>
<codeline lineno="1116"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>In<sp/>the<sp/>case<sp/>of<sp/>a<sp/>BDD<sp/>the<sp/>following<sp/>test<sp/>is<sp/>equivalent<sp/>to</highlight></codeline>
<codeline lineno="1117"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>testing<sp/>whether<sp/>the<sp/>BDD<sp/>is<sp/>the<sp/>constant<sp/>1.<sp/>This<sp/>formulation,</highlight></codeline>
<codeline lineno="1118"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>however,<sp/>works<sp/>for<sp/>ADDs<sp/>as<sp/>well,<sp/>by<sp/>assuming<sp/>the<sp/>usual</highlight></codeline>
<codeline lineno="1119"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>dichotomy<sp/>of<sp/>0<sp/>and<sp/>!=<sp/>0.</highlight></codeline>
<codeline lineno="1120"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1121"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(cuddIsConstant(my_root))<sp/>{</highlight></codeline>
<codeline lineno="1122"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(my_root<sp/>!=<sp/>zero)<sp/>{</highlight></codeline>
<codeline lineno="1123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.pos<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.neg<sp/>=<sp/>DD_BIGGY;</highlight></codeline>
<codeline lineno="1125"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.pos<sp/>=<sp/>DD_BIGGY;</highlight></codeline>
<codeline lineno="1127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.neg<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1128"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1129"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1130"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>=<sp/>cuddT(my_root);</highlight></codeline>
<codeline lineno="1131"><highlight class="normal"><sp/><sp/><sp/><sp/>E<sp/>=<sp/>cuddE(my_root);</highlight></codeline>
<codeline lineno="1132"><highlight class="normal"></highlight></codeline>
<codeline lineno="1133"><highlight class="normal"><sp/><sp/><sp/><sp/>pair_T<sp/>=<sp/>getShortest(T,<sp/>cost,<sp/>support,<sp/>visited);</highlight></codeline>
<codeline lineno="1134"><highlight class="normal"><sp/><sp/><sp/><sp/>pair_E<sp/>=<sp/>getShortest(E,<sp/>cost,<sp/>support,<sp/>visited);</highlight></codeline>
<codeline lineno="1135"><highlight class="normal"><sp/><sp/><sp/><sp/>weight<sp/>=<sp/>WEIGHT(cost,<sp/>my_root-&gt;index);</highlight></codeline>
<codeline lineno="1136"><highlight class="normal"><sp/><sp/><sp/><sp/>res_pair.pos<sp/>=<sp/>ddMin(pair_T.pos+weight,<sp/>pair_E.pos);</highlight></codeline>
<codeline lineno="1137"><highlight class="normal"><sp/><sp/><sp/><sp/>res_pair.neg<sp/>=<sp/>ddMin(pair_T.neg+weight,<sp/>pair_E.neg);</highlight></codeline>
<codeline lineno="1138"><highlight class="normal"></highlight></codeline>
<codeline lineno="1139"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Update<sp/>support.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1140"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(support<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>support[my_root-&gt;index]<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1142"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1143"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1144"><highlight class="normal"></highlight></codeline>
<codeline lineno="1145"><highlight class="normal"><sp/><sp/><sp/><sp/>my_pair<sp/>=<sp/>ALLOC(<ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref>,<sp/>1);</highlight></codeline>
<codeline lineno="1146"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(my_pair<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1147"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cudd_IsComplement(root))<sp/>{</highlight></codeline>
<codeline lineno="1148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tmp<sp/>=<sp/>res_pair.pos;</highlight></codeline>
<codeline lineno="1149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.pos<sp/>=<sp/>res_pair.neg;</highlight></codeline>
<codeline lineno="1150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.neg<sp/>=<sp/>tmp;</highlight></codeline>
<codeline lineno="1151"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1152"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(res_pair);</highlight></codeline>
<codeline lineno="1153"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1154"><highlight class="normal"><sp/><sp/><sp/><sp/>my_pair-&gt;pos<sp/>=<sp/>res_pair.pos;</highlight></codeline>
<codeline lineno="1155"><highlight class="normal"><sp/><sp/><sp/><sp/>my_pair-&gt;neg<sp/>=<sp/>res_pair.neg;</highlight></codeline>
<codeline lineno="1156"><highlight class="normal"></highlight></codeline>
<codeline lineno="1157"><highlight class="normal"><sp/><sp/><sp/><sp/>st_insert(visited,<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*)my_root,<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*)my_pair);</highlight></codeline>
<codeline lineno="1158"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cudd_IsComplement(root))<sp/>{</highlight></codeline>
<codeline lineno="1159"><highlight class="normal"><sp/><sp/><sp/><sp/>res_pair.pos<sp/>=<sp/>my_pair-&gt;neg;</highlight></codeline>
<codeline lineno="1160"><highlight class="normal"><sp/><sp/><sp/><sp/>res_pair.neg<sp/>=<sp/>my_pair-&gt;pos;</highlight></codeline>
<codeline lineno="1161"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1162"><highlight class="normal"><sp/><sp/><sp/><sp/>res_pair.pos<sp/>=<sp/>my_pair-&gt;pos;</highlight></codeline>
<codeline lineno="1163"><highlight class="normal"><sp/><sp/><sp/><sp/>res_pair.neg<sp/>=<sp/>my_pair-&gt;neg;</highlight></codeline>
<codeline lineno="1164"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1165"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(res_pair);</highlight></codeline>
<codeline lineno="1166"><highlight class="normal"></highlight></codeline>
<codeline lineno="1167"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>getShortest<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1168"><highlight class="normal"></highlight></codeline>
<codeline lineno="1169"><highlight class="normal"></highlight></codeline>
<codeline lineno="1188"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*</highlight></codeline>
<codeline lineno="1189"><highlight class="normal">getPath(</highlight></codeline>
<codeline lineno="1190"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*<sp/>manager,</highlight></codeline>
<codeline lineno="1191"><highlight class="normal"><sp/><sp/><ref refid="structst__table" kindref="compound">st_table</ref><sp/>*<sp/>visited,</highlight></codeline>
<codeline lineno="1192"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>f,</highlight></codeline>
<codeline lineno="1193"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*<sp/>weight,</highlight></codeline>
<codeline lineno="1194"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/>cost)</highlight></codeline>
<codeline lineno="1195"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1196"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/><sp/>*sol,<sp/>*tmp;</highlight></codeline>
<codeline lineno="1197"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/><sp/>*my_dd,<sp/>*T,<sp/>*E;</highlight></codeline>
<codeline lineno="1198"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref><sp/>*T_pair,<sp/>*E_pair;</highlight></codeline>
<codeline lineno="1199"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>Tcost,<sp/>Ecost;</highlight></codeline>
<codeline lineno="1200"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>complement;</highlight></codeline>
<codeline lineno="1201"><highlight class="normal"></highlight></codeline>
<codeline lineno="1202"><highlight class="normal"><sp/><sp/><sp/><sp/>my_dd<sp/>=<sp/>Cudd_Regular(f);</highlight></codeline>
<codeline lineno="1203"><highlight class="normal"><sp/><sp/><sp/><sp/>complement<sp/>=<sp/>Cudd_IsComplement(f);</highlight></codeline>
<codeline lineno="1204"><highlight class="normal"></highlight></codeline>
<codeline lineno="1205"><highlight class="normal"><sp/><sp/><sp/><sp/>sol<sp/>=<sp/>one;</highlight></codeline>
<codeline lineno="1206"><highlight class="normal"><sp/><sp/><sp/><sp/>cuddRef(sol);</highlight></codeline>
<codeline lineno="1207"><highlight class="normal"></highlight></codeline>
<codeline lineno="1208"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(!cuddIsConstant(my_dd))<sp/>{</highlight></codeline>
<codeline lineno="1209"><highlight class="normal"><sp/><sp/><sp/><sp/>Tcost<sp/>=<sp/>cost<sp/>-<sp/>WEIGHT(weight,<sp/>my_dd-&gt;index);</highlight></codeline>
<codeline lineno="1210"><highlight class="normal"><sp/><sp/><sp/><sp/>Ecost<sp/>=<sp/>cost;</highlight></codeline>
<codeline lineno="1211"><highlight class="normal"></highlight></codeline>
<codeline lineno="1212"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>=<sp/>cuddT(my_dd);</highlight></codeline>
<codeline lineno="1213"><highlight class="normal"><sp/><sp/><sp/><sp/>E<sp/>=<sp/>cuddE(my_dd);</highlight></codeline>
<codeline lineno="1214"><highlight class="normal"></highlight></codeline>
<codeline lineno="1215"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(complement)<sp/>{T<sp/>=<sp/>Cudd_Not(T);<sp/>E<sp/>=<sp/>Cudd_Not(E);}</highlight></codeline>
<codeline lineno="1216"><highlight class="normal"></highlight></codeline>
<codeline lineno="1217"><highlight class="normal"><sp/><sp/><sp/><sp/>st_lookup(visited,<sp/>Cudd_Regular(T),<sp/>&amp;T_pair);</highlight></codeline>
<codeline lineno="1218"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((Cudd_IsComplement(T)<sp/>&amp;&amp;<sp/>T_pair-&gt;neg<sp/>==<sp/>Tcost)<sp/>||</highlight></codeline>
<codeline lineno="1219"><highlight class="normal"><sp/><sp/><sp/><sp/>(!Cudd_IsComplement(T)<sp/>&amp;&amp;<sp/>T_pair-&gt;pos<sp/>==<sp/>Tcost))<sp/>{</highlight></codeline>
<codeline lineno="1220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>cuddBddAndRecur(manager,manager-&gt;vars[my_dd-&gt;index],sol);</highlight></codeline>
<codeline lineno="1221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(tmp<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_RecursiveDeref(manager,sol);</highlight></codeline>
<codeline lineno="1223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cuddRef(tmp);</highlight></codeline>
<codeline lineno="1226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_RecursiveDeref(manager,sol);</highlight></codeline>
<codeline lineno="1227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sol<sp/>=<sp/>tmp;</highlight></codeline>
<codeline lineno="1228"><highlight class="normal"></highlight></codeline>
<codeline lineno="1229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>complement<sp/>=<sp/><sp/>Cudd_IsComplement(T);</highlight></codeline>
<codeline lineno="1230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>my_dd<sp/>=<sp/>Cudd_Regular(T);</highlight></codeline>
<codeline lineno="1231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cost<sp/>=<sp/>Tcost;</highlight></codeline>
<codeline lineno="1232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1233"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1234"><highlight class="normal"><sp/><sp/><sp/><sp/>st_lookup(visited,<sp/>Cudd_Regular(E),<sp/>&amp;E_pair);</highlight></codeline>
<codeline lineno="1235"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((Cudd_IsComplement(E)<sp/>&amp;&amp;<sp/>E_pair-&gt;neg<sp/>==<sp/>Ecost)<sp/>||</highlight></codeline>
<codeline lineno="1236"><highlight class="normal"><sp/><sp/><sp/><sp/>(!Cudd_IsComplement(E)<sp/>&amp;&amp;<sp/>E_pair-&gt;pos<sp/>==<sp/>Ecost))<sp/>{</highlight></codeline>
<codeline lineno="1237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>cuddBddAndRecur(manager,Cudd_Not(manager-&gt;vars[my_dd-&gt;index]),sol);</highlight></codeline>
<codeline lineno="1238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(tmp<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_RecursiveDeref(manager,sol);</highlight></codeline>
<codeline lineno="1240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cuddRef(tmp);</highlight></codeline>
<codeline lineno="1243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_RecursiveDeref(manager,sol);</highlight></codeline>
<codeline lineno="1244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sol<sp/>=<sp/>tmp;</highlight></codeline>
<codeline lineno="1245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>complement<sp/>=<sp/>Cudd_IsComplement(E);</highlight></codeline>
<codeline lineno="1246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>my_dd<sp/>=<sp/>Cudd_Regular(E);</highlight></codeline>
<codeline lineno="1247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cost<sp/>=<sp/>Ecost;</highlight></codeline>
<codeline lineno="1248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1249"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1250"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)<sp/>fprintf(manager-&gt;err,</highlight><highlight class="stringliteral">&quot;We<sp/>shouldn&apos;t<sp/>be<sp/>here!!\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1251"><highlight class="normal"><sp/><sp/><sp/><sp/>manager-&gt;errorCode<sp/>=<sp/>CUDD_INTERNAL_ERROR;</highlight></codeline>
<codeline lineno="1252"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1253"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1254"><highlight class="normal"></highlight></codeline>
<codeline lineno="1255"><highlight class="normal"><sp/><sp/><sp/><sp/>cuddDeref(sol);</highlight></codeline>
<codeline lineno="1256"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(sol);</highlight></codeline>
<codeline lineno="1257"><highlight class="normal"></highlight></codeline>
<codeline lineno="1258"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>getPath<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1259"><highlight class="normal"></highlight></codeline>
<codeline lineno="1260"><highlight class="normal"></highlight></codeline>
<codeline lineno="1281"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref></highlight></codeline>
<codeline lineno="1282"><highlight class="normal">getLargest(</highlight></codeline>
<codeline lineno="1283"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>root,</highlight></codeline>
<codeline lineno="1284"><highlight class="normal"><sp/><sp/><ref refid="structst__table" kindref="compound">st_table</ref><sp/>*<sp/>visited)</highlight></codeline>
<codeline lineno="1285"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1286"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref><sp/>*my_pair,<sp/>res_pair,<sp/>pair_T,<sp/>pair_E;</highlight></codeline>
<codeline lineno="1287"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/><sp/>*my_root,<sp/>*T,<sp/>*E;</highlight></codeline>
<codeline lineno="1288"><highlight class="normal"></highlight></codeline>
<codeline lineno="1289"><highlight class="normal"><sp/><sp/><sp/><sp/>my_root<sp/>=<sp/>Cudd_Regular(root);</highlight></codeline>
<codeline lineno="1290"><highlight class="normal"></highlight></codeline>
<codeline lineno="1291"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(st_lookup(visited,<sp/>my_root,<sp/>&amp;my_pair))<sp/>{</highlight></codeline>
<codeline lineno="1292"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cudd_IsComplement(root))<sp/>{</highlight></codeline>
<codeline lineno="1293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.pos<sp/>=<sp/>my_pair-&gt;neg;</highlight></codeline>
<codeline lineno="1294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.neg<sp/>=<sp/>my_pair-&gt;pos;</highlight></codeline>
<codeline lineno="1295"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.pos<sp/>=<sp/>my_pair-&gt;pos;</highlight></codeline>
<codeline lineno="1297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.neg<sp/>=<sp/>my_pair-&gt;neg;</highlight></codeline>
<codeline lineno="1298"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1299"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(res_pair);</highlight></codeline>
<codeline lineno="1300"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1301"><highlight class="normal"></highlight></codeline>
<codeline lineno="1302"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>In<sp/>the<sp/>case<sp/>of<sp/>a<sp/>BDD<sp/>the<sp/>following<sp/>test<sp/>is<sp/>equivalent<sp/>to</highlight></codeline>
<codeline lineno="1303"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>testing<sp/>whether<sp/>the<sp/>BDD<sp/>is<sp/>the<sp/>constant<sp/>1.<sp/>This<sp/>formulation,</highlight></codeline>
<codeline lineno="1304"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>however,<sp/>works<sp/>for<sp/>ADDs<sp/>as<sp/>well,<sp/>by<sp/>assuming<sp/>the<sp/>usual</highlight></codeline>
<codeline lineno="1305"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>dichotomy<sp/>of<sp/>0<sp/>and<sp/>!=<sp/>0.</highlight></codeline>
<codeline lineno="1306"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1307"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(cuddIsConstant(my_root))<sp/>{</highlight></codeline>
<codeline lineno="1308"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(my_root<sp/>!=<sp/>zero)<sp/>{</highlight></codeline>
<codeline lineno="1309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.pos<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.neg<sp/>=<sp/>DD_BIGGY;</highlight></codeline>
<codeline lineno="1311"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.pos<sp/>=<sp/>DD_BIGGY;</highlight></codeline>
<codeline lineno="1313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.neg<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1314"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1315"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1316"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>=<sp/>cuddT(my_root);</highlight></codeline>
<codeline lineno="1317"><highlight class="normal"><sp/><sp/><sp/><sp/>E<sp/>=<sp/>cuddE(my_root);</highlight></codeline>
<codeline lineno="1318"><highlight class="normal"></highlight></codeline>
<codeline lineno="1319"><highlight class="normal"><sp/><sp/><sp/><sp/>pair_T<sp/>=<sp/>getLargest(T,<sp/>visited);</highlight></codeline>
<codeline lineno="1320"><highlight class="normal"><sp/><sp/><sp/><sp/>pair_E<sp/>=<sp/>getLargest(E,<sp/>visited);</highlight></codeline>
<codeline lineno="1321"><highlight class="normal"><sp/><sp/><sp/><sp/>res_pair.pos<sp/>=<sp/>ddMin(pair_T.pos,<sp/>pair_E.pos)<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="1322"><highlight class="normal"><sp/><sp/><sp/><sp/>res_pair.neg<sp/>=<sp/>ddMin(pair_T.neg,<sp/>pair_E.neg)<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="1323"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1324"><highlight class="normal"></highlight></codeline>
<codeline lineno="1325"><highlight class="normal"><sp/><sp/><sp/><sp/>my_pair<sp/>=<sp/>ALLOC(<ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref>,<sp/>1);</highlight></codeline>
<codeline lineno="1326"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(my_pair<sp/>==<sp/>NULL)<sp/>{<sp/><sp/></highlight><highlight class="comment">/*<sp/>simply<sp/>do<sp/>not<sp/>cache<sp/>this<sp/>result<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1327"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cudd_IsComplement(root))<sp/>{</highlight></codeline>
<codeline lineno="1328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tmp<sp/>=<sp/>res_pair.pos;</highlight></codeline>
<codeline lineno="1329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.pos<sp/>=<sp/>res_pair.neg;</highlight></codeline>
<codeline lineno="1330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res_pair.neg<sp/>=<sp/>tmp;</highlight></codeline>
<codeline lineno="1331"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1332"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(res_pair);</highlight></codeline>
<codeline lineno="1333"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1334"><highlight class="normal"><sp/><sp/><sp/><sp/>my_pair-&gt;pos<sp/>=<sp/>res_pair.pos;</highlight></codeline>
<codeline lineno="1335"><highlight class="normal"><sp/><sp/><sp/><sp/>my_pair-&gt;neg<sp/>=<sp/>res_pair.neg;</highlight></codeline>
<codeline lineno="1336"><highlight class="normal"></highlight></codeline>
<codeline lineno="1337"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Caching<sp/>may<sp/>fail<sp/>without<sp/>affecting<sp/>correctness.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1338"><highlight class="normal"><sp/><sp/><sp/><sp/>st_insert(visited,<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*)my_root,<sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*)my_pair);</highlight></codeline>
<codeline lineno="1339"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cudd_IsComplement(root))<sp/>{</highlight></codeline>
<codeline lineno="1340"><highlight class="normal"><sp/><sp/><sp/><sp/>res_pair.pos<sp/>=<sp/>my_pair-&gt;neg;</highlight></codeline>
<codeline lineno="1341"><highlight class="normal"><sp/><sp/><sp/><sp/>res_pair.neg<sp/>=<sp/>my_pair-&gt;pos;</highlight></codeline>
<codeline lineno="1342"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1343"><highlight class="normal"><sp/><sp/><sp/><sp/>res_pair.pos<sp/>=<sp/>my_pair-&gt;pos;</highlight></codeline>
<codeline lineno="1344"><highlight class="normal"><sp/><sp/><sp/><sp/>res_pair.neg<sp/>=<sp/>my_pair-&gt;neg;</highlight></codeline>
<codeline lineno="1345"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1346"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(res_pair);</highlight></codeline>
<codeline lineno="1347"><highlight class="normal"></highlight></codeline>
<codeline lineno="1348"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>getLargest<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1349"><highlight class="normal"></highlight></codeline>
<codeline lineno="1350"><highlight class="normal"></highlight></codeline>
<codeline lineno="1369"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*</highlight></codeline>
<codeline lineno="1370"><highlight class="normal">getCube(</highlight></codeline>
<codeline lineno="1371"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*<sp/>manager,</highlight></codeline>
<codeline lineno="1372"><highlight class="normal"><sp/><sp/><ref refid="structst__table" kindref="compound">st_table</ref><sp/>*<sp/>visited,</highlight></codeline>
<codeline lineno="1373"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*<sp/>f,</highlight></codeline>
<codeline lineno="1374"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/>cost)</highlight></codeline>
<codeline lineno="1375"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1376"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/><sp/>*sol,<sp/>*tmp;</highlight></codeline>
<codeline lineno="1377"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/><sp/>*my_dd,<sp/>*T,<sp/>*E;</highlight></codeline>
<codeline lineno="1378"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structcudd_path_pair" kindref="compound">cuddPathPair</ref><sp/>*T_pair,<sp/>*E_pair;</highlight></codeline>
<codeline lineno="1379"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>Tcost,<sp/>Ecost;</highlight></codeline>
<codeline lineno="1380"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>complement;</highlight></codeline>
<codeline lineno="1381"><highlight class="normal"></highlight></codeline>
<codeline lineno="1382"><highlight class="normal"><sp/><sp/><sp/><sp/>my_dd<sp/>=<sp/>Cudd_Regular(f);</highlight></codeline>
<codeline lineno="1383"><highlight class="normal"><sp/><sp/><sp/><sp/>complement<sp/>=<sp/>Cudd_IsComplement(f);</highlight></codeline>
<codeline lineno="1384"><highlight class="normal"></highlight></codeline>
<codeline lineno="1385"><highlight class="normal"><sp/><sp/><sp/><sp/>sol<sp/>=<sp/>one;</highlight></codeline>
<codeline lineno="1386"><highlight class="normal"><sp/><sp/><sp/><sp/>cuddRef(sol);</highlight></codeline>
<codeline lineno="1387"><highlight class="normal"></highlight></codeline>
<codeline lineno="1388"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(!cuddIsConstant(my_dd))<sp/>{</highlight></codeline>
<codeline lineno="1389"><highlight class="normal"><sp/><sp/><sp/><sp/>Tcost<sp/>=<sp/>cost<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="1390"><highlight class="normal"><sp/><sp/><sp/><sp/>Ecost<sp/>=<sp/>cost<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="1391"><highlight class="normal"></highlight></codeline>
<codeline lineno="1392"><highlight class="normal"><sp/><sp/><sp/><sp/>T<sp/>=<sp/>cuddT(my_dd);</highlight></codeline>
<codeline lineno="1393"><highlight class="normal"><sp/><sp/><sp/><sp/>E<sp/>=<sp/>cuddE(my_dd);</highlight></codeline>
<codeline lineno="1394"><highlight class="normal"></highlight></codeline>
<codeline lineno="1395"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(complement)<sp/>{T<sp/>=<sp/>Cudd_Not(T);<sp/>E<sp/>=<sp/>Cudd_Not(E);}</highlight></codeline>
<codeline lineno="1396"><highlight class="normal"></highlight></codeline>
<codeline lineno="1397"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!st_lookup(visited,<sp/>Cudd_Regular(T),<sp/>&amp;T_pair))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1398"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((Cudd_IsComplement(T)<sp/>&amp;&amp;<sp/>T_pair-&gt;neg<sp/>==<sp/>Tcost)<sp/>||</highlight></codeline>
<codeline lineno="1399"><highlight class="normal"><sp/><sp/><sp/><sp/>(!Cudd_IsComplement(T)<sp/>&amp;&amp;<sp/>T_pair-&gt;pos<sp/>==<sp/>Tcost))<sp/>{</highlight></codeline>
<codeline lineno="1400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>cuddBddAndRecur(manager,manager-&gt;vars[my_dd-&gt;index],sol);</highlight></codeline>
<codeline lineno="1401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(tmp<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_RecursiveDeref(manager,sol);</highlight></codeline>
<codeline lineno="1403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1405"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cuddRef(tmp);</highlight></codeline>
<codeline lineno="1406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_RecursiveDeref(manager,sol);</highlight></codeline>
<codeline lineno="1407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sol<sp/>=<sp/>tmp;</highlight></codeline>
<codeline lineno="1408"><highlight class="normal"></highlight></codeline>
<codeline lineno="1409"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>complement<sp/>=<sp/><sp/>Cudd_IsComplement(T);</highlight></codeline>
<codeline lineno="1410"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>my_dd<sp/>=<sp/>Cudd_Regular(T);</highlight></codeline>
<codeline lineno="1411"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cost<sp/>=<sp/>Tcost;</highlight></codeline>
<codeline lineno="1412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1413"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1414"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!st_lookup(visited,<sp/>Cudd_Regular(E),<sp/>&amp;E_pair))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1415"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((Cudd_IsComplement(E)<sp/>&amp;&amp;<sp/>E_pair-&gt;neg<sp/>==<sp/>Ecost)<sp/>||</highlight></codeline>
<codeline lineno="1416"><highlight class="normal"><sp/><sp/><sp/><sp/>(!Cudd_IsComplement(E)<sp/>&amp;&amp;<sp/>E_pair-&gt;pos<sp/>==<sp/>Ecost))<sp/>{</highlight></codeline>
<codeline lineno="1417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>cuddBddAndRecur(manager,Cudd_Not(manager-&gt;vars[my_dd-&gt;index]),sol);</highlight></codeline>
<codeline lineno="1418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(tmp<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_RecursiveDeref(manager,sol);</highlight></codeline>
<codeline lineno="1420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1422"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cuddRef(tmp);</highlight></codeline>
<codeline lineno="1423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_RecursiveDeref(manager,sol);</highlight></codeline>
<codeline lineno="1424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sol<sp/>=<sp/>tmp;</highlight></codeline>
<codeline lineno="1425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>complement<sp/>=<sp/>Cudd_IsComplement(E);</highlight></codeline>
<codeline lineno="1426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>my_dd<sp/>=<sp/>Cudd_Regular(E);</highlight></codeline>
<codeline lineno="1427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cost<sp/>=<sp/>Ecost;</highlight></codeline>
<codeline lineno="1428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1429"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1430"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)<sp/>fprintf(manager-&gt;err,</highlight><highlight class="stringliteral">&quot;We<sp/>shouldn&apos;t<sp/>be<sp/>here!\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1431"><highlight class="normal"><sp/><sp/><sp/><sp/>manager-&gt;errorCode<sp/>=<sp/>CUDD_INTERNAL_ERROR;</highlight></codeline>
<codeline lineno="1432"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1433"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1434"><highlight class="normal"></highlight></codeline>
<codeline lineno="1435"><highlight class="normal"><sp/><sp/><sp/><sp/>cuddDeref(sol);</highlight></codeline>
<codeline lineno="1436"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(sol);</highlight></codeline>
<codeline lineno="1437"><highlight class="normal"></highlight></codeline>
<codeline lineno="1438"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>getCube<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1439"><highlight class="normal"></highlight></codeline>
<codeline lineno="1440"><highlight class="normal"></highlight></codeline>
<codeline lineno="1455"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*</highlight></codeline>
<codeline lineno="1456"><highlight class="normal">ddBddMaximallyExpand(</highlight></codeline>
<codeline lineno="1457"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*dd<sp/></highlight><highlight class="comment">/*<sp/>manager<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="1458"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*lb<sp/></highlight><highlight class="comment">/*<sp/>cube<sp/>to<sp/>be<sp/>expanded<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="1459"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*ub<sp/></highlight><highlight class="comment">/*<sp/>upper<sp/>bound<sp/>cube<sp/>*/</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="1460"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*f<sp/></highlight><highlight class="comment">/*<sp/>function<sp/>against<sp/>which<sp/>to<sp/>expand<sp/>*/</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="1461"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1462"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*one,<sp/>*zero,<sp/>*lbv,<sp/>*lbvn,<sp/>*lbnx,<sp/>*ubv,<sp/>*ubvn,<sp/>*fv,<sp/>*fvn,<sp/>*res;</highlight></codeline>
<codeline lineno="1463"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*F,<sp/>*UB,<sp/>*LB,<sp/>*t,<sp/>*e;</highlight></codeline>
<codeline lineno="1464"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>top,<sp/>toplb,<sp/>topub,<sp/>topf,<sp/>index;</highlight></codeline>
<codeline lineno="1465"><highlight class="normal"></highlight></codeline>
<codeline lineno="1466"><highlight class="normal"><sp/><sp/><sp/><sp/>statLine(dd);</highlight></codeline>
<codeline lineno="1467"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Terminal<sp/>cases.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1468"><highlight class="normal"><sp/><sp/><sp/><sp/>one<sp/>=<sp/>DD_ONE(dd);</highlight></codeline>
<codeline lineno="1469"><highlight class="normal"><sp/><sp/><sp/><sp/>zero<sp/>=<sp/>Cudd_Not(one);</highlight></codeline>
<codeline lineno="1470"><highlight class="normal"><sp/><sp/><sp/><sp/>assert(ub<sp/>!=<sp/>zero<sp/>&amp;&amp;<sp/>lb<sp/>!=<sp/>zero);</highlight></codeline>
<codeline lineno="1478"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ub<sp/>==<sp/>f<sp/>||<sp/>f<sp/>==<sp/>one)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(ub);</highlight></codeline>
<codeline lineno="1479"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lb<sp/>==<sp/>f)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(lb);</highlight></codeline>
<codeline lineno="1480"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f<sp/>==<sp/>zero<sp/>||<sp/>ub<sp/>==<sp/>Cudd_Not(f)<sp/>||<sp/>lb<sp/>==<sp/>one<sp/>||<sp/>lb<sp/>==<sp/>Cudd_Not(f))</highlight></codeline>
<codeline lineno="1481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(zero);</highlight></codeline>
<codeline lineno="1482"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Cudd_IsComplement(lb)<sp/>&amp;&amp;<sp/>Cudd_IsComplement(f))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(zero);</highlight></codeline>
<codeline lineno="1483"><highlight class="normal"></highlight></codeline>
<codeline lineno="1484"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Here<sp/>lb<sp/>and<sp/>f<sp/>are<sp/>not<sp/>constant.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1485"><highlight class="normal"></highlight></codeline>
<codeline lineno="1486"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>cache.<sp/><sp/>Since<sp/>lb<sp/>and<sp/>ub<sp/>are<sp/>cubes,<sp/>their<sp/>local<sp/>reference<sp/>counts</highlight></codeline>
<codeline lineno="1487"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>are<sp/>always<sp/>1.<sp/><sp/>Hence,<sp/>we<sp/>only<sp/>check<sp/>the<sp/>reference<sp/>count<sp/>of<sp/>f.</highlight></codeline>
<codeline lineno="1488"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1489"><highlight class="normal"><sp/><sp/><sp/><sp/>F<sp/>=<sp/>Cudd_Regular(f);</highlight></codeline>
<codeline lineno="1490"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(F-&gt;ref<sp/>!=<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="1491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*tmp<sp/>=<sp/>cuddCacheLookup(dd,<sp/>DD_BDD_MAX_EXP_TAG,<sp/>lb,<sp/>ub,<sp/>f);</highlight></codeline>
<codeline lineno="1492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(tmp<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(tmp);</highlight></codeline>
<codeline lineno="1494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1495"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1496"><highlight class="normal"></highlight></codeline>
<codeline lineno="1497"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>cofactors.<sp/><sp/>For<sp/>lb<sp/>we<sp/>use<sp/>the<sp/>non-zero<sp/>one<sp/>in</highlight></codeline>
<codeline lineno="1498"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>both<sp/>branches<sp/>of<sp/>the<sp/>recursion.</highlight></codeline>
<codeline lineno="1499"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1500"><highlight class="normal"><sp/><sp/><sp/><sp/>LB<sp/>=<sp/>Cudd_Regular(lb);</highlight></codeline>
<codeline lineno="1501"><highlight class="normal"><sp/><sp/><sp/><sp/>UB<sp/>=<sp/>Cudd_Regular(ub);</highlight></codeline>
<codeline lineno="1502"><highlight class="normal"><sp/><sp/><sp/><sp/>topf<sp/>=<sp/>dd-&gt;perm[F-&gt;index];</highlight></codeline>
<codeline lineno="1503"><highlight class="normal"><sp/><sp/><sp/><sp/>toplb<sp/>=<sp/>dd-&gt;perm[LB-&gt;index];</highlight></codeline>
<codeline lineno="1504"><highlight class="normal"><sp/><sp/><sp/><sp/>topub<sp/>=<sp/>(ub<sp/>==<sp/>one)<sp/>?<sp/>CUDD_CONST_INDEX<sp/>:<sp/>dd-&gt;perm[UB-&gt;index];</highlight></codeline>
<codeline lineno="1505"><highlight class="normal"><sp/><sp/><sp/><sp/>assert(toplb<sp/>&lt;=<sp/>topub);</highlight></codeline>
<codeline lineno="1506"><highlight class="normal"><sp/><sp/><sp/><sp/>top<sp/>=<sp/>ddMin(topf,toplb);</highlight></codeline>
<codeline lineno="1507"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(toplb<sp/>==<sp/>top)<sp/>{</highlight></codeline>
<codeline lineno="1508"><highlight class="normal"><sp/><sp/><sp/><sp/>index<sp/>=<sp/>LB-&gt;index;</highlight></codeline>
<codeline lineno="1509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lbv<sp/>=<sp/>cuddT(LB);</highlight></codeline>
<codeline lineno="1510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lbvn<sp/>=<sp/>cuddE(LB);</highlight></codeline>
<codeline lineno="1511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lb<sp/>!=<sp/>LB)<sp/>{</highlight></codeline>
<codeline lineno="1512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lbv<sp/>=<sp/>Cudd_Not(lbv);</highlight></codeline>
<codeline lineno="1513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lbvn<sp/>=<sp/>Cudd_Not(lbvn);</highlight></codeline>
<codeline lineno="1514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lbv<sp/>==<sp/>zero)<sp/>{</highlight></codeline>
<codeline lineno="1516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lbnx<sp/>=<sp/>lbvn;</highlight></codeline>
<codeline lineno="1517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lbnx<sp/>=<sp/>lbv;</highlight></codeline>
<codeline lineno="1519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1520"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1521"><highlight class="normal"><sp/><sp/><sp/><sp/>index<sp/>=<sp/>F-&gt;index;</highlight></codeline>
<codeline lineno="1522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lbnx<sp/>=<sp/>lbv<sp/>=<sp/>lbvn<sp/>=<sp/>lb;</highlight></codeline>
<codeline lineno="1523"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1524"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(topub<sp/>==<sp/>top)<sp/>{</highlight></codeline>
<codeline lineno="1525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ubv<sp/>=<sp/>cuddT(UB);</highlight></codeline>
<codeline lineno="1526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ubvn<sp/>=<sp/>cuddE(UB);</highlight></codeline>
<codeline lineno="1527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ub<sp/>!=<sp/>UB)<sp/>{</highlight></codeline>
<codeline lineno="1528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ubv<sp/>=<sp/>Cudd_Not(ubv);</highlight></codeline>
<codeline lineno="1529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ubvn<sp/>=<sp/>Cudd_Not(ubvn);</highlight></codeline>
<codeline lineno="1530"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1531"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ubv<sp/>=<sp/>ubvn<sp/>=<sp/>ub;</highlight></codeline>
<codeline lineno="1533"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1534"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(topf<sp/>==<sp/>top)<sp/>{</highlight></codeline>
<codeline lineno="1535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fv<sp/>=<sp/>cuddT(F);</highlight></codeline>
<codeline lineno="1536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fvn<sp/>=<sp/>cuddE(F);</highlight></codeline>
<codeline lineno="1537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f<sp/>!=<sp/>F)<sp/>{</highlight></codeline>
<codeline lineno="1538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fv<sp/>=<sp/>Cudd_Not(fv);</highlight></codeline>
<codeline lineno="1539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fvn<sp/>=<sp/>Cudd_Not(fvn);</highlight></codeline>
<codeline lineno="1540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1541"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fv<sp/>=<sp/>fvn<sp/>=<sp/>f;</highlight></codeline>
<codeline lineno="1543"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1544"><highlight class="normal"></highlight></codeline>
<codeline lineno="1545"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Recursive<sp/>calls.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1546"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ubv<sp/>!=<sp/>zero)<sp/>{</highlight></codeline>
<codeline lineno="1547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>t<sp/>=<sp/>ddBddMaximallyExpand(dd,<sp/>lbnx,<sp/>ubv,<sp/>fv);</highlight></codeline>
<codeline lineno="1548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(t<sp/>==<sp/>NULL)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1549"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assert(topub<sp/>==<sp/>toplb<sp/>&amp;&amp;<sp/>topub<sp/>==<sp/>top<sp/>&amp;&amp;<sp/>lbv<sp/>==<sp/>zero);</highlight></codeline>
<codeline lineno="1551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>t<sp/>=<sp/>zero;</highlight></codeline>
<codeline lineno="1552"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1553"><highlight class="normal"><sp/><sp/><sp/><sp/>cuddRef(t);</highlight></codeline>
<codeline lineno="1554"><highlight class="normal"></highlight></codeline>
<codeline lineno="1555"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>If<sp/>the<sp/>top<sp/>variable<sp/>appears<sp/>only<sp/>in<sp/>lb,<sp/>the<sp/>positive<sp/>and<sp/>negative</highlight></codeline>
<codeline lineno="1556"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>cofactors<sp/>of<sp/>each<sp/>operand<sp/>are<sp/>the<sp/>same.<sp/><sp/>We<sp/>want<sp/>to<sp/>avoid<sp/>a</highlight></codeline>
<codeline lineno="1557"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>needless<sp/>recursive<sp/>call,<sp/>which<sp/>would<sp/>force<sp/>us<sp/>to<sp/>give<sp/>up<sp/>the</highlight></codeline>
<codeline lineno="1558"><highlight class="comment"><sp/><sp/><sp/><sp/>**<sp/>cache<sp/>optimization<sp/>trick<sp/>based<sp/>on<sp/>reference<sp/>counts.</highlight></codeline>
<codeline lineno="1559"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1560"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ubv<sp/>==<sp/>ubvn<sp/>&amp;&amp;<sp/>fv<sp/>==<sp/>fvn)<sp/>{</highlight></codeline>
<codeline lineno="1561"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>t;</highlight></codeline>
<codeline lineno="1562"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1563"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ubvn<sp/>!=<sp/>zero)<sp/>{</highlight></codeline>
<codeline lineno="1564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>e<sp/>=<sp/>ddBddMaximallyExpand(dd,<sp/>lbnx,<sp/>ubvn,<sp/>fvn);</highlight></codeline>
<codeline lineno="1565"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(e<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1566"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_IterDerefBdd(dd,t);</highlight></codeline>
<codeline lineno="1567"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1568"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1569"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1570"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assert(topub<sp/>==<sp/>toplb<sp/>&amp;&amp;<sp/>topub<sp/>==<sp/>top<sp/>&amp;&amp;<sp/>lbvn<sp/>==<sp/>zero);</highlight></codeline>
<codeline lineno="1571"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>e<sp/>=<sp/>zero;</highlight></codeline>
<codeline lineno="1572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1573"><highlight class="normal"></highlight></codeline>
<codeline lineno="1574"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(t<sp/>==<sp/>e)<sp/>{</highlight></codeline>
<codeline lineno="1575"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>t;</highlight></codeline>
<codeline lineno="1576"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cuddRef(e);</highlight></codeline>
<codeline lineno="1578"><highlight class="normal"></highlight></codeline>
<codeline lineno="1579"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(toplb<sp/>==<sp/>top)<sp/>{</highlight></codeline>
<codeline lineno="1580"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lbv<sp/>==<sp/>zero)<sp/>{</highlight></codeline>
<codeline lineno="1581"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Top<sp/>variable<sp/>appears<sp/>in<sp/>negative<sp/>phase.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1582"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(t<sp/>!=<sp/>one)<sp/>{</highlight></codeline>
<codeline lineno="1583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*newT;</highlight></codeline>
<codeline lineno="1584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cudd_IsComplement(t))<sp/>{</highlight></codeline>
<codeline lineno="1585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newT<sp/>=<sp/>cuddUniqueInter(dd,<sp/>index,<sp/>Cudd_Not(t),<sp/>zero);</highlight></codeline>
<codeline lineno="1586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(newT<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_IterDerefBdd(dd,t);</highlight></codeline>
<codeline lineno="1588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_IterDerefBdd(dd,e);</highlight></codeline>
<codeline lineno="1589"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1590"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1591"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newT<sp/>=<sp/>Cudd_Not(newT);</highlight></codeline>
<codeline lineno="1592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newT<sp/>=<sp/>cuddUniqueInter(dd,<sp/>index,<sp/>t,<sp/>one);</highlight></codeline>
<codeline lineno="1594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(newT<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_IterDerefBdd(dd,t);</highlight></codeline>
<codeline lineno="1596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_IterDerefBdd(dd,e);</highlight></codeline>
<codeline lineno="1597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1600"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cuddRef(newT);</highlight></codeline>
<codeline lineno="1601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cuddDeref(t);</highlight></codeline>
<codeline lineno="1602"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>t<sp/>=<sp/>newT;</highlight></codeline>
<codeline lineno="1603"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1604"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(lbvn<sp/>==<sp/>zero)<sp/>{</highlight></codeline>
<codeline lineno="1605"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Top<sp/>variable<sp/>appears<sp/>in<sp/>positive<sp/>phase.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1606"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(e<sp/>!=<sp/>one)<sp/>{</highlight></codeline>
<codeline lineno="1607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*newE;</highlight></codeline>
<codeline lineno="1608"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newE<sp/>=<sp/>cuddUniqueInter(dd,<sp/>index,<sp/>one,<sp/>e);</highlight></codeline>
<codeline lineno="1609"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(newE<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1610"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_IterDerefBdd(dd,t);</highlight></codeline>
<codeline lineno="1611"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_IterDerefBdd(dd,e);</highlight></codeline>
<codeline lineno="1612"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1613"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1614"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cuddRef(newE);</highlight></codeline>
<codeline lineno="1615"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cuddDeref(e);</highlight></codeline>
<codeline lineno="1616"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>e<sp/>=<sp/>newE;</highlight></codeline>
<codeline lineno="1617"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1618"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Not<sp/>a<sp/>cube.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1620"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_IterDerefBdd(dd,t);</highlight></codeline>
<codeline lineno="1621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_IterDerefBdd(dd,e);</highlight></codeline>
<codeline lineno="1622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1623"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1625"><highlight class="normal"></highlight></codeline>
<codeline lineno="1626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Combine<sp/>results.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>cuddBddAndRecur(dd,<sp/>t,<sp/>e);</highlight></codeline>
<codeline lineno="1628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(res<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_IterDerefBdd(dd,t);</highlight></codeline>
<codeline lineno="1630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_IterDerefBdd(dd,e);</highlight></codeline>
<codeline lineno="1631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1633"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cuddRef(res);</highlight></codeline>
<codeline lineno="1634"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_IterDerefBdd(dd,t);</highlight></codeline>
<codeline lineno="1635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_IterDerefBdd(dd,e);</highlight></codeline>
<codeline lineno="1636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1637"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1638"><highlight class="normal"></highlight></codeline>
<codeline lineno="1639"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Cache<sp/>result<sp/>and<sp/>return.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1640"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(F-&gt;ref<sp/>!=<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="1641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cuddCacheInsert(dd,<sp/>DD_BDD_MAX_EXP_TAG,<sp/>lb,<sp/>ub,<sp/>f,<sp/>res);</highlight></codeline>
<codeline lineno="1642"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1643"><highlight class="normal"><sp/><sp/><sp/><sp/>cuddDeref(res);</highlight></codeline>
<codeline lineno="1644"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(res);</highlight></codeline>
<codeline lineno="1645"><highlight class="normal"></highlight></codeline>
<codeline lineno="1646"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>ddBddMaximallyExpand<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1647"><highlight class="normal"></highlight></codeline>
<codeline lineno="1648"><highlight class="normal"></highlight></codeline>
<codeline lineno="1664"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1665"><highlight class="normal">ddBddShortestPathUnate(</highlight></codeline>
<codeline lineno="1666"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*dd,</highlight></codeline>
<codeline lineno="1667"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*f,</highlight></codeline>
<codeline lineno="1668"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*phases,</highlight></codeline>
<codeline lineno="1669"><highlight class="normal"><sp/><sp/><ref refid="structst__table" kindref="compound">st_table</ref><sp/>*table)</highlight></codeline>
<codeline lineno="1670"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1671"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>positive,<sp/>l,<sp/>lT,<sp/>lE;</highlight></codeline>
<codeline lineno="1672"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*one<sp/>=<sp/>DD_ONE(dd);</highlight></codeline>
<codeline lineno="1673"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*zero<sp/>=<sp/>Cudd_Not(one);</highlight></codeline>
<codeline lineno="1674"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*F,<sp/>*fv,<sp/>*fvn;</highlight></codeline>
<codeline lineno="1675"><highlight class="normal"></highlight></codeline>
<codeline lineno="1676"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(st_lookup_int(table,<sp/>f,<sp/>&amp;l))<sp/>{</highlight></codeline>
<codeline lineno="1677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(l);</highlight></codeline>
<codeline lineno="1678"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1679"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f<sp/>==<sp/>one)<sp/>{</highlight></codeline>
<codeline lineno="1680"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>l<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1681"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f<sp/>==<sp/>zero)<sp/>{</highlight></codeline>
<codeline lineno="1682"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>l<sp/>=<sp/>DD_BIGGY;</highlight></codeline>
<codeline lineno="1683"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1684"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>F<sp/>=<sp/>Cudd_Regular(f);</highlight></codeline>
<codeline lineno="1685"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fv<sp/>=<sp/>cuddT(F);</highlight></codeline>
<codeline lineno="1686"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fvn<sp/>=<sp/>cuddE(F);</highlight></codeline>
<codeline lineno="1687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f<sp/>!=<sp/>F)<sp/>{</highlight></codeline>
<codeline lineno="1688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fv<sp/>=<sp/>Cudd_Not(fv);</highlight></codeline>
<codeline lineno="1689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fvn<sp/>=<sp/>Cudd_Not(fvn);</highlight></codeline>
<codeline lineno="1690"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lT<sp/>=<sp/>ddBddShortestPathUnate(dd,<sp/>fv,<sp/>phases,<sp/>table);</highlight></codeline>
<codeline lineno="1692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>lE<sp/>=<sp/>ddBddShortestPathUnate(dd,<sp/>fvn,<sp/>phases,<sp/>table);</highlight></codeline>
<codeline lineno="1693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>positive<sp/>=<sp/>phases[F-&gt;index];</highlight></codeline>
<codeline lineno="1694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>l<sp/>=<sp/>positive<sp/>?<sp/>ddMin(lT+1,<sp/>lE)<sp/>:<sp/>ddMin(lT,<sp/>lE+1);</highlight></codeline>
<codeline lineno="1695"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1696"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(st_insert(table,<sp/>f,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)(ptrint)<sp/>l)<sp/>==<sp/>ST_OUT_OF_MEM)<sp/>{</highlight></codeline>
<codeline lineno="1697"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(CUDD_OUT_OF_MEM);</highlight></codeline>
<codeline lineno="1698"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1699"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(l);</highlight></codeline>
<codeline lineno="1700"><highlight class="normal"></highlight></codeline>
<codeline lineno="1701"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>ddShortestPathUnate<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1702"><highlight class="normal"></highlight></codeline>
<codeline lineno="1703"><highlight class="normal"></highlight></codeline>
<codeline lineno="1716"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*</highlight></codeline>
<codeline lineno="1717"><highlight class="normal">ddGetLargestCubeUnate(</highlight></codeline>
<codeline lineno="1718"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_manager" kindref="compound">DdManager</ref><sp/>*dd,</highlight></codeline>
<codeline lineno="1719"><highlight class="normal"><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*f,</highlight></codeline>
<codeline lineno="1720"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*phases,</highlight></codeline>
<codeline lineno="1721"><highlight class="normal"><sp/><sp/><ref refid="structst__table" kindref="compound">st_table</ref><sp/>*table)</highlight></codeline>
<codeline lineno="1722"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1723"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*res,<sp/>*scan;</highlight></codeline>
<codeline lineno="1724"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*one<sp/>=<sp/>DD_ONE(dd);</highlight></codeline>
<codeline lineno="1725"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>cost;</highlight></codeline>
<codeline lineno="1726"><highlight class="normal"></highlight></codeline>
<codeline lineno="1727"><highlight class="normal"><sp/><sp/><sp/><sp/>res<sp/>=<sp/>one;</highlight></codeline>
<codeline lineno="1728"><highlight class="normal"><sp/><sp/><sp/><sp/>cuddRef(res);</highlight></codeline>
<codeline lineno="1729"><highlight class="normal"><sp/><sp/><sp/><sp/>scan<sp/>=<sp/>f;</highlight></codeline>
<codeline lineno="1730"><highlight class="normal"><sp/><sp/><sp/><sp/>st_lookup_int(table,<sp/>scan,<sp/>&amp;cost);</highlight></codeline>
<codeline lineno="1731"><highlight class="normal"></highlight></codeline>
<codeline lineno="1732"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(!Cudd_IsConstant(scan))<sp/>{</highlight></codeline>
<codeline lineno="1733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Pcost,<sp/>Ncost,<sp/>Tcost;</highlight></codeline>
<codeline lineno="1734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*tmp,<sp/>*T,<sp/>*E;</highlight></codeline>
<codeline lineno="1735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_dd_node" kindref="compound">DdNode</ref><sp/>*rscan<sp/>=<sp/>Cudd_Regular(scan);</highlight></codeline>
<codeline lineno="1736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>rscan-&gt;index;</highlight></codeline>
<codeline lineno="1737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assert(phases[index]<sp/>==<sp/>0<sp/>||<sp/>phases[index]<sp/>==<sp/>1);</highlight></codeline>
<codeline lineno="1738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>positive<sp/>=<sp/>phases[index]<sp/>==<sp/>1;</highlight></codeline>
<codeline lineno="1739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Pcost<sp/>=<sp/>positive<sp/>?<sp/>cost<sp/>-<sp/>1<sp/>:<sp/>cost;</highlight></codeline>
<codeline lineno="1740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Ncost<sp/>=<sp/>positive<sp/>?<sp/>cost<sp/>:<sp/>cost<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="1741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>=<sp/>cuddT(rscan);</highlight></codeline>
<codeline lineno="1742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>E<sp/>=<sp/>cuddE(rscan);</highlight></codeline>
<codeline lineno="1743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(rscan<sp/>!=<sp/>scan)<sp/>{</highlight></codeline>
<codeline lineno="1744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T<sp/>=<sp/>Cudd_Not(T);</highlight></codeline>
<codeline lineno="1745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>E<sp/>=<sp/>Cudd_Not(E);</highlight></codeline>
<codeline lineno="1746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>res;</highlight></codeline>
<codeline lineno="1748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>st_lookup_int(table,<sp/>T,<sp/>&amp;Tcost);</highlight></codeline>
<codeline lineno="1749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Tcost<sp/>==<sp/>Pcost)<sp/>{</highlight></codeline>
<codeline lineno="1750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cost<sp/>=<sp/>Pcost;</highlight></codeline>
<codeline lineno="1751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scan<sp/>=<sp/>T;</highlight></codeline>
<codeline lineno="1752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(positive)<sp/>{</highlight></codeline>
<codeline lineno="1753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>cuddBddAndRecur(dd,<sp/>dd-&gt;vars[index],<sp/>res);</highlight></codeline>
<codeline lineno="1754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1756"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cost<sp/>=<sp/>Ncost;</highlight></codeline>
<codeline lineno="1757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scan<sp/>=<sp/>E;</highlight></codeline>
<codeline lineno="1758"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!positive)<sp/>{</highlight></codeline>
<codeline lineno="1759"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>cuddBddAndRecur(dd,<sp/>Cudd_Not(dd-&gt;vars[index]),<sp/>res);</highlight></codeline>
<codeline lineno="1760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(tmp<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1763"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_IterDerefBdd(dd,<sp/>res);</highlight></codeline>
<codeline lineno="1764"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(NULL);</highlight></codeline>
<codeline lineno="1765"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1766"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cuddRef(tmp);</highlight></codeline>
<codeline lineno="1767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cudd_IterDerefBdd(dd,<sp/>res);</highlight></codeline>
<codeline lineno="1768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res<sp/>=<sp/>tmp;</highlight></codeline>
<codeline lineno="1769"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1770"><highlight class="normal"></highlight></codeline>
<codeline lineno="1771"><highlight class="normal"><sp/><sp/><sp/><sp/>cuddDeref(res);</highlight></codeline>
<codeline lineno="1772"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">(res);</highlight></codeline>
<codeline lineno="1773"><highlight class="normal"></highlight></codeline>
<codeline lineno="1774"><highlight class="normal">}<sp/></highlight><highlight class="comment">/*<sp/>end<sp/>of<sp/>ddGetLargestCubeUnate<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
    </programlisting>
    <location file="lib/CUDD/cuddSat.c"/>
  </compounddef>
</doxygen>
