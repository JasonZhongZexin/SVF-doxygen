.TH "SVF::ContextCond" 3 "Sun Feb 14 2021" "SVF" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SVF::ContextCond
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <DPItem\&.h>\fP
.PP
Inherited by \fBSVF::VFPathCond\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef CallStrCxt::const_iterator \fBconst_iterator\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBContextCond\fP ()"
.br
.RI "Constructor\&. "
.ti -1c
.RI "\fBContextCond\fP (const \fBContextCond\fP &cond)"
.br
.RI "Copy Constructor\&. "
.ti -1c
.RI "virtual \fB~ContextCond\fP ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "const CallStrCxt & \fBgetContexts\fP () const"
.br
.RI "Get context\&. "
.ti -1c
.RI "CallStrCxt & \fBgetContexts\fP ()"
.br
.RI "Get context\&. "
.ti -1c
.RI "bool \fBisConcreteCxt\fP () const"
.br
.RI "Whether it is an concrete context\&. "
.ti -1c
.RI "void \fBsetNonConcreteCxt\fP ()"
.br
.RI "Whether it is an concrete context\&. "
.ti -1c
.RI "bool \fBcontainCallStr\fP (NodeID cxt) const"
.br
.RI "Whether contains callstring cxt\&. "
.ti -1c
.RI "u32_t \fBcxtSize\fP () const"
.br
.RI "Get context size\&. "
.ti -1c
.RI "virtual bool \fBpushContext\fP (NodeID ctx)"
.br
.RI "Push context\&. "
.ti -1c
.RI "virtual bool \fBmatchContext\fP (NodeID ctx)"
.br
.RI "Match context\&. "
.ti -1c
.RI "bool \fBoperator<\fP (const \fBContextCond\fP &rhs) const"
.br
.ti -1c
.RI "NodeID \fBoperator[]\fP (const u32_t index) const"
.br
.RI "Overloading operator[]\&. "
.ti -1c
.RI "\fBContextCond\fP & \fBoperator=\fP (const \fBContextCond\fP &rhs)"
.br
.RI "Overloading operator=\&. "
.ti -1c
.RI "bool \fBoperator==\fP (const \fBContextCond\fP &rhs) const"
.br
.RI "Overloading operator==\&. "
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBContextCond\fP &rhs) const"
.br
.RI "Overloading operator!=\&. "
.ti -1c
.RI "const_iterator \fBbegin\fP () const"
.br
.RI "Begin iterators\&. "
.ti -1c
.RI "const_iterator \fBend\fP () const"
.br
.RI "End iterators\&. "
.ti -1c
.RI "std::string \fBtoString\fP () const"
.br
.RI "Dump context condition\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static void \fBsetMaxCxtLen\fP (u32_t max)"
.br
.RI "set max context limit "
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static u32_t \fBmaximumCxt\fP = 0"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "CallStrCxt \fBcontext\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Context Condition 
.SH "Member Function Documentation"
.PP 
.SS "virtual bool SVF::ContextCond::matchContext (NodeID ctx)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Match context\&. if context is empty, then it is the unbalanced parentheses match
.PP
otherwise, we perform balanced parentheses matching
.SS "bool SVF::ContextCond::operator< (const \fBContextCond\fP & rhs) const\fC [inline]\fP"
Enable compare operator to avoid duplicated item insertion in map or set to be noted that two vectors can also overload operator() 
.SS "virtual bool SVF::ContextCond::pushContext (NodeID ctx)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Push context\&. handle out of context limit case

.SH "Author"
.PP 
Generated automatically by Doxygen for SVF from the source code\&.
