<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Static Value-Flow Analysis: SVF::SVFUtil Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Static Value-Flow Analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSVF.html">SVF</a></li><li class="navelem"><a class="el" href="namespaceSVF_1_1SVFUtil.html">SVFUtil</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SVF::SVFUtil Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__convert__val.html">cast_convert_val</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__convert__val_3_01To_00_01FromTy_00_01FromTy_01_4.html">cast_convert_val&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl.html">cast_retty_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01const_01From_01_5_01_4.html">cast_retty_impl&lt; To, const From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01const_01From_01_5const_01_4.html">cast_retty_impl&lt; To, const From *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01const_01From_01_4.html">cast_retty_impl&lt; To, const From &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01From_01_5_01_4.html">cast_retty_impl&lt; To, From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01std_1_1unique__ptr_3_01From_01_4_01_4.html">cast_retty_impl&lt; To, std::unique_ptr&lt; From &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__wrap.html">cast_retty_wrap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__wrap_3_01To_00_01FromTy_00_01FromTy_01_4.html">cast_retty_wrap&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">equalNodeBS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">equalPointsTo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl.html">isa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl_3_01To_00_01From_00_01typename_01std_1_1enable__if_3_01std_1_1101a002941fb8432b76e90258f1ec6b7.html">isa_impl&lt; To, From, typename std::enable_if&lt; std::is_base_of&lt; To, From &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always allow upcasts, and perform no dynamic check for them.  <a href="structSVF_1_1SVFUtil_1_1isa__impl_3_01To_00_01From_00_01typename_01std_1_1enable__if_3_01std_1_1101a002941fb8432b76e90258f1ec6b7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl.html">isa_impl_cl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01const_01From_01_5_01_4.html">isa_impl_cl&lt; To, const From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01const_01From_01_5const_01_4.html">isa_impl_cl&lt; To, const From *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01const_01From_01_4.html">isa_impl_cl&lt; To, const From &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01const_01std_1_1unique__ptr_3_01From_01_4_01_4.html">isa_impl_cl&lt; To, const std::unique_ptr&lt; From &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01From_01_5_01_4.html">isa_impl_cl&lt; To, From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01From_01_5const_01_4.html">isa_impl_cl&lt; To, From *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__wrap.html">isa_impl_wrap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__wrap_3_01To_00_01FromTy_00_01FromTy_01_4.html">isa_impl_wrap&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1simplify__type.html">simplify_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1simplify__type_3_01const_01From_01_4.html">simplify_type&lt; const From &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a68302f07b13f6e1f39aace5699762c41"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">SVF::SVFUtil::equalPointsTo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a68302f07b13f6e1f39aace5699762c41">equalPointsTo</a></td></tr>
<tr class="separator:a68302f07b13f6e1f39aace5699762c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2b39ae857d78ed9dda83880e703b0f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">SVF::SVFUtil::equalNodeBS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5c2b39ae857d78ed9dda83880e703b0f">equalNodeBS</a></td></tr>
<tr class="separator:a5c2b39ae857d78ed9dda83880e703b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4740b14abf7d308e7806a0d6d6c42ee2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceSVF.html#a4f21e91ff8eaea5207afe5c60dbd78d7">OrderedSet</a>&lt; <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a>, <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">equalPointsTo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">PointsToList</a></td></tr>
<tr class="separator:a4740b14abf7d308e7806a0d6d6c42ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5c8cbc986cccb9d84f87aae162df3737"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a5c8cbc986cccb9d84f87aae162df3737"><td class="memTemplItemLeft" align="right" valign="top">LLVM_NODISCARD bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5c8cbc986cccb9d84f87aae162df3737">isa</a> (const Y &amp;Val)</td></tr>
<tr class="separator:a5c8cbc986cccb9d84f87aae162df3737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d100868bf63b968d387eb50e9603f7c"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a0d100868bf63b968d387eb50e9603f7c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a>&lt; Y &gt;::value, typename <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, const Y &gt;::ret_type &gt;::<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a0d100868bf63b968d387eb50e9603f7c">cast</a> (const Y &amp;Val)</td></tr>
<tr class="separator:a0d100868bf63b968d387eb50e9603f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406dd9baf2ce66235d482fd6c6121b2c"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a406dd9baf2ce66235d482fd6c6121b2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, Y &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a406dd9baf2ce66235d482fd6c6121b2c">cast</a> (Y &amp;Val)</td></tr>
<tr class="separator:a406dd9baf2ce66235d482fd6c6121b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2419a55c0427571f11ad14db2fe481"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:acc2419a55c0427571f11ad14db2fe481"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, Y * &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#acc2419a55c0427571f11ad14db2fe481">cast</a> (Y *Val)</td></tr>
<tr class="separator:acc2419a55c0427571f11ad14db2fe481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ca049b4ce83c874e231f5e13bf36a8"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:af3ca049b4ce83c874e231f5e13bf36a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, std::unique_ptr&lt; Y &gt; &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af3ca049b4ce83c874e231f5e13bf36a8">cast</a> (std::unique_ptr&lt; Y &gt; &amp;&amp;Val)</td></tr>
<tr class="separator:af3ca049b4ce83c874e231f5e13bf36a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8182be247907420db00837cef9bcfa70"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a8182be247907420db00837cef9bcfa70"><td class="memTemplItemLeft" align="right" valign="top">LLVM_NODISCARD std::enable_if&lt;!<a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a>&lt; Y &gt;::value, typename <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, const Y &gt;::ret_type &gt;::<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">dyn_cast</a> (const Y &amp;Val)</td></tr>
<tr class="separator:a8182be247907420db00837cef9bcfa70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d852ba8fa569e858565b3bba403656"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a52d852ba8fa569e858565b3bba403656"><td class="memTemplItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, Y &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a52d852ba8fa569e858565b3bba403656">dyn_cast</a> (Y &amp;Val)</td></tr>
<tr class="separator:a52d852ba8fa569e858565b3bba403656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105c5c5e97d56533fb2b3ba7a0bc59f3"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a105c5c5e97d56533fb2b3ba7a0bc59f3"><td class="memTemplItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, Y * &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a105c5c5e97d56533fb2b3ba7a0bc59f3">dyn_cast</a> (Y *Val)</td></tr>
<tr class="separator:a105c5c5e97d56533fb2b3ba7a0bc59f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0b0b9f035057552a6a82154fd88e61"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a> ()</td></tr>
<tr class="memdesc:aed0b0b9f035057552a6a82154fd88e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite <a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61" title="Overwrite llvm::outs() ">llvm::outs()</a>  <a href="#aed0b0b9f035057552a6a82154fd88e61">More...</a><br /></td></tr>
<tr class="separator:aed0b0b9f035057552a6a82154fd88e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65033f068bfbeb0a1c52dcec3beb6bc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab65033f068bfbeb0a1c52dcec3beb6bc">errs</a> ()</td></tr>
<tr class="memdesc:ab65033f068bfbeb0a1c52dcec3beb6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite <a class="el" href="namespaceSVF_1_1SVFUtil.html#ab65033f068bfbeb0a1c52dcec3beb6bc" title="Overwrite llvm::errs() ">llvm::errs()</a>  <a href="#ab65033f068bfbeb0a1c52dcec3beb6bc">More...</a><br /></td></tr>
<tr class="separator:ab65033f068bfbeb0a1c52dcec3beb6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb570e9267fd7b189bd1bc877896d7ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a> (<a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> To, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=<a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>())</td></tr>
<tr class="memdesc:aeb570e9267fd7b189bd1bc877896d7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump sparse bitvector set.  <a href="#aeb570e9267fd7b189bd1bc877896d7ab">More...</a><br /></td></tr>
<tr class="separator:aeb570e9267fd7b189bd1bc877896d7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aa23b4982662d98c56af3e8ba16cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a04aa23b4982662d98c56af3e8ba16cb1">dumpSet</a> (<a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> To, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=<a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>())</td></tr>
<tr class="separator:a04aa23b4982662d98c56af3e8ba16cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#abd0a9ee845a455f9354d24a8b84a0bb3">dumpPointsToSet</a> (unsigned node, <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> To)</td></tr>
<tr class="memdesc:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump points-to set.  <a href="#abd0a9ee845a455f9354d24a8b84a0bb3">More...</a><br /></td></tr>
<tr class="separator:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30a35713852a0a525c52ae5dd463442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab30a35713852a0a525c52ae5dd463442">dumpSparseSet</a> (const <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;To)</td></tr>
<tr class="separator:ab30a35713852a0a525c52ae5dd463442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a15cc5570eed12dd6ee766213e11d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4a15cc5570eed12dd6ee766213e11d61">dumpAliasSet</a> (unsigned node, <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> To)</td></tr>
<tr class="memdesc:a4a15cc5570eed12dd6ee766213e11d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump alias set.  <a href="#a4a15cc5570eed12dd6ee766213e11d61">More...</a><br /></td></tr>
<tr class="separator:a4a15cc5570eed12dd6ee766213e11d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a55f1f8598998a3ffbbc67d32eaf8c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6a55f1f8598998a3ffbbc67d32eaf8c4">sucMsg</a> (<a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> msg)</td></tr>
<tr class="memdesc:a6a55f1f8598998a3ffbbc67d32eaf8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns successful message by converting a string into green string output.  <a href="#a6a55f1f8598998a3ffbbc67d32eaf8c4">More...</a><br /></td></tr>
<tr class="separator:a6a55f1f8598998a3ffbbc67d32eaf8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c06020737f7dff22a666b75c28c5e7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6c06020737f7dff22a666b75c28c5e7d">wrnMsg</a> (<a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> msg)</td></tr>
<tr class="memdesc:a6c06020737f7dff22a666b75c28c5e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns warning message by converting a string into yellow string output.  <a href="#a6c06020737f7dff22a666b75c28c5e7d">More...</a><br /></td></tr>
<tr class="separator:a6c06020737f7dff22a666b75c28c5e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077caa1b10ab84d101d79fc7ea50db2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a077caa1b10ab84d101d79fc7ea50db2d">writeWrnMsg</a> (<a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> msg)</td></tr>
<tr class="memdesc:a077caa1b10ab84d101d79fc7ea50db2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a message run through wrnMsg.  <a href="#a077caa1b10ab84d101d79fc7ea50db2d">More...</a><br /></td></tr>
<tr class="separator:a077caa1b10ab84d101d79fc7ea50db2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609eea630a8f88fe9eaba15ce7e48738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a609eea630a8f88fe9eaba15ce7e48738">pasMsg</a> (<a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> msg)</td></tr>
<tr class="memdesc:a609eea630a8f88fe9eaba15ce7e48738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print each pass/phase message by converting a string into blue string output.  <a href="#a609eea630a8f88fe9eaba15ce7e48738">More...</a><br /></td></tr>
<tr class="separator:a609eea630a8f88fe9eaba15ce7e48738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfe12afa463d0ceddeee11540c33ab3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6cfe12afa463d0ceddeee11540c33ab3">reportMemoryUsageKB</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;infor, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=<a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>())</td></tr>
<tr class="memdesc:a6cfe12afa463d0ceddeee11540c33ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print memory usage in KB.  <a href="#a6cfe12afa463d0ceddeee11540c33ab3">More...</a><br /></td></tr>
<tr class="separator:a6cfe12afa463d0ceddeee11540c33ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">getMemoryUsageKB</a> (<a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *vmrss_kb, <a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *vmsize_kb)</td></tr>
<tr class="memdesc:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get memory usage from system file. Return TRUE if succeed.  <a href="#a630ff9c47f58f9b8df7c8a2b3711477c">More...</a><br /></td></tr>
<tr class="separator:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7588578735679773493ff2d5e458e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a0d7588578735679773493ff2d5e458e1">increaseStackSize</a> ()</td></tr>
<tr class="memdesc:a0d7588578735679773493ff2d5e458e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the stack size limit.  <a href="#a0d7588578735679773493ff2d5e458e1">More...</a><br /></td></tr>
<tr class="separator:a0d7588578735679773493ff2d5e458e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ce14119a6e3b0b6022753ddd5890f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa5ce14119a6e3b0b6022753ddd5890f3">cmpPts</a> (const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;lpts, const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;rpts)</td></tr>
<tr class="separator:aa5ce14119a6e3b0b6022753ddd5890f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f749354b7e882ef3e5bf5081fa715b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8f749354b7e882ef3e5bf5081fa715b5">cmpNodeBS</a> (const <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;lpts, const <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;rpts)</td></tr>
<tr class="separator:a8f749354b7e882ef3e5bf5081fa715b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ebab122895189be57637b84adc7642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86ebab122895189be57637b84adc7642">ptsToNodeBS</a> (const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;pts)</td></tr>
<tr class="separator:a86ebab122895189be57637b84adc7642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ceddbe4d57b24e80201bc895f73810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af4ceddbe4d57b24e80201bc895f73810">dumpPointsToList</a> (const <a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">PointsToList</a> &amp;ptl)</td></tr>
<tr class="separator:af4ceddbe4d57b24e80201bc895f73810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c53be5490882768d51aa894b37cbf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad2c53be5490882768d51aa894b37cbf1">isIntrinsicFun</a> (const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *func)</td></tr>
<tr class="separator:ad2c53be5490882768d51aa894b37cbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f58caf27c30a1d414e06f60ca84d80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab7f58caf27c30a1d414e06f60ca84d80">isIntrinsicInst</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="memdesc:ab7f58caf27c30a1d414e06f60ca84d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it is an intrinsic instruction.  <a href="#ab7f58caf27c30a1d414e06f60ca84d80">More...</a><br /></td></tr>
<tr class="separator:ab7f58caf27c30a1d414e06f60ca84d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e08ce822223842fa6a73fd659b1a526"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a2e08ce822223842fa6a73fd659b1a526">isCallSite</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="memdesc:a2e08ce822223842fa6a73fd659b1a526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a call or invoke instruction.  <a href="#a2e08ce822223842fa6a73fd659b1a526">More...</a><br /></td></tr>
<tr class="separator:a2e08ce822223842fa6a73fd659b1a526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bf8f7eaa18fc5a09711959b5417854"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">isCallSite</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:a38bf8f7eaa18fc5a09711959b5417854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a call or invoke instruction.  <a href="#a38bf8f7eaa18fc5a09711959b5417854">More...</a><br /></td></tr>
<tr class="separator:a38bf8f7eaa18fc5a09711959b5417854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8216a92140d982303f83ea424ddc91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8d8216a92140d982303f83ea424ddc91">isNonInstricCallSite</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="memdesc:a8d8216a92140d982303f83ea424ddc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a callsite in the application code, excluding llvm intrinsic calls.  <a href="#a8d8216a92140d982303f83ea424ddc91">More...</a><br /></td></tr>
<tr class="separator:a8d8216a92140d982303f83ea424ddc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202de7ad2bea0311e2f75894c030e7a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a202de7ad2bea0311e2f75894c030e7a9">getLLVMCallSite</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="memdesc:a202de7ad2bea0311e2f75894c030e7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return LLVM callsite given a instruction.  <a href="#a202de7ad2bea0311e2f75894c030e7a9">More...</a><br /></td></tr>
<tr class="separator:a202de7ad2bea0311e2f75894c030e7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09c2b313ff1c1abcc1e5cb3f9ef46a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa09c2b313ff1c1abcc1e5cb3f9ef46a5">getFunction</a> (<a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> <a class="el" href="cJSON_8cpp.html#acc128f98d9ceca227038c771308eff39">name</a>)</td></tr>
<tr class="memdesc:aa09c2b313ff1c1abcc1e5cb3f9ef46a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the corresponding Function based on its name.  <a href="#aa09c2b313ff1c1abcc1e5cb3f9ef46a5">More...</a><br /></td></tr>
<tr class="separator:aa09c2b313ff1c1abcc1e5cb3f9ef46a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54e70082388bbd70868250aaa0bc86b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af54e70082388bbd70868250aaa0bc86b">split</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;s, char seperator)</td></tr>
<tr class="memdesc:af54e70082388bbd70868250aaa0bc86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into two substrings around the first occurrence of a separator string.  <a href="#af54e70082388bbd70868250aaa0bc86b">More...</a><br /></td></tr>
<tr class="separator:af54e70082388bbd70868250aaa0bc86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b55d5252da1f316f505cf6ce2078b28"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4b55d5252da1f316f505cf6ce2078b28">getGlobalRep</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:a4b55d5252da1f316f505cf6ce2078b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the unique defined global across multiple modules  <a href="#a4b55d5252da1f316f505cf6ce2078b28">More...</a><br /></td></tr>
<tr class="separator:a4b55d5252da1f316f505cf6ce2078b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142e650415cb81011eb59dadd3cb0637"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a142e650415cb81011eb59dadd3cb0637">getDefFunForMultipleModule</a> (const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *fun)</td></tr>
<tr class="memdesc:a142e650415cb81011eb59dadd3cb0637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the definition of a function across multiple modules.  <a href="#a142e650415cb81011eb59dadd3cb0637">More...</a><br /></td></tr>
<tr class="separator:a142e650415cb81011eb59dadd3cb0637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memTemplParams" colspan="2">template&lt;typename Data &gt; </td></tr>
<tr class="memitem:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a36c91f952a69875c33d4bd0b05a27ff2">mergePtsOccMaps</a> (<a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; Data, unsigned &gt; &amp;to, const <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; Data, unsigned &gt; from)</td></tr>
<tr class="memdesc:a36c91f952a69875c33d4bd0b05a27ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a map mapping points-to sets to a count, adds from into to.  <a href="#a36c91f952a69875c33d4bd0b05a27ff2">More...</a><br /></td></tr>
<tr class="separator:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a4c5124f2fd03ca3d898e2acd54160"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a14a4c5124f2fd03ca3d898e2acd54160">hclustMethodToString</a> (<a class="el" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a> method)</td></tr>
<tr class="memdesc:a14a4c5124f2fd03ca3d898e2acd54160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of a hclust method.  <a href="#a14a4c5124f2fd03ca3d898e2acd54160">More...</a><br /></td></tr>
<tr class="separator:a14a4c5124f2fd03ca3d898e2acd54160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecfaf26800dcebf0b079395126bc7f7"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename KeySet &gt; </td></tr>
<tr class="memitem:aeecfaf26800dcebf0b079395126bc7f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aeecfaf26800dcebf0b079395126bc7f7">insertKey</a> (const Key &amp;key, KeySet &amp;keySet)</td></tr>
<tr class="memdesc:aeecfaf26800dcebf0b079395126bc7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into a Set/CondSet (with ::insert).  <a href="#aeecfaf26800dcebf0b079395126bc7f7">More...</a><br /></td></tr>
<tr class="separator:aeecfaf26800dcebf0b079395126bc7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4f75b8313eb2b1e5a4c798a01cb99471">insertKey</a> (const <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &amp;key, <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;keySet)</td></tr>
<tr class="memdesc:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a NodeID into a NodeBS.  <a href="#a4f75b8313eb2b1e5a4c798a01cb99471">More...</a><br /></td></tr>
<tr class="separator:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee74719d33695e4da6fee5fc83f745d9"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename KeySet &gt; </td></tr>
<tr class="memitem:aee74719d33695e4da6fee5fc83f745d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aee74719d33695e4da6fee5fc83f745d9">removeKey</a> (const Key &amp;key, KeySet &amp;keySet)</td></tr>
<tr class="memdesc:aee74719d33695e4da6fee5fc83f745d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from a Set/CondSet (or anything implementing ::erase).  <a href="#aee74719d33695e4da6fee5fc83f745d9">More...</a><br /></td></tr>
<tr class="separator:aee74719d33695e4da6fee5fc83f745d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59af7fc01a534662b3b1524186ef97e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa59af7fc01a534662b3b1524186ef97e">removeKey</a> (const <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &amp;key, <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;keySet)</td></tr>
<tr class="memdesc:aa59af7fc01a534662b3b1524186ef97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a NodeID from a NodeBS.  <a href="#aa59af7fc01a534662b3b1524186ef97e">More...</a><br /></td></tr>
<tr class="separator:aa59af7fc01a534662b3b1524186ef97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4cd21115988f9f5eec12e268ddf1d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#add4cd21115988f9f5eec12e268ddf1d9">timeLimitReached</a> (int signum)</td></tr>
<tr class="memdesc:add4cd21115988f9f5eec12e268ddf1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call when alarm for time limit hits.  <a href="#add4cd21115988f9f5eec12e268ddf1d9">More...</a><br /></td></tr>
<tr class="separator:add4cd21115988f9f5eec12e268ddf1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757815a2c758695176120509ceb0ce70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a757815a2c758695176120509ceb0ce70">startAnalysisLimitTimer</a> (unsigned timeLimit)</td></tr>
<tr class="separator:a757815a2c758695176120509ceb0ce70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168f7f7a3a8c70dbf2b5b4269cd4c7c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a168f7f7a3a8c70dbf2b5b4269cd4c7c5">stopAnalysisLimitTimer</a> (bool limitTimerSet)</td></tr>
<tr class="separator:a168f7f7a3a8c70dbf2b5b4269cd4c7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817a63e8330530cb18e077556f7ce518"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a817a63e8330530cb18e077556f7ce518">type2String</a> (const <a class="el" href="namespaceSVF.html#a1d008c0666c145622b81d427be64c52d">Type</a> *<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">type</a>)</td></tr>
<tr class="separator:a817a63e8330530cb18e077556f7ce518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab302ca3fcbde9bd1a7d9d5d837a69c23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab302ca3fcbde9bd1a7d9d5d837a69c23">isAnAllocationWraper</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *)</td></tr>
<tr class="memdesc:ab302ca3fcbde9bd1a7d9d5d837a69c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function servers a allocation wrapper detector.  <a href="#ab302ca3fcbde9bd1a7d9d5d837a69c23">More...</a><br /></td></tr>
<tr class="separator:ab302ca3fcbde9bd1a7d9d5d837a69c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98299033577f1e7f4e9bc73dff3b253"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad98299033577f1e7f4e9bc73dff3b253">getLLVMFunction</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:ad98299033577f1e7f4e9bc73dff3b253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return LLVM function if this value is.  <a href="#ad98299033577f1e7f4e9bc73dff3b253">More...</a><br /></td></tr>
<tr class="separator:ad98299033577f1e7f4e9bc73dff3b253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad27a96075234ad2182a84e0e9d31a45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aad27a96075234ad2182a84e0e9d31a45">isExtCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:aad27a96075234ad2182a84e0e9d31a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e5fd7ffce966575ebf7c7e653b0919"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af3e5fd7ffce966575ebf7c7e653b0919">isExtCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:af3e5fd7ffce966575ebf7c7e653b0919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfa6e9216c6c788c26aef1967689b76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aedfa6e9216c6c788c26aef1967689b76">isHeapAllocExtCallViaArg</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:aedfa6e9216c6c788c26aef1967689b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bde3acf22383eac5bbf4e2c065a2226"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a0bde3acf22383eac5bbf4e2c065a2226">isHeapAllocExtCallViaArg</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a0bde3acf22383eac5bbf4e2c065a2226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2064cb70c76f399ce115f2621adea35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab2064cb70c76f399ce115f2621adea35">isHeapAllocExtCallViaRet</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:ab2064cb70c76f399ce115f2621adea35"><td class="mdescLeft">&#160;</td><td class="mdescRight">interfaces to be used externally  <a href="#ab2064cb70c76f399ce115f2621adea35">More...</a><br /></td></tr>
<tr class="separator:ab2064cb70c76f399ce115f2621adea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24514d87685f2258201f0de15d220bbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a24514d87685f2258201f0de15d220bbc">isHeapAllocExtCallViaRet</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a24514d87685f2258201f0de15d220bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ac673b885633849fa484938405ca75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a93ac673b885633849fa484938405ca75">isHeapAllocExtCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a93ac673b885633849fa484938405ca75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebbf43e294c3f94a2a7d5c56759bbba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1ebbf43e294c3f94a2a7d5c56759bbba">isHeapAllocExtCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a1ebbf43e294c3f94a2a7d5c56759bbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298b6366145ed871faf3d01420ae5d20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a298b6366145ed871faf3d01420ae5d20">getHeapAllocHoldingArgPosition</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a298b6366145ed871faf3d01420ae5d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af986a7698e72272707cc2a466d5ae7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5af986a7698e72272707cc2a466d5ae7">getHeapAllocHoldingArgPosition</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a5af986a7698e72272707cc2a466d5ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6740e7686ba111ae525c6c093cbbaf46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6740e7686ba111ae525c6c093cbbaf46">isReallocExtCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a6740e7686ba111ae525c6c093cbbaf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42748153e4845f3eee0ca58a1e151f97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a42748153e4845f3eee0ca58a1e151f97">isReallocExtCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a42748153e4845f3eee0ca58a1e151f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f52a7f183f1eec7c4db7e4e54fa5e2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1f52a7f183f1eec7c4db7e4e54fa5e2c">isDeallocExtCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a1f52a7f183f1eec7c4db7e4e54fa5e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9973c1326717326b26ec1ea21ebd8da5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a9973c1326717326b26ec1ea21ebd8da5">isDeallocExtCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a9973c1326717326b26ec1ea21ebd8da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62938f722543d6d7fc201b685be1abf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ae62938f722543d6d7fc201b685be1abf">isStaticExtCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:ae62938f722543d6d7fc201b685be1abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8ac16a9a2961f98001ab94aeaedf64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aab8ac16a9a2961f98001ab94aeaedf64">isStaticExtCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:aab8ac16a9a2961f98001ab94aeaedf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87fef7b10465d3e635643fcb93b95a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab87fef7b10465d3e635643fcb93b95a7">isProgEntryFunction</a> (const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *fun)</td></tr>
<tr class="separator:ab87fef7b10465d3e635643fcb93b95a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6528edf9a1750df4a84d1a60d4d0bbe4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6528edf9a1750df4a84d1a60d4d0bbe4">isProgExitCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a6528edf9a1750df4a84d1a60d4d0bbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b531ca4077e71dcc6d085e47a9730b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a68b531ca4077e71dcc6d085e47a9730b">isProgExitCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a68b531ca4077e71dcc6d085e47a9730b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72502f7f536418621485e90ab98c2016"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72502f7f536418621485e90ab98c2016"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::remove_reference&lt; T &gt;::<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">type</a> &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a72502f7f536418621485e90ab98c2016">move</a> (T &amp;&amp;t) noexcept</td></tr>
<tr class="separator:a72502f7f536418621485e90ab98c2016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5d4bb92f5df30417f414397f8e58cf01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5d4bb92f5df30417f414397f8e58cf01">errMsg</a> (<a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> msg)</td></tr>
<tr class="memdesc:a5d4bb92f5df30417f414397f8e58cf01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print error message by converting a string into red string output.  <a href="#a5d4bb92f5df30417f414397f8e58cf01">More...</a><br /></td></tr>
<tr class="separator:a5d4bb92f5df30417f414397f8e58cf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c66553e2559eebfe4f98c0c7ec4b08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af6c66553e2559eebfe4f98c0c7ec4b08">bugMsg1</a> (<a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> msg)</td></tr>
<tr class="separator:af6c66553e2559eebfe4f98c0c7ec4b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054c3e668ce8b265bbc5d923f6243ce7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a054c3e668ce8b265bbc5d923f6243ce7">bugMsg2</a> (<a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> msg)</td></tr>
<tr class="separator:a054c3e668ce8b265bbc5d923f6243ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbca7c40d2da6bd2374ea53d5de0553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aabbca7c40d2da6bd2374ea53d5de0553">bugMsg3</a> (<a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> msg)</td></tr>
<tr class="separator:aabbca7c40d2da6bd2374ea53d5de0553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a145abbd2958629718fbca41d25c3124d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a145abbd2958629718fbca41d25c3124d">getCallee</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:a145abbd2958629718fbca41d25c3124d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return callee of a callsite. Return null if this is an indirect call.  <a href="#a145abbd2958629718fbca41d25c3124d">More...</a><br /></td></tr>
<tr class="separator:a145abbd2958629718fbca41d25c3124d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26c7636bfef7ab2a36cccdcf12c3538"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:af26c7636bfef7ab2a36cccdcf12c3538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a28c0ede7e4765d2a686fc8ae0f5641a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a28c0ede7e4765d2a686fc8ae0f5641a4">getSourceLoc</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:a28c0ede7e4765d2a686fc8ae0f5641a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return source code including line number and file name from debug information.  <a href="#a28c0ede7e4765d2a686fc8ae0f5641a4">More...</a><br /></td></tr>
<tr class="separator:a28c0ede7e4765d2a686fc8ae0f5641a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c1c8bdfc1075c07c631525555194d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86c1c8bdfc1075c07c631525555194d2">getSourceLocOfFunction</a> (const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *<a class="el" href="PEGGrammar_8txt.html#acc7b4cf736579c4d83be2316d5a9e5f2">F</a>)</td></tr>
<tr class="separator:a86c1c8bdfc1075c07c631525555194d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7486fd8e5350879ed1cbd835c0d4e191"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a7486fd8e5350879ed1cbd835c0d4e191">value2String</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *value)</td></tr>
<tr class="separator:a7486fd8e5350879ed1cbd835c0d4e191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a22ef185e767ff76c098e75126c885400"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a22ef185e767ff76c098e75126c885400">isExtCall</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="separator:a22ef185e767ff76c098e75126c885400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b96a872d9096037f20e25122e469ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">isHeapAllocExtFunViaRet</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:a19b96a872d9096037f20e25122e469ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a heap allocator/reallocator.  <a href="#a19b96a872d9096037f20e25122e469ea">More...</a><br /></td></tr>
<tr class="separator:a19b96a872d9096037f20e25122e469ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a69173f50ebe48e69103befe516245"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab4a69173f50ebe48e69103befe516245">isHeapAllocExtFunViaArg</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="separator:ab4a69173f50ebe48e69103befe516245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73215bac62f1340a58f6c7f2ba9b0e7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a73215bac62f1340a58f6c7f2ba9b0e7b">getHeapAllocHoldingArgPosition</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:a73215bac62f1340a58f6c7f2ba9b0e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of argument that holds an allocated heap object.  <a href="#a73215bac62f1340a58f6c7f2ba9b0e7b">More...</a><br /></td></tr>
<tr class="separator:a73215bac62f1340a58f6c7f2ba9b0e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c74c642ad43d955ac8a3f3ad8907b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">isReallocExtFun</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:a97c74c642ad43d955ac8a3f3ad8907b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a heap reallocator.  <a href="#a97c74c642ad43d955ac8a3f3ad8907b4">More...</a><br /></td></tr>
<tr class="separator:a97c74c642ad43d955ac8a3f3ad8907b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3495236e22e4bc6404b6ac352060439c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a3495236e22e4bc6404b6ac352060439c">isDeallocExtFun</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:a3495236e22e4bc6404b6ac352060439c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a heap dealloc or not.  <a href="#a3495236e22e4bc6404b6ac352060439c">More...</a><br /></td></tr>
<tr class="separator:a3495236e22e4bc6404b6ac352060439c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc9bb7bd6c9682debf3ffab7182abf5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1bc9bb7bd6c9682debf3ffab7182abf5">isStaticExtFun</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:a1bc9bb7bd6c9682debf3ffab7182abf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a static global call.  <a href="#a1bc9bb7bd6c9682debf3ffab7182abf5">More...</a><br /></td></tr>
<tr class="separator:a1bc9bb7bd6c9682debf3ffab7182abf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c97c2b79b795465490512e267a9309b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a2c97c2b79b795465490512e267a9309b">isProgEntryFunction</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:a2c97c2b79b795465490512e267a9309b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program entry function e.g. main.  <a href="#a2c97c2b79b795465490512e267a9309b">More...</a><br /></td></tr>
<tr class="separator:a2c97c2b79b795465490512e267a9309b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f82e03d880257527bd9cb5978e05604"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6f82e03d880257527bd9cb5978e05604">getProgFunction</a> (<a class="el" href="classSVF_1_1SVFModule.html">SVFModule</a> *svfModule, const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;funName)</td></tr>
<tr class="memdesc:a6f82e03d880257527bd9cb5978e05604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get program entry function from module.  <a href="#a6f82e03d880257527bd9cb5978e05604">More...</a><br /></td></tr>
<tr class="separator:a6f82e03d880257527bd9cb5978e05604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8017e3e5100b3f63ee338b66118d266"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa8017e3e5100b3f63ee338b66118d266">getProgEntryFunction</a> (<a class="el" href="classSVF_1_1SVFModule.html">SVFModule</a> *svfModule)</td></tr>
<tr class="memdesc:aa8017e3e5100b3f63ee338b66118d266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get program entry function from module.  <a href="#aa8017e3e5100b3f63ee338b66118d266">More...</a><br /></td></tr>
<tr class="separator:aa8017e3e5100b3f63ee338b66118d266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7ee60be22e8f9397db108131696d57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">isProgExitFunction</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:aec7ee60be22e8f9397db108131696d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a program exit function call.  <a href="#aec7ee60be22e8f9397db108131696d57">More...</a><br /></td></tr>
<tr class="separator:aec7ee60be22e8f9397db108131696d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e85d445e8b7b205134acd3874bba388"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a9e85d445e8b7b205134acd3874bba388">isConstantData</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:a9e85d445e8b7b205134acd3874bba388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the value refers to constant data, e.g., i32 0.  <a href="#a9e85d445e8b7b205134acd3874bba388">More...</a><br /></td></tr>
<tr class="separator:a9e85d445e8b7b205134acd3874bba388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac840e43fa58a90099de99a1953f091ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac840e43fa58a90099de99a1953f091ac">getForkedFun</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:ac840e43fa58a90099de99a1953f091ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return thread fork function.  <a href="#ac840e43fa58a90099de99a1953f091ac">More...</a><br /></td></tr>
<tr class="separator:ac840e43fa58a90099de99a1953f091ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc8c549625712e006079642c656ec83"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4cc8c549625712e006079642c656ec83">getForkedFun</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a4cc8c549625712e006079642c656ec83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a61ed4bb80d88b0f8dbc02535c224fdfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a61ed4bb80d88b0f8dbc02535c224fdfb">isHeapAllocOrStaticExtCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:a61ed4bb80d88b0f8dbc02535c224fdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a static global call.  <a href="#a61ed4bb80d88b0f8dbc02535c224fdfb">More...</a><br /></td></tr>
<tr class="separator:a61ed4bb80d88b0f8dbc02535c224fdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8afe88cb58a2ac484c3bc4dd15ece9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a0c8afe88cb58a2ac484c3bc4dd15ece9">isHeapAllocOrStaticExtCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a0c8afe88cb58a2ac484c3bc4dd15ece9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5c2abeb363081381c3dc939ab511e3f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5c2abeb363081381c3dc939ab511e3f0">isThreadForkCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a5c2abeb363081381c3dc939ab511e3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834afc0042c24ed5a1dd00cadc1f00c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a834afc0042c24ed5a1dd00cadc1f00c3">isThreadForkCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a834afc0042c24ed5a1dd00cadc1f00c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a28fbb7cc51eb7e25d88f43e3eb1f30fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a28fbb7cc51eb7e25d88f43e3eb1f30fb">isHareParForCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a28fbb7cc51eb7e25d88f43e3eb1f30fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b37c6fe1232ebc35ffa052bd392e2e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a9b37c6fe1232ebc35ffa052bd392e2e8">isHareParForCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a9b37c6fe1232ebc35ffa052bd392e2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a194a8cf292726bd6cd54307b555c068a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a194a8cf292726bd6cd54307b555c068a">isThreadJoinCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a194a8cf292726bd6cd54307b555c068a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14793b41b05439a8a82fdce02e0587d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a14793b41b05439a8a82fdce02e0587d5">isThreadJoinCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a14793b41b05439a8a82fdce02e0587d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3af5073a1cdc000678f7e4bbc943f5d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a3af5073a1cdc000678f7e4bbc943f5d5">isThreadExitCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a3af5073a1cdc000678f7e4bbc943f5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae025d6727ef34fbeaa7ad48a4dabdcd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aae025d6727ef34fbeaa7ad48a4dabdcd">isThreadExitCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:aae025d6727ef34fbeaa7ad48a4dabdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5f3ecd0770991b6e84afe47a3934f0d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5f3ecd0770991b6e84afe47a3934f0d2">isLockAquireCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a5f3ecd0770991b6e84afe47a3934f0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343dae805a34d102b9c1b96f173468df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a343dae805a34d102b9c1b96f173468df">isLockAquireCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a343dae805a34d102b9c1b96f173468df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1241ef1c19df14f7db0bd62dd68f14f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1241ef1c19df14f7db0bd62dd68f14f9">isLockReleaseCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a1241ef1c19df14f7db0bd62dd68f14f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ac49c70252036a957694f2cf05ae2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a84ac49c70252036a957694f2cf05ae2c">isLockReleaseCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a84ac49c70252036a957694f2cf05ae2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad09ba410acbbaee2aac9dd406c3cf01a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad09ba410acbbaee2aac9dd406c3cf01a">isBarrierWaitCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:ad09ba410acbbaee2aac9dd406c3cf01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a barrier wait call.  <a href="#ad09ba410acbbaee2aac9dd406c3cf01a">More...</a><br /></td></tr>
<tr class="separator:ad09ba410acbbaee2aac9dd406c3cf01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7fc57e1f5cec705e310a4bb72cba94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a0a7fc57e1f5cec705e310a4bb72cba94">isBarrierWaitCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a0a7fc57e1f5cec705e310a4bb72cba94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaeeb386d80b51d729322317065606454"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aaeeb386d80b51d729322317065606454">getActualParmAtForkSite</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:aaeeb386d80b51d729322317065606454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sole argument of the thread routine.  <a href="#aaeeb386d80b51d729322317065606454">More...</a><br /></td></tr>
<tr class="separator:aaeeb386d80b51d729322317065606454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01119ea4e3a10ebecdef4d390a1c4c88"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a01119ea4e3a10ebecdef4d390a1c4c88">getActualParmAtForkSite</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a01119ea4e3a10ebecdef4d390a1c4c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab048cbce6e4f5a3d6ff90da3565220ff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab048cbce6e4f5a3d6ff90da3565220ff">getTaskFuncAtHareParForSite</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:ab048cbce6e4f5a3d6ff90da3565220ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the task function of the parallel_for routine.  <a href="#ab048cbce6e4f5a3d6ff90da3565220ff">More...</a><br /></td></tr>
<tr class="separator:ab048cbce6e4f5a3d6ff90da3565220ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111fa1ecf72adbd2e0ff27e922f0d34a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a111fa1ecf72adbd2e0ff27e922f0d34a">getTaskFuncAtHareParForSite</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a111fa1ecf72adbd2e0ff27e922f0d34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad3471260b66bdd7e6b790ad2a94fe7ce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad3471260b66bdd7e6b790ad2a94fe7ce">getTaskDataAtHareParForSite</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:ad3471260b66bdd7e6b790ad2a94fe7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the task data argument of the parallel_for rountine.  <a href="#ad3471260b66bdd7e6b790ad2a94fe7ce">More...</a><br /></td></tr>
<tr class="separator:ad3471260b66bdd7e6b790ad2a94fe7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3dd36ee492b60039928a86519518a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5f3dd36ee492b60039928a86519518a5">getTaskDataAtHareParForSite</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a5f3dd36ee492b60039928a86519518a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a5c2b39ae857d78ed9dda83880e703b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2b39ae857d78ed9dda83880e703b0f">&#9670;&nbsp;</a></span>equalNodeBS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">SVF::SVFUtil::equalNodeBS</a>  <a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">SVF::SVFUtil::equalNodeBS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68302f07b13f6e1f39aace5699762c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68302f07b13f6e1f39aace5699762c41">&#9670;&nbsp;</a></span>equalPointsTo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">SVF::SVFUtil::equalPointsTo</a>  <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">SVF::SVFUtil::equalPointsTo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4740b14abf7d308e7806a0d6d6c42ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4740b14abf7d308e7806a0d6d6c42ee2">&#9670;&nbsp;</a></span>PointsToList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceSVF.html#a4f21e91ff8eaea5207afe5c60dbd78d7">OrderedSet</a>&lt;<a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a>, <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">equalPointsTo</a>&gt; <a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">SVF::SVFUtil::PointsToList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00164">164</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af6c66553e2559eebfe4f98c0c7ec4b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c66553e2559eebfe4f98c0c7ec4b08">&#9670;&nbsp;</a></span>bugMsg1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::bugMsg1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00081">81</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;{</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#a897b10d246533c95ba86cb79f92e465a">KYEL</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;}</div><div class="ttc" id="SVFUtil_8cpp_html_a897b10d246533c95ba86cb79f92e465a"><div class="ttname"><a href="SVFUtil_8cpp.html#a897b10d246533c95ba86cb79f92e465a">KYEL</a></div><div class="ttdeci">#define KYEL</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00043">SVFUtil.cpp:43</a></div></div>
<div class="ttc" id="SVFUtil_8cpp_html_a137aa83ec74421d226a90c92ec032ac9"><div class="ttname"><a href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a></div><div class="ttdeci">#define KNRM</div><div class="ttdoc">Color for output format. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00040">SVFUtil.cpp:40</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a054c3e668ce8b265bbc5d923f6243ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054c3e668ce8b265bbc5d923f6243ce7">&#9670;&nbsp;</a></span>bugMsg2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::bugMsg2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00086">86</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;{</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#a326cbc9ef8d75aa44a591bf476c9835b">KPUR</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;}</div><div class="ttc" id="SVFUtil_8cpp_html_a137aa83ec74421d226a90c92ec032ac9"><div class="ttname"><a href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a></div><div class="ttdeci">#define KNRM</div><div class="ttdoc">Color for output format. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00040">SVFUtil.cpp:40</a></div></div>
<div class="ttc" id="SVFUtil_8cpp_html_a326cbc9ef8d75aa44a591bf476c9835b"><div class="ttname"><a href="SVFUtil_8cpp.html#a326cbc9ef8d75aa44a591bf476c9835b">KPUR</a></div><div class="ttdeci">#define KPUR</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00045">SVFUtil.cpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aabbca7c40d2da6bd2374ea53d5de0553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbca7c40d2da6bd2374ea53d5de0553">&#9670;&nbsp;</a></span>bugMsg3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::bugMsg3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00091">91</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;{</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#add84f76d7bfbbc2b00215d7195f8d3bd">KCYA</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;}</div><div class="ttc" id="SVFUtil_8cpp_html_a137aa83ec74421d226a90c92ec032ac9"><div class="ttname"><a href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a></div><div class="ttdeci">#define KNRM</div><div class="ttdoc">Color for output format. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00040">SVFUtil.cpp:40</a></div></div>
<div class="ttc" id="SVFUtil_8cpp_html_add84f76d7bfbbc2b00215d7195f8d3bd"><div class="ttname"><a href="SVFUtil_8cpp.html#add84f76d7bfbbc2b00215d7195f8d3bd">KCYA</a></div><div class="ttdeci">#define KCYA</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00046">SVFUtil.cpp:46</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d100868bf63b968d387eb50e9603f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d100868bf63b968d387eb50e9603f7c">&#9670;&nbsp;</a></span>cast() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a>&lt;Y&gt;::value, typename <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, const Y&gt;::ret_type&gt;::<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">type</a> SVF::SVFUtil::cast </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00297">297</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;{</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    assert(llvm::isa&lt;X&gt;(Val) &amp;&amp; <span class="stringliteral">&quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;</span>);</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    <span class="keywordflow">return</span> cast_convert_val&lt;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;           X, <span class="keyword">const</span> Y, <span class="keyword">typename</span> simplify_type&lt;const Y&gt;::SimpleType&gt;::doit(Val);</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a406dd9baf2ce66235d482fd6c6121b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406dd9baf2ce66235d482fd6c6121b2c">&#9670;&nbsp;</a></span>cast() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, Y&gt;::ret_type SVF::SVFUtil::cast </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00305">305</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;{</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    assert(llvm::isa&lt;X&gt;(Val) &amp;&amp; <span class="stringliteral">&quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;</span>);</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    <span class="keywordflow">return</span> cast_convert_val&lt;X, Y,</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;           <span class="keyword">typename</span> simplify_type&lt;Y&gt;::SimpleType&gt;::doit(Val);</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="acc2419a55c0427571f11ad14db2fe481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2419a55c0427571f11ad14db2fe481">&#9670;&nbsp;</a></span>cast() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, Y *&gt;::ret_type SVF::SVFUtil::cast </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00313">313</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;{</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    assert(llvm::isa&lt;X&gt;(Val) &amp;&amp; <span class="stringliteral">&quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;</span>);</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <span class="keywordflow">return</span> cast_convert_val&lt;X, Y*,</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;           <span class="keyword">typename</span> simplify_type&lt;Y*&gt;::SimpleType&gt;::doit(Val);</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="af3ca049b4ce83c874e231f5e13bf36a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ca049b4ce83c874e231f5e13bf36a8">&#9670;&nbsp;</a></span>cast() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, std::unique_ptr&lt;Y&gt; &gt;::ret_type SVF::SVFUtil::cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Y &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00322">322</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;{</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    assert(llvm::isa&lt;X&gt;(Val.get()) &amp;&amp; <span class="stringliteral">&quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;</span>);</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    <span class="keyword">using</span> ret_type = <span class="keyword">typename</span> cast_retty&lt;X, std::unique_ptr&lt;Y&gt;&gt;::ret_type;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    <span class="keywordflow">return</span> ret_type(</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;               cast_convert_val&lt;X, Y *, <span class="keyword">typename</span> simplify_type&lt;Y *&gt;::SimpleType&gt;::doit(</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;                   Val.release()));</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a8f749354b7e882ef3e5bf5081fa715b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f749354b7e882ef3e5bf5081fa715b5">&#9670;&nbsp;</a></span>cmpNodeBS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::cmpNodeBS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>lpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>rpts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00123">123</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;{</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="keywordflow">if</span> (lpts.count() != rpts.count())</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="keywordflow">return</span> (lpts.count() &lt; rpts.count());</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    {</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        NodeBS::iterator bit = lpts.begin(), eit = lpts.end();</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        NodeBS::iterator rbit = rpts.begin(), reit = rpts.end();</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        <span class="keywordflow">for</span> (; bit != eit &amp;&amp; rbit != reit; bit++, rbit++)</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        {</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;            <span class="keywordflow">if</span> (*bit != *rbit)</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                <span class="keywordflow">return</span> (*bit &lt; *rbit);</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        }</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    }</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aa5ce14119a6e3b0b6022753ddd5890f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ce14119a6e3b0b6022753ddd5890f3">&#9670;&nbsp;</a></span>cmpPts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::cmpPts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;&#160;</td>
          <td class="paramname"><em>lpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;&#160;</td>
          <td class="paramname"><em>rpts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare two <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> according to their size and points-to elements.</p><ol type="1">
<li><a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> with smaller size is smaller than the other;</li>
<li>If the sizes are equal, comparing the points-to targets. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00105">105</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;{</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keywordflow">if</span> (lpts.count() != rpts.count())</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        <span class="keywordflow">return</span> (lpts.count() &lt; rpts.count());</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    {</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        PointsTo::iterator bit = lpts.begin(), eit = lpts.end();</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        PointsTo::iterator rbit = rpts.begin(), reit = rpts.end();</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        <span class="keywordflow">for</span> (; bit != eit &amp;&amp; rbit != reit; bit++, rbit++)</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        {</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;            <span class="keywordflow">if</span> (*bit != *rbit)</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                <span class="keywordflow">return</span> (*bit &lt; *rbit);</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        }</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    }</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a4a15cc5570eed12dd6ee766213e11d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a15cc5570eed12dd6ee766213e11d61">&#9670;&nbsp;</a></span>dumpAliasSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpAliasSet </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a>&#160;</td>
          <td class="paramname"><em>bs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump alias set. </p>
<p>Dump alias set </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00137">137</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;{</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;node &quot;</span> &lt;&lt; node &lt;&lt; <span class="stringliteral">&quot; alias set: {&quot;</span>;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a>(bs);</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aeb570e9267fd7b189bd1bc877896d7ab"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">SVF::SVFUtil::dumpSet</a></div><div class="ttdeci">void dumpSet(NodeBS To, OutStream &amp;O=SVFUtil::outs())</div><div class="ttdoc">Dump sparse bitvector set. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00147">SVFUtil.cpp:147</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aed0b0b9f035057552a6a82154fd88e61"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVF::SVFUtil::outs</a></div><div class="ttdeci">std::ostream &amp; outs()</div><div class="ttdoc">Overwrite llvm::outs() </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00049">SVFUtil.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af4ceddbe4d57b24e80201bc895f73810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ceddbe4d57b24e80201bc895f73810">&#9670;&nbsp;</a></span>dumpPointsToList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpPointsToList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">PointsToList</a> &amp;&#160;</td>
          <td class="paramname"><em>ptl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00122">122</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;{</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;{&quot;</span>;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="keywordflow">for</span> (PointsToList::const_iterator ii = ptl.begin(), ie = ptl.end();</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            ii != ie; ii++)</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    {</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        <span class="keyword">auto</span> bs = *ii;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <a class="code" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a>(bs);</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    }</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aeb570e9267fd7b189bd1bc877896d7ab"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">SVF::SVFUtil::dumpSet</a></div><div class="ttdeci">void dumpSet(NodeBS To, OutStream &amp;O=SVFUtil::outs())</div><div class="ttdoc">Dump sparse bitvector set. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00147">SVFUtil.cpp:147</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aed0b0b9f035057552a6a82154fd88e61"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVF::SVFUtil::outs</a></div><div class="ttdeci">std::ostream &amp; outs()</div><div class="ttdoc">Overwrite llvm::outs() </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00049">SVFUtil.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abd0a9ee845a455f9354d24a8b84a0bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0a9ee845a455f9354d24a8b84a0bb3">&#9670;&nbsp;</a></span>dumpPointsToSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpPointsToSet </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a>&#160;</td>
          <td class="paramname"><em>bs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump points-to set. </p>
<p>Dump points-to set </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00107">107</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;{</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;node &quot;</span> &lt;&lt; node &lt;&lt; <span class="stringliteral">&quot; points-to: {&quot;</span>;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a>(bs);</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aeb570e9267fd7b189bd1bc877896d7ab"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">SVF::SVFUtil::dumpSet</a></div><div class="ttdeci">void dumpSet(NodeBS To, OutStream &amp;O=SVFUtil::outs())</div><div class="ttdoc">Dump sparse bitvector set. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00147">SVFUtil.cpp:147</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aed0b0b9f035057552a6a82154fd88e61"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVF::SVFUtil::outs</a></div><div class="ttdeci">std::ostream &amp; outs()</div><div class="ttdoc">Overwrite llvm::outs() </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00049">SVFUtil.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb570e9267fd7b189bd1bc877896d7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb570e9267fd7b189bd1bc877896d7ab">&#9670;&nbsp;</a></span>dumpSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a>&#160;</td>
          <td class="paramname"><em>bs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;&#160;</td>
          <td class="paramname"><em>O</em> = <code><a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump sparse bitvector set. </p>
<p>Dump bit vector set </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00147">147</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;{</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="classSVF_1_1SparseBitVector_1_1SparseBitVectorIterator.html">NodeBS::iterator</a> ii = bs.<a class="code" href="classSVF_1_1SparseBitVector.html#abf76d8157c49ddba24bdc9dab3655772">begin</a>(), ie = bs.<a class="code" href="classSVF_1_1SparseBitVector.html#a1b5abe09fd0fcd337385653cb47343c1">end</a>();</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            ii != ie; ii++)</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    {</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        O &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *ii &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    }</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;}</div><div class="ttc" id="classSVF_1_1SparseBitVector_1_1SparseBitVectorIterator_html"><div class="ttname"><a href="classSVF_1_1SparseBitVector_1_1SparseBitVectorIterator.html">SVF::SparseBitVector::SparseBitVectorIterator</a></div><div class="ttdef"><b>Definition:</b> <a href="SparseBitVector_8h_source.html#l00534">SparseBitVector.h:534</a></div></div>
<div class="ttc" id="classSVF_1_1SparseBitVector_html_a1b5abe09fd0fcd337385653cb47343c1"><div class="ttname"><a href="classSVF_1_1SparseBitVector.html#a1b5abe09fd0fcd337385653cb47343c1">SVF::SparseBitVector::end</a></div><div class="ttdeci">iterator end() const</div><div class="ttdef"><b>Definition:</b> <a href="SparseBitVector_8h_source.html#l01118">SparseBitVector.h:1118</a></div></div>
<div class="ttc" id="classSVF_1_1SparseBitVector_html_abf76d8157c49ddba24bdc9dab3655772"><div class="ttname"><a href="classSVF_1_1SparseBitVector.html#abf76d8157c49ddba24bdc9dab3655772">SVF::SparseBitVector::begin</a></div><div class="ttdeci">iterator begin() const</div><div class="ttdef"><b>Definition:</b> <a href="SparseBitVector_8h_source.html#l01113">SparseBitVector.h:1113</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a04aa23b4982662d98c56af3e8ba16cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04aa23b4982662d98c56af3e8ba16cb1">&#9670;&nbsp;</a></span>dumpSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a>&#160;</td>
          <td class="paramname"><em>To</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;&#160;</td>
          <td class="paramname"><em>O</em> = <code><a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00156">156</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;{</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> <a class="code" href="cJSON_8cpp.html#ab6e2ea6dc7bd57d1483413449998230a">n</a> : pt)</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    {</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        o &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="cJSON_8cpp.html#ab6e2ea6dc7bd57d1483413449998230a">n</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    }</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a43a65e0d33af3c743294f7a1139d2301"><div class="ttname"><a href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">SVF::NodeID</a></div><div class="ttdeci">unsigned NodeID</div><div class="ttdef"><b>Definition:</b> <a href="MTAResultValidator_8h_source.html#l00019">MTAResultValidator.h:19</a></div></div>
<div class="ttc" id="cJSON_8cpp_html_ab6e2ea6dc7bd57d1483413449998230a"><div class="ttname"><a href="cJSON_8cpp.html#ab6e2ea6dc7bd57d1483413449998230a">n</a></div><div class="ttdeci">cJSON * n</div><div class="ttdef"><b>Definition:</b> <a href="cJSON_8cpp_source.html#l02558">cJSON.cpp:2558</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab30a35713852a0a525c52ae5dd463442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30a35713852a0a525c52ae5dd463442">&#9670;&nbsp;</a></span>dumpSparseSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpSparseSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>To</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00115">115</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;{</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;{&quot;</span>;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a>(bs);</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aeb570e9267fd7b189bd1bc877896d7ab"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">SVF::SVFUtil::dumpSet</a></div><div class="ttdeci">void dumpSet(NodeBS To, OutStream &amp;O=SVFUtil::outs())</div><div class="ttdoc">Dump sparse bitvector set. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00147">SVFUtil.cpp:147</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aed0b0b9f035057552a6a82154fd88e61"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVF::SVFUtil::outs</a></div><div class="ttdeci">std::ostream &amp; outs()</div><div class="ttdoc">Overwrite llvm::outs() </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00049">SVFUtil.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8182be247907420db00837cef9bcfa70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8182be247907420db00837cef9bcfa70">&#9670;&nbsp;</a></span>dyn_cast() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD std::enable_if&lt;!<a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a>&lt;Y&gt;::value, typename <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, const Y&gt;::ret_type&gt;::<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">type</a> SVF::SVFUtil::dyn_cast </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00343">343</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;{</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    <span class="keywordflow">return</span> llvm::isa&lt;X&gt;(Val) ? llvm::cast&lt;X&gt;(Val) : nullptr;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a52d852ba8fa569e858565b3bba403656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d852ba8fa569e858565b3bba403656">&#9670;&nbsp;</a></span>dyn_cast() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, Y&gt;::ret_type SVF::SVFUtil::dyn_cast </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00349">349</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;{</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    <span class="keywordflow">return</span> llvm::isa&lt;X&gt;(Val) ? llvm::cast&lt;X&gt;(Val) : nullptr;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a105c5c5e97d56533fb2b3ba7a0bc59f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105c5c5e97d56533fb2b3ba7a0bc59f3">&#9670;&nbsp;</a></span>dyn_cast() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, Y *&gt;::ret_type SVF::SVFUtil::dyn_cast </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00355">355</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;{</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    <span class="keywordflow">return</span> llvm::isa&lt;X&gt;(Val) ? llvm::cast&lt;X&gt;(Val) : nullptr;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5d4bb92f5df30417f414397f8e58cf01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4bb92f5df30417f414397f8e58cf01">&#9670;&nbsp;</a></span>errMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::errMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print error message by converting a string into red string output. </p>
<p>print error message by converting a string into red string output </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00076">76</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;{</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#a66290957baed5df3930ada4cb8caccf1">KRED</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;}</div><div class="ttc" id="SVFUtil_8cpp_html_a66290957baed5df3930ada4cb8caccf1"><div class="ttname"><a href="SVFUtil_8cpp.html#a66290957baed5df3930ada4cb8caccf1">KRED</a></div><div class="ttdeci">#define KRED</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00041">SVFUtil.cpp:41</a></div></div>
<div class="ttc" id="SVFUtil_8cpp_html_a137aa83ec74421d226a90c92ec032ac9"><div class="ttname"><a href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a></div><div class="ttdeci">#define KNRM</div><div class="ttdoc">Color for output format. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00040">SVFUtil.cpp:40</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab65033f068bfbeb0a1c52dcec3beb6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65033f068bfbeb0a1c52dcec3beb6bc">&#9670;&nbsp;</a></span>errs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; SVF::SVFUtil::errs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrite <a class="el" href="namespaceSVF_1_1SVFUtil.html#ab65033f068bfbeb0a1c52dcec3beb6bc" title="Overwrite llvm::errs() ">llvm::errs()</a> </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00055">55</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;{</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="keywordflow">return</span> std::cerr;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aaeeb386d80b51d729322317065606454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeeb386d80b51d729322317065606454">&#9670;&nbsp;</a></span>getActualParmAtForkSite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getActualParmAtForkSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return sole argument of the thread routine. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00677">677</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;{</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getActualParmAtForkSite(cs);</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a01119ea4e3a10ebecdef4d390a1c4c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01119ea4e3a10ebecdef4d390a1c4c88">&#9670;&nbsp;</a></span>getActualParmAtForkSite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getActualParmAtForkSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00681">681</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;{</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getActualParmAtForkSite(inst);</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a145abbd2958629718fbca41d25c3124d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145abbd2958629718fbca41d25c3124d">&#9670;&nbsp;</a></span>getCallee() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a>* SVF::SVFUtil::getCallee </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return callee of a callsite. Return null if this is an indirect call. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00281">281</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;{</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="comment">// FIXME: do we need to strip-off the casts here to discover more library functions</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    <a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *callee = <a class="code" href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVFUtil::dyn_cast</a>&lt;<a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a>&gt;(cs.getCalledValue()-&gt;stripPointerCasts());</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a142e650415cb81011eb59dadd3cb0637">getDefFunForMultipleModule</a>(callee);</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a142e650415cb81011eb59dadd3cb0637"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a142e650415cb81011eb59dadd3cb0637">SVF::SVFUtil::getDefFunForMultipleModule</a></div><div class="ttdeci">const SVFFunction * getDefFunForMultipleModule(const Function *fun)</div><div class="ttdoc">Get the definition of a function across multiple modules. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00269">SVFUtil.h:269</a></div></div>
<div class="ttc" id="namespaceSVF_html_a5faee14fa1dd41447bc73ac365fe33c1"><div class="ttname"><a href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">SVF::Function</a></div><div class="ttdeci">llvm::Function Function</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00070">BasicTypes.h:70</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a8182be247907420db00837cef9bcfa70"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVF::SVFUtil::dyn_cast</a></div><div class="ttdeci">LLVM_NODISCARD std::enable_if&lt;!is_simple_type&lt; Y &gt;::value, typename cast_retty&lt; X, const Y &gt;::ret_type &gt;::type dyn_cast(const Y &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="Casting_8h_source.html#l00343">Casting.h:343</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af26c7636bfef7ab2a36cccdcf12c3538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26c7636bfef7ab2a36cccdcf12c3538">&#9670;&nbsp;</a></span>getCallee() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a>* SVF::SVFUtil::getCallee </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00288">288</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;{</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">isCallSite</a>(inst))</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    CallSite cs(const_cast&lt;Instruction*&gt;(inst));</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs);</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a38bf8f7eaa18fc5a09711959b5417854"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">SVF::SVFUtil::isCallSite</a></div><div class="ttdeci">bool isCallSite(const Value *val)</div><div class="ttdoc">Whether an instruction is a call or invoke instruction. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00201">SVFUtil.h:201</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a142e650415cb81011eb59dadd3cb0637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142e650415cb81011eb59dadd3cb0637">&#9670;&nbsp;</a></span>getDefFunForMultipleModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a>* SVF::SVFUtil::getDefFunForMultipleModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the definition of a function across multiple modules. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00269">269</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;{</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    <span class="keywordflow">if</span>(fun == <span class="keyword">nullptr</span>) <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    LLVMModuleSet* llvmModuleset = LLVMModuleSet::getLLVMModuleSet();</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    <span class="keyword">const</span> SVFFunction* svfFun = llvmModuleset-&gt;getSVFFunction(fun);</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    <span class="keywordflow">if</span> (fun-&gt;isDeclaration() &amp;&amp; llvmModuleset-&gt;hasDefinition(fun))</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;        svfFun = LLVMModuleSet::getLLVMModuleSet()-&gt;getDefinition(fun);</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    <span class="keywordflow">return</span> svfFun;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ac840e43fa58a90099de99a1953f091ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac840e43fa58a90099de99a1953f091ac">&#9670;&nbsp;</a></span>getForkedFun() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getForkedFun </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return thread fork function. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00461">461</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;{</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getForkedFun(cs);</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a4cc8c549625712e006079642c656ec83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc8c549625712e006079642c656ec83">&#9670;&nbsp;</a></span>getForkedFun() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getForkedFun </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00465">465</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;{</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getForkedFun(inst);</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aa09c2b313ff1c1abcc1e5cb3f9ef46a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09c2b313ff1c1abcc1e5cb3f9ef46a5">&#9670;&nbsp;</a></span>getFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a>* SVF::SVFUtil::getFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the corresponding Function based on its name. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00225">225</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;{</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    <a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a>* fun = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    LLVMModuleSet* llvmModuleset = LLVMModuleSet::getLLVMModuleSet();</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> i = 0; i &lt; llvmModuleset-&gt;getModuleNum(); ++i)</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    {</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <a class="code" href="namespaceSVF.html#aa7a770b5dd5cd0e37d06a1088f252906">Module</a> *mod = llvmModuleset-&gt;getModule(i);</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        fun = mod-&gt;getFunction(<a class="code" href="cJSON_8h.html#a25d22ecc7e656d2c59332072684e8766">name</a>);</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="keywordflow">if</span>(fun)</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        {</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            <span class="keywordflow">return</span> llvmModuleset-&gt;getSVFFunction(fun);</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        }</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    }</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_aa7a770b5dd5cd0e37d06a1088f252906"><div class="ttname"><a href="namespaceSVF.html#aa7a770b5dd5cd0e37d06a1088f252906">SVF::Module</a></div><div class="ttdeci">llvm::Module Module</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00077">BasicTypes.h:77</a></div></div>
<div class="ttc" id="cJSON_8h_html_a25d22ecc7e656d2c59332072684e8766"><div class="ttname"><a href="cJSON_8h.html#a25d22ecc7e656d2c59332072684e8766">name</a></div><div class="ttdeci">const char *const name</div><div class="ttdef"><b>Definition:</b> <a href="cJSON_8h_source.html#l00264">cJSON.h:264</a></div></div>
<div class="ttc" id="namespaceSVF_html_ad42bff8d0a7d60a085aa32d10f4955af"><div class="ttname"><a href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">SVF::u32_t</a></div><div class="ttdeci">unsigned u32_t</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00085">SVFBasicTypes.h:85</a></div></div>
<div class="ttc" id="namespaceSVF_html_a5faee14fa1dd41447bc73ac365fe33c1"><div class="ttname"><a href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">SVF::Function</a></div><div class="ttdeci">llvm::Function Function</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00070">BasicTypes.h:70</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4b55d5252da1f316f505cf6ce2078b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b55d5252da1f316f505cf6ce2078b28">&#9670;&nbsp;</a></span>getGlobalRep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getGlobalRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the unique defined global across multiple modules </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00258">258</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;{</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a09f5fa3bc44bf53612a085e3a611cc4e">GlobalVariable</a>* gvar = SVFUtil::dyn_cast&lt;GlobalVariable&gt;(val))</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    {</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        <span class="keywordflow">if</span> (LLVMModuleSet::getLLVMModuleSet()-&gt;hasGlobalRep(gvar))</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;            val = LLVMModuleSet::getLLVMModuleSet()-&gt;getGlobalRep(gvar);</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    }</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    <span class="keywordflow">return</span> val;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a09f5fa3bc44bf53612a085e3a611cc4e"><div class="ttname"><a href="namespaceSVF.html#a09f5fa3bc44bf53612a085e3a611cc4e">SVF::GlobalVariable</a></div><div class="ttdeci">llvm::GlobalVariable GlobalVariable</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00076">BasicTypes.h:76</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a73215bac62f1340a58f6c7f2ba9b0e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73215bac62f1340a58f6c7f2ba9b0e7b">&#9670;&nbsp;</a></span>getHeapAllocHoldingArgPosition() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SVF::SVFUtil::getHeapAllocHoldingArgPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the position of argument that holds an allocated heap object. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00379">379</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;{</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    <span class="keywordflow">return</span> ExtAPI::getExtAPI()-&gt;get_alloc_arg_pos(fun);</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a298b6366145ed871faf3d01420ae5d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298b6366145ed871faf3d01420ae5d20">&#9670;&nbsp;</a></span>getHeapAllocHoldingArgPosition() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SVF::SVFUtil::getHeapAllocHoldingArgPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00530">530</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;{</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a5af986a7698e72272707cc2a466d5ae7">getHeapAllocHoldingArgPosition</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs));</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a5af986a7698e72272707cc2a466d5ae7"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a5af986a7698e72272707cc2a466d5ae7">SVF::SVFUtil::getHeapAllocHoldingArgPosition</a></div><div class="ttdeci">int getHeapAllocHoldingArgPosition(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00535">SVFUtil.h:535</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5af986a7698e72272707cc2a466d5ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af986a7698e72272707cc2a466d5ae7">&#9670;&nbsp;</a></span>getHeapAllocHoldingArgPosition() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SVF::SVFUtil::getHeapAllocHoldingArgPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00535">535</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;{</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a5af986a7698e72272707cc2a466d5ae7">getHeapAllocHoldingArgPosition</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(inst));</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a5af986a7698e72272707cc2a466d5ae7"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a5af986a7698e72272707cc2a466d5ae7">SVF::SVFUtil::getHeapAllocHoldingArgPosition</a></div><div class="ttdeci">int getHeapAllocHoldingArgPosition(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00535">SVFUtil.h:535</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a202de7ad2bea0311e2f75894c030e7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202de7ad2bea0311e2f75894c030e7a9">&#9670;&nbsp;</a></span>getLLVMCallSite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSVF_1_1CallSite.html">CallSite</a> SVF::SVFUtil::getLLVMCallSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return LLVM callsite given a instruction. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00217">217</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;{</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    assert(<a class="code" href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">isCallSite</a>(inst) &amp;&amp; <span class="stringliteral">&quot;not a callsite?&quot;</span>);</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    CallSite cs(const_cast&lt;Instruction*&gt;(inst));</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    <span class="keywordflow">return</span> cs;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a38bf8f7eaa18fc5a09711959b5417854"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">SVF::SVFUtil::isCallSite</a></div><div class="ttdeci">bool isCallSite(const Value *val)</div><div class="ttdoc">Whether an instruction is a call or invoke instruction. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00201">SVFUtil.h:201</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad98299033577f1e7f4e9bc73dff3b253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98299033577f1e7f4e9bc73dff3b253">&#9670;&nbsp;</a></span>getLLVMFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a>* SVF::SVFUtil::getLLVMFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return LLVM function if this value is. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00480">480</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;{</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *fun = <a class="code" href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVFUtil::dyn_cast</a>&lt;<a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a>&gt;(val-&gt;stripPointerCasts());</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    <span class="keywordflow">return</span> fun;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a5faee14fa1dd41447bc73ac365fe33c1"><div class="ttname"><a href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">SVF::Function</a></div><div class="ttdeci">llvm::Function Function</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00070">BasicTypes.h:70</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a8182be247907420db00837cef9bcfa70"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVF::SVFUtil::dyn_cast</a></div><div class="ttdeci">LLVM_NODISCARD std::enable_if&lt;!is_simple_type&lt; Y &gt;::value, typename cast_retty&lt; X, const Y &gt;::ret_type &gt;::type dyn_cast(const Y &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="Casting_8h_source.html#l00343">Casting.h:343</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a630ff9c47f58f9b8df7c8a2b3711477c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630ff9c47f58f9b8df7c8a2b3711477c">&#9670;&nbsp;</a></span>getMemoryUsageKB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::getMemoryUsageKB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *&#160;</td>
          <td class="paramname"><em>vmrss_kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *&#160;</td>
          <td class="paramname"><em>vmsize_kb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get memory usage from system file. Return TRUE if succeed. </p>
<p>Get memory usage </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00177">177</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;{</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="comment">/* Get the the current process&#39; status file from the proc filesystem */</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="keywordtype">char</span> <a class="code" href="cJSON_8h.html#a503753140aa27b00f99a3501280b2746">buffer</a>[8192];</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    FILE* procfile = fopen(<span class="stringliteral">&quot;/proc/self/status&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <span class="keywordflow">if</span>(procfile)</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    {</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <a class="code" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> result = fread(buffer, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), 8192, procfile);</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="keywordflow">if</span> (result == 0)</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        {</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;            fputs (<span class="stringliteral">&quot;Reading error\n&quot;</span>,stderr);</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;        }</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    }</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    {</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        fputs (<span class="stringliteral">&quot;/proc/self/status file not exit\n&quot;</span>,stderr);</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    }</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    fclose(procfile);</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <span class="comment">/* Look through proc status contents line by line */</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="keywordtype">char</span> delims[] = <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="keywordtype">char</span>* line = strtok(buffer, delims);</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    <span class="keywordtype">bool</span> found_vmrss = <span class="keyword">false</span>;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    <span class="keywordtype">bool</span> found_vmsize = <span class="keyword">false</span>;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="keywordflow">while</span> (line != <span class="keyword">nullptr</span> &amp;&amp; (found_vmrss == <span class="keyword">false</span> || found_vmsize == <span class="keyword">false</span>))</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    {</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        <span class="keywordflow">if</span> (strstr(line, <span class="stringliteral">&quot;VmRSS:&quot;</span>) != <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        {</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;            sscanf(line, <span class="stringliteral">&quot;%*s %u&quot;</span>, vmrss_kb);</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;            found_vmrss = <span class="keyword">true</span>;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        }</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        <span class="keywordflow">if</span> (strstr(line, <span class="stringliteral">&quot;VmSize:&quot;</span>) != <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        {</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;            sscanf(line, <span class="stringliteral">&quot;%*s %u&quot;</span>, vmsize_kb);</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;            found_vmsize = <span class="keyword">true</span>;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        }</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        line = strtok(<span class="keyword">nullptr</span>, delims);</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    }</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    <span class="keywordflow">return</span> (found_vmrss &amp;&amp; found_vmsize);</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_ad42bff8d0a7d60a085aa32d10f4955af"><div class="ttname"><a href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">SVF::u32_t</a></div><div class="ttdeci">unsigned u32_t</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00085">SVFBasicTypes.h:85</a></div></div>
<div class="ttc" id="cJSON_8h_html_a503753140aa27b00f99a3501280b2746"><div class="ttname"><a href="cJSON_8h.html#a503753140aa27b00f99a3501280b2746">buffer</a></div><div class="ttdeci">char * buffer</div><div class="ttdef"><b>Definition:</b> <a href="cJSON_8h_source.html#l00163">cJSON.h:163</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8017e3e5100b3f63ee338b66118d266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8017e3e5100b3f63ee338b66118d266">&#9670;&nbsp;</a></span>getProgEntryFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a>* SVF::SVFUtil::getProgEntryFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1SVFModule.html">SVFModule</a> *&#160;</td>
          <td class="paramname"><em>svfModule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get program entry function from module. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00430">430</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;{</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    <span class="keywordflow">for</span> (SVFModule::const_iterator it = svfModule-&gt;begin(), eit = svfModule-&gt;end(); it != eit; ++it)</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    {</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;        <span class="keyword">const</span> SVFFunction *fun = *it;</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1SVFUtil.html#ab87fef7b10465d3e635643fcb93b95a7">isProgEntryFunction</a>(fun))</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;            <span class="keywordflow">return</span> (fun);</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    }</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ab87fef7b10465d3e635643fcb93b95a7"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ab87fef7b10465d3e635643fcb93b95a7">SVF::SVFUtil::isProgEntryFunction</a></div><div class="ttdeci">bool isProgEntryFunction(const Function *fun)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00711">SVFUtil.h:711</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6f82e03d880257527bd9cb5978e05604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f82e03d880257527bd9cb5978e05604">&#9670;&nbsp;</a></span>getProgFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a>* SVF::SVFUtil::getProgFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1SVFModule.html">SVFModule</a> *&#160;</td>
          <td class="paramname"><em>svfModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>funName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get program entry function from module. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00418">418</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;{</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <span class="keywordflow">for</span> (SVFModule::const_iterator it = svfModule-&gt;begin(), eit = svfModule-&gt;end(); it != eit; ++it)</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    {</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        <span class="keyword">const</span> SVFFunction *fun = *it;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;        <span class="keywordflow">if</span> (fun-&gt;getName()==funName)</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;            <span class="keywordflow">return</span> fun;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    }</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a28c0ede7e4765d2a686fc8ae0f5641a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c0ede7e4765d2a686fc8ae0f5641a4">&#9670;&nbsp;</a></span>getSourceLoc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::getSourceLoc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return source code including line number and file name from debug information. </p>
<p>Get the meta data (line number and file name) info of a LLVM value </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00267">267</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;{</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    <span class="keywordflow">if</span>(val==<span class="keyword">nullptr</span>)  <span class="keywordflow">return</span> <span class="stringliteral">&quot;{ empty val }&quot;</span>;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    <a class="code" href="cJSON_8h.html#ad4c68ea99a26b0a98ad9a79982960458">std::string</a> str;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    <a class="code" href="namespaceSVF.html#a726981481ac082dcda3e4921416b65a0">raw_string_ostream</a> rawstr(str);</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    rawstr &lt;&lt; <span class="stringliteral">&quot;{ &quot;</span>;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst = SVFUtil::dyn_cast&lt;Instruction&gt;(val))</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    {</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        <span class="keywordflow">if</span> (SVFUtil::isa&lt;AllocaInst&gt;(inst))</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        {</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;            <span class="keywordflow">for</span> (<a class="code" href="namespaceSVF.html#a98310cccad527f8151328f2c87b29563">llvm::DbgInfoIntrinsic</a> *DII : FindDbgAddrUses(const_cast&lt;Instruction*&gt;(inst)))</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;            {</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF.html#a52a9bff350f21692eae3b519030c314d">llvm::DbgDeclareInst</a> *DDI = SVFUtil::dyn_cast&lt;llvm::DbgDeclareInst&gt;(DII))</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                {</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                    llvm::DIVariable *DIVar = SVFUtil::cast&lt;llvm::DIVariable&gt;(DDI-&gt;getVariable());</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;                    rawstr &lt;&lt; <span class="stringliteral">&quot;ln: &quot;</span> &lt;&lt; DIVar-&gt;getLine() &lt;&lt; <span class="stringliteral">&quot; fl: &quot;</span> &lt;&lt; DIVar-&gt;getFilename();</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                }</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;            }</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;        }</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF.html#ad3d3cec1813411f039211c86236f7adb">MDNode</a> *N = inst-&gt;getMetadata(<span class="stringliteral">&quot;dbg&quot;</span>))   <span class="comment">// Here I is an LLVM instruction</span></div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        {</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;            llvm::DILocation* Loc = SVFUtil::cast&lt;llvm::DILocation&gt;(N);                   <span class="comment">// DILocation is in DebugInfo.h</span></div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;            <span class="keywordtype">unsigned</span> Line = Loc-&gt;getLine();</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;            <span class="keywordtype">unsigned</span> Column = Loc-&gt;getColumn();</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;            <a class="code" href="cJSON_8h.html#ad4c68ea99a26b0a98ad9a79982960458">std::string</a> File = Loc-&gt;getFilename().str();</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;            <span class="comment">//StringRef Dir = Loc.getDirectory();</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;            <span class="keywordflow">if</span>(File.empty() || Line == 0)</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            {</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;                <span class="keyword">auto</span> inlineLoc = Loc-&gt;getInlinedAt();</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                <span class="keywordflow">if</span>(inlineLoc)</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                {</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                    Line = inlineLoc-&gt;getLine();</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                    Column = inlineLoc-&gt;getColumn();</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                    File = inlineLoc-&gt;getFilename().str();</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                }</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;            }</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            rawstr &lt;&lt; <span class="stringliteral">&quot;ln: &quot;</span> &lt;&lt; Line &lt;&lt; <span class="stringliteral">&quot;  cl: &quot;</span> &lt;&lt; Column &lt;&lt; <span class="stringliteral">&quot;  fl: &quot;</span> &lt;&lt; File;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        }</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    }</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a58cdfbc4160cae08745b67844ac29801">Argument</a>* argument = SVFUtil::dyn_cast&lt;Argument&gt;(val))</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    {</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        <span class="keywordflow">if</span> (argument-&gt;getArgNo()%10 == 1)</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            rawstr &lt;&lt; argument-&gt;getArgNo() &lt;&lt; <span class="stringliteral">&quot;st&quot;</span>;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argument-&gt;getArgNo()%10 == 2)</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;            rawstr &lt;&lt; argument-&gt;getArgNo() &lt;&lt; <span class="stringliteral">&quot;nd&quot;</span>;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argument-&gt;getArgNo()%10 == 3)</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;            rawstr &lt;&lt; argument-&gt;getArgNo() &lt;&lt; <span class="stringliteral">&quot;rd&quot;</span>;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;            rawstr &lt;&lt; argument-&gt;getArgNo() &lt;&lt; <span class="stringliteral">&quot;th&quot;</span>;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        rawstr &lt;&lt; <span class="stringliteral">&quot; arg &quot;</span> &lt;&lt; argument-&gt;getParent()-&gt;getName() &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;               &lt;&lt; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a86c1c8bdfc1075c07c631525555194d2">getSourceLocOfFunction</a>(argument-&gt;getParent());</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    }</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a09f5fa3bc44bf53612a085e3a611cc4e">GlobalVariable</a>* gvar = SVFUtil::dyn_cast&lt;GlobalVariable&gt;(val))</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    {</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        rawstr &lt;&lt; <span class="stringliteral">&quot;Glob &quot;</span>;</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        <a class="code" href="namespaceSVF.html#a3011dbac9102f044ad5f36a4ad3d4a71">NamedMDNode</a>* CU_Nodes = gvar-&gt;getParent()-&gt;getNamedMetadata(<span class="stringliteral">&quot;llvm.dbg.cu&quot;</span>);</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        <span class="keywordflow">if</span>(CU_Nodes)</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        {</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0, e = CU_Nodes-&gt;getNumOperands(); i != e; ++i)</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;            {</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                llvm::DICompileUnit *CUNode = SVFUtil::cast&lt;llvm::DICompileUnit&gt;(CU_Nodes-&gt;getOperand(i));</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                <span class="keywordflow">for</span> (llvm::DIGlobalVariableExpression *GV : CUNode-&gt;getGlobalVariables())</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                {</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                    llvm::DIGlobalVariable * DGV = GV-&gt;getVariable();</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                    <span class="keywordflow">if</span>(DGV-&gt;getName() == gvar-&gt;getName())</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                    {</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                        rawstr &lt;&lt; <span class="stringliteral">&quot;ln: &quot;</span> &lt;&lt; DGV-&gt;getLine() &lt;&lt; <span class="stringliteral">&quot; fl: &quot;</span> &lt;&lt; DGV-&gt;getFilename();</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                    }</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                }</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;            }</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        }</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    }</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a>* func = SVFUtil::dyn_cast&lt;Function&gt;(val))</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    {</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        rawstr &lt;&lt; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a86c1c8bdfc1075c07c631525555194d2">getSourceLocOfFunction</a>(func);</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    }</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a>* bb = SVFUtil::dyn_cast&lt;BasicBlock&gt;(val))</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    {</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        rawstr &lt;&lt; <span class="stringliteral">&quot;basic block: &quot;</span> &lt;&lt; bb-&gt;getName() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a28c0ede7e4765d2a686fc8ae0f5641a4">getSourceLoc</a>(bb-&gt;getFirstNonPHI());</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    }</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#a9e85d445e8b7b205134acd3874bba388">SVFUtil::isConstantData</a>(val))</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    {</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        rawstr &lt;&lt; <span class="stringliteral">&quot;constant data&quot;</span>;</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    }</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    {</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;        rawstr &lt;&lt; <span class="stringliteral">&quot;Can only get source location for instruction, argument, global var, function or constant data.&quot;</span>;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    }</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    rawstr &lt;&lt; <span class="stringliteral">&quot; }&quot;</span>;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    <span class="keywordflow">if</span>(rawstr.str()==<span class="stringliteral">&quot;{  }&quot;</span>)</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;    <span class="keywordflow">return</span> rawstr.str();</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a23bf614858f168b6ad76e0233cec9965"><div class="ttname"><a href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">SVF::BasicBlock</a></div><div class="ttdeci">llvm::BasicBlock BasicBlock</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00071">BasicTypes.h:71</a></div></div>
<div class="ttc" id="namespaceSVF_html_a09f5fa3bc44bf53612a085e3a611cc4e"><div class="ttname"><a href="namespaceSVF.html#a09f5fa3bc44bf53612a085e3a611cc4e">SVF::GlobalVariable</a></div><div class="ttdeci">llvm::GlobalVariable GlobalVariable</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00076">BasicTypes.h:76</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a28c0ede7e4765d2a686fc8ae0f5641a4"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a28c0ede7e4765d2a686fc8ae0f5641a4">SVF::SVFUtil::getSourceLoc</a></div><div class="ttdeci">std::string getSourceLoc(const Value *val)</div><div class="ttdoc">Return source code including line number and file name from debug information. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00267">SVFUtil.cpp:267</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a86c1c8bdfc1075c07c631525555194d2"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a86c1c8bdfc1075c07c631525555194d2">SVF::SVFUtil::getSourceLocOfFunction</a></div><div class="ttdeci">std::string getSourceLocOfFunction(const Function *F)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00248">SVFUtil.cpp:248</a></div></div>
<div class="ttc" id="namespaceSVF_html_a5faee14fa1dd41447bc73ac365fe33c1"><div class="ttname"><a href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">SVF::Function</a></div><div class="ttdeci">llvm::Function Function</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00070">BasicTypes.h:70</a></div></div>
<div class="ttc" id="namespaceSVF_html_a7875172ff434b2210eea7cecfbbd959e"><div class="ttname"><a href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">SVF::Instruction</a></div><div class="ttdeci">llvm::Instruction Instruction</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00073">BasicTypes.h:73</a></div></div>
<div class="ttc" id="namespaceSVF_html_a726981481ac082dcda3e4921416b65a0"><div class="ttname"><a href="namespaceSVF.html#a726981481ac082dcda3e4921416b65a0">SVF::raw_string_ostream</a></div><div class="ttdeci">llvm::raw_string_ostream raw_string_ostream</div><div class="ttdoc">LLVM outputs. </div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00083">BasicTypes.h:83</a></div></div>
<div class="ttc" id="namespaceSVF_html_a58cdfbc4160cae08745b67844ac29801"><div class="ttname"><a href="namespaceSVF.html#a58cdfbc4160cae08745b67844ac29801">SVF::Argument</a></div><div class="ttdeci">llvm::Argument Argument</div><div class="ttdoc">LLVM Aliases and constants. </div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00093">BasicTypes.h:93</a></div></div>
<div class="ttc" id="namespaceSVF_html_ad3d3cec1813411f039211c86236f7adb"><div class="ttname"><a href="namespaceSVF.html#ad3d3cec1813411f039211c86236f7adb">SVF::MDNode</a></div><div class="ttdeci">llvm::MDNode MDNode</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00100">BasicTypes.h:100</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a9e85d445e8b7b205134acd3874bba388"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a9e85d445e8b7b205134acd3874bba388">SVF::SVFUtil::isConstantData</a></div><div class="ttdeci">bool isConstantData(const Value *val)</div><div class="ttdoc">Return true if the value refers to constant data, e.g., i32 0. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00451">SVFUtil.h:451</a></div></div>
<div class="ttc" id="namespaceSVF_html_a98310cccad527f8151328f2c87b29563"><div class="ttname"><a href="namespaceSVF.html#a98310cccad527f8151328f2c87b29563">SVF::DbgInfoIntrinsic</a></div><div class="ttdeci">llvm::DbgInfoIntrinsic DbgInfoIntrinsic</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00100">BasicTypes.h:100</a></div></div>
<div class="ttc" id="namespaceSVF_html_a3011dbac9102f044ad5f36a4ad3d4a71"><div class="ttname"><a href="namespaceSVF.html#a3011dbac9102f044ad5f36a4ad3d4a71">SVF::NamedMDNode</a></div><div class="ttdeci">llvm::NamedMDNode NamedMDNode</div><div class="ttdoc">LLVM metadata. </div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00099">BasicTypes.h:99</a></div></div>
<div class="ttc" id="namespaceSVF_html_a52a9bff350f21692eae3b519030c314d"><div class="ttname"><a href="namespaceSVF.html#a52a9bff350f21692eae3b519030c314d">SVF::DbgDeclareInst</a></div><div class="ttdeci">llvm::DbgDeclareInst DbgDeclareInst</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00102">BasicTypes.h:102</a></div></div>
<div class="ttc" id="cJSON_8h_html_ad4c68ea99a26b0a98ad9a79982960458"><div class="ttname"><a href="cJSON_8h.html#ad4c68ea99a26b0a98ad9a79982960458">string</a></div><div class="ttdeci">const char *const string</div><div class="ttdef"><b>Definition:</b> <a href="cJSON_8h_source.html#l00172">cJSON.h:172</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a86c1c8bdfc1075c07c631525555194d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c1c8bdfc1075c07c631525555194d2">&#9670;&nbsp;</a></span>getSourceLocOfFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::getSourceLocOfFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get source code line number of a function according to debug info </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00248">248</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;{</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    <a class="code" href="cJSON_8h.html#ad4c68ea99a26b0a98ad9a79982960458">std::string</a> str;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    <a class="code" href="namespaceSVF.html#a726981481ac082dcda3e4921416b65a0">raw_string_ostream</a> rawstr(str);</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    <span class="comment">/*</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="comment">     * https://reviews.llvm.org/D18074?id=50385</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="comment">     * looks like the relevant</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF.html#a89c7208bfc0b57873dfa574f52050295">llvm::DISubprogram</a> *SP =  <a class="code" href="CFLGrammar_8txt.html#a00967427d1c110ffcc82ea2a966f4564">F</a>-&gt;getSubprogram())</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    {</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        <span class="keywordflow">if</span> (SP-&gt;describes(<a class="code" href="CFLGrammar_8txt.html#a00967427d1c110ffcc82ea2a966f4564">F</a>))</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            rawstr &lt;&lt; <span class="stringliteral">&quot;in line: &quot;</span> &lt;&lt; SP-&gt;getLine() &lt;&lt; <span class="stringliteral">&quot; file: &quot;</span> &lt;&lt; SP-&gt;getFilename();</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    }</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    <span class="keywordflow">return</span> rawstr.str();</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a726981481ac082dcda3e4921416b65a0"><div class="ttname"><a href="namespaceSVF.html#a726981481ac082dcda3e4921416b65a0">SVF::raw_string_ostream</a></div><div class="ttdeci">llvm::raw_string_ostream raw_string_ostream</div><div class="ttdoc">LLVM outputs. </div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00083">BasicTypes.h:83</a></div></div>
<div class="ttc" id="namespaceSVF_html_a89c7208bfc0b57873dfa574f52050295"><div class="ttname"><a href="namespaceSVF.html#a89c7208bfc0b57873dfa574f52050295">SVF::DISubprogram</a></div><div class="ttdeci">llvm::DISubprogram DISubprogram</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00124">BasicTypes.h:124</a></div></div>
<div class="ttc" id="CFLGrammar_8txt_html_a00967427d1c110ffcc82ea2a966f4564"><div class="ttname"><a href="CFLGrammar_8txt.html#a00967427d1c110ffcc82ea2a966f4564">F</a></div><div class="ttdeci">V Fbar V F</div><div class="ttdef"><b>Definition:</b> <a href="CFLGrammar_8txt_source.html#l00016">CFLGrammar.txt:16</a></div></div>
<div class="ttc" id="cJSON_8h_html_ad4c68ea99a26b0a98ad9a79982960458"><div class="ttname"><a href="cJSON_8h.html#ad4c68ea99a26b0a98ad9a79982960458">string</a></div><div class="ttdeci">const char *const string</div><div class="ttdef"><b>Definition:</b> <a href="cJSON_8h_source.html#l00172">cJSON.h:172</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad3471260b66bdd7e6b790ad2a94fe7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3471260b66bdd7e6b790ad2a94fe7ce">&#9670;&nbsp;</a></span>getTaskDataAtHareParForSite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getTaskDataAtHareParForSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the task data argument of the parallel_for rountine. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00701">701</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;{</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getTaskDataAtHareParForSite(cs);</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5f3dd36ee492b60039928a86519518a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3dd36ee492b60039928a86519518a5">&#9670;&nbsp;</a></span>getTaskDataAtHareParForSite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getTaskDataAtHareParForSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00705">705</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;{</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getTaskDataAtHareParForSite(inst);</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab048cbce6e4f5a3d6ff90da3565220ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab048cbce6e4f5a3d6ff90da3565220ff">&#9670;&nbsp;</a></span>getTaskFuncAtHareParForSite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getTaskFuncAtHareParForSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the task function of the parallel_for routine. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00689">689</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;{</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getTaskFuncAtHareParForSite(cs);</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a111fa1ecf72adbd2e0ff27e922f0d34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111fa1ecf72adbd2e0ff27e922f0d34a">&#9670;&nbsp;</a></span>getTaskFuncAtHareParForSite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getTaskFuncAtHareParForSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00693">693</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;{</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getTaskFuncAtHareParForSite(inst);</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a14a4c5124f2fd03ca3d898e2acd54160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a4c5124f2fd03ca3d898e2acd54160">&#9670;&nbsp;</a></span>hclustMethodToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::hclustMethodToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of a hclust method. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00367">367</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;{</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    <span class="keywordflow">switch</span> (method)</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    {</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddad16cc6362447cc32292c4af4c6fe8024">HCLUST_METHOD_SINGLE</a>:</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;single&quot;</span>;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda44ce22fdfc560f27242e9b8f8e7009f4">HCLUST_METHOD_COMPLETE</a>:</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;complete&quot;</span>;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda3ab72664fc61704a1ba46bddbc347115">HCLUST_METHOD_AVERAGE</a>:</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;average&quot;</span>;</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddaa453b79910d9c6f7f57a179bcdf63474">HCLUST_METHOD_MEDIAN</a>:</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;median&quot;</span>;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618">HCLUST_METHOD_SVF_BEST</a>:</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;svf-best&quot;</span>;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    <span class="keywordflow">default</span>:</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;        assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;SVFUtil::hclustMethodToString: unknown method&quot;</span>);</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        abort();</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    }</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;}</div><div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dda44ce22fdfc560f27242e9b8f8e7009f4"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda44ce22fdfc560f27242e9b8f8e7009f4">HCLUST_METHOD_COMPLETE</a></div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00070">fastcluster.h:70</a></div></div>
<div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913ddaa453b79910d9c6f7f57a179bcdf63474"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddaa453b79910d9c6f7f57a179bcdf63474">HCLUST_METHOD_MEDIAN</a></div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00074">fastcluster.h:74</a></div></div>
<div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618">HCLUST_METHOD_SVF_BEST</a></div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00076">fastcluster.h:76</a></div></div>
<div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913ddad16cc6362447cc32292c4af4c6fe8024"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddad16cc6362447cc32292c4af4c6fe8024">HCLUST_METHOD_SINGLE</a></div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00068">fastcluster.h:68</a></div></div>
<div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dda3ab72664fc61704a1ba46bddbc347115"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda3ab72664fc61704a1ba46bddbc347115">HCLUST_METHOD_AVERAGE</a></div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00072">fastcluster.h:72</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d7588578735679773493ff2d5e458e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7588578735679773493ff2d5e458e1">&#9670;&nbsp;</a></span>increaseStackSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::increaseStackSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the stack size limit. </p>
<p>Increase stack size </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00227">227</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;{</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    <span class="keyword">const</span> rlim_t kStackSize = 256L * 1024L * 1024L;   <span class="comment">// min stack size = 256 Mb</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="keyword">struct </span>rlimit rl;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <span class="keywordtype">int</span> result = getrlimit(RLIMIT_STACK, &amp;rl);</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <span class="keywordflow">if</span> (result == 0)</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    {</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="keywordflow">if</span> (rl.rlim_cur &lt; kStackSize)</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        {</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            rl.rlim_cur = kStackSize;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;            result = setrlimit(RLIMIT_STACK, &amp;rl);</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;            <span class="keywordflow">if</span> (result != 0)</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                <a class="code" href="namespaceSVF_1_1SVFUtil.html#a077caa1b10ab84d101d79fc7ea50db2d">writeWrnMsg</a>(<span class="stringliteral">&quot;setrlimit returned result !=0 \n&quot;</span>);</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        }</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    }</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a077caa1b10ab84d101d79fc7ea50db2d"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a077caa1b10ab84d101d79fc7ea50db2d">SVF::SVFUtil::writeWrnMsg</a></div><div class="ttdeci">void writeWrnMsg(std::string msg)</div><div class="ttdoc">Writes a message run through wrnMsg. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00067">SVFUtil.cpp:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeecfaf26800dcebf0b079395126bc7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecfaf26800dcebf0b079395126bc7f7">&#9670;&nbsp;</a></span>insertKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename KeySet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::insertKey </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet &amp;&#160;</td>
          <td class="paramname"><em>keySet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element into a Set/CondSet (with ::insert). </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00319">319</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;{</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    keySet.insert(key);</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a4f75b8313eb2b1e5a4c798a01cb99471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f75b8313eb2b1e5a4c798a01cb99471">&#9670;&nbsp;</a></span>insertKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::insertKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>keySet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a NodeID into a NodeBS. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00325">325</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;{</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    keySet.set(key);</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5c8cbc986cccb9d84f87aae162df3737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8cbc986cccb9d84f87aae162df3737">&#9670;&nbsp;</a></span>isa()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD bool SVF::SVFUtil::isa </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00184">184</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;{</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="keywordflow">return</span> isa_impl_wrap&lt;X, <span class="keyword">const</span> Y,</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;           <span class="keyword">typename</span> simplify_type&lt;const Y&gt;::SimpleType&gt;::doit(Val);</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab302ca3fcbde9bd1a7d9d5d837a69c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab302ca3fcbde9bd1a7d9d5d837a69c23">&#9670;&nbsp;</a></span>isAnAllocationWraper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isAnAllocationWraper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function servers a allocation wrapper detector. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00474">474</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;{</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ad09ba410acbbaee2aac9dd406c3cf01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09ba410acbbaee2aac9dd406c3cf01a">&#9670;&nbsp;</a></span>isBarrierWaitCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isBarrierWaitCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this is a barrier wait call. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00665">665</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;{</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDBarWait(cs);</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a0a7fc57e1f5cec705e310a4bb72cba94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7fc57e1f5cec705e310a4bb72cba94">&#9670;&nbsp;</a></span>isBarrierWaitCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isBarrierWaitCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00669">669</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;{</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDBarWait(inst);</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a2e08ce822223842fa6a73fd659b1a526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e08ce822223842fa6a73fd659b1a526">&#9670;&nbsp;</a></span>isCallSite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isCallSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether an instruction is a call or invoke instruction. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00196">196</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;{</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="keywordflow">return</span> SVFUtil::isa&lt;CallBase&gt;(inst);</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a38bf8f7eaa18fc5a09711959b5417854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38bf8f7eaa18fc5a09711959b5417854">&#9670;&nbsp;</a></span>isCallSite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isCallSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether an instruction is a call or invoke instruction. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00201">201</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;{</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a>* inst = SVFUtil::dyn_cast&lt;Instruction&gt;(val))</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">SVFUtil::isCallSite</a>(inst);</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a7875172ff434b2210eea7cecfbbd959e"><div class="ttname"><a href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">SVF::Instruction</a></div><div class="ttdeci">llvm::Instruction Instruction</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00073">BasicTypes.h:73</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a38bf8f7eaa18fc5a09711959b5417854"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">SVF::SVFUtil::isCallSite</a></div><div class="ttdeci">bool isCallSite(const Value *val)</div><div class="ttdoc">Whether an instruction is a call or invoke instruction. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00201">SVFUtil.h:201</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9e85d445e8b7b205134acd3874bba388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e85d445e8b7b205134acd3874bba388">&#9670;&nbsp;</a></span>isConstantData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isConstantData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the value refers to constant data, e.g., i32 0. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00451">451</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;{</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    <span class="keywordflow">return</span> SVFUtil::isa&lt;ConstantData&gt;(val)</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;           || SVFUtil::isa&lt;ConstantAggregate&gt;(val)</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;           || SVFUtil::isa&lt;MetadataAsValue&gt;(val)</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;           || SVFUtil::isa&lt;BlockAddress&gt;(val);</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a1f52a7f183f1eec7c4db7e4e54fa5e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f52a7f183f1eec7c4db7e4e54fa5e2c">&#9670;&nbsp;</a></span>isDeallocExtCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isDeallocExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00554">554</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;{</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a3495236e22e4bc6404b6ac352060439c">isDeallocExtFun</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs));</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a3495236e22e4bc6404b6ac352060439c"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a3495236e22e4bc6404b6ac352060439c">SVF::SVFUtil::isDeallocExtFun</a></div><div class="ttdeci">bool isDeallocExtFun(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a heap dealloc or not. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00395">SVFUtil.h:395</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9973c1326717326b26ec1ea21ebd8da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9973c1326717326b26ec1ea21ebd8da5">&#9670;&nbsp;</a></span>isDeallocExtCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isDeallocExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00559">559</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;{</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a3495236e22e4bc6404b6ac352060439c">isDeallocExtFun</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(inst));</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a3495236e22e4bc6404b6ac352060439c"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a3495236e22e4bc6404b6ac352060439c">SVF::SVFUtil::isDeallocExtFun</a></div><div class="ttdeci">bool isDeallocExtFun(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a heap dealloc or not. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00395">SVFUtil.h:395</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3495236e22e4bc6404b6ac352060439c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3495236e22e4bc6404b6ac352060439c">&#9670;&nbsp;</a></span>isDeallocExtFun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isDeallocExtFun </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the call is a heap dealloc or not. </p>
<p>note that this function is not suppose to be used externally </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00395">395</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;{</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; (ExtAPI::getExtAPI()-&gt;is_dealloc(fun));</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a22ef185e767ff76c098e75126c885400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ef185e767ff76c098e75126c885400">&#9670;&nbsp;</a></span>isExtCall() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the call is an external call (external library in function summary table) If the libary function is redefined in the application code (e.g., memcpy), it will return false and will not be treated as an external call. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00358">358</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;{</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; ExtAPI::getExtAPI()-&gt;is_ext(fun);</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aad27a96075234ad2182a84e0e9d31a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad27a96075234ad2182a84e0e9d31a45">&#9670;&nbsp;</a></span>isExtCall() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00486">486</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;{</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#af3e5fd7ffce966575ebf7c7e653b0919">isExtCall</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs));</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af3e5fd7ffce966575ebf7c7e653b0919"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af3e5fd7ffce966575ebf7c7e653b0919">SVF::SVFUtil::isExtCall</a></div><div class="ttdeci">bool isExtCall(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00491">SVFUtil.h:491</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af3e5fd7ffce966575ebf7c7e653b0919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e5fd7ffce966575ebf7c7e653b0919">&#9670;&nbsp;</a></span>isExtCall() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00491">491</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;{</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#af3e5fd7ffce966575ebf7c7e653b0919">isExtCall</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(inst));</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af3e5fd7ffce966575ebf7c7e653b0919"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af3e5fd7ffce966575ebf7c7e653b0919">SVF::SVFUtil::isExtCall</a></div><div class="ttdeci">bool isExtCall(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00491">SVFUtil.h:491</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a28fbb7cc51eb7e25d88f43e3eb1f30fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28fbb7cc51eb7e25d88f43e3eb1f30fb">&#9670;&nbsp;</a></span>isHareParForCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHareParForCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a hare_parallel_for call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00605">605</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;{</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isHareParFor(cs);</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a9b37c6fe1232ebc35ffa052bd392e2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b37c6fe1232ebc35ffa052bd392e2e8">&#9670;&nbsp;</a></span>isHareParForCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHareParForCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00609">609</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;{</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isHareParFor(inst);</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a93ac673b885633849fa484938405ca75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ac673b885633849fa484938405ca75">&#9670;&nbsp;</a></span>isHeapAllocExtCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00519">519</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;{</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a24514d87685f2258201f0de15d220bbc">isHeapAllocExtCallViaRet</a>(cs) || <a class="code" href="namespaceSVF_1_1SVFUtil.html#a0bde3acf22383eac5bbf4e2c065a2226">isHeapAllocExtCallViaArg</a>(cs);</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a24514d87685f2258201f0de15d220bbc"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a24514d87685f2258201f0de15d220bbc">SVF::SVFUtil::isHeapAllocExtCallViaRet</a></div><div class="ttdeci">bool isHeapAllocExtCallViaRet(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00513">SVFUtil.h:513</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a0bde3acf22383eac5bbf4e2c065a2226"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a0bde3acf22383eac5bbf4e2c065a2226">SVF::SVFUtil::isHeapAllocExtCallViaArg</a></div><div class="ttdeci">bool isHeapAllocExtCallViaArg(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00501">SVFUtil.h:501</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1ebbf43e294c3f94a2a7d5c56759bbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebbf43e294c3f94a2a7d5c56759bbba">&#9670;&nbsp;</a></span>isHeapAllocExtCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00524">524</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;{</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a24514d87685f2258201f0de15d220bbc">isHeapAllocExtCallViaRet</a>(inst) || <a class="code" href="namespaceSVF_1_1SVFUtil.html#a0bde3acf22383eac5bbf4e2c065a2226">isHeapAllocExtCallViaArg</a>(inst);</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a24514d87685f2258201f0de15d220bbc"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a24514d87685f2258201f0de15d220bbc">SVF::SVFUtil::isHeapAllocExtCallViaRet</a></div><div class="ttdeci">bool isHeapAllocExtCallViaRet(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00513">SVFUtil.h:513</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a0bde3acf22383eac5bbf4e2c065a2226"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a0bde3acf22383eac5bbf4e2c065a2226">SVF::SVFUtil::isHeapAllocExtCallViaArg</a></div><div class="ttdeci">bool isHeapAllocExtCallViaArg(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00501">SVFUtil.h:501</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aedfa6e9216c6c788c26aef1967689b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfa6e9216c6c788c26aef1967689b76">&#9670;&nbsp;</a></span>isHeapAllocExtCallViaArg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtCallViaArg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00496">496</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;{</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#ab4a69173f50ebe48e69103befe516245">isHeapAllocExtFunViaArg</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs));</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ab4a69173f50ebe48e69103befe516245"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ab4a69173f50ebe48e69103befe516245">SVF::SVFUtil::isHeapAllocExtFunViaArg</a></div><div class="ttdeci">bool isHeapAllocExtFunViaArg(const SVFFunction *fun)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00372">SVFUtil.h:372</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0bde3acf22383eac5bbf4e2c065a2226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bde3acf22383eac5bbf4e2c065a2226">&#9670;&nbsp;</a></span>isHeapAllocExtCallViaArg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtCallViaArg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00501">501</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;{</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#ab4a69173f50ebe48e69103befe516245">isHeapAllocExtFunViaArg</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(inst));</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ab4a69173f50ebe48e69103befe516245"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ab4a69173f50ebe48e69103befe516245">SVF::SVFUtil::isHeapAllocExtFunViaArg</a></div><div class="ttdeci">bool isHeapAllocExtFunViaArg(const SVFFunction *fun)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00372">SVFUtil.h:372</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab2064cb70c76f399ce115f2621adea35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2064cb70c76f399ce115f2621adea35">&#9670;&nbsp;</a></span>isHeapAllocExtCallViaRet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtCallViaRet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>interfaces to be used externally </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00507">507</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;{</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    <span class="keywordtype">bool</span> isPtrTy = cs.getInstruction()-&gt;getType()-&gt;isPointerTy();</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    <span class="keywordflow">return</span> isPtrTy &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">isHeapAllocExtFunViaRet</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs));</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a19b96a872d9096037f20e25122e469ea"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">SVF::SVFUtil::isHeapAllocExtFunViaRet</a></div><div class="ttdeci">bool isHeapAllocExtFunViaRet(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a heap allocator/reallocator. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00366">SVFUtil.h:366</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a24514d87685f2258201f0de15d220bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24514d87685f2258201f0de15d220bbc">&#9670;&nbsp;</a></span>isHeapAllocExtCallViaRet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtCallViaRet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00513">513</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;{</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    <span class="keywordtype">bool</span> isPtrTy = inst-&gt;getType()-&gt;isPointerTy();</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;    <span class="keywordflow">return</span> isPtrTy &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">isHeapAllocExtFunViaRet</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(inst));</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a19b96a872d9096037f20e25122e469ea"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">SVF::SVFUtil::isHeapAllocExtFunViaRet</a></div><div class="ttdeci">bool isHeapAllocExtFunViaRet(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a heap allocator/reallocator. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00366">SVFUtil.h:366</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab4a69173f50ebe48e69103befe516245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a69173f50ebe48e69103befe516245">&#9670;&nbsp;</a></span>isHeapAllocExtFunViaArg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtFunViaArg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00372">372</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;{</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; ExtAPI::getExtAPI()-&gt;is_arg_alloc(fun);</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a19b96a872d9096037f20e25122e469ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b96a872d9096037f20e25122e469ea">&#9670;&nbsp;</a></span>isHeapAllocExtFunViaRet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtFunViaRet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the call is a heap allocator/reallocator. </p>
<p>note that these two functions are not suppose to be used externally </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00366">366</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;{</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; (ExtAPI::getExtAPI()-&gt;is_alloc(fun)</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;                   || ExtAPI::getExtAPI()-&gt;is_realloc(fun));</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a61ed4bb80d88b0f8dbc02535c224fdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ed4bb80d88b0f8dbc02535c224fdfb">&#9670;&nbsp;</a></span>isHeapAllocOrStaticExtCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocOrStaticExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the call is a static global call. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00580">580</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;{</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#aab8ac16a9a2961f98001ab94aeaedf64">isStaticExtCall</a>(cs) || <a class="code" href="namespaceSVF_1_1SVFUtil.html#a1ebbf43e294c3f94a2a7d5c56759bbba">isHeapAllocExtCall</a>(cs);</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a1ebbf43e294c3f94a2a7d5c56759bbba"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a1ebbf43e294c3f94a2a7d5c56759bbba">SVF::SVFUtil::isHeapAllocExtCall</a></div><div class="ttdeci">bool isHeapAllocExtCall(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00524">SVFUtil.h:524</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aab8ac16a9a2961f98001ab94aeaedf64"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aab8ac16a9a2961f98001ab94aeaedf64">SVF::SVFUtil::isStaticExtCall</a></div><div class="ttdeci">bool isStaticExtCall(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00571">SVFUtil.h:571</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0c8afe88cb58a2ac484c3bc4dd15ece9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8afe88cb58a2ac484c3bc4dd15ece9">&#9670;&nbsp;</a></span>isHeapAllocOrStaticExtCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocOrStaticExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00585">585</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;{</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#aab8ac16a9a2961f98001ab94aeaedf64">isStaticExtCall</a>(inst) || <a class="code" href="namespaceSVF_1_1SVFUtil.html#a1ebbf43e294c3f94a2a7d5c56759bbba">isHeapAllocExtCall</a>(inst);</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a1ebbf43e294c3f94a2a7d5c56759bbba"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a1ebbf43e294c3f94a2a7d5c56759bbba">SVF::SVFUtil::isHeapAllocExtCall</a></div><div class="ttdeci">bool isHeapAllocExtCall(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00524">SVFUtil.h:524</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aab8ac16a9a2961f98001ab94aeaedf64"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aab8ac16a9a2961f98001ab94aeaedf64">SVF::SVFUtil::isStaticExtCall</a></div><div class="ttdeci">bool isStaticExtCall(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00571">SVFUtil.h:571</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad2c53be5490882768d51aa894b37cbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c53be5490882768d51aa894b37cbf1">&#9670;&nbsp;</a></span>isIntrinsicFun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isIntrinsicFun </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00167">167</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;{</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    <span class="keywordflow">if</span> (func &amp;&amp; (func-&gt;getIntrinsicID() == llvm::Intrinsic::donothing ||</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                 func-&gt;getIntrinsicID() == llvm::Intrinsic::dbg_addr ||</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                 func-&gt;getIntrinsicID() == llvm::Intrinsic::dbg_declare ||</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                 func-&gt;getIntrinsicID() == llvm::Intrinsic::dbg_label ||</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                 func-&gt;getIntrinsicID() == llvm::Intrinsic::dbg_value))</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    {</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    }</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab7f58caf27c30a1d414e06f60ca84d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f58caf27c30a1d414e06f60ca84d80">&#9670;&nbsp;</a></span>isIntrinsicInst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isIntrinsicInst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if it is an intrinsic instruction. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00181">181</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;{</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a1f4624771922dc8c2447ad7433588c73">llvm::CallBase</a>* call = llvm::dyn_cast&lt;llvm::CallBase&gt;(inst))</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    {</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a>* func = call-&gt;getCalledFunction();</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1SVFUtil.html#ad2c53be5490882768d51aa894b37cbf1">isIntrinsicFun</a>(func))</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        {</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        }</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    }</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ad2c53be5490882768d51aa894b37cbf1"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ad2c53be5490882768d51aa894b37cbf1">SVF::SVFUtil::isIntrinsicFun</a></div><div class="ttdeci">bool isIntrinsicFun(const Function *func)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00167">SVFUtil.h:167</a></div></div>
<div class="ttc" id="namespaceSVF_html_a5faee14fa1dd41447bc73ac365fe33c1"><div class="ttname"><a href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">SVF::Function</a></div><div class="ttdeci">llvm::Function Function</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00070">BasicTypes.h:70</a></div></div>
<div class="ttc" id="namespaceSVF_html_a1f4624771922dc8c2447ad7433588c73"><div class="ttname"><a href="namespaceSVF.html#a1f4624771922dc8c2447ad7433588c73">SVF::CallBase</a></div><div class="ttdeci">llvm::CallBase CallBase</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00074">BasicTypes.h:74</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5f3ecd0770991b6e84afe47a3934f0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3ecd0770991b6e84afe47a3934f0d2">&#9670;&nbsp;</a></span>isLockAquireCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isLockAquireCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a lock acquire call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00641">641</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;{</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDAcquire(cs);</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a343dae805a34d102b9c1b96f173468df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343dae805a34d102b9c1b96f173468df">&#9670;&nbsp;</a></span>isLockAquireCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isLockAquireCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00645">645</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;{</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDAcquire(inst);</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a1241ef1c19df14f7db0bd62dd68f14f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1241ef1c19df14f7db0bd62dd68f14f9">&#9670;&nbsp;</a></span>isLockReleaseCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isLockReleaseCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a lock acquire call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00653">653</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;{</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDRelease(cs);</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a84ac49c70252036a957694f2cf05ae2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ac49c70252036a957694f2cf05ae2c">&#9670;&nbsp;</a></span>isLockReleaseCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isLockReleaseCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00657">657</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;{</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDRelease(inst);</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a8d8216a92140d982303f83ea424ddc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8216a92140d982303f83ea424ddc91">&#9670;&nbsp;</a></span>isNonInstricCallSite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isNonInstricCallSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether an instruction is a callsite in the application code, excluding llvm intrinsic calls. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00209">209</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;{</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    <span class="keywordflow">if</span>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#ab7f58caf27c30a1d414e06f60ca84d80">isIntrinsicInst</a>(inst))</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">isCallSite</a>(inst);</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ab7f58caf27c30a1d414e06f60ca84d80"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ab7f58caf27c30a1d414e06f60ca84d80">SVF::SVFUtil::isIntrinsicInst</a></div><div class="ttdeci">bool isIntrinsicInst(const Instruction *inst)</div><div class="ttdoc">Return true if it is an intrinsic instruction. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00181">SVFUtil.h:181</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a38bf8f7eaa18fc5a09711959b5417854"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">SVF::SVFUtil::isCallSite</a></div><div class="ttdeci">bool isCallSite(const Value *val)</div><div class="ttdoc">Whether an instruction is a call or invoke instruction. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00201">SVFUtil.h:201</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2c97c2b79b795465490512e267a9309b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c97c2b79b795465490512e267a9309b">&#9670;&nbsp;</a></span>isProgEntryFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isProgEntryFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Program entry function e.g. main. </p>
<p>Return true if this is a program entry function (e.g. main) </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00411">411</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;{</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; fun-&gt;getName() == <span class="stringliteral">&quot;main&quot;</span>;</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab87fef7b10465d3e635643fcb93b95a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87fef7b10465d3e635643fcb93b95a7">&#9670;&nbsp;</a></span>isProgEntryFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isProgEntryFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00711">711</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;{</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; fun-&gt;getName() == <span class="stringliteral">&quot;main&quot;</span>;</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a6528edf9a1750df4a84d1a60d4d0bbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6528edf9a1750df4a84d1a60d4d0bbe4">&#9670;&nbsp;</a></span>isProgExitCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isProgExitCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00717">717</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;{</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">isProgExitFunction</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs));</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aec7ee60be22e8f9397db108131696d57"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">SVF::SVFUtil::isProgExitFunction</a></div><div class="ttdeci">bool isProgExitFunction(const SVFFunction *fun)</div><div class="ttdoc">Return true if this is a program exit function call. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00443">SVFUtil.h:443</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a68b531ca4077e71dcc6d085e47a9730b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b531ca4077e71dcc6d085e47a9730b">&#9670;&nbsp;</a></span>isProgExitCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isProgExitCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00722">722</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;{</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">isProgExitFunction</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(inst));</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aec7ee60be22e8f9397db108131696d57"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">SVF::SVFUtil::isProgExitFunction</a></div><div class="ttdeci">bool isProgExitFunction(const SVFFunction *fun)</div><div class="ttdoc">Return true if this is a program exit function call. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00443">SVFUtil.h:443</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aec7ee60be22e8f9397db108131696d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7ee60be22e8f9397db108131696d57">&#9670;&nbsp;</a></span>isProgExitFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isProgExitFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this is a program exit function call. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00443">443</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;{</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; (fun-&gt;getName() == <span class="stringliteral">&quot;exit&quot;</span> ||</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;                   fun-&gt;getName() == <span class="stringliteral">&quot;__assert_rtn&quot;</span> ||</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;                   fun-&gt;getName() == <span class="stringliteral">&quot;__assert_fail&quot;</span> );</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a6740e7686ba111ae525c6c093cbbaf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6740e7686ba111ae525c6c093cbbaf46">&#9670;&nbsp;</a></span>isReallocExtCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isReallocExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00541">541</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;{</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    <span class="keywordtype">bool</span> isPtrTy = cs.getInstruction()-&gt;getType()-&gt;isPointerTy();</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;    <span class="keywordflow">return</span> isPtrTy &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">isReallocExtFun</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs));</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a97c74c642ad43d955ac8a3f3ad8907b4"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">SVF::SVFUtil::isReallocExtFun</a></div><div class="ttdeci">bool isReallocExtFun(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a heap reallocator. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00387">SVFUtil.h:387</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a42748153e4845f3eee0ca58a1e151f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42748153e4845f3eee0ca58a1e151f97">&#9670;&nbsp;</a></span>isReallocExtCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isReallocExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00547">547</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;{</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;    <span class="keywordtype">bool</span> isPtrTy = inst-&gt;getType()-&gt;isPointerTy();</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;    <span class="keywordflow">return</span> isPtrTy &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">isReallocExtFun</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(inst));</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a97c74c642ad43d955ac8a3f3ad8907b4"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">SVF::SVFUtil::isReallocExtFun</a></div><div class="ttdeci">bool isReallocExtFun(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a heap reallocator. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00387">SVFUtil.h:387</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a97c74c642ad43d955ac8a3f3ad8907b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c74c642ad43d955ac8a3f3ad8907b4">&#9670;&nbsp;</a></span>isReallocExtFun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isReallocExtFun </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the call is a heap reallocator. </p>
<p>note that this function is not suppose to be used externally </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00387">387</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;{</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; (ExtAPI::getExtAPI()-&gt;is_realloc(fun));</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ae62938f722543d6d7fc201b685be1abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62938f722543d6d7fc201b685be1abf">&#9670;&nbsp;</a></span>isStaticExtCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isStaticExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00565">565</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;{</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;    <span class="keywordtype">bool</span> isPtrTy = cs.getInstruction()-&gt;getType()-&gt;isPointerTy();</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;    <span class="keywordflow">return</span> isPtrTy &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a1bc9bb7bd6c9682debf3ffab7182abf5">isStaticExtFun</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs));</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a1bc9bb7bd6c9682debf3ffab7182abf5"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a1bc9bb7bd6c9682debf3ffab7182abf5">SVF::SVFUtil::isStaticExtFun</a></div><div class="ttdeci">bool isStaticExtFun(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a static global call. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00403">SVFUtil.h:403</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aab8ac16a9a2961f98001ab94aeaedf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8ac16a9a2961f98001ab94aeaedf64">&#9670;&nbsp;</a></span>isStaticExtCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isStaticExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00571">571</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;{</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;    <span class="keywordtype">bool</span> isPtrTy = inst-&gt;getType()-&gt;isPointerTy();</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;    <span class="keywordflow">return</span> isPtrTy &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a1bc9bb7bd6c9682debf3ffab7182abf5">isStaticExtFun</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(inst));</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a1bc9bb7bd6c9682debf3ffab7182abf5"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a1bc9bb7bd6c9682debf3ffab7182abf5">SVF::SVFUtil::isStaticExtFun</a></div><div class="ttdeci">bool isStaticExtFun(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a static global call. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00403">SVFUtil.h:403</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1bc9bb7bd6c9682debf3ffab7182abf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc9bb7bd6c9682debf3ffab7182abf5">&#9670;&nbsp;</a></span>isStaticExtFun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isStaticExtFun </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the call is a static global call. </p>
<p>note that this function is not suppose to be used externally </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00403">403</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;{</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; ExtAPI::getExtAPI()-&gt;has_static(fun);</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a3af5073a1cdc000678f7e4bbc943f5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af5073a1cdc000678f7e4bbc943f5d5">&#9670;&nbsp;</a></span>isThreadExitCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isThreadExitCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a thread exit call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00629">629</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;{</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDExit(cs);</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aae025d6727ef34fbeaa7ad48a4dabdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae025d6727ef34fbeaa7ad48a4dabdcd">&#9670;&nbsp;</a></span>isThreadExitCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isThreadExitCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00633">633</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;{</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDExit(inst);</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5c2abeb363081381c3dc939ab511e3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2abeb363081381c3dc939ab511e3f0">&#9670;&nbsp;</a></span>isThreadForkCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isThreadForkCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a thread creation call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00593">593</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;{</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDFork(cs);</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a834afc0042c24ed5a1dd00cadc1f00c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834afc0042c24ed5a1dd00cadc1f00c3">&#9670;&nbsp;</a></span>isThreadForkCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isThreadForkCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00597">597</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;{</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDFork(inst);</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a194a8cf292726bd6cd54307b555c068a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194a8cf292726bd6cd54307b555c068a">&#9670;&nbsp;</a></span>isThreadJoinCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isThreadJoinCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a thread join call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00617">617</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;{</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDJoin(cs);</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a14793b41b05439a8a82fdce02e0587d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14793b41b05439a8a82fdce02e0587d5">&#9670;&nbsp;</a></span>isThreadJoinCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isThreadJoinCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00621">621</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;{</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDJoin(inst);</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a36c91f952a69875c33d4bd0b05a27ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c91f952a69875c33d4bd0b05a27ff2">&#9670;&nbsp;</a></span>mergePtsOccMaps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::mergePtsOccMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; Data, unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; Data, unsigned &gt;&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a map mapping points-to sets to a count, adds from into to. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00306">306</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;{</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">typename</span> Map&lt;Data, unsigned&gt;::value_type &amp;ptocc : from)</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    {</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        to[ptocc.first] += ptocc.second;</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    }</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a72502f7f536418621485e90ab98c2016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72502f7f536418621485e90ab98c2016">&#9670;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::remove_reference&lt;T&gt;::<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">type</a>&amp;&amp; SVF::SVFUtil::move </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00729">729</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;{</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a72502f7f536418621485e90ab98c2016">std::move</a>(t);</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a72502f7f536418621485e90ab98c2016"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a72502f7f536418621485e90ab98c2016">SVF::SVFUtil::move</a></div><div class="ttdeci">constexpr std::remove_reference&lt; T &gt;::type &amp;&amp; move(T &amp;&amp;t) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00729">SVFUtil.h:729</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aed0b0b9f035057552a6a82154fd88e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0b0b9f035057552a6a82154fd88e61">&#9670;&nbsp;</a></span>outs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; SVF::SVFUtil::outs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrite <a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61" title="Overwrite llvm::outs() ">llvm::outs()</a> </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00049">49</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;{</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="keywordflow">return</span> std::cout;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a609eea630a8f88fe9eaba15ce7e48738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609eea630a8f88fe9eaba15ce7e48738">&#9670;&nbsp;</a></span>pasMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::pasMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print each pass/phase message by converting a string into blue string output. </p>
<p>print each pass/phase message by converting a string into blue string output </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00099">99</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;{</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#a3f838f2fc3a9a3b434be606fc908964b">KBLU</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;}</div><div class="ttc" id="SVFUtil_8cpp_html_a3f838f2fc3a9a3b434be606fc908964b"><div class="ttname"><a href="SVFUtil_8cpp.html#a3f838f2fc3a9a3b434be606fc908964b">KBLU</a></div><div class="ttdeci">#define KBLU</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00044">SVFUtil.cpp:44</a></div></div>
<div class="ttc" id="SVFUtil_8cpp_html_a137aa83ec74421d226a90c92ec032ac9"><div class="ttname"><a href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a></div><div class="ttdeci">#define KNRM</div><div class="ttdoc">Color for output format. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00040">SVFUtil.cpp:40</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a86ebab122895189be57637b84adc7642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ebab122895189be57637b84adc7642">&#9670;&nbsp;</a></span>ptsToNodeBS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> SVF::SVFUtil::ptsToNodeBS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;&#160;</td>
          <td class="paramname"><em>pts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00157">157</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;{</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <a class="code" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> nbs;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> o : pts) nbs.<a class="code" href="classSVF_1_1SparseBitVector.html#a61bd86909a141f9de873d92c0f904832">set</a>(o);</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    <span class="keywordflow">return</span> nbs;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a43a65e0d33af3c743294f7a1139d2301"><div class="ttname"><a href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">SVF::NodeID</a></div><div class="ttdeci">unsigned NodeID</div><div class="ttdef"><b>Definition:</b> <a href="MTAResultValidator_8h_source.html#l00019">MTAResultValidator.h:19</a></div></div>
<div class="ttc" id="namespaceSVF_html_aa7b6a13e52671de8524b130738aeb564"><div class="ttname"><a href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">SVF::NodeBS</a></div><div class="ttdeci">SparseBitVector NodeBS</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00096">SVFBasicTypes.h:96</a></div></div>
<div class="ttc" id="classSVF_1_1SparseBitVector_html_a61bd86909a141f9de873d92c0f904832"><div class="ttname"><a href="classSVF_1_1SparseBitVector.html#a61bd86909a141f9de873d92c0f904832">SVF::SparseBitVector::set</a></div><div class="ttdeci">void set(unsigned Idx)</div><div class="ttdef"><b>Definition:</b> <a href="SparseBitVector_8h_source.html#l00745">SparseBitVector.h:745</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aee74719d33695e4da6fee5fc83f745d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee74719d33695e4da6fee5fc83f745d9">&#9670;&nbsp;</a></span>removeKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename KeySet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::removeKey </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet &amp;&#160;</td>
          <td class="paramname"><em>keySet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an element from a Set/CondSet (or anything implementing ::erase). </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00332">332</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;{</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    keySet.erase(key);</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aa59af7fc01a534662b3b1524186ef97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59af7fc01a534662b3b1524186ef97e">&#9670;&nbsp;</a></span>removeKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::removeKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>keySet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a NodeID from a NodeBS. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00338">338</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;{</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    keySet.reset(key);</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a6cfe12afa463d0ceddeee11540c33ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfe12afa463d0ceddeee11540c33ab3">&#9670;&nbsp;</a></span>reportMemoryUsageKB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::reportMemoryUsageKB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>infor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;&#160;</td>
          <td class="paramname"><em>O</em> = <code><a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print memory usage in KB. </p>
<p>Print memory usage </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00167">167</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;{</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    <a class="code" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> vmrss, vmsize;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">getMemoryUsageKB</a>(&amp;vmrss, &amp;vmsize))</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        O &lt;&lt; infor &lt;&lt; <span class="stringliteral">&quot;\tVmRSS: &quot;</span> &lt;&lt; vmrss &lt;&lt; <span class="stringliteral">&quot;\tVmSize: &quot;</span> &lt;&lt; vmsize &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_ad42bff8d0a7d60a085aa32d10f4955af"><div class="ttname"><a href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">SVF::u32_t</a></div><div class="ttdeci">unsigned u32_t</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00085">SVFBasicTypes.h:85</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a630ff9c47f58f9b8df7c8a2b3711477c"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">SVF::SVFUtil::getMemoryUsageKB</a></div><div class="ttdeci">bool getMemoryUsageKB(u32_t *vmrss_kb, u32_t *vmsize_kb)</div><div class="ttdoc">Get memory usage from system file. Return TRUE if succeed. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00177">SVFUtil.cpp:177</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af54e70082388bbd70868250aaa0bc86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54e70082388bbd70868250aaa0bc86b">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&gt; SVF::SVFUtil::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>seperator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split into two substrings around the first occurrence of a separator string. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00243">243</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;{</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    std::vector&lt;std::string&gt; output;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    std::string::size_type prev_pos = 0, pos = 0;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    <span class="keywordflow">while</span>((pos = s.find(seperator, pos)) != std::string::npos)</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    {</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        <a class="code" href="cJSON_8h.html#ad4c68ea99a26b0a98ad9a79982960458">std::string</a> substring( s.substr(prev_pos, pos-prev_pos) );</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        output.push_back(substring);</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        prev_pos = ++pos;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    }</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    output.push_back(s.substr(prev_pos, pos-prev_pos));</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    <span class="keywordflow">return</span> output;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;}</div><div class="ttc" id="cJSON_8h_html_ad4c68ea99a26b0a98ad9a79982960458"><div class="ttname"><a href="cJSON_8h.html#ad4c68ea99a26b0a98ad9a79982960458">string</a></div><div class="ttdeci">const char *const string</div><div class="ttdef"><b>Definition:</b> <a href="cJSON_8h_source.html#l00172">cJSON.h:172</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a757815a2c758695176120509ceb0ce70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757815a2c758695176120509ceb0ce70">&#9670;&nbsp;</a></span>startAnalysisLimitTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::startAnalysisLimitTimer </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeLimit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts an analysis timer. If timeLimit is 0, sets no timer. If an alarm has already been set, does not set another. Returns whether we set a timer or not. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00430">430</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;{</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    <span class="keywordflow">if</span> (timeLimit == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    <span class="comment">// If an alarm is already set, don&#39;t set another. That means this analysis</span></div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    <span class="comment">// is part of another which has a time limit.</span></div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    <span class="keywordtype">unsigned</span> remainingSeconds = alarm(0);</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    <span class="keywordflow">if</span> (remainingSeconds != 0)</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    {</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        <span class="comment">// Continue the previous alarm and move on.</span></div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        alarm(remainingSeconds);</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    }</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    signal(SIGALRM, &amp;<a class="code" href="namespaceSVF_1_1SVFUtil.html#add4cd21115988f9f5eec12e268ddf1d9">timeLimitReached</a>);</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    alarm(timeLimit);</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_add4cd21115988f9f5eec12e268ddf1d9"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#add4cd21115988f9f5eec12e268ddf1d9">SVF::SVFUtil::timeLimitReached</a></div><div class="ttdeci">void timeLimitReached(int signum)</div><div class="ttdoc">Function to call when alarm for time limit hits. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00421">SVFUtil.cpp:421</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a168f7f7a3a8c70dbf2b5b4269cd4c7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168f7f7a3a8c70dbf2b5b4269cd4c7c5">&#9670;&nbsp;</a></span>stopAnalysisLimitTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::stopAnalysisLimitTimer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>limitTimerSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops an analysis timer. limitTimerSet indicates whether the caller set the timer or not (return value of startLimitTimer). </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00451">451</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;{</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    <span class="keywordflow">if</span> (limitTimerSet) alarm(0);</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a6a55f1f8598998a3ffbbc67d32eaf8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a55f1f8598998a3ffbbc67d32eaf8c4">&#9670;&nbsp;</a></span>sucMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::sucMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns successful message by converting a string into green string output. </p>
<p>print successful message by converting a string into green string output </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00054">54</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;{</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#ac081c83b067273757f7a2e54a5957d41">KGRN</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;}</div><div class="ttc" id="SVFUtil_8cpp_html_ac081c83b067273757f7a2e54a5957d41"><div class="ttname"><a href="SVFUtil_8cpp.html#ac081c83b067273757f7a2e54a5957d41">KGRN</a></div><div class="ttdeci">#define KGRN</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00042">SVFUtil.cpp:42</a></div></div>
<div class="ttc" id="SVFUtil_8cpp_html_a137aa83ec74421d226a90c92ec032ac9"><div class="ttname"><a href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a></div><div class="ttdeci">#define KNRM</div><div class="ttdoc">Color for output format. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00040">SVFUtil.cpp:40</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="add4cd21115988f9f5eec12e268ddf1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4cd21115988f9f5eec12e268ddf1d9">&#9670;&nbsp;</a></span>timeLimitReached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::timeLimitReached </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to call when alarm for time limit hits. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00421">421</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;{</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>().flush();</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    <span class="comment">// TODO: output does not indicate which time limit is reached.</span></div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    <span class="comment">//       This can be better in the future.</span></div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>() &lt;&lt; <span class="stringliteral">&quot;WPA: time limit reached\n&quot;</span>;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    exit(101);</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aed0b0b9f035057552a6a82154fd88e61"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVF::SVFUtil::outs</a></div><div class="ttdeci">std::ostream &amp; outs()</div><div class="ttdoc">Overwrite llvm::outs() </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00049">SVFUtil.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a817a63e8330530cb18e077556f7ce518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817a63e8330530cb18e077556f7ce518">&#9670;&nbsp;</a></span>type2String()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::type2String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a1d008c0666c145622b81d427be64c52d">Type</a> *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00456">456</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;{</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    <a class="code" href="cJSON_8h.html#ad4c68ea99a26b0a98ad9a79982960458">std::string</a> str;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <a class="code" href="namespaceSVF.html#a726981481ac082dcda3e4921416b65a0">llvm::raw_string_ostream</a> rawstr(str);</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    assert(<a class="code" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">type</a> != <span class="keyword">nullptr</span> &amp;&amp; <span class="stringliteral">&quot;Given null type!&quot;</span>);</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    rawstr &lt;&lt; *<a class="code" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">type</a>;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    <span class="keywordflow">return</span> rawstr.str();</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;}</div><div class="ttc" id="cJSON_8cpp_html_a3f9a0d3265a6254722587175dac3e4dc"><div class="ttname"><a href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">type</a></div><div class="ttdeci">newitem type</div><div class="ttdef"><b>Definition:</b> <a href="cJSON_8cpp_source.html#l02739">cJSON.cpp:2739</a></div></div>
<div class="ttc" id="namespaceSVF_html_a726981481ac082dcda3e4921416b65a0"><div class="ttname"><a href="namespaceSVF.html#a726981481ac082dcda3e4921416b65a0">SVF::raw_string_ostream</a></div><div class="ttdeci">llvm::raw_string_ostream raw_string_ostream</div><div class="ttdoc">LLVM outputs. </div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00083">BasicTypes.h:83</a></div></div>
<div class="ttc" id="cJSON_8h_html_ad4c68ea99a26b0a98ad9a79982960458"><div class="ttname"><a href="cJSON_8h.html#ad4c68ea99a26b0a98ad9a79982960458">string</a></div><div class="ttdeci">const char *const string</div><div class="ttdef"><b>Definition:</b> <a href="cJSON_8h_source.html#l00172">cJSON.h:172</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7486fd8e5350879ed1cbd835c0d4e191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7486fd8e5350879ed1cbd835c0d4e191">&#9670;&nbsp;</a></span>value2String()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::value2String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return string of an LLVM Value </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00390">390</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;{</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    <a class="code" href="cJSON_8h.html#ad4c68ea99a26b0a98ad9a79982960458">std::string</a> str;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    <a class="code" href="namespaceSVF.html#a726981481ac082dcda3e4921416b65a0">raw_string_ostream</a> rawstr(str);</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    <span class="keywordflow">if</span>(value)</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    {</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;        <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">SVF::Function</a>* fun = SVFUtil::dyn_cast&lt;Function&gt;(value))</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;            rawstr &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; fun-&gt;getName() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;            rawstr &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *value &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;        rawstr &lt;&lt; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a28c0ede7e4765d2a686fc8ae0f5641a4">getSourceLoc</a>(value);</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    }</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="keywordflow">return</span> rawstr.str();</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a28c0ede7e4765d2a686fc8ae0f5641a4"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a28c0ede7e4765d2a686fc8ae0f5641a4">SVF::SVFUtil::getSourceLoc</a></div><div class="ttdeci">std::string getSourceLoc(const Value *val)</div><div class="ttdoc">Return source code including line number and file name from debug information. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00267">SVFUtil.cpp:267</a></div></div>
<div class="ttc" id="namespaceSVF_html_a5faee14fa1dd41447bc73ac365fe33c1"><div class="ttname"><a href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">SVF::Function</a></div><div class="ttdeci">llvm::Function Function</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00070">BasicTypes.h:70</a></div></div>
<div class="ttc" id="namespaceSVF_html_a726981481ac082dcda3e4921416b65a0"><div class="ttname"><a href="namespaceSVF.html#a726981481ac082dcda3e4921416b65a0">SVF::raw_string_ostream</a></div><div class="ttdeci">llvm::raw_string_ostream raw_string_ostream</div><div class="ttdoc">LLVM outputs. </div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00083">BasicTypes.h:83</a></div></div>
<div class="ttc" id="cJSON_8h_html_ad4c68ea99a26b0a98ad9a79982960458"><div class="ttname"><a href="cJSON_8h.html#ad4c68ea99a26b0a98ad9a79982960458">string</a></div><div class="ttdeci">const char *const string</div><div class="ttdef"><b>Definition:</b> <a href="cJSON_8h_source.html#l00172">cJSON.h:172</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a077caa1b10ab84d101d79fc7ea50db2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077caa1b10ab84d101d79fc7ea50db2d">&#9670;&nbsp;</a></span>writeWrnMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::writeWrnMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a message run through wrnMsg. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00067">67</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;{</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <span class="keywordflow">if</span>(Options::DisableWarn) <span class="keywordflow">return</span>;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a6c06020737f7dff22a666b75c28c5e7d">wrnMsg</a>(msg) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aed0b0b9f035057552a6a82154fd88e61"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVF::SVFUtil::outs</a></div><div class="ttdeci">std::ostream &amp; outs()</div><div class="ttdoc">Overwrite llvm::outs() </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00049">SVFUtil.h:49</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a6c06020737f7dff22a666b75c28c5e7d"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a6c06020737f7dff22a666b75c28c5e7d">SVF::SVFUtil::wrnMsg</a></div><div class="ttdeci">std::string wrnMsg(std::string msg)</div><div class="ttdoc">Returns warning message by converting a string into yellow string output. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00062">SVFUtil.cpp:62</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6c06020737f7dff22a666b75c28c5e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c06020737f7dff22a666b75c28c5e7d">&#9670;&nbsp;</a></span>wrnMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::wrnMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns warning message by converting a string into yellow string output. </p>
<p>print warning message by converting a string into yellow string output </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00062">62</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;{</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#a897b10d246533c95ba86cb79f92e465a">KYEL</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;}</div><div class="ttc" id="SVFUtil_8cpp_html_a897b10d246533c95ba86cb79f92e465a"><div class="ttname"><a href="SVFUtil_8cpp.html#a897b10d246533c95ba86cb79f92e465a">KYEL</a></div><div class="ttdeci">#define KYEL</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00043">SVFUtil.cpp:43</a></div></div>
<div class="ttc" id="SVFUtil_8cpp_html_a137aa83ec74421d226a90c92ec032ac9"><div class="ttname"><a href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a></div><div class="ttdeci">#define KNRM</div><div class="ttdoc">Color for output format. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00040">SVFUtil.cpp:40</a></div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
