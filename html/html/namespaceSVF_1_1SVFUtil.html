<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Static Value-Flow Analysis: SVF::SVFUtil Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Static Value-Flow Analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSVF.html">SVF</a></li><li class="navelem"><a class="el" href="namespaceSVF_1_1SVFUtil.html">SVFUtil</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SVF::SVFUtil Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__convert__val.html">cast_convert_val</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__convert__val_3_01To_00_01FromTy_00_01FromTy_01_4.html">cast_convert_val&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl.html">cast_retty_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01const_01From_01_5_01_4.html">cast_retty_impl&lt; To, const From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01const_01From_01_5const_01_4.html">cast_retty_impl&lt; To, const From *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01const_01From_01_4.html">cast_retty_impl&lt; To, const From &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01From_01_5_01_4.html">cast_retty_impl&lt; To, From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01std_1_1unique__ptr_3_01From_01_4_01_4.html">cast_retty_impl&lt; To, std::unique_ptr&lt; From &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__wrap.html">cast_retty_wrap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__wrap_3_01To_00_01FromTy_00_01FromTy_01_4.html">cast_retty_wrap&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">equalNodeBS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">equalPointsTo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl.html">isa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl_3_01To_00_01From_00_01typename_01std_1_1enable__if_3_01std_1_1101a002941fb8432b76e90258f1ec6b7.html">isa_impl&lt; To, From, typename std::enable_if&lt; std::is_base_of&lt; To, From &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always allow upcasts, and perform no dynamic check for them.  <a href="structSVF_1_1SVFUtil_1_1isa__impl_3_01To_00_01From_00_01typename_01std_1_1enable__if_3_01std_1_1101a002941fb8432b76e90258f1ec6b7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl.html">isa_impl_cl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01const_01From_01_5_01_4.html">isa_impl_cl&lt; To, const From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01const_01From_01_5const_01_4.html">isa_impl_cl&lt; To, const From *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01const_01From_01_4.html">isa_impl_cl&lt; To, const From &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01const_01std_1_1unique__ptr_3_01From_01_4_01_4.html">isa_impl_cl&lt; To, const std::unique_ptr&lt; From &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01From_01_5_01_4.html">isa_impl_cl&lt; To, From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01From_01_5const_01_4.html">isa_impl_cl&lt; To, From *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__wrap.html">isa_impl_wrap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__wrap_3_01To_00_01FromTy_00_01FromTy_01_4.html">isa_impl_wrap&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1simplify__type.html">simplify_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1simplify__type_3_01const_01From_01_4.html">simplify_type&lt; const From &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a68302f07b13f6e1f39aace5699762c41"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">SVF::SVFUtil::equalPointsTo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a68302f07b13f6e1f39aace5699762c41">equalPointsTo</a></td></tr>
<tr class="separator:a68302f07b13f6e1f39aace5699762c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2b39ae857d78ed9dda83880e703b0f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">SVF::SVFUtil::equalNodeBS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5c2b39ae857d78ed9dda83880e703b0f">equalNodeBS</a></td></tr>
<tr class="separator:a5c2b39ae857d78ed9dda83880e703b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4740b14abf7d308e7806a0d6d6c42ee2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceSVF.html#a4f21e91ff8eaea5207afe5c60dbd78d7">OrderedSet</a>&lt; <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a>, <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">equalPointsTo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">PointsToList</a></td></tr>
<tr class="separator:a4740b14abf7d308e7806a0d6d6c42ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac0df4ee0bf78167dd9461227b5cce7af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac0df4ee0bf78167dd9461227b5cce7af">isBlackholeSym</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:ac0df4ee0bf78167dd9461227b5cce7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this value is a black hole.  <a href="#ac0df4ee0bf78167dd9461227b5cce7af">More...</a><br /></td></tr>
<tr class="separator:ac0df4ee0bf78167dd9461227b5cce7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1107b2635f374e71e6a3a43834469b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4c1107b2635f374e71e6a3a43834469b">isNullPtrSym</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:a4c1107b2635f374e71e6a3a43834469b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this value is a black hole.  <a href="#a4c1107b2635f374e71e6a3a43834469b">More...</a><br /></td></tr>
<tr class="separator:a4c1107b2635f374e71e6a3a43834469b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6442fbf0cccd55cf93eab2b656756e9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6442fbf0cccd55cf93eab2b656756e9a">isConstantObjSym</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:a6442fbf0cccd55cf93eab2b656756e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this value points-to a constant object.  <a href="#a6442fbf0cccd55cf93eab2b656756e9a">More...</a><br /></td></tr>
<tr class="separator:a6442fbf0cccd55cf93eab2b656756e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd525a2e3b7b9167b61b2304cc2cbdf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#abd525a2e3b7b9167b61b2304cc2cbdf2">isReturn</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="memdesc:abd525a2e3b7b9167b61b2304cc2cbdf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a return instruction.  <a href="#abd525a2e3b7b9167b61b2304cc2cbdf2">More...</a><br /></td></tr>
<tr class="separator:abd525a2e3b7b9167b61b2304cc2cbdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7f56fa15cea924a09cd6903de2606c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceSVF.html#a1d008c0666c145622b81d427be64c52d">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8e7f56fa15cea924a09cd6903de2606c">getPtrElementType</a> (const <a class="el" href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">PointerType</a> *pty)</td></tr>
<tr class="separator:a8e7f56fa15cea924a09cd6903de2606c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9fd07cb66dbdeef696c3c745856094"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#acc9fd07cb66dbdeef696c3c745856094">isObject</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *ref)</td></tr>
<tr class="memdesc:acc9fd07cb66dbdeef696c3c745856094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this value refers to a object.  <a href="#acc9fd07cb66dbdeef696c3c745856094">More...</a><br /></td></tr>
<tr class="separator:acc9fd07cb66dbdeef696c3c745856094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4191a1c81d80bf26aac120ed880135"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4d4191a1c81d80bf26aac120ed880135">ArgInProgEntryFunction</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:a4d4191a1c81d80bf26aac120ed880135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an argument of a program entry function (e.g. main)  <a href="#a4d4191a1c81d80bf26aac120ed880135">More...</a><br /></td></tr>
<tr class="separator:a4d4191a1c81d80bf26aac120ed880135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcfe3e66a16813350ec8dffd47c5644"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4dcfe3e66a16813350ec8dffd47c5644">isPtrInDeadFunction</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *value)</td></tr>
<tr class="memdesc:a4dcfe3e66a16813350ec8dffd47c5644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is value in a dead function (function without any caller)  <a href="#a4dcfe3e66a16813350ec8dffd47c5644">More...</a><br /></td></tr>
<tr class="separator:a4dcfe3e66a16813350ec8dffd47c5644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7e06e90a215086696effb5f5537baf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a7a7e06e90a215086696effb5f5537baf">functionDoesNotRet</a> (const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *fun)</td></tr>
<tr class="memdesc:a7a7e06e90a215086696effb5f5537baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the function has a return instruction reachable from function entry.  <a href="#a7a7e06e90a215086696effb5f5537baf">More...</a><br /></td></tr>
<tr class="separator:a7a7e06e90a215086696effb5f5537baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b29238f1f32978c7b6aded4b73244d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a61b29238f1f32978c7b6aded4b73244d">getFunReachableBBs</a> (const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *fun, <a class="el" href="namespaceSVF.html#aecbb42b8e9d17fa0189c50dda9fd5fdd">DominatorTree</a> *dt, std::vector&lt; const <a class="el" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *&gt; &amp;bbs)</td></tr>
<tr class="memdesc:a61b29238f1f32978c7b6aded4b73244d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reachable basic block from function entry.  <a href="#a61b29238f1f32978c7b6aded4b73244d">More...</a><br /></td></tr>
<tr class="separator:a61b29238f1f32978c7b6aded4b73244d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb226930eeaf558575e09e5b65e0223"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a3cb226930eeaf558575e09e5b65e0223">getFunExitBB</a> (const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *fun)</td></tr>
<tr class="separator:a3cb226930eeaf558575e09e5b65e0223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86763e6a3606598580cd0172aecb5bc7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86763e6a3606598580cd0172aecb5bc7">stripConstantCasts</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:a86763e6a3606598580cd0172aecb5bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip off the constant casts.  <a href="#a86763e6a3606598580cd0172aecb5bc7">More...</a><br /></td></tr>
<tr class="separator:a86763e6a3606598580cd0172aecb5bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69991ab4e9a7705202c1357079ab5fa8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a69991ab4e9a7705202c1357079ab5fa8">stripAllCasts</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:a69991ab4e9a7705202c1357079ab5fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip off the all casts.  <a href="#a69991ab4e9a7705202c1357079ab5fa8">More...</a><br /></td></tr>
<tr class="separator:a69991ab4e9a7705202c1357079ab5fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973113323e30a01fd904b35ac18d40ce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a1d008c0666c145622b81d427be64c52d">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a973113323e30a01fd904b35ac18d40ce">getTypeOfHeapAlloc</a> (const llvm::Instruction *inst)</td></tr>
<tr class="memdesc:a973113323e30a01fd904b35ac18d40ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the heap allocation.  <a href="#a973113323e30a01fd904b35ac18d40ce">More...</a><br /></td></tr>
<tr class="separator:a973113323e30a01fd904b35ac18d40ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72b3529e87e71767c6d226821cfddb3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad72b3529e87e71767c6d226821cfddb3">getUniqueUseViaCastInst</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:ad72b3529e87e71767c6d226821cfddb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitcast instruction which is val's only use site, otherwise return nullptr.  <a href="#ad72b3529e87e71767c6d226821cfddb3">More...</a><br /></td></tr>
<tr class="separator:ad72b3529e87e71767c6d226821cfddb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0dde753f9f79e30296208eb4d97eed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="SVF-FE_2BasicTypes_8h.html#aa81a27b9c6b2a354437417162220fb14">DataLayout</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#abe0dde753f9f79e30296208eb4d97eed">getDataLayout</a> (<a class="el" href="namespaceSVF.html#aa7a770b5dd5cd0e37d06a1088f252906">Module</a> *mod)</td></tr>
<tr class="separator:abe0dde753f9f79e30296208eb4d97eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9959fa23ab4bdc65ca36fbda8c1b70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a2f9959fa23ab4bdc65ca36fbda8c1b70">getNextInsts</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *curInst, std::vector&lt; const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&gt; &amp;instList)</td></tr>
<tr class="memdesc:a2f9959fa23ab4bdc65ca36fbda8c1b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next instructions following control flow.  <a href="#a2f9959fa23ab4bdc65ca36fbda8c1b70">More...</a><br /></td></tr>
<tr class="separator:a2f9959fa23ab4bdc65ca36fbda8c1b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3a8d6cb1715db9518579fb60181d5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a7e3a8d6cb1715db9518579fb60181d5b">getPrevInsts</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *curInst, std::vector&lt; const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&gt; &amp;instList)</td></tr>
<tr class="memdesc:a7e3a8d6cb1715db9518579fb60181d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the previous instructions following control flow.  <a href="#a7e3a8d6cb1715db9518579fb60181d5b">More...</a><br /></td></tr>
<tr class="separator:a7e3a8d6cb1715db9518579fb60181d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1631bbbed23fbfe2204779ecc0dc2769"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1631bbbed23fbfe2204779ecc0dc2769">getBBSuccessorPos</a> (const <a class="el" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *BB, const <a class="el" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *Succ)</td></tr>
<tr class="memdesc:a1631bbbed23fbfe2204779ecc0dc2769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get basic block successor position.  <a href="#a1631bbbed23fbfe2204779ecc0dc2769">More...</a><br /></td></tr>
<tr class="separator:a1631bbbed23fbfe2204779ecc0dc2769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737684498679dc16a26f2411d88f36aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a737684498679dc16a26f2411d88f36aa">getBBSuccessorNum</a> (const <a class="el" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *BB)</td></tr>
<tr class="memdesc:a737684498679dc16a26f2411d88f36aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get num of BB's successors.  <a href="#a737684498679dc16a26f2411d88f36aa">More...</a><br /></td></tr>
<tr class="separator:a737684498679dc16a26f2411d88f36aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40e2e043b04ede541688ce61048fb4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ae40e2e043b04ede541688ce61048fb4e">getBBPredecessorPos</a> (const <a class="el" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *BB, const <a class="el" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *Pred)</td></tr>
<tr class="memdesc:ae40e2e043b04ede541688ce61048fb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get basic block predecessor positin.  <a href="#ae40e2e043b04ede541688ce61048fb4e">More...</a><br /></td></tr>
<tr class="separator:ae40e2e043b04ede541688ce61048fb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e78b0b6593209d78fae1dd0a5469463"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a0e78b0b6593209d78fae1dd0a5469463">getBBPredecessorNum</a> (const <a class="el" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *BB)</td></tr>
<tr class="memdesc:a0e78b0b6593209d78fae1dd0a5469463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get num of BB's predecessors.  <a href="#a0e78b0b6593209d78fae1dd0a5469463">More...</a><br /></td></tr>
<tr class="separator:a0e78b0b6593209d78fae1dd0a5469463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1657ceed1953f96329fe7226bf7da4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa1657ceed1953f96329fe7226bf7da4c">isIRFile</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:aa1657ceed1953f96329fe7226bf7da4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a file is an LLVM IR file.  <a href="#aa1657ceed1953f96329fe7226bf7da4c">More...</a><br /></td></tr>
<tr class="separator:aa1657ceed1953f96329fe7226bf7da4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ca9a79ce7b6960e3fc42d8b183bd50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a62ca9a79ce7b6960e3fc42d8b183bd50">processArguments</a> (int argc, char **argv, int &amp;arg_num, char **arg_value, std::vector&lt; std::string &gt; &amp;moduleNameVec)</td></tr>
<tr class="memdesc:a62ca9a79ce7b6960e3fc42d8b183bd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse argument for multi-module analysis.  <a href="#a62ca9a79ce7b6960e3fc42d8b183bd50">More...</a><br /></td></tr>
<tr class="separator:a62ca9a79ce7b6960e3fc42d8b183bd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8cbc986cccb9d84f87aae162df3737"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a5c8cbc986cccb9d84f87aae162df3737"><td class="memTemplItemLeft" align="right" valign="top">LLVM_NODISCARD bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5c8cbc986cccb9d84f87aae162df3737">isa</a> (const Y &amp;Val)</td></tr>
<tr class="separator:a5c8cbc986cccb9d84f87aae162df3737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d100868bf63b968d387eb50e9603f7c"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a0d100868bf63b968d387eb50e9603f7c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a>&lt; Y &gt;::value, typename <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, const Y &gt;::ret_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a0d100868bf63b968d387eb50e9603f7c">cast</a> (const Y &amp;Val)</td></tr>
<tr class="separator:a0d100868bf63b968d387eb50e9603f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406dd9baf2ce66235d482fd6c6121b2c"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a406dd9baf2ce66235d482fd6c6121b2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, Y &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a406dd9baf2ce66235d482fd6c6121b2c">cast</a> (Y &amp;Val)</td></tr>
<tr class="separator:a406dd9baf2ce66235d482fd6c6121b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2419a55c0427571f11ad14db2fe481"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:acc2419a55c0427571f11ad14db2fe481"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, Y * &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#acc2419a55c0427571f11ad14db2fe481">cast</a> (Y *Val)</td></tr>
<tr class="separator:acc2419a55c0427571f11ad14db2fe481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ca049b4ce83c874e231f5e13bf36a8"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:af3ca049b4ce83c874e231f5e13bf36a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, std::unique_ptr&lt; Y &gt; &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af3ca049b4ce83c874e231f5e13bf36a8">cast</a> (std::unique_ptr&lt; Y &gt; &amp;&amp;Val)</td></tr>
<tr class="separator:af3ca049b4ce83c874e231f5e13bf36a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8182be247907420db00837cef9bcfa70"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a8182be247907420db00837cef9bcfa70"><td class="memTemplItemLeft" align="right" valign="top">LLVM_NODISCARD std::enable_if&lt;!<a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a>&lt; Y &gt;::value, typename <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, const Y &gt;::ret_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">dyn_cast</a> (const Y &amp;Val)</td></tr>
<tr class="separator:a8182be247907420db00837cef9bcfa70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d852ba8fa569e858565b3bba403656"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a52d852ba8fa569e858565b3bba403656"><td class="memTemplItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, Y &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a52d852ba8fa569e858565b3bba403656">dyn_cast</a> (Y &amp;Val)</td></tr>
<tr class="separator:a52d852ba8fa569e858565b3bba403656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105c5c5e97d56533fb2b3ba7a0bc59f3"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a105c5c5e97d56533fb2b3ba7a0bc59f3"><td class="memTemplItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, Y * &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a105c5c5e97d56533fb2b3ba7a0bc59f3">dyn_cast</a> (Y *Val)</td></tr>
<tr class="separator:a105c5c5e97d56533fb2b3ba7a0bc59f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0b0b9f035057552a6a82154fd88e61"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a> ()</td></tr>
<tr class="memdesc:aed0b0b9f035057552a6a82154fd88e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite <a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61" title="Overwrite llvm::outs() ">llvm::outs()</a>  <a href="#aed0b0b9f035057552a6a82154fd88e61">More...</a><br /></td></tr>
<tr class="separator:aed0b0b9f035057552a6a82154fd88e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65033f068bfbeb0a1c52dcec3beb6bc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab65033f068bfbeb0a1c52dcec3beb6bc">errs</a> ()</td></tr>
<tr class="memdesc:ab65033f068bfbeb0a1c52dcec3beb6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite <a class="el" href="namespaceSVF_1_1SVFUtil.html#ab65033f068bfbeb0a1c52dcec3beb6bc" title="Overwrite llvm::errs() ">llvm::errs()</a>  <a href="#ab65033f068bfbeb0a1c52dcec3beb6bc">More...</a><br /></td></tr>
<tr class="separator:ab65033f068bfbeb0a1c52dcec3beb6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb570e9267fd7b189bd1bc877896d7ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a> (<a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> To, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=<a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>())</td></tr>
<tr class="memdesc:aeb570e9267fd7b189bd1bc877896d7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump sparse bitvector set.  <a href="#aeb570e9267fd7b189bd1bc877896d7ab">More...</a><br /></td></tr>
<tr class="separator:aeb570e9267fd7b189bd1bc877896d7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aa23b4982662d98c56af3e8ba16cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a04aa23b4982662d98c56af3e8ba16cb1">dumpSet</a> (<a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> To, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=<a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>())</td></tr>
<tr class="separator:a04aa23b4982662d98c56af3e8ba16cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#abd0a9ee845a455f9354d24a8b84a0bb3">dumpPointsToSet</a> (unsigned node, <a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> To)</td></tr>
<tr class="memdesc:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump points-to set.  <a href="#abd0a9ee845a455f9354d24a8b84a0bb3">More...</a><br /></td></tr>
<tr class="separator:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30a35713852a0a525c52ae5dd463442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab30a35713852a0a525c52ae5dd463442">dumpSparseSet</a> (const <a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> &amp;To)</td></tr>
<tr class="separator:ab30a35713852a0a525c52ae5dd463442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a15cc5570eed12dd6ee766213e11d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4a15cc5570eed12dd6ee766213e11d61">dumpAliasSet</a> (unsigned node, <a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> To)</td></tr>
<tr class="memdesc:a4a15cc5570eed12dd6ee766213e11d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump alias set.  <a href="#a4a15cc5570eed12dd6ee766213e11d61">More...</a><br /></td></tr>
<tr class="separator:a4a15cc5570eed12dd6ee766213e11d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a55f1f8598998a3ffbbc67d32eaf8c4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6a55f1f8598998a3ffbbc67d32eaf8c4">sucMsg</a> (std::string msg)</td></tr>
<tr class="memdesc:a6a55f1f8598998a3ffbbc67d32eaf8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns successful message by converting a string into green string output.  <a href="#a6a55f1f8598998a3ffbbc67d32eaf8c4">More...</a><br /></td></tr>
<tr class="separator:a6a55f1f8598998a3ffbbc67d32eaf8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c06020737f7dff22a666b75c28c5e7d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6c06020737f7dff22a666b75c28c5e7d">wrnMsg</a> (std::string msg)</td></tr>
<tr class="memdesc:a6c06020737f7dff22a666b75c28c5e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns warning message by converting a string into yellow string output.  <a href="#a6c06020737f7dff22a666b75c28c5e7d">More...</a><br /></td></tr>
<tr class="separator:a6c06020737f7dff22a666b75c28c5e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077caa1b10ab84d101d79fc7ea50db2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a077caa1b10ab84d101d79fc7ea50db2d">writeWrnMsg</a> (std::string msg)</td></tr>
<tr class="memdesc:a077caa1b10ab84d101d79fc7ea50db2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a message run through wrnMsg.  <a href="#a077caa1b10ab84d101d79fc7ea50db2d">More...</a><br /></td></tr>
<tr class="separator:a077caa1b10ab84d101d79fc7ea50db2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609eea630a8f88fe9eaba15ce7e48738"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a609eea630a8f88fe9eaba15ce7e48738">pasMsg</a> (std::string msg)</td></tr>
<tr class="memdesc:a609eea630a8f88fe9eaba15ce7e48738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print each pass/phase message by converting a string into blue string output.  <a href="#a609eea630a8f88fe9eaba15ce7e48738">More...</a><br /></td></tr>
<tr class="separator:a609eea630a8f88fe9eaba15ce7e48738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfe12afa463d0ceddeee11540c33ab3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6cfe12afa463d0ceddeee11540c33ab3">reportMemoryUsageKB</a> (const std::string &amp;infor, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=<a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>())</td></tr>
<tr class="memdesc:a6cfe12afa463d0ceddeee11540c33ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print memory usage in KB.  <a href="#a6cfe12afa463d0ceddeee11540c33ab3">More...</a><br /></td></tr>
<tr class="separator:a6cfe12afa463d0ceddeee11540c33ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">getMemoryUsageKB</a> (<a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *vmrss_kb, <a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *vmsize_kb)</td></tr>
<tr class="memdesc:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get memory usage from system file. Return TRUE if succeed.  <a href="#a630ff9c47f58f9b8df7c8a2b3711477c">More...</a><br /></td></tr>
<tr class="separator:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7588578735679773493ff2d5e458e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a0d7588578735679773493ff2d5e458e1">increaseStackSize</a> ()</td></tr>
<tr class="memdesc:a0d7588578735679773493ff2d5e458e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the stack size limit.  <a href="#a0d7588578735679773493ff2d5e458e1">More...</a><br /></td></tr>
<tr class="separator:a0d7588578735679773493ff2d5e458e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ce14119a6e3b0b6022753ddd5890f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa5ce14119a6e3b0b6022753ddd5890f3">cmpPts</a> (const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;lpts, const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;rpts)</td></tr>
<tr class="separator:aa5ce14119a6e3b0b6022753ddd5890f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f749354b7e882ef3e5bf5081fa715b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8f749354b7e882ef3e5bf5081fa715b5">cmpNodeBS</a> (const <a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> &amp;lpts, const <a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> &amp;rpts)</td></tr>
<tr class="separator:a8f749354b7e882ef3e5bf5081fa715b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ebab122895189be57637b84adc7642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86ebab122895189be57637b84adc7642">ptsToNodeBS</a> (const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;pts)</td></tr>
<tr class="separator:a86ebab122895189be57637b84adc7642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ceddbe4d57b24e80201bc895f73810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af4ceddbe4d57b24e80201bc895f73810">dumpPointsToList</a> (const <a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">PointsToList</a> &amp;ptl)</td></tr>
<tr class="separator:af4ceddbe4d57b24e80201bc895f73810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c53be5490882768d51aa894b37cbf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad2c53be5490882768d51aa894b37cbf1">isIntrinsicFun</a> (const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *func)</td></tr>
<tr class="separator:ad2c53be5490882768d51aa894b37cbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f58caf27c30a1d414e06f60ca84d80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab7f58caf27c30a1d414e06f60ca84d80">isIntrinsicInst</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="memdesc:ab7f58caf27c30a1d414e06f60ca84d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it is an intrinsic instruction.  <a href="#ab7f58caf27c30a1d414e06f60ca84d80">More...</a><br /></td></tr>
<tr class="separator:ab7f58caf27c30a1d414e06f60ca84d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e08ce822223842fa6a73fd659b1a526"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a2e08ce822223842fa6a73fd659b1a526">isCallSite</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="memdesc:a2e08ce822223842fa6a73fd659b1a526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a call or invoke instruction.  <a href="#a2e08ce822223842fa6a73fd659b1a526">More...</a><br /></td></tr>
<tr class="separator:a2e08ce822223842fa6a73fd659b1a526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bf8f7eaa18fc5a09711959b5417854"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">isCallSite</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:a38bf8f7eaa18fc5a09711959b5417854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a call or invoke instruction.  <a href="#a38bf8f7eaa18fc5a09711959b5417854">More...</a><br /></td></tr>
<tr class="separator:a38bf8f7eaa18fc5a09711959b5417854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8216a92140d982303f83ea424ddc91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8d8216a92140d982303f83ea424ddc91">isNonInstricCallSite</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="memdesc:a8d8216a92140d982303f83ea424ddc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a callsite in the application code, excluding llvm intrinsic calls.  <a href="#a8d8216a92140d982303f83ea424ddc91">More...</a><br /></td></tr>
<tr class="separator:a8d8216a92140d982303f83ea424ddc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202de7ad2bea0311e2f75894c030e7a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a202de7ad2bea0311e2f75894c030e7a9">getLLVMCallSite</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="memdesc:a202de7ad2bea0311e2f75894c030e7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return LLVM callsite given a instruction.  <a href="#a202de7ad2bea0311e2f75894c030e7a9">More...</a><br /></td></tr>
<tr class="separator:a202de7ad2bea0311e2f75894c030e7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09c2b313ff1c1abcc1e5cb3f9ef46a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa09c2b313ff1c1abcc1e5cb3f9ef46a5">getFunction</a> (std::string name)</td></tr>
<tr class="memdesc:aa09c2b313ff1c1abcc1e5cb3f9ef46a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the corresponding Function based on its name.  <a href="#aa09c2b313ff1c1abcc1e5cb3f9ef46a5">More...</a><br /></td></tr>
<tr class="separator:aa09c2b313ff1c1abcc1e5cb3f9ef46a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54e70082388bbd70868250aaa0bc86b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af54e70082388bbd70868250aaa0bc86b">split</a> (const std::string &amp;s, char seperator)</td></tr>
<tr class="memdesc:af54e70082388bbd70868250aaa0bc86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into two substrings around the first occurrence of a separator string.  <a href="#af54e70082388bbd70868250aaa0bc86b">More...</a><br /></td></tr>
<tr class="separator:af54e70082388bbd70868250aaa0bc86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b55d5252da1f316f505cf6ce2078b28"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4b55d5252da1f316f505cf6ce2078b28">getGlobalRep</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:a4b55d5252da1f316f505cf6ce2078b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the unique defined global across multiple modules  <a href="#a4b55d5252da1f316f505cf6ce2078b28">More...</a><br /></td></tr>
<tr class="separator:a4b55d5252da1f316f505cf6ce2078b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142e650415cb81011eb59dadd3cb0637"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a142e650415cb81011eb59dadd3cb0637">getDefFunForMultipleModule</a> (const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *fun)</td></tr>
<tr class="memdesc:a142e650415cb81011eb59dadd3cb0637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the definition of a function across multiple modules.  <a href="#a142e650415cb81011eb59dadd3cb0637">More...</a><br /></td></tr>
<tr class="separator:a142e650415cb81011eb59dadd3cb0637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memTemplParams" colspan="2">template&lt;typename Data &gt; </td></tr>
<tr class="memitem:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a36c91f952a69875c33d4bd0b05a27ff2">mergePtsOccMaps</a> (<a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; Data, unsigned &gt; &amp;to, const <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; Data, unsigned &gt; from)</td></tr>
<tr class="memdesc:a36c91f952a69875c33d4bd0b05a27ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a map mapping points-to sets to a count, adds from into to.  <a href="#a36c91f952a69875c33d4bd0b05a27ff2">More...</a><br /></td></tr>
<tr class="separator:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a4c5124f2fd03ca3d898e2acd54160"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a14a4c5124f2fd03ca3d898e2acd54160">hclustMethodToString</a> (<a class="el" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a> method)</td></tr>
<tr class="memdesc:a14a4c5124f2fd03ca3d898e2acd54160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of a hclust method.  <a href="#a14a4c5124f2fd03ca3d898e2acd54160">More...</a><br /></td></tr>
<tr class="separator:a14a4c5124f2fd03ca3d898e2acd54160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecfaf26800dcebf0b079395126bc7f7"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename KeySet &gt; </td></tr>
<tr class="memitem:aeecfaf26800dcebf0b079395126bc7f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aeecfaf26800dcebf0b079395126bc7f7">insertKey</a> (const Key &amp;key, KeySet &amp;keySet)</td></tr>
<tr class="memdesc:aeecfaf26800dcebf0b079395126bc7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into a Set/CondSet (with ::insert).  <a href="#aeecfaf26800dcebf0b079395126bc7f7">More...</a><br /></td></tr>
<tr class="separator:aeecfaf26800dcebf0b079395126bc7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4f75b8313eb2b1e5a4c798a01cb99471">insertKey</a> (const <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &amp;key, <a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> &amp;keySet)</td></tr>
<tr class="memdesc:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a NodeID into a NodeBS.  <a href="#a4f75b8313eb2b1e5a4c798a01cb99471">More...</a><br /></td></tr>
<tr class="separator:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee74719d33695e4da6fee5fc83f745d9"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename KeySet &gt; </td></tr>
<tr class="memitem:aee74719d33695e4da6fee5fc83f745d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aee74719d33695e4da6fee5fc83f745d9">removeKey</a> (const Key &amp;key, KeySet &amp;keySet)</td></tr>
<tr class="memdesc:aee74719d33695e4da6fee5fc83f745d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from a Set/CondSet (or anything implementing ::erase).  <a href="#aee74719d33695e4da6fee5fc83f745d9">More...</a><br /></td></tr>
<tr class="separator:aee74719d33695e4da6fee5fc83f745d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59af7fc01a534662b3b1524186ef97e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa59af7fc01a534662b3b1524186ef97e">removeKey</a> (const <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &amp;key, <a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> &amp;keySet)</td></tr>
<tr class="memdesc:aa59af7fc01a534662b3b1524186ef97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a NodeID from a NodeBS.  <a href="#aa59af7fc01a534662b3b1524186ef97e">More...</a><br /></td></tr>
<tr class="separator:aa59af7fc01a534662b3b1524186ef97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4cd21115988f9f5eec12e268ddf1d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#add4cd21115988f9f5eec12e268ddf1d9">timeLimitReached</a> (int signum)</td></tr>
<tr class="memdesc:add4cd21115988f9f5eec12e268ddf1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call when alarm for time limit hits.  <a href="#add4cd21115988f9f5eec12e268ddf1d9">More...</a><br /></td></tr>
<tr class="separator:add4cd21115988f9f5eec12e268ddf1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757815a2c758695176120509ceb0ce70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a757815a2c758695176120509ceb0ce70">startAnalysisLimitTimer</a> (unsigned timeLimit)</td></tr>
<tr class="separator:a757815a2c758695176120509ceb0ce70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168f7f7a3a8c70dbf2b5b4269cd4c7c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a168f7f7a3a8c70dbf2b5b4269cd4c7c5">stopAnalysisLimitTimer</a> (bool limitTimerSet)</td></tr>
<tr class="separator:a168f7f7a3a8c70dbf2b5b4269cd4c7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817a63e8330530cb18e077556f7ce518"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a817a63e8330530cb18e077556f7ce518">type2String</a> (const <a class="el" href="namespaceSVF.html#a1d008c0666c145622b81d427be64c52d">Type</a> *type)</td></tr>
<tr class="separator:a817a63e8330530cb18e077556f7ce518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab302ca3fcbde9bd1a7d9d5d837a69c23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab302ca3fcbde9bd1a7d9d5d837a69c23">isAnAllocationWraper</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *)</td></tr>
<tr class="memdesc:ab302ca3fcbde9bd1a7d9d5d837a69c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function servers a allocation wrapper detector.  <a href="#ab302ca3fcbde9bd1a7d9d5d837a69c23">More...</a><br /></td></tr>
<tr class="separator:ab302ca3fcbde9bd1a7d9d5d837a69c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98299033577f1e7f4e9bc73dff3b253"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad98299033577f1e7f4e9bc73dff3b253">getLLVMFunction</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:ad98299033577f1e7f4e9bc73dff3b253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return LLVM function if this value is.  <a href="#ad98299033577f1e7f4e9bc73dff3b253">More...</a><br /></td></tr>
<tr class="separator:ad98299033577f1e7f4e9bc73dff3b253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad27a96075234ad2182a84e0e9d31a45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aad27a96075234ad2182a84e0e9d31a45">isExtCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:aad27a96075234ad2182a84e0e9d31a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e5fd7ffce966575ebf7c7e653b0919"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af3e5fd7ffce966575ebf7c7e653b0919">isExtCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:af3e5fd7ffce966575ebf7c7e653b0919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfa6e9216c6c788c26aef1967689b76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aedfa6e9216c6c788c26aef1967689b76">isHeapAllocExtCallViaArg</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:aedfa6e9216c6c788c26aef1967689b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bde3acf22383eac5bbf4e2c065a2226"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a0bde3acf22383eac5bbf4e2c065a2226">isHeapAllocExtCallViaArg</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a0bde3acf22383eac5bbf4e2c065a2226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2064cb70c76f399ce115f2621adea35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab2064cb70c76f399ce115f2621adea35">isHeapAllocExtCallViaRet</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:ab2064cb70c76f399ce115f2621adea35"><td class="mdescLeft">&#160;</td><td class="mdescRight">interfaces to be used externally  <a href="#ab2064cb70c76f399ce115f2621adea35">More...</a><br /></td></tr>
<tr class="separator:ab2064cb70c76f399ce115f2621adea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24514d87685f2258201f0de15d220bbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a24514d87685f2258201f0de15d220bbc">isHeapAllocExtCallViaRet</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a24514d87685f2258201f0de15d220bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ac673b885633849fa484938405ca75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a93ac673b885633849fa484938405ca75">isHeapAllocExtCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a93ac673b885633849fa484938405ca75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebbf43e294c3f94a2a7d5c56759bbba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1ebbf43e294c3f94a2a7d5c56759bbba">isHeapAllocExtCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a1ebbf43e294c3f94a2a7d5c56759bbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298b6366145ed871faf3d01420ae5d20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a298b6366145ed871faf3d01420ae5d20">getHeapAllocHoldingArgPosition</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a298b6366145ed871faf3d01420ae5d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af986a7698e72272707cc2a466d5ae7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5af986a7698e72272707cc2a466d5ae7">getHeapAllocHoldingArgPosition</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a5af986a7698e72272707cc2a466d5ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6740e7686ba111ae525c6c093cbbaf46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6740e7686ba111ae525c6c093cbbaf46">isReallocExtCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a6740e7686ba111ae525c6c093cbbaf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42748153e4845f3eee0ca58a1e151f97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a42748153e4845f3eee0ca58a1e151f97">isReallocExtCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a42748153e4845f3eee0ca58a1e151f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f52a7f183f1eec7c4db7e4e54fa5e2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1f52a7f183f1eec7c4db7e4e54fa5e2c">isDeallocExtCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a1f52a7f183f1eec7c4db7e4e54fa5e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9973c1326717326b26ec1ea21ebd8da5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a9973c1326717326b26ec1ea21ebd8da5">isDeallocExtCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a9973c1326717326b26ec1ea21ebd8da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62938f722543d6d7fc201b685be1abf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ae62938f722543d6d7fc201b685be1abf">isStaticExtCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:ae62938f722543d6d7fc201b685be1abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8ac16a9a2961f98001ab94aeaedf64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aab8ac16a9a2961f98001ab94aeaedf64">isStaticExtCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:aab8ac16a9a2961f98001ab94aeaedf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87fef7b10465d3e635643fcb93b95a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab87fef7b10465d3e635643fcb93b95a7">isProgEntryFunction</a> (const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *fun)</td></tr>
<tr class="separator:ab87fef7b10465d3e635643fcb93b95a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6528edf9a1750df4a84d1a60d4d0bbe4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6528edf9a1750df4a84d1a60d4d0bbe4">isProgExitCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a6528edf9a1750df4a84d1a60d4d0bbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b531ca4077e71dcc6d085e47a9730b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a68b531ca4077e71dcc6d085e47a9730b">isProgExitCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a68b531ca4077e71dcc6d085e47a9730b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9232d260dc83d3a25cd98195ba76567a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a9232d260dc83d3a25cd98195ba76567a">getRefTypeOfHeapAllocOrStatic</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:a9232d260dc83d3a25cd98195ba76567a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference type of heap/static object from an allocation site.  <a href="#a9232d260dc83d3a25cd98195ba76567a">More...</a><br /></td></tr>
<tr class="separator:a9232d260dc83d3a25cd98195ba76567a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642f8284fbb260dd81fb29d5fadf6822"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">PointerType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a642f8284fbb260dd81fb29d5fadf6822">getRefTypeOfHeapAllocOrStatic</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a642f8284fbb260dd81fb29d5fadf6822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6d268e8d588717601345be3a911a7625"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6d268e8d588717601345be3a911a7625">isDeadFunction</a> (const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *fun)</td></tr>
<tr class="memdesc:a6d268e8d588717601345be3a911a7625"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether this is a function without any possible caller?  <a href="#a6d268e8d588717601345be3a911a7625">More...</a><br /></td></tr>
<tr class="separator:a6d268e8d588717601345be3a911a7625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4543a9c0299c72deb68f2472e1ea05ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4543a9c0299c72deb68f2472e1ea05ce">ArgInDeadFunction</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:a4543a9c0299c72deb68f2472e1ea05ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether this is an argument in dead function  <a href="#a4543a9c0299c72deb68f2472e1ea05ce">More...</a><br /></td></tr>
<tr class="separator:a4543a9c0299c72deb68f2472e1ea05ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae7007ebc6a543dc30ef076b4aed75b1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ae7007ebc6a543dc30ef076b4aed75b1b">isNoCallerFunction</a> (const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *fun)</td></tr>
<tr class="memdesc:ae7007ebc6a543dc30ef076b4aed75b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function does not have any possible caller in the call graph.  <a href="#ae7007ebc6a543dc30ef076b4aed75b1b">More...</a><br /></td></tr>
<tr class="separator:ae7007ebc6a543dc30ef076b4aed75b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd690c09e01989e57899875ca97f0166"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#afd690c09e01989e57899875ca97f0166">ArgInNoCallerFunction</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:afd690c09e01989e57899875ca97f0166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument in a function does not have a caller.  <a href="#afd690c09e01989e57899875ca97f0166">More...</a><br /></td></tr>
<tr class="separator:afd690c09e01989e57899875ca97f0166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a384b0986a6c4e99dfc4e1629b3598c3c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a384b0986a6c4e99dfc4e1629b3598c3c">isGepConstantExpr</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:a384b0986a6c4e99dfc4e1629b3598c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return corresponding constant expression, otherwise return nullptr.  <a href="#a384b0986a6c4e99dfc4e1629b3598c3c">More...</a><br /></td></tr>
<tr class="separator:a384b0986a6c4e99dfc4e1629b3598c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc4376ada53ddfbf8df2ca817153555"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6bc4376ada53ddfbf8df2ca817153555">isInt2PtrConstantExpr</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="separator:a6bc4376ada53ddfbf8df2ca817153555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093b7ae4ad144fb5d028366b1814861a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a093b7ae4ad144fb5d028366b1814861a">isPtr2IntConstantExpr</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="separator:a093b7ae4ad144fb5d028366b1814861a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e404bcc6613ba10a56c4fbdc842c5a8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a7e404bcc6613ba10a56c4fbdc842c5a8">isCastConstantExpr</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="separator:a7e404bcc6613ba10a56c4fbdc842c5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d991d5bfccce9ebdef0cbb6f4bf739"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a07d991d5bfccce9ebdef0cbb6f4bf739">isSelectConstantExpr</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="separator:a07d991d5bfccce9ebdef0cbb6f4bf739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1373688c6faba4dcdb640106575ea433"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1373688c6faba4dcdb640106575ea433">isTruncConstantExpr</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="separator:a1373688c6faba4dcdb640106575ea433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adb63c87a9489ab905d42230ac66299"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4adb63c87a9489ab905d42230ac66299">isCmpConstantExpr</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="separator:a4adb63c87a9489ab905d42230ac66299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c9072210a5f5baeafe36da03f2fde2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a43c9072210a5f5baeafe36da03f2fde2">isBinaryConstantExpr</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="separator:a43c9072210a5f5baeafe36da03f2fde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14757d5cf466bba20a125f118378560"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af14757d5cf466bba20a125f118378560">isUnaryConstantExpr</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="separator:af14757d5cf466bba20a125f118378560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a86fec3512ea1fc724cf567f52d348678"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86fec3512ea1fc724cf567f52d348678">getTypeSizeInBytes</a> (const <a class="el" href="namespaceSVF.html#a1d008c0666c145622b81d427be64c52d">Type</a> *type)</td></tr>
<tr class="memdesc:a86fec3512ea1fc724cf567f52d348678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to get the size of the type from target data layout.  <a href="#a86fec3512ea1fc724cf567f52d348678">More...</a><br /></td></tr>
<tr class="separator:a86fec3512ea1fc724cf567f52d348678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dadc280bc2df41b82167ed236985dd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1dadc280bc2df41b82167ed236985dd5">getTypeSizeInBytes</a> (const <a class="el" href="namespaceSVF.html#a2bf58575ac7d068e0f1a4cf953b9e6cb">StructType</a> *sty, <a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> field_index)</td></tr>
<tr class="separator:a1dadc280bc2df41b82167ed236985dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5d4bb92f5df30417f414397f8e58cf01"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5d4bb92f5df30417f414397f8e58cf01">errMsg</a> (std::string msg)</td></tr>
<tr class="memdesc:a5d4bb92f5df30417f414397f8e58cf01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print error message by converting a string into red string output.  <a href="#a5d4bb92f5df30417f414397f8e58cf01">More...</a><br /></td></tr>
<tr class="separator:a5d4bb92f5df30417f414397f8e58cf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c66553e2559eebfe4f98c0c7ec4b08"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af6c66553e2559eebfe4f98c0c7ec4b08">bugMsg1</a> (std::string msg)</td></tr>
<tr class="separator:af6c66553e2559eebfe4f98c0c7ec4b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054c3e668ce8b265bbc5d923f6243ce7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a054c3e668ce8b265bbc5d923f6243ce7">bugMsg2</a> (std::string msg)</td></tr>
<tr class="separator:a054c3e668ce8b265bbc5d923f6243ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbca7c40d2da6bd2374ea53d5de0553"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aabbca7c40d2da6bd2374ea53d5de0553">bugMsg3</a> (std::string msg)</td></tr>
<tr class="separator:aabbca7c40d2da6bd2374ea53d5de0553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a145abbd2958629718fbca41d25c3124d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a145abbd2958629718fbca41d25c3124d">getCallee</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:a145abbd2958629718fbca41d25c3124d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return callee of a callsite. Return null if this is an indirect call.  <a href="#a145abbd2958629718fbca41d25c3124d">More...</a><br /></td></tr>
<tr class="separator:a145abbd2958629718fbca41d25c3124d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26c7636bfef7ab2a36cccdcf12c3538"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:af26c7636bfef7ab2a36cccdcf12c3538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a28c0ede7e4765d2a686fc8ae0f5641a4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a28c0ede7e4765d2a686fc8ae0f5641a4">getSourceLoc</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:a28c0ede7e4765d2a686fc8ae0f5641a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return source code including line number and file name from debug information.  <a href="#a28c0ede7e4765d2a686fc8ae0f5641a4">More...</a><br /></td></tr>
<tr class="separator:a28c0ede7e4765d2a686fc8ae0f5641a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c1c8bdfc1075c07c631525555194d2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86c1c8bdfc1075c07c631525555194d2">getSourceLocOfFunction</a> (const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *<a class="el" href="CFLGrammarDev_8txt.html#a5526c6e27f7632db909dee64f361d2c9">F</a>)</td></tr>
<tr class="separator:a86c1c8bdfc1075c07c631525555194d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7486fd8e5350879ed1cbd835c0d4e191"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a7486fd8e5350879ed1cbd835c0d4e191">value2String</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *value)</td></tr>
<tr class="separator:a7486fd8e5350879ed1cbd835c0d4e191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a22ef185e767ff76c098e75126c885400"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a22ef185e767ff76c098e75126c885400">isExtCall</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="separator:a22ef185e767ff76c098e75126c885400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b96a872d9096037f20e25122e469ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">isHeapAllocExtFunViaRet</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:a19b96a872d9096037f20e25122e469ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a heap allocator/reallocator.  <a href="#a19b96a872d9096037f20e25122e469ea">More...</a><br /></td></tr>
<tr class="separator:a19b96a872d9096037f20e25122e469ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a69173f50ebe48e69103befe516245"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab4a69173f50ebe48e69103befe516245">isHeapAllocExtFunViaArg</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="separator:ab4a69173f50ebe48e69103befe516245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73215bac62f1340a58f6c7f2ba9b0e7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a73215bac62f1340a58f6c7f2ba9b0e7b">getHeapAllocHoldingArgPosition</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:a73215bac62f1340a58f6c7f2ba9b0e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of argument that holds an allocated heap object.  <a href="#a73215bac62f1340a58f6c7f2ba9b0e7b">More...</a><br /></td></tr>
<tr class="separator:a73215bac62f1340a58f6c7f2ba9b0e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c74c642ad43d955ac8a3f3ad8907b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">isReallocExtFun</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:a97c74c642ad43d955ac8a3f3ad8907b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a heap reallocator.  <a href="#a97c74c642ad43d955ac8a3f3ad8907b4">More...</a><br /></td></tr>
<tr class="separator:a97c74c642ad43d955ac8a3f3ad8907b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3495236e22e4bc6404b6ac352060439c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a3495236e22e4bc6404b6ac352060439c">isDeallocExtFun</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:a3495236e22e4bc6404b6ac352060439c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a heap dealloc or not.  <a href="#a3495236e22e4bc6404b6ac352060439c">More...</a><br /></td></tr>
<tr class="separator:a3495236e22e4bc6404b6ac352060439c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc9bb7bd6c9682debf3ffab7182abf5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1bc9bb7bd6c9682debf3ffab7182abf5">isStaticExtFun</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:a1bc9bb7bd6c9682debf3ffab7182abf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a static global call.  <a href="#a1bc9bb7bd6c9682debf3ffab7182abf5">More...</a><br /></td></tr>
<tr class="separator:a1bc9bb7bd6c9682debf3ffab7182abf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e7507fb376b1625bc1573132ab9f06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSVF_1_1ExtAPI.html#aaf94c82d98f8ed1514ee49c9881a4094">ExtAPI::extf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac3e7507fb376b1625bc1573132ab9f06">extCallTy</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:ac3e7507fb376b1625bc1573132ab9f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return external call type.  <a href="#ac3e7507fb376b1625bc1573132ab9f06">More...</a><br /></td></tr>
<tr class="separator:ac3e7507fb376b1625bc1573132ab9f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c97c2b79b795465490512e267a9309b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a2c97c2b79b795465490512e267a9309b">isProgEntryFunction</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:a2c97c2b79b795465490512e267a9309b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program entry function e.g. main.  <a href="#a2c97c2b79b795465490512e267a9309b">More...</a><br /></td></tr>
<tr class="separator:a2c97c2b79b795465490512e267a9309b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f82e03d880257527bd9cb5978e05604"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6f82e03d880257527bd9cb5978e05604">getProgFunction</a> (<a class="el" href="classSVF_1_1SVFModule.html">SVFModule</a> *svfModule, const std::string &amp;funName)</td></tr>
<tr class="memdesc:a6f82e03d880257527bd9cb5978e05604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get program entry function from module.  <a href="#a6f82e03d880257527bd9cb5978e05604">More...</a><br /></td></tr>
<tr class="separator:a6f82e03d880257527bd9cb5978e05604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8017e3e5100b3f63ee338b66118d266"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa8017e3e5100b3f63ee338b66118d266">getProgEntryFunction</a> (<a class="el" href="classSVF_1_1SVFModule.html">SVFModule</a> *svfModule)</td></tr>
<tr class="memdesc:aa8017e3e5100b3f63ee338b66118d266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get program entry function from module.  <a href="#aa8017e3e5100b3f63ee338b66118d266">More...</a><br /></td></tr>
<tr class="separator:aa8017e3e5100b3f63ee338b66118d266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7ee60be22e8f9397db108131696d57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">isProgExitFunction</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:aec7ee60be22e8f9397db108131696d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a program exit function call.  <a href="#aec7ee60be22e8f9397db108131696d57">More...</a><br /></td></tr>
<tr class="separator:aec7ee60be22e8f9397db108131696d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e85d445e8b7b205134acd3874bba388"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a9e85d445e8b7b205134acd3874bba388">isConstantData</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:a9e85d445e8b7b205134acd3874bba388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the value refers to constant data, e.g., i32 0.  <a href="#a9e85d445e8b7b205134acd3874bba388">More...</a><br /></td></tr>
<tr class="separator:a9e85d445e8b7b205134acd3874bba388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac840e43fa58a90099de99a1953f091ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac840e43fa58a90099de99a1953f091ac">getForkedFun</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:ac840e43fa58a90099de99a1953f091ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return thread fork function.  <a href="#ac840e43fa58a90099de99a1953f091ac">More...</a><br /></td></tr>
<tr class="separator:ac840e43fa58a90099de99a1953f091ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc8c549625712e006079642c656ec83"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4cc8c549625712e006079642c656ec83">getForkedFun</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a4cc8c549625712e006079642c656ec83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a61ed4bb80d88b0f8dbc02535c224fdfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a61ed4bb80d88b0f8dbc02535c224fdfb">isHeapAllocOrStaticExtCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:a61ed4bb80d88b0f8dbc02535c224fdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a static global call.  <a href="#a61ed4bb80d88b0f8dbc02535c224fdfb">More...</a><br /></td></tr>
<tr class="separator:a61ed4bb80d88b0f8dbc02535c224fdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8afe88cb58a2ac484c3bc4dd15ece9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a0c8afe88cb58a2ac484c3bc4dd15ece9">isHeapAllocOrStaticExtCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a0c8afe88cb58a2ac484c3bc4dd15ece9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5c2abeb363081381c3dc939ab511e3f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5c2abeb363081381c3dc939ab511e3f0">isThreadForkCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a5c2abeb363081381c3dc939ab511e3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834afc0042c24ed5a1dd00cadc1f00c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a834afc0042c24ed5a1dd00cadc1f00c3">isThreadForkCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a834afc0042c24ed5a1dd00cadc1f00c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a28fbb7cc51eb7e25d88f43e3eb1f30fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a28fbb7cc51eb7e25d88f43e3eb1f30fb">isHareParForCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a28fbb7cc51eb7e25d88f43e3eb1f30fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b37c6fe1232ebc35ffa052bd392e2e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a9b37c6fe1232ebc35ffa052bd392e2e8">isHareParForCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a9b37c6fe1232ebc35ffa052bd392e2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a194a8cf292726bd6cd54307b555c068a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a194a8cf292726bd6cd54307b555c068a">isThreadJoinCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a194a8cf292726bd6cd54307b555c068a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14793b41b05439a8a82fdce02e0587d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a14793b41b05439a8a82fdce02e0587d5">isThreadJoinCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a14793b41b05439a8a82fdce02e0587d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3af5073a1cdc000678f7e4bbc943f5d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a3af5073a1cdc000678f7e4bbc943f5d5">isThreadExitCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a3af5073a1cdc000678f7e4bbc943f5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae025d6727ef34fbeaa7ad48a4dabdcd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aae025d6727ef34fbeaa7ad48a4dabdcd">isThreadExitCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:aae025d6727ef34fbeaa7ad48a4dabdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5f3ecd0770991b6e84afe47a3934f0d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5f3ecd0770991b6e84afe47a3934f0d2">isLockAquireCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a5f3ecd0770991b6e84afe47a3934f0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343dae805a34d102b9c1b96f173468df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a343dae805a34d102b9c1b96f173468df">isLockAquireCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a343dae805a34d102b9c1b96f173468df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1241ef1c19df14f7db0bd62dd68f14f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1241ef1c19df14f7db0bd62dd68f14f9">isLockReleaseCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="separator:a1241ef1c19df14f7db0bd62dd68f14f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ac49c70252036a957694f2cf05ae2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a84ac49c70252036a957694f2cf05ae2c">isLockReleaseCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a84ac49c70252036a957694f2cf05ae2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad09ba410acbbaee2aac9dd406c3cf01a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad09ba410acbbaee2aac9dd406c3cf01a">isBarrierWaitCall</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:ad09ba410acbbaee2aac9dd406c3cf01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a barrier wait call.  <a href="#ad09ba410acbbaee2aac9dd406c3cf01a">More...</a><br /></td></tr>
<tr class="separator:ad09ba410acbbaee2aac9dd406c3cf01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7fc57e1f5cec705e310a4bb72cba94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a0a7fc57e1f5cec705e310a4bb72cba94">isBarrierWaitCall</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a0a7fc57e1f5cec705e310a4bb72cba94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaeeb386d80b51d729322317065606454"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aaeeb386d80b51d729322317065606454">getActualParmAtForkSite</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:aaeeb386d80b51d729322317065606454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sole argument of the thread routine.  <a href="#aaeeb386d80b51d729322317065606454">More...</a><br /></td></tr>
<tr class="separator:aaeeb386d80b51d729322317065606454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01119ea4e3a10ebecdef4d390a1c4c88"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a01119ea4e3a10ebecdef4d390a1c4c88">getActualParmAtForkSite</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a01119ea4e3a10ebecdef4d390a1c4c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab048cbce6e4f5a3d6ff90da3565220ff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab048cbce6e4f5a3d6ff90da3565220ff">getTaskFuncAtHareParForSite</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:ab048cbce6e4f5a3d6ff90da3565220ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the task function of the parallel_for routine.  <a href="#ab048cbce6e4f5a3d6ff90da3565220ff">More...</a><br /></td></tr>
<tr class="separator:ab048cbce6e4f5a3d6ff90da3565220ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111fa1ecf72adbd2e0ff27e922f0d34a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a111fa1ecf72adbd2e0ff27e922f0d34a">getTaskFuncAtHareParForSite</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a111fa1ecf72adbd2e0ff27e922f0d34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad3471260b66bdd7e6b790ad2a94fe7ce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad3471260b66bdd7e6b790ad2a94fe7ce">getTaskDataAtHareParForSite</a> (const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a> cs)</td></tr>
<tr class="memdesc:ad3471260b66bdd7e6b790ad2a94fe7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the task data argument of the parallel_for rountine.  <a href="#ad3471260b66bdd7e6b790ad2a94fe7ce">More...</a><br /></td></tr>
<tr class="separator:ad3471260b66bdd7e6b790ad2a94fe7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3dd36ee492b60039928a86519518a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5f3dd36ee492b60039928a86519518a5">getTaskDataAtHareParForSite</a> (const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst)</td></tr>
<tr class="separator:a5f3dd36ee492b60039928a86519518a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a5c2b39ae857d78ed9dda83880e703b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2b39ae857d78ed9dda83880e703b0f">&#9670;&nbsp;</a></span>equalNodeBS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">SVF::SVFUtil::equalNodeBS</a>  <a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">SVF::SVFUtil::equalNodeBS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68302f07b13f6e1f39aace5699762c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68302f07b13f6e1f39aace5699762c41">&#9670;&nbsp;</a></span>equalPointsTo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">SVF::SVFUtil::equalPointsTo</a>  <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">SVF::SVFUtil::equalPointsTo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4740b14abf7d308e7806a0d6d6c42ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4740b14abf7d308e7806a0d6d6c42ee2">&#9670;&nbsp;</a></span>PointsToList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceSVF.html#a4f21e91ff8eaea5207afe5c60dbd78d7">OrderedSet</a>&lt;<a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a>, <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">equalPointsTo</a>&gt; <a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">SVF::SVFUtil::PointsToList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00164">164</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4543a9c0299c72deb68f2472e1ea05ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4543a9c0299c72deb68f2472e1ea05ce">&#9670;&nbsp;</a></span>ArgInDeadFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::ArgInDeadFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether this is an argument in dead function </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00124">124</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;{</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="keywordflow">return</span> SVFUtil::isa&lt;Argument&gt;(val)</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;           &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a6d268e8d588717601345be3a911a7625">isDeadFunction</a>(SVFUtil::cast&lt;Argument&gt;(val)-&gt;getParent());</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a6d268e8d588717601345be3a911a7625"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a6d268e8d588717601345be3a911a7625">SVF::SVFUtil::isDeadFunction</a></div><div class="ttdeci">bool isDeadFunction(const Function *fun)</div><div class="ttdoc">whether this is a function without any possible caller? </div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8cpp_source.html#l00160">LLVMUtil.cpp:160</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afd690c09e01989e57899875ca97f0166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd690c09e01989e57899875ca97f0166">&#9670;&nbsp;</a></span>ArgInNoCallerFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::ArgInNoCallerFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the argument in a function does not have a caller. </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00152">152</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;{</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    <span class="keywordflow">return</span> SVFUtil::isa&lt;Argument&gt;(val)</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;           &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#ae7007ebc6a543dc30ef076b4aed75b1b">isNoCallerFunction</a>(SVFUtil::cast&lt;Argument&gt;(val)-&gt;getParent());</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ae7007ebc6a543dc30ef076b4aed75b1b"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ae7007ebc6a543dc30ef076b4aed75b1b">SVF::SVFUtil::isNoCallerFunction</a></div><div class="ttdeci">bool isNoCallerFunction(const Function *fun)</div><div class="ttdoc">Function does not have any possible caller in the call graph. </div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8h_source.html#l00146">LLVMUtil.h:146</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4d4191a1c81d80bf26aac120ed880135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4191a1c81d80bf26aac120ed880135">&#9670;&nbsp;</a></span>ArgInProgEntryFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::ArgInProgEntryFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this is an argument of a program entry function (e.g. main) </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00132">132</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;{</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    <span class="keywordflow">return</span> SVFUtil::isa&lt;Argument&gt;(val)</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;           &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a2c97c2b79b795465490512e267a9309b">isProgEntryFunction</a>(SVFUtil::cast&lt;Argument&gt;(val)-&gt;getParent());</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a2c97c2b79b795465490512e267a9309b"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a2c97c2b79b795465490512e267a9309b">SVF::SVFUtil::isProgEntryFunction</a></div><div class="ttdeci">bool isProgEntryFunction(const SVFFunction *fun)</div><div class="ttdoc">Program entry function e.g. main. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00417">SVFUtil.h:417</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af6c66553e2559eebfe4f98c0c7ec4b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c66553e2559eebfe4f98c0c7ec4b08">&#9670;&nbsp;</a></span>bugMsg1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::bugMsg1 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00082">82</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;{</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#a897b10d246533c95ba86cb79f92e465a">KYEL</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;}</div><div class="ttc" id="SVFUtil_8cpp_html_a897b10d246533c95ba86cb79f92e465a"><div class="ttname"><a href="SVFUtil_8cpp.html#a897b10d246533c95ba86cb79f92e465a">KYEL</a></div><div class="ttdeci">#define KYEL</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00044">SVFUtil.cpp:44</a></div></div>
<div class="ttc" id="SVFUtil_8cpp_html_a137aa83ec74421d226a90c92ec032ac9"><div class="ttname"><a href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a></div><div class="ttdeci">#define KNRM</div><div class="ttdoc">Color for output format. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00041">SVFUtil.cpp:41</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a054c3e668ce8b265bbc5d923f6243ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054c3e668ce8b265bbc5d923f6243ce7">&#9670;&nbsp;</a></span>bugMsg2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::bugMsg2 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00087">87</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;{</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#a326cbc9ef8d75aa44a591bf476c9835b">KPUR</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;}</div><div class="ttc" id="SVFUtil_8cpp_html_a137aa83ec74421d226a90c92ec032ac9"><div class="ttname"><a href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a></div><div class="ttdeci">#define KNRM</div><div class="ttdoc">Color for output format. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00041">SVFUtil.cpp:41</a></div></div>
<div class="ttc" id="SVFUtil_8cpp_html_a326cbc9ef8d75aa44a591bf476c9835b"><div class="ttname"><a href="SVFUtil_8cpp.html#a326cbc9ef8d75aa44a591bf476c9835b">KPUR</a></div><div class="ttdeci">#define KPUR</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00046">SVFUtil.cpp:46</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aabbca7c40d2da6bd2374ea53d5de0553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbca7c40d2da6bd2374ea53d5de0553">&#9670;&nbsp;</a></span>bugMsg3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::bugMsg3 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00092">92</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;{</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#add84f76d7bfbbc2b00215d7195f8d3bd">KCYA</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;}</div><div class="ttc" id="SVFUtil_8cpp_html_a137aa83ec74421d226a90c92ec032ac9"><div class="ttname"><a href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a></div><div class="ttdeci">#define KNRM</div><div class="ttdoc">Color for output format. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00041">SVFUtil.cpp:41</a></div></div>
<div class="ttc" id="SVFUtil_8cpp_html_add84f76d7bfbbc2b00215d7195f8d3bd"><div class="ttname"><a href="SVFUtil_8cpp.html#add84f76d7bfbbc2b00215d7195f8d3bd">KCYA</a></div><div class="ttdeci">#define KCYA</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00047">SVFUtil.cpp:47</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d100868bf63b968d387eb50e9603f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d100868bf63b968d387eb50e9603f7c">&#9670;&nbsp;</a></span>cast() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a>&lt;Y&gt;::value, typename <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, const Y&gt;::ret_type&gt;::type SVF::SVFUtil::cast </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00297">297</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;{</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(llvm::isa&lt;X&gt;(Val) &amp;&amp; <span class="stringliteral">&quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;</span>);</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    <span class="keywordflow">return</span> cast_convert_val&lt;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;           X, <span class="keyword">const</span> Y, <span class="keyword">typename</span> simplify_type&lt;const Y&gt;::SimpleType&gt;::doit(Val);</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;}</div><div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a406dd9baf2ce66235d482fd6c6121b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406dd9baf2ce66235d482fd6c6121b2c">&#9670;&nbsp;</a></span>cast() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, Y&gt;::ret_type SVF::SVFUtil::cast </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00305">305</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;{</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(llvm::isa&lt;X&gt;(Val) &amp;&amp; <span class="stringliteral">&quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;</span>);</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    <span class="keywordflow">return</span> cast_convert_val&lt;X, Y,</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;           <span class="keyword">typename</span> simplify_type&lt;Y&gt;::SimpleType&gt;::doit(Val);</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;}</div><div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acc2419a55c0427571f11ad14db2fe481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2419a55c0427571f11ad14db2fe481">&#9670;&nbsp;</a></span>cast() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, Y *&gt;::ret_type SVF::SVFUtil::cast </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00313">313</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;{</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(llvm::isa&lt;X&gt;(Val) &amp;&amp; <span class="stringliteral">&quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;</span>);</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <span class="keywordflow">return</span> cast_convert_val&lt;X, Y*,</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;           <span class="keyword">typename</span> simplify_type&lt;Y*&gt;::SimpleType&gt;::doit(Val);</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;}</div><div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af3ca049b4ce83c874e231f5e13bf36a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ca049b4ce83c874e231f5e13bf36a8">&#9670;&nbsp;</a></span>cast() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, std::unique_ptr&lt;Y&gt; &gt;::ret_type SVF::SVFUtil::cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Y &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00322">322</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;{</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(llvm::isa&lt;X&gt;(Val.get()) &amp;&amp; <span class="stringliteral">&quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;</span>);</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    <span class="keyword">using</span> ret_type = <span class="keyword">typename</span> cast_retty&lt;X, std::unique_ptr&lt;Y&gt;&gt;::ret_type;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    <span class="keywordflow">return</span> ret_type(</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;               cast_convert_val&lt;X, Y *, <span class="keyword">typename</span> simplify_type&lt;Y *&gt;::SimpleType&gt;::doit(</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;                   Val.release()));</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;}</div><div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8f749354b7e882ef3e5bf5081fa715b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f749354b7e882ef3e5bf5081fa715b5">&#9670;&nbsp;</a></span>cmpNodeBS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::cmpNodeBS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>lpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>rpts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00123">123</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;{</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="keywordflow">if</span> (lpts.count() != rpts.count())</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="keywordflow">return</span> (lpts.count() &lt; rpts.count());</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    {</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        NodeBS::iterator bit = lpts.begin(), eit = lpts.end();</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        NodeBS::iterator rbit = rpts.begin(), reit = rpts.end();</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        <span class="keywordflow">for</span> (; bit != eit &amp;&amp; rbit != reit; bit++, rbit++)</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        {</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;            <span class="keywordflow">if</span> (*bit != *rbit)</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                <span class="keywordflow">return</span> (*bit &lt; *rbit);</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        }</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    }</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aa5ce14119a6e3b0b6022753ddd5890f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ce14119a6e3b0b6022753ddd5890f3">&#9670;&nbsp;</a></span>cmpPts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::cmpPts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;&#160;</td>
          <td class="paramname"><em>lpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;&#160;</td>
          <td class="paramname"><em>rpts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare two <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> according to their size and points-to elements.</p><ol type="1">
<li><a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> with smaller size is smaller than the other;</li>
<li>If the sizes are equal, comparing the points-to targets. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00105">105</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;{</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keywordflow">if</span> (lpts.count() != rpts.count())</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        <span class="keywordflow">return</span> (lpts.count() &lt; rpts.count());</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    {</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        PointsTo::iterator bit = lpts.begin(), eit = lpts.end();</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        PointsTo::iterator rbit = rpts.begin(), reit = rpts.end();</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        <span class="keywordflow">for</span> (; bit != eit &amp;&amp; rbit != reit; bit++, rbit++)</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        {</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;            <span class="keywordflow">if</span> (*bit != *rbit)</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                <span class="keywordflow">return</span> (*bit &lt; *rbit);</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        }</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    }</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a4a15cc5570eed12dd6ee766213e11d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a15cc5570eed12dd6ee766213e11d61">&#9670;&nbsp;</a></span>dumpAliasSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpAliasSet </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a>&#160;</td>
          <td class="paramname"><em>bs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump alias set. </p>
<p>Dump alias set </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00138">138</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;{</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;node &quot;</span> &lt;&lt; node &lt;&lt; <span class="stringliteral">&quot; alias set: {&quot;</span>;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a>(bs);</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aeb570e9267fd7b189bd1bc877896d7ab"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">SVF::SVFUtil::dumpSet</a></div><div class="ttdeci">void dumpSet(NodeBS To, OutStream &amp;O=SVFUtil::outs())</div><div class="ttdoc">Dump sparse bitvector set. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00148">SVFUtil.cpp:148</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aed0b0b9f035057552a6a82154fd88e61"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVF::SVFUtil::outs</a></div><div class="ttdeci">std::ostream &amp; outs()</div><div class="ttdoc">Overwrite llvm::outs() </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00049">SVFUtil.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af4ceddbe4d57b24e80201bc895f73810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ceddbe4d57b24e80201bc895f73810">&#9670;&nbsp;</a></span>dumpPointsToList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpPointsToList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">PointsToList</a> &amp;&#160;</td>
          <td class="paramname"><em>ptl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00123">123</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;{</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;{&quot;</span>;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="keywordflow">for</span> (PointsToList::const_iterator ii = ptl.begin(), ie = ptl.end();</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;            ii != ie; ii++)</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    {</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <span class="keyword">auto</span> bs = *ii;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        <a class="code" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a>(bs);</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    }</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aeb570e9267fd7b189bd1bc877896d7ab"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">SVF::SVFUtil::dumpSet</a></div><div class="ttdeci">void dumpSet(NodeBS To, OutStream &amp;O=SVFUtil::outs())</div><div class="ttdoc">Dump sparse bitvector set. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00148">SVFUtil.cpp:148</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aed0b0b9f035057552a6a82154fd88e61"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVF::SVFUtil::outs</a></div><div class="ttdeci">std::ostream &amp; outs()</div><div class="ttdoc">Overwrite llvm::outs() </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00049">SVFUtil.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abd0a9ee845a455f9354d24a8b84a0bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0a9ee845a455f9354d24a8b84a0bb3">&#9670;&nbsp;</a></span>dumpPointsToSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpPointsToSet </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a>&#160;</td>
          <td class="paramname"><em>bs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump points-to set. </p>
<p>Dump points-to set </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00108">108</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;{</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;node &quot;</span> &lt;&lt; node &lt;&lt; <span class="stringliteral">&quot; points-to: {&quot;</span>;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a>(bs);</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aeb570e9267fd7b189bd1bc877896d7ab"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">SVF::SVFUtil::dumpSet</a></div><div class="ttdeci">void dumpSet(NodeBS To, OutStream &amp;O=SVFUtil::outs())</div><div class="ttdoc">Dump sparse bitvector set. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00148">SVFUtil.cpp:148</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aed0b0b9f035057552a6a82154fd88e61"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVF::SVFUtil::outs</a></div><div class="ttdeci">std::ostream &amp; outs()</div><div class="ttdoc">Overwrite llvm::outs() </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00049">SVFUtil.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb570e9267fd7b189bd1bc877896d7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb570e9267fd7b189bd1bc877896d7ab">&#9670;&nbsp;</a></span>dumpSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a>&#160;</td>
          <td class="paramname"><em>bs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;&#160;</td>
          <td class="paramname"><em>O</em> = <code><a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump sparse bitvector set. </p>
<p>Dump bit vector set </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00148">148</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;{</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="keywordflow">for</span> (NodeBS::iterator ii = bs.begin(), ie = bs.end();</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;            ii != ie; ii++)</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    {</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        O &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *ii &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    }</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a04aa23b4982662d98c56af3e8ba16cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04aa23b4982662d98c56af3e8ba16cb1">&#9670;&nbsp;</a></span>dumpSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a>&#160;</td>
          <td class="paramname"><em>To</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;&#160;</td>
          <td class="paramname"><em>O</em> = <code><a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00157">157</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;{</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> n : pt)</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    {</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        o &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    }</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a43a65e0d33af3c743294f7a1139d2301"><div class="ttname"><a href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">SVF::NodeID</a></div><div class="ttdeci">unsigned NodeID</div><div class="ttdef"><b>Definition:</b> <a href="MTAResultValidator_8h_source.html#l00019">MTAResultValidator.h:19</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab30a35713852a0a525c52ae5dd463442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30a35713852a0a525c52ae5dd463442">&#9670;&nbsp;</a></span>dumpSparseSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpSparseSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>To</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00116">116</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;{</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;{&quot;</span>;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a>(bs);</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aeb570e9267fd7b189bd1bc877896d7ab"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">SVF::SVFUtil::dumpSet</a></div><div class="ttdeci">void dumpSet(NodeBS To, OutStream &amp;O=SVFUtil::outs())</div><div class="ttdoc">Dump sparse bitvector set. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00148">SVFUtil.cpp:148</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aed0b0b9f035057552a6a82154fd88e61"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVF::SVFUtil::outs</a></div><div class="ttdeci">std::ostream &amp; outs()</div><div class="ttdoc">Overwrite llvm::outs() </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00049">SVFUtil.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8182be247907420db00837cef9bcfa70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8182be247907420db00837cef9bcfa70">&#9670;&nbsp;</a></span>dyn_cast() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD std::enable_if&lt;!<a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a>&lt;Y&gt;::value, typename <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, const Y&gt;::ret_type&gt;::type SVF::SVFUtil::dyn_cast </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00343">343</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;{</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    <span class="keywordflow">return</span> llvm::isa&lt;X&gt;(Val) ? llvm::cast&lt;X&gt;(Val) : nullptr;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a52d852ba8fa569e858565b3bba403656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d852ba8fa569e858565b3bba403656">&#9670;&nbsp;</a></span>dyn_cast() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, Y&gt;::ret_type SVF::SVFUtil::dyn_cast </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00349">349</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;{</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    <span class="keywordflow">return</span> llvm::isa&lt;X&gt;(Val) ? llvm::cast&lt;X&gt;(Val) : nullptr;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a105c5c5e97d56533fb2b3ba7a0bc59f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105c5c5e97d56533fb2b3ba7a0bc59f3">&#9670;&nbsp;</a></span>dyn_cast() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, Y *&gt;::ret_type SVF::SVFUtil::dyn_cast </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00355">355</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;{</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    <span class="keywordflow">return</span> llvm::isa&lt;X&gt;(Val) ? llvm::cast&lt;X&gt;(Val) : nullptr;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5d4bb92f5df30417f414397f8e58cf01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4bb92f5df30417f414397f8e58cf01">&#9670;&nbsp;</a></span>errMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::errMsg </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print error message by converting a string into red string output. </p>
<p>print error message by converting a string into red string output </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00077">77</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;{</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#a66290957baed5df3930ada4cb8caccf1">KRED</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;}</div><div class="ttc" id="SVFUtil_8cpp_html_a66290957baed5df3930ada4cb8caccf1"><div class="ttname"><a href="SVFUtil_8cpp.html#a66290957baed5df3930ada4cb8caccf1">KRED</a></div><div class="ttdeci">#define KRED</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00042">SVFUtil.cpp:42</a></div></div>
<div class="ttc" id="SVFUtil_8cpp_html_a137aa83ec74421d226a90c92ec032ac9"><div class="ttname"><a href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a></div><div class="ttdeci">#define KNRM</div><div class="ttdoc">Color for output format. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00041">SVFUtil.cpp:41</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab65033f068bfbeb0a1c52dcec3beb6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65033f068bfbeb0a1c52dcec3beb6bc">&#9670;&nbsp;</a></span>errs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; SVF::SVFUtil::errs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrite <a class="el" href="namespaceSVF_1_1SVFUtil.html#ab65033f068bfbeb0a1c52dcec3beb6bc" title="Overwrite llvm::errs() ">llvm::errs()</a> </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00055">55</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;{</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="keywordflow">return</span> std::cerr;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ac3e7507fb376b1625bc1573132ab9f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e7507fb376b1625bc1573132ab9f06">&#9670;&nbsp;</a></span>extCallTy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSVF_1_1ExtAPI.html#aaf94c82d98f8ed1514ee49c9881a4094">ExtAPI::extf_t</a> SVF::SVFUtil::extCallTy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return external call type. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00409">409</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;{</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    <span class="keywordflow">return</span> ExtAPI::getExtAPI()-&gt;get_type(fun);</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a7a7e06e90a215086696effb5f5537baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7e06e90a215086696effb5f5537baf">&#9670;&nbsp;</a></span>functionDoesNotRet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::functionDoesNotRet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the function has a return instruction reachable from function entry. </p>
<p>Return true if the function has a return instruction reachable from function entry </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00123">123</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;{</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    std::vector&lt;const BasicBlock*&gt; bbVec;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <a class="code" href="namespaceSVF.html#af739db846e47ba6b2fd15eaad31ab7fb">Set&lt;const BasicBlock*&gt;</a> visited;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    bbVec.push_back(&amp;fun-&gt;getEntryBlock());</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    <span class="keywordflow">while</span>(!bbVec.empty())</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    {</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a>* bb = bbVec.back();</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        bbVec.pop_back();</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        <span class="keywordflow">for</span> (BasicBlock::const_iterator it = bb-&gt;begin(), eit = bb-&gt;end();</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                it != eit; ++it)</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        {</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;            <span class="keywordflow">if</span>(SVFUtil::isa&lt;ReturnInst&gt;(*it))</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        }</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="namespaceSVF.html#a3436a988bf80c021cd8022fb445b66d5">succ_const_iterator</a> sit = succ_begin(bb), esit = succ_end(bb);</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                sit != esit; ++sit)</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        {</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;            <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a>* succbb = (*sit);</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;            <span class="keywordflow">if</span>(visited.find(succbb)==visited.end())</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                visited.insert(succbb);</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;            bbVec.push_back(succbb);</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        }</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    }</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment">//    if(isProgEntryFunction(fun)==false) {</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment">//        writeWrnMsg(fun-&gt;getName().str() + &quot; does not have return&quot;);</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment">//    }</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a23bf614858f168b6ad76e0233cec9965"><div class="ttname"><a href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">SVF::BasicBlock</a></div><div class="ttdeci">llvm::BasicBlock BasicBlock</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00071">BasicTypes.h:71</a></div></div>
<div class="ttc" id="namespaceSVF_html_a3436a988bf80c021cd8022fb445b66d5"><div class="ttname"><a href="namespaceSVF.html#a3436a988bf80c021cd8022fb445b66d5">SVF::succ_const_iterator</a></div><div class="ttdeci">llvm::succ_const_iterator succ_const_iterator</div><div class="ttdoc">LLVM Iterators. </div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00119">BasicTypes.h:119</a></div></div>
<div class="ttc" id="namespaceSVF_html_af739db846e47ba6b2fd15eaad31ab7fb"><div class="ttname"><a href="namespaceSVF.html#af739db846e47ba6b2fd15eaad31ab7fb">SVF::Set</a></div><div class="ttdeci">std::unordered_set&lt; Key, Hash, KeyEqual, Allocator &gt; Set</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00104">SVFBasicTypes.h:104</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aaeeb386d80b51d729322317065606454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeeb386d80b51d729322317065606454">&#9670;&nbsp;</a></span>getActualParmAtForkSite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getActualParmAtForkSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return sole argument of the thread routine. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00683">683</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;{</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getActualParmAtForkSite(cs);</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a01119ea4e3a10ebecdef4d390a1c4c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01119ea4e3a10ebecdef4d390a1c4c88">&#9670;&nbsp;</a></span>getActualParmAtForkSite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getActualParmAtForkSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00687">687</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;{</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getActualParmAtForkSite(inst);</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a0e78b0b6593209d78fae1dd0a5469463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e78b0b6593209d78fae1dd0a5469463">&#9670;&nbsp;</a></span>getBBPredecessorNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> SVF::SVFUtil::getBBPredecessorNum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *&#160;</td>
          <td class="paramname"><em>BB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get num of BB's predecessors. </p>
<p>Get the num of BB's predecessors </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00397">397</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;{</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    <a class="code" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> num = 0;</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="SVF-FE_2BasicTypes_8h.html#a45136b941670180e9ba248bb4e52f09f">const_pred_iterator</a> it = pred_begin(BB), et = pred_end(BB); it != et; ++it)</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        num++;</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="keywordflow">return</span> num;</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_ad42bff8d0a7d60a085aa32d10f4955af"><div class="ttname"><a href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">SVF::u32_t</a></div><div class="ttdeci">unsigned u32_t</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00084">SVFBasicTypes.h:84</a></div></div>
<div class="ttc" id="SVF-FE_2BasicTypes_8h_html_a45136b941670180e9ba248bb4e52f09f"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#a45136b941670180e9ba248bb4e52f09f">const_pred_iterator</a></div><div class="ttdeci">llvm::const_pred_iterator const_pred_iterator</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00114">BasicTypes.h:114</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae40e2e043b04ede541688ce61048fb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40e2e043b04ede541688ce61048fb4e">&#9670;&nbsp;</a></span>getBBPredecessorPos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> SVF::SVFUtil::getBBPredecessorPos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *&#160;</td>
          <td class="paramname"><em>succbb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get basic block predecessor positin. </p>
<p>Return a position index from current bb to it successor bb </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00374">374</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;{</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    <a class="code" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> pos = 0;</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="SVF-FE_2BasicTypes_8h.html#a45136b941670180e9ba248bb4e52f09f">const_pred_iterator</a> it = pred_begin(succbb), et = pred_end(succbb); it != et; ++it, ++pos)</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    {</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        <span class="keywordflow">if</span>(*it==bb)</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;            <span class="keywordflow">return</span> pos;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    }</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Didn&#39;t find predecessor edge?&quot;</span>);</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    <span class="keywordflow">return</span> pos;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;}</div><div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
<div class="ttc" id="namespaceSVF_html_ad42bff8d0a7d60a085aa32d10f4955af"><div class="ttname"><a href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">SVF::u32_t</a></div><div class="ttdeci">unsigned u32_t</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00084">SVFBasicTypes.h:84</a></div></div>
<div class="ttc" id="SVF-FE_2BasicTypes_8h_html_a45136b941670180e9ba248bb4e52f09f"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#a45136b941670180e9ba248bb4e52f09f">const_pred_iterator</a></div><div class="ttdeci">llvm::const_pred_iterator const_pred_iterator</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00114">BasicTypes.h:114</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a737684498679dc16a26f2411d88f36aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737684498679dc16a26f2411d88f36aa">&#9670;&nbsp;</a></span>getBBSuccessorNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> SVF::SVFUtil::getBBSuccessorNum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *&#160;</td>
          <td class="paramname"><em>BB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get num of BB's successors. </p>
<p>Get the num of BB's successors </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00389">389</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;{</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    <span class="keywordflow">return</span> BB-&gt;getTerminator()-&gt;getNumSuccessors();</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a1631bbbed23fbfe2204779ecc0dc2769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1631bbbed23fbfe2204779ecc0dc2769">&#9670;&nbsp;</a></span>getBBSuccessorPos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> SVF::SVFUtil::getBBSuccessorPos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *&#160;</td>
          <td class="paramname"><em>BB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *&#160;</td>
          <td class="paramname"><em>Succ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get basic block successor position. </p>
<p>Get position of a successor basic block </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00357">357</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;{</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <a class="code" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> i = 0;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *SuccBB: successors(BB))</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    {</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;        <span class="keywordflow">if</span> (SuccBB == Succ)</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;            <span class="keywordflow">return</span> i;</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        i++;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    }</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Didn&#39;t find succesor edge?&quot;</span>);</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a23bf614858f168b6ad76e0233cec9965"><div class="ttname"><a href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">SVF::BasicBlock</a></div><div class="ttdeci">llvm::BasicBlock BasicBlock</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00071">BasicTypes.h:71</a></div></div>
<div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
<div class="ttc" id="namespaceSVF_html_ad42bff8d0a7d60a085aa32d10f4955af"><div class="ttname"><a href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">SVF::u32_t</a></div><div class="ttdeci">unsigned u32_t</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00084">SVFBasicTypes.h:84</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a145abbd2958629718fbca41d25c3124d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145abbd2958629718fbca41d25c3124d">&#9670;&nbsp;</a></span>getCallee() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a>* SVF::SVFUtil::getCallee </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return callee of a callsite. Return null if this is an indirect call. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00281">281</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;{</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="comment">// FIXME: do we need to strip-off the casts here to discover more library functions</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    <a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *callee = <a class="code" href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVFUtil::dyn_cast</a>&lt;<a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a>&gt;(cs.getCalledValue()-&gt;stripPointerCasts());</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a142e650415cb81011eb59dadd3cb0637">getDefFunForMultipleModule</a>(callee);</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a142e650415cb81011eb59dadd3cb0637"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a142e650415cb81011eb59dadd3cb0637">SVF::SVFUtil::getDefFunForMultipleModule</a></div><div class="ttdeci">const SVFFunction * getDefFunForMultipleModule(const Function *fun)</div><div class="ttdoc">Get the definition of a function across multiple modules. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00269">SVFUtil.h:269</a></div></div>
<div class="ttc" id="namespaceSVF_html_a5faee14fa1dd41447bc73ac365fe33c1"><div class="ttname"><a href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">SVF::Function</a></div><div class="ttdeci">llvm::Function Function</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00070">BasicTypes.h:70</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a8182be247907420db00837cef9bcfa70"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVF::SVFUtil::dyn_cast</a></div><div class="ttdeci">LLVM_NODISCARD std::enable_if&lt;!is_simple_type&lt; Y &gt;::value, typename cast_retty&lt; X, const Y &gt;::ret_type &gt;::type dyn_cast(const Y &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="Casting_8h_source.html#l00343">Casting.h:343</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af26c7636bfef7ab2a36cccdcf12c3538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26c7636bfef7ab2a36cccdcf12c3538">&#9670;&nbsp;</a></span>getCallee() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a>* SVF::SVFUtil::getCallee </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00288">288</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;{</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">isCallSite</a>(inst))</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    CallSite cs(const_cast&lt;Instruction*&gt;(inst));</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs);</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a38bf8f7eaa18fc5a09711959b5417854"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">SVF::SVFUtil::isCallSite</a></div><div class="ttdeci">bool isCallSite(const Value *val)</div><div class="ttdoc">Whether an instruction is a call or invoke instruction. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00201">SVFUtil.h:201</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abe0dde753f9f79e30296208eb4d97eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0dde753f9f79e30296208eb4d97eed">&#9670;&nbsp;</a></span>getDataLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="SVF-FE_2BasicTypes_8h.html#aa81a27b9c6b2a354437417162220fb14">DataLayout</a>* SVF::SVFUtil::getDataLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aa7a770b5dd5cd0e37d06a1088f252906">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00280">280</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;{</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    <span class="keyword">static</span> <a class="code" href="SVF-FE_2BasicTypes_8h.html#aa81a27b9c6b2a354437417162220fb14">DataLayout</a> *dl = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="keywordflow">if</span> (dl == <span class="keyword">nullptr</span>) dl = <span class="keyword">new</span> <a class="code" href="SVF-FE_2BasicTypes_8h.html#aa81a27b9c6b2a354437417162220fb14">DataLayout</a>(mod);</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    <span class="keywordflow">return</span> dl;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;}</div><div class="ttc" id="SVF-FE_2BasicTypes_8h_html_aa81a27b9c6b2a354437417162220fb14"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#aa81a27b9c6b2a354437417162220fb14">DataLayout</a></div><div class="ttdeci">llvm::DataLayout DataLayout</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00051">BasicTypes.h:51</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a142e650415cb81011eb59dadd3cb0637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142e650415cb81011eb59dadd3cb0637">&#9670;&nbsp;</a></span>getDefFunForMultipleModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a>* SVF::SVFUtil::getDefFunForMultipleModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the definition of a function across multiple modules. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00269">269</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;{</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    <span class="keywordflow">if</span>(fun == <span class="keyword">nullptr</span>) <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    LLVMModuleSet* llvmModuleset = LLVMModuleSet::getLLVMModuleSet();</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    <span class="keyword">const</span> SVFFunction* svfFun = llvmModuleset-&gt;getSVFFunction(fun);</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    <span class="keywordflow">if</span> (fun-&gt;isDeclaration() &amp;&amp; llvmModuleset-&gt;hasDefinition(fun))</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;        svfFun = LLVMModuleSet::getLLVMModuleSet()-&gt;getDefinition(fun);</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    <span class="keywordflow">return</span> svfFun;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ac840e43fa58a90099de99a1953f091ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac840e43fa58a90099de99a1953f091ac">&#9670;&nbsp;</a></span>getForkedFun() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getForkedFun </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return thread fork function. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00467">467</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;{</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getForkedFun(cs);</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a4cc8c549625712e006079642c656ec83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc8c549625712e006079642c656ec83">&#9670;&nbsp;</a></span>getForkedFun() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getForkedFun </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00471">471</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;{</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getForkedFun(inst);</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aa09c2b313ff1c1abcc1e5cb3f9ef46a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09c2b313ff1c1abcc1e5cb3f9ef46a5">&#9670;&nbsp;</a></span>getFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a>* SVF::SVFUtil::getFunction </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the corresponding Function based on its name. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00225">225</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;{</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    <a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a>* fun = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    LLVMModuleSet* llvmModuleset = LLVMModuleSet::getLLVMModuleSet();</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> i = 0; i &lt; llvmModuleset-&gt;getModuleNum(); ++i)</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    {</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <a class="code" href="namespaceSVF.html#aa7a770b5dd5cd0e37d06a1088f252906">Module</a> *mod = llvmModuleset-&gt;getModule(i);</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        fun = mod-&gt;getFunction(name);</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="keywordflow">if</span>(fun)</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        {</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            <span class="keywordflow">return</span> llvmModuleset-&gt;getSVFFunction(fun);</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        }</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    }</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_aa7a770b5dd5cd0e37d06a1088f252906"><div class="ttname"><a href="namespaceSVF.html#aa7a770b5dd5cd0e37d06a1088f252906">SVF::Module</a></div><div class="ttdeci">llvm::Module Module</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00077">BasicTypes.h:77</a></div></div>
<div class="ttc" id="namespaceSVF_html_ad42bff8d0a7d60a085aa32d10f4955af"><div class="ttname"><a href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">SVF::u32_t</a></div><div class="ttdeci">unsigned u32_t</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00084">SVFBasicTypes.h:84</a></div></div>
<div class="ttc" id="namespaceSVF_html_a5faee14fa1dd41447bc73ac365fe33c1"><div class="ttname"><a href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">SVF::Function</a></div><div class="ttdeci">llvm::Function Function</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00070">BasicTypes.h:70</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3cb226930eeaf558575e09e5b65e0223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb226930eeaf558575e09e5b65e0223">&#9670;&nbsp;</a></span>getFunExitBB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a>* SVF::SVFUtil::getFunExitBB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get function exit basic block FIXME: this back() here is only valid when UnifyFunctionExitNodes pass is invoked </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00167">167</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;{</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    <span class="keywordflow">return</span> &amp;fun-&gt;back();</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a61b29238f1f32978c7b6aded4b73244d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b29238f1f32978c7b6aded4b73244d">&#9670;&nbsp;</a></span>getFunReachableBBs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::getFunReachableBBs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aecbb42b8e9d17fa0189c50dda9fd5fdd">DominatorTree</a> *&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>reachableBBs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get reachable basic block from function entry. </p>
<p>Return reachable bbs from function entry </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00094">94</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;{</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <a class="code" href="namespaceSVF.html#af739db846e47ba6b2fd15eaad31ab7fb">Set&lt;const BasicBlock*&gt;</a> visited;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    std::vector&lt;const BasicBlock*&gt; bbVec;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    bbVec.push_back(&amp;fun-&gt;getEntryBlock());</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keywordflow">while</span>(!bbVec.empty())</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    {</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a>* bb = bbVec.back();</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        bbVec.pop_back();</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        reachableBBs.push_back(bb);</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="namespaceSVF.html#a827d09974dc7bf0849f96823cc2fee89">DomTreeNode</a> *dtNode = dt-&gt;getNode(const_cast&lt;BasicBlock*&gt;(bb)))</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        {</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;            <span class="keywordflow">for</span> (DomTreeNode::iterator DI = dtNode-&gt;begin(), DE = dtNode-&gt;end();</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                    DI != DE; ++DI)</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            {</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a>* succbb = (*DI)-&gt;getBlock();</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                <span class="keywordflow">if</span>(visited.find(succbb)==visited.end())</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                    visited.insert(succbb);</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;                <span class="keywordflow">else</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;                bbVec.push_back(succbb);</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;            }</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        }</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    }</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a23bf614858f168b6ad76e0233cec9965"><div class="ttname"><a href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">SVF::BasicBlock</a></div><div class="ttdeci">llvm::BasicBlock BasicBlock</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00071">BasicTypes.h:71</a></div></div>
<div class="ttc" id="namespaceSVF_html_a827d09974dc7bf0849f96823cc2fee89"><div class="ttname"><a href="namespaceSVF.html#a827d09974dc7bf0849f96823cc2fee89">SVF::DomTreeNode</a></div><div class="ttdeci">llvm::DomTreeNode DomTreeNode</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00112">BasicTypes.h:112</a></div></div>
<div class="ttc" id="namespaceSVF_html_af739db846e47ba6b2fd15eaad31ab7fb"><div class="ttname"><a href="namespaceSVF.html#af739db846e47ba6b2fd15eaad31ab7fb">SVF::Set</a></div><div class="ttdeci">std::unordered_set&lt; Key, Hash, KeyEqual, Allocator &gt; Set</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00104">SVFBasicTypes.h:104</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4b55d5252da1f316f505cf6ce2078b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b55d5252da1f316f505cf6ce2078b28">&#9670;&nbsp;</a></span>getGlobalRep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getGlobalRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the unique defined global across multiple modules </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00258">258</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;{</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a09f5fa3bc44bf53612a085e3a611cc4e">GlobalVariable</a>* gvar = SVFUtil::dyn_cast&lt;GlobalVariable&gt;(val))</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    {</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        <span class="keywordflow">if</span> (LLVMModuleSet::getLLVMModuleSet()-&gt;hasGlobalRep(gvar))</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;            val = LLVMModuleSet::getLLVMModuleSet()-&gt;getGlobalRep(gvar);</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    }</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    <span class="keywordflow">return</span> val;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a09f5fa3bc44bf53612a085e3a611cc4e"><div class="ttname"><a href="namespaceSVF.html#a09f5fa3bc44bf53612a085e3a611cc4e">SVF::GlobalVariable</a></div><div class="ttdeci">llvm::GlobalVariable GlobalVariable</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00076">BasicTypes.h:76</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a73215bac62f1340a58f6c7f2ba9b0e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73215bac62f1340a58f6c7f2ba9b0e7b">&#9670;&nbsp;</a></span>getHeapAllocHoldingArgPosition() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SVF::SVFUtil::getHeapAllocHoldingArgPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the position of argument that holds an allocated heap object. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00379">379</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;{</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    <span class="keywordflow">return</span> ExtAPI::getExtAPI()-&gt;get_alloc_arg_pos(fun);</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a298b6366145ed871faf3d01420ae5d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298b6366145ed871faf3d01420ae5d20">&#9670;&nbsp;</a></span>getHeapAllocHoldingArgPosition() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SVF::SVFUtil::getHeapAllocHoldingArgPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00536">536</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;{</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a5af986a7698e72272707cc2a466d5ae7">getHeapAllocHoldingArgPosition</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs));</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a5af986a7698e72272707cc2a466d5ae7"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a5af986a7698e72272707cc2a466d5ae7">SVF::SVFUtil::getHeapAllocHoldingArgPosition</a></div><div class="ttdeci">int getHeapAllocHoldingArgPosition(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00541">SVFUtil.h:541</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5af986a7698e72272707cc2a466d5ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af986a7698e72272707cc2a466d5ae7">&#9670;&nbsp;</a></span>getHeapAllocHoldingArgPosition() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SVF::SVFUtil::getHeapAllocHoldingArgPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00541">541</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;{</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a5af986a7698e72272707cc2a466d5ae7">getHeapAllocHoldingArgPosition</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(inst));</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a5af986a7698e72272707cc2a466d5ae7"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a5af986a7698e72272707cc2a466d5ae7">SVF::SVFUtil::getHeapAllocHoldingArgPosition</a></div><div class="ttdeci">int getHeapAllocHoldingArgPosition(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00541">SVFUtil.h:541</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a202de7ad2bea0311e2f75894c030e7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202de7ad2bea0311e2f75894c030e7a9">&#9670;&nbsp;</a></span>getLLVMCallSite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSVF_1_1CallSite.html">CallSite</a> SVF::SVFUtil::getLLVMCallSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return LLVM callsite given a instruction. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00217">217</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;{</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">isCallSite</a>(inst) &amp;&amp; <span class="stringliteral">&quot;not a callsite?&quot;</span>);</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    CallSite cs(const_cast&lt;Instruction*&gt;(inst));</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    <span class="keywordflow">return</span> cs;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;}</div><div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a38bf8f7eaa18fc5a09711959b5417854"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">SVF::SVFUtil::isCallSite</a></div><div class="ttdeci">bool isCallSite(const Value *val)</div><div class="ttdoc">Whether an instruction is a call or invoke instruction. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00201">SVFUtil.h:201</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad98299033577f1e7f4e9bc73dff3b253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98299033577f1e7f4e9bc73dff3b253">&#9670;&nbsp;</a></span>getLLVMFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a>* SVF::SVFUtil::getLLVMFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return LLVM function if this value is. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00486">486</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;{</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *fun = <a class="code" href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVFUtil::dyn_cast</a>&lt;<a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a>&gt;(val-&gt;stripPointerCasts());</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    <span class="keywordflow">return</span> fun;</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a5faee14fa1dd41447bc73ac365fe33c1"><div class="ttname"><a href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">SVF::Function</a></div><div class="ttdeci">llvm::Function Function</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00070">BasicTypes.h:70</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a8182be247907420db00837cef9bcfa70"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVF::SVFUtil::dyn_cast</a></div><div class="ttdeci">LLVM_NODISCARD std::enable_if&lt;!is_simple_type&lt; Y &gt;::value, typename cast_retty&lt; X, const Y &gt;::ret_type &gt;::type dyn_cast(const Y &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="Casting_8h_source.html#l00343">Casting.h:343</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a630ff9c47f58f9b8df7c8a2b3711477c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630ff9c47f58f9b8df7c8a2b3711477c">&#9670;&nbsp;</a></span>getMemoryUsageKB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::getMemoryUsageKB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *&#160;</td>
          <td class="paramname"><em>vmrss_kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *&#160;</td>
          <td class="paramname"><em>vmsize_kb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get memory usage from system file. Return TRUE if succeed. </p>
<p>Get memory usage </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00178">178</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;{</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="comment">/* Get the the current process&#39; status file from the proc filesystem */</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <span class="keywordtype">char</span> buffer[8192];</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    FILE* procfile = fopen(<span class="stringliteral">&quot;/proc/self/status&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    <span class="keywordflow">if</span>(procfile)</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    {</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <a class="code" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> <a class="code" href="cuddInt_8c.html#a8b2e13c78efca330f06b6ddcd7464b41">result</a> = fread(buffer, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), 8192, procfile);</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        <span class="keywordflow">if</span> (result == 0)</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        {</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;            fputs (<span class="stringliteral">&quot;Reading error\n&quot;</span>,stderr);</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        }</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    }</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    {</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        fputs (<span class="stringliteral">&quot;/proc/self/status file not exit\n&quot;</span>,stderr);</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    }</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    fclose(procfile);</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="comment">/* Look through proc status contents line by line */</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="keywordtype">char</span> delims[] = <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="keywordtype">char</span>* line = <a class="code" href="util_8h.html#a8bf943e1f78acc0236f9075a94765663">strtok</a>(buffer, delims);</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    <span class="keywordtype">bool</span> found_vmrss = <span class="keyword">false</span>;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    <span class="keywordtype">bool</span> found_vmsize = <span class="keyword">false</span>;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <span class="keywordflow">while</span> (line != <span class="keyword">nullptr</span> &amp;&amp; (found_vmrss == <span class="keyword">false</span> || found_vmsize == <span class="keyword">false</span>))</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    {</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="util_8h.html#aaaaf5365ac473a2e91c3326c08d4eeb2">strstr</a>(line, <span class="stringliteral">&quot;VmRSS:&quot;</span>) != <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        {</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;            sscanf(line, <span class="stringliteral">&quot;%*s %u&quot;</span>, vmrss_kb);</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            found_vmrss = <span class="keyword">true</span>;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        }</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="util_8h.html#aaaaf5365ac473a2e91c3326c08d4eeb2">strstr</a>(line, <span class="stringliteral">&quot;VmSize:&quot;</span>) != <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        {</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;            sscanf(line, <span class="stringliteral">&quot;%*s %u&quot;</span>, vmsize_kb);</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;            found_vmsize = <span class="keyword">true</span>;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        }</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        line = <a class="code" href="util_8h.html#a8bf943e1f78acc0236f9075a94765663">strtok</a>(<span class="keyword">nullptr</span>, delims);</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    }</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="keywordflow">return</span> (found_vmrss &amp;&amp; found_vmsize);</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_ad42bff8d0a7d60a085aa32d10f4955af"><div class="ttname"><a href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">SVF::u32_t</a></div><div class="ttdeci">unsigned u32_t</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00084">SVFBasicTypes.h:84</a></div></div>
<div class="ttc" id="util_8h_html_aaaaf5365ac473a2e91c3326c08d4eeb2"><div class="ttname"><a href="util_8h.html#aaaaf5365ac473a2e91c3326c08d4eeb2">strstr</a></div><div class="ttdeci">char * strstr()</div></div>
<div class="ttc" id="cuddInt_8c_html_a8b2e13c78efca330f06b6ddcd7464b41"><div class="ttname"><a href="cuddInt_8c.html#a8b2e13c78efca330f06b6ddcd7464b41">result</a></div><div class="ttdeci">static int result</div><div class="ttdef"><b>Definition:</b> <a href="cuddInt_8c_source.html#l07466">cuddInt.c:7466</a></div></div>
<div class="ttc" id="util_8h_html_a8bf943e1f78acc0236f9075a94765663"><div class="ttname"><a href="util_8h.html#a8bf943e1f78acc0236f9075a94765663">strtok</a></div><div class="ttdeci">char * strtok()</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f9959fa23ab4bdc65ca36fbda8c1b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9959fa23ab4bdc65ca36fbda8c1b70">&#9670;&nbsp;</a></span>getNextInsts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::getNextInsts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>curInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>instList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next instructions following control flow. </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00250">250</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;{</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    <span class="keywordflow">if</span> (!curInst-&gt;isTerminator())</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    {</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a>* nextInst = curInst-&gt;getNextNode();</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1SVFUtil.html#ab7f58caf27c30a1d414e06f60ca84d80">isIntrinsicInst</a>(nextInst))</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            <a class="code" href="namespaceSVF_1_1SVFUtil.html#a2f9959fa23ab4bdc65ca36fbda8c1b70">getNextInsts</a>(nextInst, instList);</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            instList.push_back(nextInst);</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    }</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    {</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *BB = curInst-&gt;getParent();</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        <span class="comment">// Visit all successors of BB in the CFG</span></div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="namespaceSVF.html#a3436a988bf80c021cd8022fb445b66d5">succ_const_iterator</a> it = succ_begin(BB), ie = succ_end(BB); it != ie; ++it)</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        {</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a>* nextInst = &amp;((*it)-&gt;front());</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1SVFUtil.html#ab7f58caf27c30a1d414e06f60ca84d80">isIntrinsicInst</a>(nextInst))</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;                <a class="code" href="namespaceSVF_1_1SVFUtil.html#a2f9959fa23ab4bdc65ca36fbda8c1b70">getNextInsts</a>(nextInst, instList);</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;                instList.push_back(nextInst);</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;        }</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    }</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ab7f58caf27c30a1d414e06f60ca84d80"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ab7f58caf27c30a1d414e06f60ca84d80">SVF::SVFUtil::isIntrinsicInst</a></div><div class="ttdeci">bool isIntrinsicInst(const Instruction *inst)</div><div class="ttdoc">Return true if it is an intrinsic instruction. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00181">SVFUtil.h:181</a></div></div>
<div class="ttc" id="namespaceSVF_html_a23bf614858f168b6ad76e0233cec9965"><div class="ttname"><a href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">SVF::BasicBlock</a></div><div class="ttdeci">llvm::BasicBlock BasicBlock</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00071">BasicTypes.h:71</a></div></div>
<div class="ttc" id="namespaceSVF_html_a3436a988bf80c021cd8022fb445b66d5"><div class="ttname"><a href="namespaceSVF.html#a3436a988bf80c021cd8022fb445b66d5">SVF::succ_const_iterator</a></div><div class="ttdeci">llvm::succ_const_iterator succ_const_iterator</div><div class="ttdoc">LLVM Iterators. </div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00119">BasicTypes.h:119</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a2f9959fa23ab4bdc65ca36fbda8c1b70"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a2f9959fa23ab4bdc65ca36fbda8c1b70">SVF::SVFUtil::getNextInsts</a></div><div class="ttdeci">void getNextInsts(const Instruction *curInst, std::vector&lt; const Instruction *&gt; &amp;instList)</div><div class="ttdoc">Get the next instructions following control flow. </div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8cpp_source.html#l00250">LLVMUtil.cpp:250</a></div></div>
<div class="ttc" id="namespaceSVF_html_a7875172ff434b2210eea7cecfbbd959e"><div class="ttname"><a href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">SVF::Instruction</a></div><div class="ttdeci">llvm::Instruction Instruction</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00073">BasicTypes.h:73</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e3a8d6cb1715db9518579fb60181d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3a8d6cb1715db9518579fb60181d5b">&#9670;&nbsp;</a></span>getPrevInsts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::getPrevInsts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>curInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>instList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the previous instructions following control flow. </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00277">277</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;{</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    <span class="keywordflow">if</span> (curInst != &amp;(curInst-&gt;getParent()-&gt;front()))</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    {</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a>* prevInst = curInst-&gt;getPrevNode();</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1SVFUtil.html#ab7f58caf27c30a1d414e06f60ca84d80">isIntrinsicInst</a>(prevInst))</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;            <a class="code" href="namespaceSVF_1_1SVFUtil.html#a7e3a8d6cb1715db9518579fb60181d5b">getPrevInsts</a>(prevInst, instList);</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;            instList.push_back(prevInst);</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    }</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    {</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a> *BB = curInst-&gt;getParent();</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        <span class="comment">// Visit all successors of BB in the CFG</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="SVF-FE_2BasicTypes_8h.html#a45136b941670180e9ba248bb4e52f09f">const_pred_iterator</a> it = pred_begin(BB), ie = pred_end(BB); it != ie; ++it)</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        {</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;            <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a>* prevInst = &amp;((*it)-&gt;back());</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1SVFUtil.html#ab7f58caf27c30a1d414e06f60ca84d80">isIntrinsicInst</a>(prevInst))</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;                <a class="code" href="namespaceSVF_1_1SVFUtil.html#a7e3a8d6cb1715db9518579fb60181d5b">getPrevInsts</a>(prevInst, instList);</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;                instList.push_back(prevInst);</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        }</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    }</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ab7f58caf27c30a1d414e06f60ca84d80"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ab7f58caf27c30a1d414e06f60ca84d80">SVF::SVFUtil::isIntrinsicInst</a></div><div class="ttdeci">bool isIntrinsicInst(const Instruction *inst)</div><div class="ttdoc">Return true if it is an intrinsic instruction. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00181">SVFUtil.h:181</a></div></div>
<div class="ttc" id="namespaceSVF_html_a23bf614858f168b6ad76e0233cec9965"><div class="ttname"><a href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">SVF::BasicBlock</a></div><div class="ttdeci">llvm::BasicBlock BasicBlock</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00071">BasicTypes.h:71</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a7e3a8d6cb1715db9518579fb60181d5b"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a7e3a8d6cb1715db9518579fb60181d5b">SVF::SVFUtil::getPrevInsts</a></div><div class="ttdeci">void getPrevInsts(const Instruction *curInst, std::vector&lt; const Instruction *&gt; &amp;instList)</div><div class="ttdoc">Get the previous instructions following control flow. </div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8cpp_source.html#l00277">LLVMUtil.cpp:277</a></div></div>
<div class="ttc" id="namespaceSVF_html_a7875172ff434b2210eea7cecfbbd959e"><div class="ttname"><a href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">SVF::Instruction</a></div><div class="ttdeci">llvm::Instruction Instruction</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00073">BasicTypes.h:73</a></div></div>
<div class="ttc" id="SVF-FE_2BasicTypes_8h_html_a45136b941670180e9ba248bb4e52f09f"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#a45136b941670180e9ba248bb4e52f09f">const_pred_iterator</a></div><div class="ttdeci">llvm::const_pred_iterator const_pred_iterator</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00114">BasicTypes.h:114</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8017e3e5100b3f63ee338b66118d266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8017e3e5100b3f63ee338b66118d266">&#9670;&nbsp;</a></span>getProgEntryFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a>* SVF::SVFUtil::getProgEntryFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1SVFModule.html">SVFModule</a> *&#160;</td>
          <td class="paramname"><em>svfModule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get program entry function from module. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00436">436</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;{</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    <span class="keywordflow">for</span> (SVFModule::const_iterator it = svfModule-&gt;begin(), eit = svfModule-&gt;end(); it != eit; ++it)</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    {</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        <span class="keyword">const</span> SVFFunction *fun = *it;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1SVFUtil.html#ab87fef7b10465d3e635643fcb93b95a7">isProgEntryFunction</a>(fun))</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;            <span class="keywordflow">return</span> (fun);</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    }</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ab87fef7b10465d3e635643fcb93b95a7"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ab87fef7b10465d3e635643fcb93b95a7">SVF::SVFUtil::isProgEntryFunction</a></div><div class="ttdeci">bool isProgEntryFunction(const Function *fun)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00717">SVFUtil.h:717</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6f82e03d880257527bd9cb5978e05604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f82e03d880257527bd9cb5978e05604">&#9670;&nbsp;</a></span>getProgFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a>* SVF::SVFUtil::getProgFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1SVFModule.html">SVFModule</a> *&#160;</td>
          <td class="paramname"><em>svfModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>funName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get program entry function from module. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00424">424</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;{</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <span class="keywordflow">for</span> (SVFModule::const_iterator it = svfModule-&gt;begin(), eit = svfModule-&gt;end(); it != eit; ++it)</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    {</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;        <span class="keyword">const</span> SVFFunction *fun = *it;</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;        <span class="keywordflow">if</span> (fun-&gt;getName()==funName)</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;            <span class="keywordflow">return</span> fun;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    }</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a8e7f56fa15cea924a09cd6903de2606c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7f56fa15cea924a09cd6903de2606c">&#9670;&nbsp;</a></span>getPtrElementType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceSVF.html#a1d008c0666c145622b81d427be64c52d">Type</a>* SVF::SVFUtil::getPtrElementType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">PointerType</a> *&#160;</td>
          <td class="paramname"><em>pty</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00073">73</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;{</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="preprocessor">#if (LLVM_VERSION_MAJOR &lt; 14)</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <span class="keywordflow">return</span> pty-&gt;getElementType();</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(!pty-&gt;isOpaque() &amp;&amp; <span class="stringliteral">&quot;Opaque Pointer is used, please recompile the source adding &#39;-Xclang -no-opaque-pointer&#39;&quot;</span>);</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <span class="keywordflow">return</span> pty-&gt;getNonOpaquePointerElementType();</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;}</div><div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9232d260dc83d3a25cd98195ba76567a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9232d260dc83d3a25cd98195ba76567a">&#9670;&nbsp;</a></span>getRefTypeOfHeapAllocOrStatic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">PointerType</a>* SVF::SVFUtil::getRefTypeOfHeapAllocOrStatic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the reference type of heap/static object from an allocation site. </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00085">85</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;{</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">PointerType</a> *refType = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="comment">// Case 1: heap object held by *argument, we should get its element type.</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1SVFUtil.html#aedfa6e9216c6c788c26aef1967689b76">isHeapAllocExtCallViaArg</a>(cs))</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    {</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="keywordtype">int</span> argPos = <a class="code" href="namespaceSVF_1_1SVFUtil.html#a73215bac62f1340a58f6c7f2ba9b0e7b">getHeapAllocHoldingArgPosition</a>(cs);</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *arg = cs.getArgument(argPos);</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">PointerType</a> *argType = SVFUtil::dyn_cast&lt;PointerType&gt;(arg-&gt;getType()))</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;            refType = <a class="code" href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVFUtil::dyn_cast</a>&lt;<a class="code" href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">PointerType</a>&gt;(<a class="code" href="namespaceSVF_1_1SVFUtil.html#a8e7f56fa15cea924a09cd6903de2606c">getPtrElementType</a>(argType));</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    }</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="comment">// Case 2: heap/static object held by return value.</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    {</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>((<a class="code" href="namespaceSVF_1_1SVFUtil.html#ae62938f722543d6d7fc201b685be1abf">isStaticExtCall</a>(cs) || <a class="code" href="namespaceSVF_1_1SVFUtil.html#ab2064cb70c76f399ce115f2621adea35">isHeapAllocExtCallViaRet</a>(cs))</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;               &amp;&amp; <span class="stringliteral">&quot;Must be heap alloc via ret, or static allocation site&quot;</span>);</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        refType = <a class="code" href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVFUtil::dyn_cast</a>&lt;<a class="code" href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">PointerType</a>&gt;(cs.getType());</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    }</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(refType &amp;&amp; <span class="stringliteral">&quot;Allocated object must be held by a pointer-typed value.&quot;</span>);</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <span class="keywordflow">return</span> refType;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;}</div><div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
<div class="ttc" id="namespaceSVF_html_aa962cc1d782cc46553251e96b64a754b"><div class="ttname"><a href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">SVF::PointerType</a></div><div class="ttdeci">llvm::PointerType PointerType</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00089">BasicTypes.h:89</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a8e7f56fa15cea924a09cd6903de2606c"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a8e7f56fa15cea924a09cd6903de2606c">SVF::SVFUtil::getPtrElementType</a></div><div class="ttdeci">static Type * getPtrElementType(const PointerType *pty)</div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8h_source.html#l00073">LLVMUtil.h:73</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aedfa6e9216c6c788c26aef1967689b76"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aedfa6e9216c6c788c26aef1967689b76">SVF::SVFUtil::isHeapAllocExtCallViaArg</a></div><div class="ttdeci">bool isHeapAllocExtCallViaArg(const CallSite cs)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00502">SVFUtil.h:502</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ab2064cb70c76f399ce115f2621adea35"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ab2064cb70c76f399ce115f2621adea35">SVF::SVFUtil::isHeapAllocExtCallViaRet</a></div><div class="ttdeci">bool isHeapAllocExtCallViaRet(const CallSite cs)</div><div class="ttdoc">interfaces to be used externally </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00513">SVFUtil.h:513</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ae62938f722543d6d7fc201b685be1abf"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ae62938f722543d6d7fc201b685be1abf">SVF::SVFUtil::isStaticExtCall</a></div><div class="ttdeci">bool isStaticExtCall(const CallSite cs)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00571">SVFUtil.h:571</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a73215bac62f1340a58f6c7f2ba9b0e7b"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a73215bac62f1340a58f6c7f2ba9b0e7b">SVF::SVFUtil::getHeapAllocHoldingArgPosition</a></div><div class="ttdeci">int getHeapAllocHoldingArgPosition(const SVFFunction *fun)</div><div class="ttdoc">Get the position of argument that holds an allocated heap object. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00379">SVFUtil.h:379</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a8182be247907420db00837cef9bcfa70"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVF::SVFUtil::dyn_cast</a></div><div class="ttdeci">LLVM_NODISCARD std::enable_if&lt;!is_simple_type&lt; Y &gt;::value, typename cast_retty&lt; X, const Y &gt;::ret_type &gt;::type dyn_cast(const Y &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="Casting_8h_source.html#l00343">Casting.h:343</a></div></div>
<div class="ttc" id="namespaceSVF_html_a90b263fd2f541eca78135078114cabda"><div class="ttname"><a href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">SVF::Value</a></div><div class="ttdeci">llvm::Value Value</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00072">BasicTypes.h:72</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a642f8284fbb260dd81fb29d5fadf6822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642f8284fbb260dd81fb29d5fadf6822">&#9670;&nbsp;</a></span>getRefTypeOfHeapAllocOrStatic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">PointerType</a>* SVF::SVFUtil::getRefTypeOfHeapAllocOrStatic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00107">107</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;{</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    CallSite cs(const_cast&lt;Instruction*&gt;(inst));</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a642f8284fbb260dd81fb29d5fadf6822">getRefTypeOfHeapAllocOrStatic</a>(cs);</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a642f8284fbb260dd81fb29d5fadf6822"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a642f8284fbb260dd81fb29d5fadf6822">SVF::SVFUtil::getRefTypeOfHeapAllocOrStatic</a></div><div class="ttdeci">const PointerType * getRefTypeOfHeapAllocOrStatic(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8h_source.html#l00107">LLVMUtil.h:107</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a28c0ede7e4765d2a686fc8ae0f5641a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c0ede7e4765d2a686fc8ae0f5641a4">&#9670;&nbsp;</a></span>getSourceLoc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::getSourceLoc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return source code including line number and file name from debug information. </p>
<p>Get the meta data (line number and file name) info of a LLVM value </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00268">268</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;{</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    <span class="keywordflow">if</span>(val==<span class="keyword">nullptr</span>)  <span class="keywordflow">return</span> <span class="stringliteral">&quot;{ empty val }&quot;</span>;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    std::string str;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    <a class="code" href="namespaceSVF.html#a726981481ac082dcda3e4921416b65a0">raw_string_ostream</a> rawstr(str);</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    rawstr &lt;&lt; <span class="stringliteral">&quot;{ &quot;</span>;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *inst = SVFUtil::dyn_cast&lt;Instruction&gt;(val))</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    {</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        <span class="keywordflow">if</span> (SVFUtil::isa&lt;AllocaInst&gt;(inst))</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        {</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;            <span class="keywordflow">for</span> (llvm::DbgInfoIntrinsic *DII : FindDbgAddrUses(const_cast&lt;Instruction*&gt;(inst)))</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;            {</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;                <span class="keywordflow">if</span> (llvm::DbgDeclareInst *DDI = SVFUtil::dyn_cast&lt;llvm::DbgDeclareInst&gt;(DII))</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                {</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;                    llvm::DIVariable *DIVar = SVFUtil::cast&lt;llvm::DIVariable&gt;(DDI-&gt;getVariable());</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                    rawstr &lt;&lt; <span class="stringliteral">&quot;ln: &quot;</span> &lt;&lt; DIVar-&gt;getLine() &lt;&lt; <span class="stringliteral">&quot; fl: &quot;</span> &lt;&lt; DIVar-&gt;getFilename();</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                    <span class="keywordflow">break</span>;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                }</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;            }</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        }</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF.html#ad3d3cec1813411f039211c86236f7adb">MDNode</a> *N = inst-&gt;getMetadata(<span class="stringliteral">&quot;dbg&quot;</span>))   <span class="comment">// Here I is an LLVM instruction</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        {</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;            llvm::DILocation* Loc = SVFUtil::cast&lt;llvm::DILocation&gt;(N);                   <span class="comment">// DILocation is in DebugInfo.h</span></div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;            <span class="keywordtype">unsigned</span> Line = Loc-&gt;getLine();</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;            <span class="keywordtype">unsigned</span> Column = Loc-&gt;getColumn();</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;            std::string File = Loc-&gt;getFilename().str();</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;            <span class="comment">//StringRef Dir = Loc.getDirectory();</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            <span class="keywordflow">if</span>(File.empty() || Line == 0)</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;            {</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                <span class="keyword">auto</span> inlineLoc = Loc-&gt;getInlinedAt();</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                <span class="keywordflow">if</span>(inlineLoc)</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                {</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                    Line = inlineLoc-&gt;getLine();</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                    Column = inlineLoc-&gt;getColumn();</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                    File = inlineLoc-&gt;getFilename().str();</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                }</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            }</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;            rawstr &lt;&lt; <span class="stringliteral">&quot;ln: &quot;</span> &lt;&lt; Line &lt;&lt; <span class="stringliteral">&quot;  cl: &quot;</span> &lt;&lt; Column &lt;&lt; <span class="stringliteral">&quot;  fl: &quot;</span> &lt;&lt; File;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        }</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    }</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a58cdfbc4160cae08745b67844ac29801">Argument</a>* argument = SVFUtil::dyn_cast&lt;Argument&gt;(val))</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    {</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        <span class="keywordflow">if</span> (argument-&gt;getArgNo()%10 == 1)</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;            rawstr &lt;&lt; argument-&gt;getArgNo() &lt;&lt; <span class="stringliteral">&quot;st&quot;</span>;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argument-&gt;getArgNo()%10 == 2)</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;            rawstr &lt;&lt; argument-&gt;getArgNo() &lt;&lt; <span class="stringliteral">&quot;nd&quot;</span>;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argument-&gt;getArgNo()%10 == 3)</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;            rawstr &lt;&lt; argument-&gt;getArgNo() &lt;&lt; <span class="stringliteral">&quot;rd&quot;</span>;</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;            rawstr &lt;&lt; argument-&gt;getArgNo() &lt;&lt; <span class="stringliteral">&quot;th&quot;</span>;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;        rawstr &lt;&lt; <span class="stringliteral">&quot; arg &quot;</span> &lt;&lt; argument-&gt;getParent()-&gt;getName() &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;               &lt;&lt; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a86c1c8bdfc1075c07c631525555194d2">getSourceLocOfFunction</a>(argument-&gt;getParent());</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    }</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a09f5fa3bc44bf53612a085e3a611cc4e">GlobalVariable</a>* gvar = SVFUtil::dyn_cast&lt;GlobalVariable&gt;(val))</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    {</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        rawstr &lt;&lt; <span class="stringliteral">&quot;Glob &quot;</span>;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        <a class="code" href="namespaceSVF.html#a3011dbac9102f044ad5f36a4ad3d4a71">NamedMDNode</a>* CU_Nodes = gvar-&gt;getParent()-&gt;getNamedMetadata(<span class="stringliteral">&quot;llvm.dbg.cu&quot;</span>);</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        <span class="keywordflow">if</span>(CU_Nodes)</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        {</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0, e = CU_Nodes-&gt;getNumOperands(); i != e; ++i)</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;            {</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                llvm::DICompileUnit *CUNode = SVFUtil::cast&lt;llvm::DICompileUnit&gt;(CU_Nodes-&gt;getOperand(i));</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                <span class="keywordflow">for</span> (llvm::DIGlobalVariableExpression *GV : CUNode-&gt;getGlobalVariables())</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                {</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                    llvm::DIGlobalVariable * DGV = GV-&gt;getVariable();</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                    <span class="keywordflow">if</span>(DGV-&gt;getName() == gvar-&gt;getName())</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                    {</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                        rawstr &lt;&lt; <span class="stringliteral">&quot;ln: &quot;</span> &lt;&lt; DGV-&gt;getLine() &lt;&lt; <span class="stringliteral">&quot; fl: &quot;</span> &lt;&lt; DGV-&gt;getFilename();</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;                    }</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                }</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;            }</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        }</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    }</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a>* func = SVFUtil::dyn_cast&lt;Function&gt;(val))</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    {</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        rawstr &lt;&lt; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a86c1c8bdfc1075c07c631525555194d2">getSourceLocOfFunction</a>(func);</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    }</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">BasicBlock</a>* bb = SVFUtil::dyn_cast&lt;BasicBlock&gt;(val))</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    {</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;        rawstr &lt;&lt; <span class="stringliteral">&quot;basic block: &quot;</span> &lt;&lt; bb-&gt;getName() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a28c0ede7e4765d2a686fc8ae0f5641a4">getSourceLoc</a>(bb-&gt;getFirstNonPHI());</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    }</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#a9e85d445e8b7b205134acd3874bba388">SVFUtil::isConstantData</a>(val))</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    {</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;        rawstr &lt;&lt; <span class="stringliteral">&quot;constant data&quot;</span>;</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    }</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    {</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;        rawstr &lt;&lt; <span class="stringliteral">&quot;Can only get source location for instruction, argument, global var, function or constant data.&quot;</span>;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    }</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    rawstr &lt;&lt; <span class="stringliteral">&quot; }&quot;</span>;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    <span class="keywordflow">if</span>(rawstr.str()==<span class="stringliteral">&quot;{  }&quot;</span>)</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    <span class="keywordflow">return</span> rawstr.str();</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a23bf614858f168b6ad76e0233cec9965"><div class="ttname"><a href="namespaceSVF.html#a23bf614858f168b6ad76e0233cec9965">SVF::BasicBlock</a></div><div class="ttdeci">llvm::BasicBlock BasicBlock</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00071">BasicTypes.h:71</a></div></div>
<div class="ttc" id="namespaceSVF_html_a09f5fa3bc44bf53612a085e3a611cc4e"><div class="ttname"><a href="namespaceSVF.html#a09f5fa3bc44bf53612a085e3a611cc4e">SVF::GlobalVariable</a></div><div class="ttdeci">llvm::GlobalVariable GlobalVariable</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00076">BasicTypes.h:76</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a28c0ede7e4765d2a686fc8ae0f5641a4"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a28c0ede7e4765d2a686fc8ae0f5641a4">SVF::SVFUtil::getSourceLoc</a></div><div class="ttdeci">std::string getSourceLoc(const Value *val)</div><div class="ttdoc">Return source code including line number and file name from debug information. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00268">SVFUtil.cpp:268</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a86c1c8bdfc1075c07c631525555194d2"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a86c1c8bdfc1075c07c631525555194d2">SVF::SVFUtil::getSourceLocOfFunction</a></div><div class="ttdeci">std::string getSourceLocOfFunction(const Function *F)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00249">SVFUtil.cpp:249</a></div></div>
<div class="ttc" id="namespaceSVF_html_a5faee14fa1dd41447bc73ac365fe33c1"><div class="ttname"><a href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">SVF::Function</a></div><div class="ttdeci">llvm::Function Function</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00070">BasicTypes.h:70</a></div></div>
<div class="ttc" id="namespaceSVF_html_a7875172ff434b2210eea7cecfbbd959e"><div class="ttname"><a href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">SVF::Instruction</a></div><div class="ttdeci">llvm::Instruction Instruction</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00073">BasicTypes.h:73</a></div></div>
<div class="ttc" id="namespaceSVF_html_a726981481ac082dcda3e4921416b65a0"><div class="ttname"><a href="namespaceSVF.html#a726981481ac082dcda3e4921416b65a0">SVF::raw_string_ostream</a></div><div class="ttdeci">llvm::raw_string_ostream raw_string_ostream</div><div class="ttdoc">LLVM outputs. </div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00083">BasicTypes.h:83</a></div></div>
<div class="ttc" id="namespaceSVF_html_a58cdfbc4160cae08745b67844ac29801"><div class="ttname"><a href="namespaceSVF.html#a58cdfbc4160cae08745b67844ac29801">SVF::Argument</a></div><div class="ttdeci">llvm::Argument Argument</div><div class="ttdoc">LLVM Aliases and constants. </div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00093">BasicTypes.h:93</a></div></div>
<div class="ttc" id="namespaceSVF_html_ad3d3cec1813411f039211c86236f7adb"><div class="ttname"><a href="namespaceSVF.html#ad3d3cec1813411f039211c86236f7adb">SVF::MDNode</a></div><div class="ttdeci">llvm::MDNode MDNode</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00101">BasicTypes.h:101</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a9e85d445e8b7b205134acd3874bba388"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a9e85d445e8b7b205134acd3874bba388">SVF::SVFUtil::isConstantData</a></div><div class="ttdeci">bool isConstantData(const Value *val)</div><div class="ttdoc">Return true if the value refers to constant data, e.g., i32 0. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00457">SVFUtil.h:457</a></div></div>
<div class="ttc" id="namespaceSVF_html_a3011dbac9102f044ad5f36a4ad3d4a71"><div class="ttname"><a href="namespaceSVF.html#a3011dbac9102f044ad5f36a4ad3d4a71">SVF::NamedMDNode</a></div><div class="ttdeci">llvm::NamedMDNode NamedMDNode</div><div class="ttdoc">LLVM metadata. </div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00100">BasicTypes.h:100</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a86c1c8bdfc1075c07c631525555194d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c1c8bdfc1075c07c631525555194d2">&#9670;&nbsp;</a></span>getSourceLocOfFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::getSourceLocOfFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get source code line number of a function according to debug info </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00249">249</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;{</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    std::string str;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    <a class="code" href="namespaceSVF.html#a726981481ac082dcda3e4921416b65a0">raw_string_ostream</a> rawstr(str);</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    <span class="comment">/*</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="comment">     * https://reviews.llvm.org/D18074?id=50385</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="comment">     * looks like the relevant</span></div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF.html#a89c7208bfc0b57873dfa574f52050295">llvm::DISubprogram</a> *SP =  <a class="code" href="CFLGrammar_8txt.html#acc7b4cf736579c4d83be2316d5a9e5f2">F</a>-&gt;getSubprogram())</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    {</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;        <span class="keywordflow">if</span> (SP-&gt;describes(<a class="code" href="CFLGrammar_8txt.html#acc7b4cf736579c4d83be2316d5a9e5f2">F</a>))</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            rawstr &lt;&lt; <span class="stringliteral">&quot;in line: &quot;</span> &lt;&lt; SP-&gt;getLine() &lt;&lt; <span class="stringliteral">&quot; file: &quot;</span> &lt;&lt; SP-&gt;getFilename();</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    }</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    <span class="keywordflow">return</span> rawstr.str();</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a726981481ac082dcda3e4921416b65a0"><div class="ttname"><a href="namespaceSVF.html#a726981481ac082dcda3e4921416b65a0">SVF::raw_string_ostream</a></div><div class="ttdeci">llvm::raw_string_ostream raw_string_ostream</div><div class="ttdoc">LLVM outputs. </div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00083">BasicTypes.h:83</a></div></div>
<div class="ttc" id="namespaceSVF_html_a89c7208bfc0b57873dfa574f52050295"><div class="ttname"><a href="namespaceSVF.html#a89c7208bfc0b57873dfa574f52050295">SVF::DISubprogram</a></div><div class="ttdeci">llvm::DISubprogram DISubprogram</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00125">BasicTypes.h:125</a></div></div>
<div class="ttc" id="CFLGrammar_8txt_html_acc7b4cf736579c4d83be2316d5a9e5f2"><div class="ttname"><a href="CFLGrammar_8txt.html#acc7b4cf736579c4d83be2316d5a9e5f2">F</a></div><div class="ttdeci">V Fbar V F</div><div class="ttdef"><b>Definition:</b> <a href="CFLGrammar_8txt_source.html#l00014">CFLGrammar.txt:14</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad3471260b66bdd7e6b790ad2a94fe7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3471260b66bdd7e6b790ad2a94fe7ce">&#9670;&nbsp;</a></span>getTaskDataAtHareParForSite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getTaskDataAtHareParForSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the task data argument of the parallel_for rountine. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00707">707</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;{</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getTaskDataAtHareParForSite(cs);</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5f3dd36ee492b60039928a86519518a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3dd36ee492b60039928a86519518a5">&#9670;&nbsp;</a></span>getTaskDataAtHareParForSite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getTaskDataAtHareParForSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00711">711</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;{</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getTaskDataAtHareParForSite(inst);</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab048cbce6e4f5a3d6ff90da3565220ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab048cbce6e4f5a3d6ff90da3565220ff">&#9670;&nbsp;</a></span>getTaskFuncAtHareParForSite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getTaskFuncAtHareParForSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the task function of the parallel_for routine. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00695">695</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;{</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getTaskFuncAtHareParForSite(cs);</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a111fa1ecf72adbd2e0ff27e922f0d34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111fa1ecf72adbd2e0ff27e922f0d34a">&#9670;&nbsp;</a></span>getTaskFuncAtHareParForSite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* SVF::SVFUtil::getTaskFuncAtHareParForSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00699">699</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;{</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getTaskFuncAtHareParForSite(inst);</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a973113323e30a01fd904b35ac18d40ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973113323e30a01fd904b35ac18d40ce">&#9670;&nbsp;</a></span>getTypeOfHeapAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a1d008c0666c145622b81d427be64c52d">Type</a> * SVF::SVFUtil::getTypeOfHeapAlloc </td>
          <td>(</td>
          <td class="paramtype">const llvm::Instruction *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type of the heap allocation. </p>
<p>Return the type of the object from a heap allocation </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00326">326</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;{</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">PointerType</a>* type = <a class="code" href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVFUtil::dyn_cast</a>&lt;<a class="code" href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">PointerType</a>&gt;(inst-&gt;getType());</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    <span class="keywordflow">if</span>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#ab2064cb70c76f399ce115f2621adea35">isHeapAllocExtCallViaRet</a>(inst))</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    {</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;        <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a>* v = <a class="code" href="namespaceSVF_1_1SVFUtil.html#ad72b3529e87e71767c6d226821cfddb3">getUniqueUseViaCastInst</a>(inst))</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        {</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;            <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">PointerType</a>* newTy = SVFUtil::dyn_cast&lt;PointerType&gt;(v-&gt;getType()))</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                type = newTy;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        }</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    }</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#aedfa6e9216c6c788c26aef1967689b76">isHeapAllocExtCallViaArg</a>(inst))</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    {</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        <a class="code" href="classSVF_1_1CallSite.html">CallSite</a> cs = <a class="code" href="namespaceSVF_1_1SVFUtil.html#a202de7ad2bea0311e2f75894c030e7a9">getLLVMCallSite</a>(inst);</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        <span class="keywordtype">int</span> arg_pos = <a class="code" href="namespaceSVF_1_1SVFUtil.html#a73215bac62f1340a58f6c7f2ba9b0e7b">getHeapAllocHoldingArgPosition</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#a145abbd2958629718fbca41d25c3124d">getCallee</a>(cs));</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *arg = cs.<a class="code" href="classSVF_1_1CallSite.html#a26a594d36bbb5b77e7085502812d9ca2">getArgument</a>(arg_pos);</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        type = <a class="code" href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVFUtil::dyn_cast</a>&lt;<a class="code" href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">PointerType</a>&gt;(arg-&gt;getType());</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    }</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    {</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>( <span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;not a heap allocation instruction?&quot;</span>);</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    }</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(type &amp;&amp; <span class="stringliteral">&quot;not a pointer type?&quot;</span>);</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a8e7f56fa15cea924a09cd6903de2606c">getPtrElementType</a>(type);</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ad72b3529e87e71767c6d226821cfddb3"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ad72b3529e87e71767c6d226821cfddb3">SVF::SVFUtil::getUniqueUseViaCastInst</a></div><div class="ttdeci">const Value * getUniqueUseViaCastInst(const Value *val)</div><div class="ttdoc">Return the bitcast instruction which is val&amp;#39;s only use site, otherwise return nullptr. </div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8cpp_source.html#l00307">LLVMUtil.cpp:307</a></div></div>
<div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
<div class="ttc" id="namespaceSVF_html_aa962cc1d782cc46553251e96b64a754b"><div class="ttname"><a href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">SVF::PointerType</a></div><div class="ttdeci">llvm::PointerType PointerType</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00089">BasicTypes.h:89</a></div></div>
<div class="ttc" id="classSVF_1_1CallSite_html_a26a594d36bbb5b77e7085502812d9ca2"><div class="ttname"><a href="classSVF_1_1CallSite.html#a26a594d36bbb5b77e7085502812d9ca2">SVF::CallSite::getArgument</a></div><div class="ttdeci">Value * getArgument(unsigned ArgNo) const</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00215">BasicTypes.h:215</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a8e7f56fa15cea924a09cd6903de2606c"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a8e7f56fa15cea924a09cd6903de2606c">SVF::SVFUtil::getPtrElementType</a></div><div class="ttdeci">static Type * getPtrElementType(const PointerType *pty)</div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8h_source.html#l00073">LLVMUtil.h:73</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aedfa6e9216c6c788c26aef1967689b76"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aedfa6e9216c6c788c26aef1967689b76">SVF::SVFUtil::isHeapAllocExtCallViaArg</a></div><div class="ttdeci">bool isHeapAllocExtCallViaArg(const CallSite cs)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00502">SVFUtil.h:502</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ab2064cb70c76f399ce115f2621adea35"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ab2064cb70c76f399ce115f2621adea35">SVF::SVFUtil::isHeapAllocExtCallViaRet</a></div><div class="ttdeci">bool isHeapAllocExtCallViaRet(const CallSite cs)</div><div class="ttdoc">interfaces to be used externally </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00513">SVFUtil.h:513</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a145abbd2958629718fbca41d25c3124d"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a145abbd2958629718fbca41d25c3124d">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const CallSite cs)</div><div class="ttdoc">Return callee of a callsite. Return null if this is an indirect call. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00281">SVFUtil.h:281</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a73215bac62f1340a58f6c7f2ba9b0e7b"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a73215bac62f1340a58f6c7f2ba9b0e7b">SVF::SVFUtil::getHeapAllocHoldingArgPosition</a></div><div class="ttdeci">int getHeapAllocHoldingArgPosition(const SVFFunction *fun)</div><div class="ttdoc">Get the position of argument that holds an allocated heap object. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00379">SVFUtil.h:379</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a202de7ad2bea0311e2f75894c030e7a9"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a202de7ad2bea0311e2f75894c030e7a9">SVF::SVFUtil::getLLVMCallSite</a></div><div class="ttdeci">CallSite getLLVMCallSite(const Instruction *inst)</div><div class="ttdoc">Return LLVM callsite given a instruction. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00217">SVFUtil.h:217</a></div></div>
<div class="ttc" id="classSVF_1_1CallSite_html"><div class="ttname"><a href="classSVF_1_1CallSite.html">SVF::CallSite</a></div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00202">BasicTypes.h:202</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a8182be247907420db00837cef9bcfa70"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVF::SVFUtil::dyn_cast</a></div><div class="ttdeci">LLVM_NODISCARD std::enable_if&lt;!is_simple_type&lt; Y &gt;::value, typename cast_retty&lt; X, const Y &gt;::ret_type &gt;::type dyn_cast(const Y &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="Casting_8h_source.html#l00343">Casting.h:343</a></div></div>
<div class="ttc" id="namespaceSVF_html_a90b263fd2f541eca78135078114cabda"><div class="ttname"><a href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">SVF::Value</a></div><div class="ttdeci">llvm::Value Value</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00072">BasicTypes.h:72</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a86fec3512ea1fc724cf567f52d348678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fec3512ea1fc724cf567f52d348678">&#9670;&nbsp;</a></span>getTypeSizeInBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> SVF::SVFUtil::getTypeSizeInBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a1d008c0666c145622b81d427be64c52d">Type</a> *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to get the size of the type from target data layout. </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00455">455</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;{</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    <span class="comment">// if the type has size then simply return it, otherwise just return 0</span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <span class="keywordflow">if</span>(type-&gt;isSized())</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#abe0dde753f9f79e30296208eb4d97eed">getDataLayout</a>(LLVMModuleSet::getLLVMModuleSet()-&gt;getMainLLVMModule())-&gt;getTypeStoreSize(const_cast&lt;Type*&gt;(type));</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;        <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_abe0dde753f9f79e30296208eb4d97eed"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#abe0dde753f9f79e30296208eb4d97eed">SVF::SVFUtil::getDataLayout</a></div><div class="ttdeci">static DataLayout * getDataLayout(Module *mod)</div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8h_source.html#l00280">LLVMUtil.h:280</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1dadc280bc2df41b82167ed236985dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dadc280bc2df41b82167ed236985dd5">&#9670;&nbsp;</a></span>getTypeSizeInBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> SVF::SVFUtil::getTypeSizeInBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a2bf58575ac7d068e0f1a4cf953b9e6cb">StructType</a> *&#160;</td>
          <td class="paramname"><em>sty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td>
          <td class="paramname"><em>field_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>if this struct type does not have any element, i.e., opaque </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00465">465</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;{</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    <span class="keyword">const</span> <a class="code" href="SVF-FE_2BasicTypes_8h.html#aef8af3d6e4b75a3e3e108b636a48fbd3">StructLayout</a> *stTySL = <a class="code" href="namespaceSVF_1_1SVFUtil.html#abe0dde753f9f79e30296208eb4d97eed">getDataLayout</a>(LLVMModuleSet::getLLVMModuleSet()-&gt;getMainLLVMModule())-&gt;getStructLayout( const_cast&lt;StructType *&gt;(sty) );</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    <span class="keywordflow">if</span>(sty-&gt;isOpaque())</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;        <span class="keywordflow">return</span> stTySL-&gt;getElementOffset(field_idx);</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;}</div><div class="ttc" id="SVF-FE_2BasicTypes_8h_html_aef8af3d6e4b75a3e3e108b636a48fbd3"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#aef8af3d6e4b75a3e3e108b636a48fbd3">StructLayout</a></div><div class="ttdeci">llvm::StructLayout StructLayout</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00048">BasicTypes.h:48</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_abe0dde753f9f79e30296208eb4d97eed"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#abe0dde753f9f79e30296208eb4d97eed">SVF::SVFUtil::getDataLayout</a></div><div class="ttdeci">static DataLayout * getDataLayout(Module *mod)</div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8h_source.html#l00280">LLVMUtil.h:280</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad72b3529e87e71767c6d226821cfddb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72b3529e87e71767c6d226821cfddb3">&#9670;&nbsp;</a></span>getUniqueUseViaCastInst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> * SVF::SVFUtil::getUniqueUseViaCastInst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bitcast instruction which is val's only use site, otherwise return nullptr. </p>
<p>If type is void* (i8*) and val is only used at a bitcast instruction </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00307">307</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;{</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">PointerType</a> * type = <a class="code" href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVFUtil::dyn_cast</a>&lt;<a class="code" href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">PointerType</a>&gt;(val-&gt;getType());</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(type &amp;&amp; <span class="stringliteral">&quot;this value should be a pointer type!&quot;</span>);</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF.html#a3d9e7f32dc17fe8d40f8d6a011403b91">IntegerType</a> *IT = SVFUtil::dyn_cast&lt;IntegerType&gt;(<a class="code" href="namespaceSVF_1_1SVFUtil.html#a8e7f56fa15cea924a09cd6903de2606c">getPtrElementType</a>(type)))</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    {</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        <span class="keywordflow">if</span> (IT-&gt;getBitWidth() == 8 &amp;&amp; val-&gt;getNumUses()==1)</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        {</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;            <span class="keyword">const</span> <a class="code" href="SVF-FE_2BasicTypes_8h.html#a9c01c67684e99545d8e0403321594977">Use</a> *u = &amp;*val-&gt;use_begin();</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVFUtil::dyn_cast</a>&lt;<a class="code" href="SVF-FE_2BasicTypes_8h.html#ab8cddf2ff868c0a9ae99483640c9ecef">BitCastInst</a>&gt;(u-&gt;getUser());</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        }</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    }</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;}</div><div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
<div class="ttc" id="namespaceSVF_html_aa962cc1d782cc46553251e96b64a754b"><div class="ttname"><a href="namespaceSVF.html#aa962cc1d782cc46553251e96b64a754b">SVF::PointerType</a></div><div class="ttdeci">llvm::PointerType PointerType</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00089">BasicTypes.h:89</a></div></div>
<div class="ttc" id="SVF-FE_2BasicTypes_8h_html_ab8cddf2ff868c0a9ae99483640c9ecef"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#ab8cddf2ff868c0a9ae99483640c9ecef">BitCastInst</a></div><div class="ttdeci">llvm::BitCastInst BitCastInst</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00066">BasicTypes.h:66</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a8e7f56fa15cea924a09cd6903de2606c"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a8e7f56fa15cea924a09cd6903de2606c">SVF::SVFUtil::getPtrElementType</a></div><div class="ttdeci">static Type * getPtrElementType(const PointerType *pty)</div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8h_source.html#l00073">LLVMUtil.h:73</a></div></div>
<div class="ttc" id="SVF-FE_2BasicTypes_8h_html_a9c01c67684e99545d8e0403321594977"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#a9c01c67684e99545d8e0403321594977">Use</a></div><div class="ttdeci">llvm::Use Use</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00029">BasicTypes.h:29</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a8182be247907420db00837cef9bcfa70"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a8182be247907420db00837cef9bcfa70">SVF::SVFUtil::dyn_cast</a></div><div class="ttdeci">LLVM_NODISCARD std::enable_if&lt;!is_simple_type&lt; Y &gt;::value, typename cast_retty&lt; X, const Y &gt;::ret_type &gt;::type dyn_cast(const Y &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="Casting_8h_source.html#l00343">Casting.h:343</a></div></div>
<div class="ttc" id="namespaceSVF_html_a3d9e7f32dc17fe8d40f8d6a011403b91"><div class="ttname"><a href="namespaceSVF.html#a3d9e7f32dc17fe8d40f8d6a011403b91">SVF::IntegerType</a></div><div class="ttdeci">llvm::IntegerType IntegerType</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00122">BasicTypes.h:122</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a14a4c5124f2fd03ca3d898e2acd54160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a4c5124f2fd03ca3d898e2acd54160">&#9670;&nbsp;</a></span>hclustMethodToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::hclustMethodToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of a hclust method. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00368">368</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;{</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    <span class="keywordflow">switch</span> (method)</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    {</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddad16cc6362447cc32292c4af4c6fe8024">HCLUST_METHOD_SINGLE</a>:</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;single&quot;</span>;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda44ce22fdfc560f27242e9b8f8e7009f4">HCLUST_METHOD_COMPLETE</a>:</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;complete&quot;</span>;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda3ab72664fc61704a1ba46bddbc347115">HCLUST_METHOD_AVERAGE</a>:</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;average&quot;</span>;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddaa453b79910d9c6f7f57a179bcdf63474">HCLUST_METHOD_MEDIAN</a>:</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;median&quot;</span>;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618">HCLUST_METHOD_SVF_BEST</a>:</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;svf-best&quot;</span>;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    <span class="keywordflow">default</span>:</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;SVFUtil::hclustMethodToString: unknown method&quot;</span>);</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        <a class="code" href="util_8h.html#a23c00958edf66c39625a0d535dee57b7">abort</a>();</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    }</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;}</div><div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
<div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dda44ce22fdfc560f27242e9b8f8e7009f4"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda44ce22fdfc560f27242e9b8f8e7009f4">HCLUST_METHOD_COMPLETE</a></div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00070">fastcluster.h:70</a></div></div>
<div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913ddaa453b79910d9c6f7f57a179bcdf63474"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddaa453b79910d9c6f7f57a179bcdf63474">HCLUST_METHOD_MEDIAN</a></div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00074">fastcluster.h:74</a></div></div>
<div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618">HCLUST_METHOD_SVF_BEST</a></div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00076">fastcluster.h:76</a></div></div>
<div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913ddad16cc6362447cc32292c4af4c6fe8024"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddad16cc6362447cc32292c4af4c6fe8024">HCLUST_METHOD_SINGLE</a></div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00068">fastcluster.h:68</a></div></div>
<div class="ttc" id="util_8h_html_a23c00958edf66c39625a0d535dee57b7"><div class="ttname"><a href="util_8h.html#a23c00958edf66c39625a0d535dee57b7">abort</a></div><div class="ttdeci">VOID_OR_INT abort()</div></div>
<div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dda3ab72664fc61704a1ba46bddbc347115"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda3ab72664fc61704a1ba46bddbc347115">HCLUST_METHOD_AVERAGE</a></div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00072">fastcluster.h:72</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d7588578735679773493ff2d5e458e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7588578735679773493ff2d5e458e1">&#9670;&nbsp;</a></span>increaseStackSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::increaseStackSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the stack size limit. </p>
<p>Increase stack size </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00228">228</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;{</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="keyword">const</span> rlim_t kStackSize = 256L * 1024L * 1024L;   <span class="comment">// min stack size = 256 Mb</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <span class="keyword">struct </span>rlimit rl;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <span class="keywordtype">int</span> <a class="code" href="cuddInt_8c.html#a8b2e13c78efca330f06b6ddcd7464b41">result</a> = getrlimit(RLIMIT_STACK, &amp;rl);</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    <span class="keywordflow">if</span> (result == 0)</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    {</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        <span class="keywordflow">if</span> (rl.rlim_cur &lt; kStackSize)</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        {</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;            rl.rlim_cur = kStackSize;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;            result = setrlimit(RLIMIT_STACK, &amp;rl);</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;            <span class="keywordflow">if</span> (result != 0)</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                <a class="code" href="namespaceSVF_1_1SVFUtil.html#a077caa1b10ab84d101d79fc7ea50db2d">writeWrnMsg</a>(<span class="stringliteral">&quot;setrlimit returned result !=0 \n&quot;</span>);</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;        }</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    }</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a077caa1b10ab84d101d79fc7ea50db2d"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a077caa1b10ab84d101d79fc7ea50db2d">SVF::SVFUtil::writeWrnMsg</a></div><div class="ttdeci">void writeWrnMsg(std::string msg)</div><div class="ttdoc">Writes a message run through wrnMsg. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00068">SVFUtil.cpp:68</a></div></div>
<div class="ttc" id="cuddInt_8c_html_a8b2e13c78efca330f06b6ddcd7464b41"><div class="ttname"><a href="cuddInt_8c.html#a8b2e13c78efca330f06b6ddcd7464b41">result</a></div><div class="ttdeci">static int result</div><div class="ttdef"><b>Definition:</b> <a href="cuddInt_8c_source.html#l07466">cuddInt.c:7466</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeecfaf26800dcebf0b079395126bc7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecfaf26800dcebf0b079395126bc7f7">&#9670;&nbsp;</a></span>insertKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename KeySet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::insertKey </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet &amp;&#160;</td>
          <td class="paramname"><em>keySet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element into a Set/CondSet (with ::insert). </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00319">319</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;{</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    keySet.insert(key);</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a4f75b8313eb2b1e5a4c798a01cb99471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f75b8313eb2b1e5a4c798a01cb99471">&#9670;&nbsp;</a></span>insertKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::insertKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>keySet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a NodeID into a NodeBS. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00325">325</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;{</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    keySet.set(key);</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5c8cbc986cccb9d84f87aae162df3737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8cbc986cccb9d84f87aae162df3737">&#9670;&nbsp;</a></span>isa()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_NODISCARD bool SVF::SVFUtil::isa </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00184">184</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;{</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="keywordflow">return</span> isa_impl_wrap&lt;X, <span class="keyword">const</span> Y,</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;           <span class="keyword">typename</span> simplify_type&lt;const Y&gt;::SimpleType&gt;::doit(Val);</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab302ca3fcbde9bd1a7d9d5d837a69c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab302ca3fcbde9bd1a7d9d5d837a69c23">&#9670;&nbsp;</a></span>isAnAllocationWraper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isAnAllocationWraper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function servers a allocation wrapper detector. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00480">480</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;{</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ad09ba410acbbaee2aac9dd406c3cf01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09ba410acbbaee2aac9dd406c3cf01a">&#9670;&nbsp;</a></span>isBarrierWaitCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isBarrierWaitCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this is a barrier wait call. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00671">671</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;{</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDBarWait(cs);</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a0a7fc57e1f5cec705e310a4bb72cba94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7fc57e1f5cec705e310a4bb72cba94">&#9670;&nbsp;</a></span>isBarrierWaitCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isBarrierWaitCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00675">675</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;{</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDBarWait(inst);</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a43c9072210a5f5baeafe36da03f2fde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c9072210a5f5baeafe36da03f2fde2">&#9670;&nbsp;</a></span>isBinaryConstantExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* SVF::SVFUtil::isBinaryConstantExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00259">259</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;{</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* constExpr = SVFUtil::dyn_cast&lt;ConstantExpr&gt;(val))</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    {</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        <span class="keywordflow">if</span>((constExpr-&gt;getOpcode() &gt;= Instruction::BinaryOpsBegin) &amp;&amp; (constExpr-&gt;getOpcode() &lt;= Instruction::BinaryOpsEnd))</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            <span class="keywordflow">return</span> constExpr;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    }</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;}</div><div class="ttc" id="SVF-FE_2BasicTypes_8h_html_a60115de303225d173fb935cf7619a2cb"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a></div><div class="ttdeci">llvm::ConstantExpr ConstantExpr</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00057">BasicTypes.h:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac0df4ee0bf78167dd9461227b5cce7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0df4ee0bf78167dd9461227b5cce7af">&#9670;&nbsp;</a></span>isBlackholeSym()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isBlackholeSym </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this value is a black hole. </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00048">48</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;{</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keywordflow">return</span> (SVFUtil::isa&lt;UndefValue&gt;(val));</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a2e08ce822223842fa6a73fd659b1a526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e08ce822223842fa6a73fd659b1a526">&#9670;&nbsp;</a></span>isCallSite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isCallSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether an instruction is a call or invoke instruction. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00196">196</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;{</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="keywordflow">return</span> SVFUtil::isa&lt;CallBase&gt;(inst);</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a38bf8f7eaa18fc5a09711959b5417854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38bf8f7eaa18fc5a09711959b5417854">&#9670;&nbsp;</a></span>isCallSite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isCallSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether an instruction is a call or invoke instruction. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00201">201</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;{</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a>* inst = SVFUtil::dyn_cast&lt;Instruction&gt;(val))</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">SVFUtil::isCallSite</a>(inst);</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a7875172ff434b2210eea7cecfbbd959e"><div class="ttname"><a href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">SVF::Instruction</a></div><div class="ttdeci">llvm::Instruction Instruction</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00073">BasicTypes.h:73</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a38bf8f7eaa18fc5a09711959b5417854"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">SVF::SVFUtil::isCallSite</a></div><div class="ttdeci">bool isCallSite(const Value *val)</div><div class="ttdoc">Whether an instruction is a call or invoke instruction. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00201">SVFUtil.h:201</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e404bcc6613ba10a56c4fbdc842c5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e404bcc6613ba10a56c4fbdc842c5a8">&#9670;&nbsp;</a></span>isCastConstantExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* SVF::SVFUtil::isCastConstantExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00215">215</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;{</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* constExpr = SVFUtil::dyn_cast&lt;ConstantExpr&gt;(val))</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    {</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        <span class="keywordflow">if</span>(constExpr-&gt;getOpcode() == Instruction::BitCast)</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;            <span class="keywordflow">return</span> constExpr;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    }</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;}</div><div class="ttc" id="SVF-FE_2BasicTypes_8h_html_a60115de303225d173fb935cf7619a2cb"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a></div><div class="ttdeci">llvm::ConstantExpr ConstantExpr</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00057">BasicTypes.h:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4adb63c87a9489ab905d42230ac66299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4adb63c87a9489ab905d42230ac66299">&#9670;&nbsp;</a></span>isCmpConstantExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* SVF::SVFUtil::isCmpConstantExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00249">249</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;{</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* constExpr = SVFUtil::dyn_cast&lt;ConstantExpr&gt;(val))</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    {</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        <span class="keywordflow">if</span>(constExpr-&gt;getOpcode() == Instruction::ICmp || constExpr-&gt;getOpcode() == Instruction::FCmp)</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            <span class="keywordflow">return</span> constExpr;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    }</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;}</div><div class="ttc" id="SVF-FE_2BasicTypes_8h_html_a60115de303225d173fb935cf7619a2cb"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a></div><div class="ttdeci">llvm::ConstantExpr ConstantExpr</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00057">BasicTypes.h:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9e85d445e8b7b205134acd3874bba388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e85d445e8b7b205134acd3874bba388">&#9670;&nbsp;</a></span>isConstantData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isConstantData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the value refers to constant data, e.g., i32 0. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00457">457</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;{</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <span class="keywordflow">return</span> SVFUtil::isa&lt;ConstantData&gt;(val)</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;           || SVFUtil::isa&lt;ConstantAggregate&gt;(val)</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;           || SVFUtil::isa&lt;MetadataAsValue&gt;(val)</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;           || SVFUtil::isa&lt;BlockAddress&gt;(val);</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a6442fbf0cccd55cf93eab2b656756e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6442fbf0cccd55cf93eab2b656756e9a">&#9670;&nbsp;</a></span>isConstantObjSym()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isConstantObjSym </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether this value points-to a constant object. </p>
<p>Check whether this value points-to a constant object </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00060">60</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;{</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a09f5fa3bc44bf53612a085e3a611cc4e">GlobalVariable</a>* v = SVFUtil::dyn_cast&lt;GlobalVariable&gt;(val))</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    {</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1cppUtil.html#aeef0f5c6486379043a7d47b0635f2667">cppUtil::isValVtbl</a>(v))</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!v-&gt;hasInitializer())</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;        {</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;            <span class="keywordflow">if</span>(v-&gt;isExternalLinkage(v-&gt;getLinkage()))</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        }</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;        {</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            <a class="code" href="classSVF_1_1StInfo.html">StInfo</a> *stInfo = SymbolTableInfo::SymbolInfo()-&gt;getStructInfo(v-&gt;getInitializer()-&gt;getType());</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;            <span class="keyword">const</span> std::vector&lt;const Type*&gt; &amp;fields = stInfo-&gt;<a class="code" href="classSVF_1_1StInfo.html#a7fe5593e487a04e8f0eb28ca7bc31fe9">getFlattenFieldTypes</a>();</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            <span class="keywordflow">for</span> (std::vector&lt;const Type*&gt;::const_iterator it = fields.begin(), eit = fields.end(); it != eit; ++it)</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            {</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a1d008c0666c145622b81d427be64c52d">Type</a> *elemTy = *it;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(!SVFUtil::isa&lt;FunctionType&gt;(elemTy) &amp;&amp; <span class="stringliteral">&quot;Initializer of a global is a function?&quot;</span>);</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                <span class="keywordflow">if</span> (SVFUtil::isa&lt;PointerType&gt;(elemTy))</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;            }</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            <span class="keywordflow">return</span> v-&gt;isConstant();</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        }</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    }</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a9e85d445e8b7b205134acd3874bba388">SVFUtil::isConstantData</a>(val);</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a1d008c0666c145622b81d427be64c52d"><div class="ttname"><a href="namespaceSVF.html#a1d008c0666c145622b81d427be64c52d">SVF::Type</a></div><div class="ttdeci">llvm::Type Type</div><div class="ttdoc">LLVM Basic classes. </div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00065">BasicTypes.h:65</a></div></div>
<div class="ttc" id="namespaceSVF_html_a09f5fa3bc44bf53612a085e3a611cc4e"><div class="ttname"><a href="namespaceSVF.html#a09f5fa3bc44bf53612a085e3a611cc4e">SVF::GlobalVariable</a></div><div class="ttdeci">llvm::GlobalVariable GlobalVariable</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00076">BasicTypes.h:76</a></div></div>
<div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
<div class="ttc" id="namespaceSVF_1_1cppUtil_html_aeef0f5c6486379043a7d47b0635f2667"><div class="ttname"><a href="namespaceSVF_1_1cppUtil.html#aeef0f5c6486379043a7d47b0635f2667">SVF::cppUtil::isValVtbl</a></div><div class="ttdeci">bool isValVtbl(const Value *val)</div><div class="ttdef"><b>Definition:</b> <a href="CPPUtil_8cpp_source.html#l00124">CPPUtil.cpp:124</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a9e85d445e8b7b205134acd3874bba388"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a9e85d445e8b7b205134acd3874bba388">SVF::SVFUtil::isConstantData</a></div><div class="ttdeci">bool isConstantData(const Value *val)</div><div class="ttdoc">Return true if the value refers to constant data, e.g., i32 0. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00457">SVFUtil.h:457</a></div></div>
<div class="ttc" id="classSVF_1_1StInfo_html"><div class="ttname"><a href="classSVF_1_1StInfo.html">SVF::StInfo</a></div><div class="ttdef"><b>Definition:</b> <a href="SymbolTableInfo_8h_source.html#l00467">SymbolTableInfo.h:467</a></div></div>
<div class="ttc" id="classSVF_1_1StInfo_html_a7fe5593e487a04e8f0eb28ca7bc31fe9"><div class="ttname"><a href="classSVF_1_1StInfo.html#a7fe5593e487a04e8f0eb28ca7bc31fe9">SVF::StInfo::getFlattenFieldTypes</a></div><div class="ttdeci">std::vector&lt; const Type * &gt; &amp; getFlattenFieldTypes()</div><div class="ttdef"><b>Definition:</b> <a href="SymbolTableInfo_8h_source.html#l00521">SymbolTableInfo.h:521</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d268e8d588717601345be3a911a7625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d268e8d588717601345be3a911a7625">&#9670;&nbsp;</a></span>isDeadFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isDeadFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>whether this is a function without any possible caller? </p>
<p>Method for dead function, which does not have any possible caller function address is not taken and never be used in call or invoke instruction</p>
<p>Return true if this is a function without any possible caller </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00160">160</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;{</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <span class="keywordflow">if</span>(fun-&gt;hasAddressTaken())</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    <span class="keywordflow">if</span>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#a2c97c2b79b795465490512e267a9309b">isProgEntryFunction</a>(fun))</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    <span class="keywordflow">for</span> (Value::const_user_iterator i = fun-&gt;user_begin(), e = fun-&gt;user_end(); i != e; ++i)</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    {</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1SVFUtil.html#a2e08ce822223842fa6a73fd659b1a526">SVFUtil::isCallSite</a>(*i))</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    }</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="keywordflow">if</span> (LLVMModuleSet::getLLVMModuleSet()-&gt;hasDeclaration(fun))</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    {</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        <span class="keyword">const</span> <a class="code" href="classSVF_1_1SVFModule.html#acfd1ffb4696136de493843786c799e6b">SVFModule::FunctionSetType</a> &amp;decls = LLVMModuleSet::getLLVMModuleSet()-&gt;getDeclaration(fun);</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        <span class="keywordflow">for</span> (SVFModule::FunctionSetType::const_iterator it = decls.begin(),</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;                eit = decls.end(); it != eit; ++it)</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        {</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;            <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *decl = (*it)-&gt;getLLVMFun();</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            <span class="keywordflow">if</span>(decl-&gt;hasAddressTaken())</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;            <span class="keywordflow">for</span> (Value::const_user_iterator i = decl-&gt;user_begin(), e = decl-&gt;user_end(); i != e; ++i)</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;            {</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1SVFUtil.html#a2e08ce822223842fa6a73fd659b1a526">SVFUtil::isCallSite</a>(*i))</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            }</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        }</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    }</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a2e08ce822223842fa6a73fd659b1a526"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a2e08ce822223842fa6a73fd659b1a526">SVF::SVFUtil::isCallSite</a></div><div class="ttdeci">bool isCallSite(const Instruction *inst)</div><div class="ttdoc">Whether an instruction is a call or invoke instruction. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00196">SVFUtil.h:196</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a2c97c2b79b795465490512e267a9309b"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a2c97c2b79b795465490512e267a9309b">SVF::SVFUtil::isProgEntryFunction</a></div><div class="ttdeci">bool isProgEntryFunction(const SVFFunction *fun)</div><div class="ttdoc">Program entry function e.g. main. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00417">SVFUtil.h:417</a></div></div>
<div class="ttc" id="namespaceSVF_html_a5faee14fa1dd41447bc73ac365fe33c1"><div class="ttname"><a href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">SVF::Function</a></div><div class="ttdeci">llvm::Function Function</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00070">BasicTypes.h:70</a></div></div>
<div class="ttc" id="classSVF_1_1SVFModule_html_acfd1ffb4696136de493843786c799e6b"><div class="ttname"><a href="classSVF_1_1SVFModule.html#acfd1ffb4696136de493843786c799e6b">SVF::SVFModule::FunctionSetType</a></div><div class="ttdeci">std::vector&lt; const SVFFunction * &gt; FunctionSetType</div><div class="ttdef"><b>Definition:</b> <a href="SVFModule_8h_source.html#l00044">SVFModule.h:44</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1f52a7f183f1eec7c4db7e4e54fa5e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f52a7f183f1eec7c4db7e4e54fa5e2c">&#9670;&nbsp;</a></span>isDeallocExtCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isDeallocExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00560">560</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;{</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a3495236e22e4bc6404b6ac352060439c">isDeallocExtFun</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs));</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a3495236e22e4bc6404b6ac352060439c"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a3495236e22e4bc6404b6ac352060439c">SVF::SVFUtil::isDeallocExtFun</a></div><div class="ttdeci">bool isDeallocExtFun(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a heap dealloc or not. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00395">SVFUtil.h:395</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9973c1326717326b26ec1ea21ebd8da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9973c1326717326b26ec1ea21ebd8da5">&#9670;&nbsp;</a></span>isDeallocExtCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isDeallocExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00565">565</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;{</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a3495236e22e4bc6404b6ac352060439c">isDeallocExtFun</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(inst));</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a3495236e22e4bc6404b6ac352060439c"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a3495236e22e4bc6404b6ac352060439c">SVF::SVFUtil::isDeallocExtFun</a></div><div class="ttdeci">bool isDeallocExtFun(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a heap dealloc or not. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00395">SVFUtil.h:395</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3495236e22e4bc6404b6ac352060439c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3495236e22e4bc6404b6ac352060439c">&#9670;&nbsp;</a></span>isDeallocExtFun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isDeallocExtFun </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the call is a heap dealloc or not. </p>
<p>note that this function is not suppose to be used externally </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00395">395</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;{</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; (ExtAPI::getExtAPI()-&gt;is_dealloc(fun));</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a22ef185e767ff76c098e75126c885400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ef185e767ff76c098e75126c885400">&#9670;&nbsp;</a></span>isExtCall() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the call is an external call (external library in function summary table) If the libary function is redefined in the application code (e.g., memcpy), it will return false and will not be treated as an external call. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00358">358</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;{</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; ExtAPI::getExtAPI()-&gt;is_ext(fun);</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aad27a96075234ad2182a84e0e9d31a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad27a96075234ad2182a84e0e9d31a45">&#9670;&nbsp;</a></span>isExtCall() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00492">492</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;{</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#af3e5fd7ffce966575ebf7c7e653b0919">isExtCall</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs));</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af3e5fd7ffce966575ebf7c7e653b0919"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af3e5fd7ffce966575ebf7c7e653b0919">SVF::SVFUtil::isExtCall</a></div><div class="ttdeci">bool isExtCall(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00497">SVFUtil.h:497</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af3e5fd7ffce966575ebf7c7e653b0919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e5fd7ffce966575ebf7c7e653b0919">&#9670;&nbsp;</a></span>isExtCall() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00497">497</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;{</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#af3e5fd7ffce966575ebf7c7e653b0919">isExtCall</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(inst));</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af3e5fd7ffce966575ebf7c7e653b0919"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af3e5fd7ffce966575ebf7c7e653b0919">SVF::SVFUtil::isExtCall</a></div><div class="ttdeci">bool isExtCall(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00497">SVFUtil.h:497</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a384b0986a6c4e99dfc4e1629b3598c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384b0986a6c4e99dfc4e1629b3598c3c">&#9670;&nbsp;</a></span>isGepConstantExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* SVF::SVFUtil::isGepConstantExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return corresponding constant expression, otherwise return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00185">185</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;{</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* constExpr = SVFUtil::dyn_cast&lt;ConstantExpr&gt;(val))</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    {</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        <span class="keywordflow">if</span>(constExpr-&gt;getOpcode() == Instruction::GetElementPtr)</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;            <span class="keywordflow">return</span> constExpr;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    }</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;}</div><div class="ttc" id="SVF-FE_2BasicTypes_8h_html_a60115de303225d173fb935cf7619a2cb"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a></div><div class="ttdeci">llvm::ConstantExpr ConstantExpr</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00057">BasicTypes.h:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a28fbb7cc51eb7e25d88f43e3eb1f30fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28fbb7cc51eb7e25d88f43e3eb1f30fb">&#9670;&nbsp;</a></span>isHareParForCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHareParForCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a hare_parallel_for call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00611">611</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;{</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isHareParFor(cs);</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a9b37c6fe1232ebc35ffa052bd392e2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b37c6fe1232ebc35ffa052bd392e2e8">&#9670;&nbsp;</a></span>isHareParForCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHareParForCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00615">615</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;{</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isHareParFor(inst);</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a93ac673b885633849fa484938405ca75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ac673b885633849fa484938405ca75">&#9670;&nbsp;</a></span>isHeapAllocExtCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00525">525</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;{</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a24514d87685f2258201f0de15d220bbc">isHeapAllocExtCallViaRet</a>(cs) || <a class="code" href="namespaceSVF_1_1SVFUtil.html#a0bde3acf22383eac5bbf4e2c065a2226">isHeapAllocExtCallViaArg</a>(cs);</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a24514d87685f2258201f0de15d220bbc"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a24514d87685f2258201f0de15d220bbc">SVF::SVFUtil::isHeapAllocExtCallViaRet</a></div><div class="ttdeci">bool isHeapAllocExtCallViaRet(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00519">SVFUtil.h:519</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a0bde3acf22383eac5bbf4e2c065a2226"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a0bde3acf22383eac5bbf4e2c065a2226">SVF::SVFUtil::isHeapAllocExtCallViaArg</a></div><div class="ttdeci">bool isHeapAllocExtCallViaArg(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00507">SVFUtil.h:507</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1ebbf43e294c3f94a2a7d5c56759bbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebbf43e294c3f94a2a7d5c56759bbba">&#9670;&nbsp;</a></span>isHeapAllocExtCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00530">530</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;{</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a24514d87685f2258201f0de15d220bbc">isHeapAllocExtCallViaRet</a>(inst) || <a class="code" href="namespaceSVF_1_1SVFUtil.html#a0bde3acf22383eac5bbf4e2c065a2226">isHeapAllocExtCallViaArg</a>(inst);</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a24514d87685f2258201f0de15d220bbc"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a24514d87685f2258201f0de15d220bbc">SVF::SVFUtil::isHeapAllocExtCallViaRet</a></div><div class="ttdeci">bool isHeapAllocExtCallViaRet(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00519">SVFUtil.h:519</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a0bde3acf22383eac5bbf4e2c065a2226"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a0bde3acf22383eac5bbf4e2c065a2226">SVF::SVFUtil::isHeapAllocExtCallViaArg</a></div><div class="ttdeci">bool isHeapAllocExtCallViaArg(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00507">SVFUtil.h:507</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aedfa6e9216c6c788c26aef1967689b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfa6e9216c6c788c26aef1967689b76">&#9670;&nbsp;</a></span>isHeapAllocExtCallViaArg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtCallViaArg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00502">502</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;{</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#ab4a69173f50ebe48e69103befe516245">isHeapAllocExtFunViaArg</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs));</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ab4a69173f50ebe48e69103befe516245"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ab4a69173f50ebe48e69103befe516245">SVF::SVFUtil::isHeapAllocExtFunViaArg</a></div><div class="ttdeci">bool isHeapAllocExtFunViaArg(const SVFFunction *fun)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00372">SVFUtil.h:372</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0bde3acf22383eac5bbf4e2c065a2226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bde3acf22383eac5bbf4e2c065a2226">&#9670;&nbsp;</a></span>isHeapAllocExtCallViaArg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtCallViaArg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00507">507</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;{</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#ab4a69173f50ebe48e69103befe516245">isHeapAllocExtFunViaArg</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(inst));</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ab4a69173f50ebe48e69103befe516245"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ab4a69173f50ebe48e69103befe516245">SVF::SVFUtil::isHeapAllocExtFunViaArg</a></div><div class="ttdeci">bool isHeapAllocExtFunViaArg(const SVFFunction *fun)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00372">SVFUtil.h:372</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab2064cb70c76f399ce115f2621adea35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2064cb70c76f399ce115f2621adea35">&#9670;&nbsp;</a></span>isHeapAllocExtCallViaRet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtCallViaRet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>interfaces to be used externally </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00513">513</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;{</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    <span class="keywordtype">bool</span> isPtrTy = cs.getInstruction()-&gt;getType()-&gt;isPointerTy();</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;    <span class="keywordflow">return</span> isPtrTy &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">isHeapAllocExtFunViaRet</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs));</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a19b96a872d9096037f20e25122e469ea"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">SVF::SVFUtil::isHeapAllocExtFunViaRet</a></div><div class="ttdeci">bool isHeapAllocExtFunViaRet(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a heap allocator/reallocator. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00366">SVFUtil.h:366</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a24514d87685f2258201f0de15d220bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24514d87685f2258201f0de15d220bbc">&#9670;&nbsp;</a></span>isHeapAllocExtCallViaRet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtCallViaRet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00519">519</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;{</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    <span class="keywordtype">bool</span> isPtrTy = inst-&gt;getType()-&gt;isPointerTy();</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    <span class="keywordflow">return</span> isPtrTy &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">isHeapAllocExtFunViaRet</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(inst));</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a19b96a872d9096037f20e25122e469ea"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">SVF::SVFUtil::isHeapAllocExtFunViaRet</a></div><div class="ttdeci">bool isHeapAllocExtFunViaRet(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a heap allocator/reallocator. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00366">SVFUtil.h:366</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab4a69173f50ebe48e69103befe516245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a69173f50ebe48e69103befe516245">&#9670;&nbsp;</a></span>isHeapAllocExtFunViaArg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtFunViaArg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00372">372</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;{</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; ExtAPI::getExtAPI()-&gt;is_arg_alloc(fun);</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a19b96a872d9096037f20e25122e469ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b96a872d9096037f20e25122e469ea">&#9670;&nbsp;</a></span>isHeapAllocExtFunViaRet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtFunViaRet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the call is a heap allocator/reallocator. </p>
<p>note that these two functions are not suppose to be used externally </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00366">366</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;{</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; (ExtAPI::getExtAPI()-&gt;is_alloc(fun)</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;                   || ExtAPI::getExtAPI()-&gt;is_realloc(fun));</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a61ed4bb80d88b0f8dbc02535c224fdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ed4bb80d88b0f8dbc02535c224fdfb">&#9670;&nbsp;</a></span>isHeapAllocOrStaticExtCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocOrStaticExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the call is a static global call. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00586">586</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;{</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#aab8ac16a9a2961f98001ab94aeaedf64">isStaticExtCall</a>(cs) || <a class="code" href="namespaceSVF_1_1SVFUtil.html#a1ebbf43e294c3f94a2a7d5c56759bbba">isHeapAllocExtCall</a>(cs);</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a1ebbf43e294c3f94a2a7d5c56759bbba"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a1ebbf43e294c3f94a2a7d5c56759bbba">SVF::SVFUtil::isHeapAllocExtCall</a></div><div class="ttdeci">bool isHeapAllocExtCall(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00530">SVFUtil.h:530</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aab8ac16a9a2961f98001ab94aeaedf64"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aab8ac16a9a2961f98001ab94aeaedf64">SVF::SVFUtil::isStaticExtCall</a></div><div class="ttdeci">bool isStaticExtCall(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00577">SVFUtil.h:577</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0c8afe88cb58a2ac484c3bc4dd15ece9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8afe88cb58a2ac484c3bc4dd15ece9">&#9670;&nbsp;</a></span>isHeapAllocOrStaticExtCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocOrStaticExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00591">591</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;{</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#aab8ac16a9a2961f98001ab94aeaedf64">isStaticExtCall</a>(inst) || <a class="code" href="namespaceSVF_1_1SVFUtil.html#a1ebbf43e294c3f94a2a7d5c56759bbba">isHeapAllocExtCall</a>(inst);</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a1ebbf43e294c3f94a2a7d5c56759bbba"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a1ebbf43e294c3f94a2a7d5c56759bbba">SVF::SVFUtil::isHeapAllocExtCall</a></div><div class="ttdeci">bool isHeapAllocExtCall(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00530">SVFUtil.h:530</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aab8ac16a9a2961f98001ab94aeaedf64"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aab8ac16a9a2961f98001ab94aeaedf64">SVF::SVFUtil::isStaticExtCall</a></div><div class="ttdeci">bool isStaticExtCall(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00577">SVFUtil.h:577</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6bc4376ada53ddfbf8df2ca817153555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc4376ada53ddfbf8df2ca817153555">&#9670;&nbsp;</a></span>isInt2PtrConstantExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* SVF::SVFUtil::isInt2PtrConstantExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00195">195</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;{</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* constExpr = SVFUtil::dyn_cast&lt;ConstantExpr&gt;(val))</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    {</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        <span class="keywordflow">if</span>(constExpr-&gt;getOpcode() == Instruction::IntToPtr)</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            <span class="keywordflow">return</span> constExpr;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    }</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;}</div><div class="ttc" id="SVF-FE_2BasicTypes_8h_html_a60115de303225d173fb935cf7619a2cb"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a></div><div class="ttdeci">llvm::ConstantExpr ConstantExpr</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00057">BasicTypes.h:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad2c53be5490882768d51aa894b37cbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c53be5490882768d51aa894b37cbf1">&#9670;&nbsp;</a></span>isIntrinsicFun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isIntrinsicFun </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00167">167</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;{</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    <span class="keywordflow">if</span> (func &amp;&amp; (func-&gt;getIntrinsicID() == llvm::Intrinsic::donothing ||</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                 func-&gt;getIntrinsicID() == llvm::Intrinsic::dbg_addr ||</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;                 func-&gt;getIntrinsicID() == llvm::Intrinsic::dbg_declare ||</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                 func-&gt;getIntrinsicID() == llvm::Intrinsic::dbg_label ||</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;                 func-&gt;getIntrinsicID() == llvm::Intrinsic::dbg_value))</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    {</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;    }</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab7f58caf27c30a1d414e06f60ca84d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f58caf27c30a1d414e06f60ca84d80">&#9670;&nbsp;</a></span>isIntrinsicInst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isIntrinsicInst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if it is an intrinsic instruction. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00181">181</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;{</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a1f4624771922dc8c2447ad7433588c73">llvm::CallBase</a>* call = llvm::dyn_cast&lt;llvm::CallBase&gt;(inst))</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    {</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a>* func = call-&gt;getCalledFunction();</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1SVFUtil.html#ad2c53be5490882768d51aa894b37cbf1">isIntrinsicFun</a>(func))</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        {</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        }</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    }</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ad2c53be5490882768d51aa894b37cbf1"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ad2c53be5490882768d51aa894b37cbf1">SVF::SVFUtil::isIntrinsicFun</a></div><div class="ttdeci">bool isIntrinsicFun(const Function *func)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00167">SVFUtil.h:167</a></div></div>
<div class="ttc" id="namespaceSVF_html_a5faee14fa1dd41447bc73ac365fe33c1"><div class="ttname"><a href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">SVF::Function</a></div><div class="ttdeci">llvm::Function Function</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00070">BasicTypes.h:70</a></div></div>
<div class="ttc" id="namespaceSVF_html_a1f4624771922dc8c2447ad7433588c73"><div class="ttname"><a href="namespaceSVF.html#a1f4624771922dc8c2447ad7433588c73">SVF::CallBase</a></div><div class="ttdeci">llvm::CallBase CallBase</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00074">BasicTypes.h:74</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1657ceed1953f96329fe7226bf7da4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1657ceed1953f96329fe7226bf7da4c">&#9670;&nbsp;</a></span>isIRFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isIRFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a file is an LLVM IR file. </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00410">410</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;{</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    llvm::ErrorOr&lt;std::unique_ptr&lt;llvm::MemoryBuffer&gt;&gt; FileOrErr = llvm::MemoryBuffer::getFileOrSTDIN(filename);</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    <span class="keywordflow">if</span> (FileOrErr.getError())</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    llvm::MemoryBufferRef Buffer = FileOrErr.get()-&gt;getMemBufferRef();</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *bufferStart =</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)Buffer.getBufferStart();</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *bufferEnd =</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;        (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)Buffer.getBufferEnd();</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <span class="keywordflow">return</span> llvm::isBitcode(bufferStart, bufferEnd) ? true :</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;           Buffer.getBuffer().startswith(<span class="stringliteral">&quot;; ModuleID =&quot;</span>);</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5f3ecd0770991b6e84afe47a3934f0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3ecd0770991b6e84afe47a3934f0d2">&#9670;&nbsp;</a></span>isLockAquireCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isLockAquireCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a lock acquire call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00647">647</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;{</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDAcquire(cs);</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a343dae805a34d102b9c1b96f173468df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343dae805a34d102b9c1b96f173468df">&#9670;&nbsp;</a></span>isLockAquireCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isLockAquireCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00651">651</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;{</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDAcquire(inst);</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a1241ef1c19df14f7db0bd62dd68f14f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1241ef1c19df14f7db0bd62dd68f14f9">&#9670;&nbsp;</a></span>isLockReleaseCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isLockReleaseCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a lock acquire call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00659">659</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;{</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDRelease(cs);</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a84ac49c70252036a957694f2cf05ae2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ac49c70252036a957694f2cf05ae2c">&#9670;&nbsp;</a></span>isLockReleaseCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isLockReleaseCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00663">663</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;{</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDRelease(inst);</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ae7007ebc6a543dc30ef076b4aed75b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7007ebc6a543dc30ef076b4aed75b1b">&#9670;&nbsp;</a></span>isNoCallerFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isNoCallerFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function does not have any possible caller in the call graph. </p>
<p>Return true if the function does not have a caller (either it is a main function or a dead function) </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00146">146</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;{</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a6d268e8d588717601345be3a911a7625">isDeadFunction</a>(fun) || <a class="code" href="namespaceSVF_1_1SVFUtil.html#a2c97c2b79b795465490512e267a9309b">isProgEntryFunction</a>(fun);</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a2c97c2b79b795465490512e267a9309b"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a2c97c2b79b795465490512e267a9309b">SVF::SVFUtil::isProgEntryFunction</a></div><div class="ttdeci">bool isProgEntryFunction(const SVFFunction *fun)</div><div class="ttdoc">Program entry function e.g. main. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00417">SVFUtil.h:417</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a6d268e8d588717601345be3a911a7625"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a6d268e8d588717601345be3a911a7625">SVF::SVFUtil::isDeadFunction</a></div><div class="ttdeci">bool isDeadFunction(const Function *fun)</div><div class="ttdoc">whether this is a function without any possible caller? </div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8cpp_source.html#l00160">LLVMUtil.cpp:160</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8d8216a92140d982303f83ea424ddc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8216a92140d982303f83ea424ddc91">&#9670;&nbsp;</a></span>isNonInstricCallSite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isNonInstricCallSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether an instruction is a callsite in the application code, excluding llvm intrinsic calls. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00209">209</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;{</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    <span class="keywordflow">if</span>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#ab7f58caf27c30a1d414e06f60ca84d80">isIntrinsicInst</a>(inst))</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">isCallSite</a>(inst);</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ab7f58caf27c30a1d414e06f60ca84d80"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ab7f58caf27c30a1d414e06f60ca84d80">SVF::SVFUtil::isIntrinsicInst</a></div><div class="ttdeci">bool isIntrinsicInst(const Instruction *inst)</div><div class="ttdoc">Return true if it is an intrinsic instruction. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00181">SVFUtil.h:181</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a38bf8f7eaa18fc5a09711959b5417854"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">SVF::SVFUtil::isCallSite</a></div><div class="ttdeci">bool isCallSite(const Value *val)</div><div class="ttdoc">Whether an instruction is a call or invoke instruction. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00201">SVFUtil.h:201</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4c1107b2635f374e71e6a3a43834469b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1107b2635f374e71e6a3a43834469b">&#9670;&nbsp;</a></span>isNullPtrSym()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isNullPtrSym </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether this value is a black hole. </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00054">54</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;{</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a7e230c0cba2e3a7c2e5a5f2ee7d88af9">Constant</a>* v = SVFUtil::dyn_cast&lt;Constant&gt;(val))</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    {</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        <span class="keywordflow">return</span> v-&gt;isNullValue() &amp;&amp; v-&gt;getType()-&gt;isPointerTy();</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    }</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a7e230c0cba2e3a7c2e5a5f2ee7d88af9"><div class="ttname"><a href="namespaceSVF.html#a7e230c0cba2e3a7c2e5a5f2ee7d88af9">SVF::Constant</a></div><div class="ttdeci">llvm::Constant Constant</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00094">BasicTypes.h:94</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acc9fd07cb66dbdeef696c3c745856094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9fd07cb66dbdeef696c3c745856094">&#9670;&nbsp;</a></span>isObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this value refers to a object. </p>
<p>A value represents an object if it is 1) function, 2) global 3) stack 4) heap </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00042">42</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;{</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="keywordtype">bool</span> createobj = <span class="keyword">false</span>;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordflow">if</span> (SVFUtil::isa&lt;Instruction&gt;(ref) &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#ae62938f722543d6d7fc201b685be1abf">SVFUtil::isStaticExtCall</a>(SVFUtil::cast&lt;Instruction&gt;(ref)) )</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        createobj = <span class="keyword">true</span>;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="keywordflow">if</span> (SVFUtil::isa&lt;Instruction&gt;(ref) &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#ab2064cb70c76f399ce115f2621adea35">SVFUtil::isHeapAllocExtCallViaRet</a>(SVFUtil::cast&lt;Instruction&gt;(ref)))</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        createobj = <span class="keyword">true</span>;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="keywordflow">if</span> (SVFUtil::isa&lt;GlobalVariable&gt;(ref))</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        createobj = <span class="keyword">true</span>;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="keywordflow">if</span> (SVFUtil::isa&lt;Function&gt;(ref) || SVFUtil::isa&lt;AllocaInst&gt;(ref) )</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        createobj = <span class="keyword">true</span>;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="keywordflow">return</span> createobj;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ab2064cb70c76f399ce115f2621adea35"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ab2064cb70c76f399ce115f2621adea35">SVF::SVFUtil::isHeapAllocExtCallViaRet</a></div><div class="ttdeci">bool isHeapAllocExtCallViaRet(const CallSite cs)</div><div class="ttdoc">interfaces to be used externally </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00513">SVFUtil.h:513</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_ae62938f722543d6d7fc201b685be1abf"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ae62938f722543d6d7fc201b685be1abf">SVF::SVFUtil::isStaticExtCall</a></div><div class="ttdeci">bool isStaticExtCall(const CallSite cs)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00571">SVFUtil.h:571</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2c97c2b79b795465490512e267a9309b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c97c2b79b795465490512e267a9309b">&#9670;&nbsp;</a></span>isProgEntryFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isProgEntryFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Program entry function e.g. main. </p>
<p>Return true if this is a program entry function (e.g. main) </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00417">417</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;{</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; fun-&gt;getName() == <span class="stringliteral">&quot;main&quot;</span>;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab87fef7b10465d3e635643fcb93b95a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87fef7b10465d3e635643fcb93b95a7">&#9670;&nbsp;</a></span>isProgEntryFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isProgEntryFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00717">717</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;{</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; fun-&gt;getName() == <span class="stringliteral">&quot;main&quot;</span>;</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a6528edf9a1750df4a84d1a60d4d0bbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6528edf9a1750df4a84d1a60d4d0bbe4">&#9670;&nbsp;</a></span>isProgExitCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isProgExitCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00723">723</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;{</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">isProgExitFunction</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs));</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aec7ee60be22e8f9397db108131696d57"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">SVF::SVFUtil::isProgExitFunction</a></div><div class="ttdeci">bool isProgExitFunction(const SVFFunction *fun)</div><div class="ttdoc">Return true if this is a program exit function call. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00449">SVFUtil.h:449</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a68b531ca4077e71dcc6d085e47a9730b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b531ca4077e71dcc6d085e47a9730b">&#9670;&nbsp;</a></span>isProgExitCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isProgExitCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00728">728</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;{</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">isProgExitFunction</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(inst));</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aec7ee60be22e8f9397db108131696d57"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">SVF::SVFUtil::isProgExitFunction</a></div><div class="ttdeci">bool isProgExitFunction(const SVFFunction *fun)</div><div class="ttdoc">Return true if this is a program exit function call. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00449">SVFUtil.h:449</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aec7ee60be22e8f9397db108131696d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7ee60be22e8f9397db108131696d57">&#9670;&nbsp;</a></span>isProgExitFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isProgExitFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this is a program exit function call. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00449">449</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;{</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; (fun-&gt;getName() == <span class="stringliteral">&quot;exit&quot;</span> ||</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;                   fun-&gt;getName() == <span class="stringliteral">&quot;__assert_rtn&quot;</span> ||</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                   fun-&gt;getName() == <span class="stringliteral">&quot;__assert_fail&quot;</span> );</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a093b7ae4ad144fb5d028366b1814861a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093b7ae4ad144fb5d028366b1814861a">&#9670;&nbsp;</a></span>isPtr2IntConstantExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* SVF::SVFUtil::isPtr2IntConstantExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00205">205</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;{</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* constExpr = SVFUtil::dyn_cast&lt;ConstantExpr&gt;(val))</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    {</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        <span class="keywordflow">if</span>(constExpr-&gt;getOpcode() == Instruction::PtrToInt)</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            <span class="keywordflow">return</span> constExpr;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    }</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;}</div><div class="ttc" id="SVF-FE_2BasicTypes_8h_html_a60115de303225d173fb935cf7619a2cb"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a></div><div class="ttdeci">llvm::ConstantExpr ConstantExpr</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00057">BasicTypes.h:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4dcfe3e66a16813350ec8dffd47c5644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcfe3e66a16813350ec8dffd47c5644">&#9670;&nbsp;</a></span>isPtrInDeadFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isPtrInDeadFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is value in a dead function (function without any caller) </p>
<p>Return true if this is a value in a dead function (function without any caller) </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00193">193</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;{</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a>* inst = SVFUtil::dyn_cast&lt;Instruction&gt;(value))</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    {</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#a6d268e8d588717601345be3a911a7625">isDeadFunction</a>(inst-&gt;getParent()-&gt;getParent()))</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    }</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a58cdfbc4160cae08745b67844ac29801">Argument</a>* arg = SVFUtil::dyn_cast&lt;Argument&gt;(value))</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    {</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        <span class="keywordflow">if</span>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#a6d268e8d588717601345be3a911a7625">isDeadFunction</a>(arg-&gt;getParent()))</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    }</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a7875172ff434b2210eea7cecfbbd959e"><div class="ttname"><a href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">SVF::Instruction</a></div><div class="ttdeci">llvm::Instruction Instruction</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00073">BasicTypes.h:73</a></div></div>
<div class="ttc" id="namespaceSVF_html_a58cdfbc4160cae08745b67844ac29801"><div class="ttname"><a href="namespaceSVF.html#a58cdfbc4160cae08745b67844ac29801">SVF::Argument</a></div><div class="ttdeci">llvm::Argument Argument</div><div class="ttdoc">LLVM Aliases and constants. </div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00093">BasicTypes.h:93</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a6d268e8d588717601345be3a911a7625"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a6d268e8d588717601345be3a911a7625">SVF::SVFUtil::isDeadFunction</a></div><div class="ttdeci">bool isDeadFunction(const Function *fun)</div><div class="ttdoc">whether this is a function without any possible caller? </div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8cpp_source.html#l00160">LLVMUtil.cpp:160</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6740e7686ba111ae525c6c093cbbaf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6740e7686ba111ae525c6c093cbbaf46">&#9670;&nbsp;</a></span>isReallocExtCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isReallocExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00547">547</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;{</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;    <span class="keywordtype">bool</span> isPtrTy = cs.getInstruction()-&gt;getType()-&gt;isPointerTy();</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;    <span class="keywordflow">return</span> isPtrTy &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">isReallocExtFun</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs));</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a97c74c642ad43d955ac8a3f3ad8907b4"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">SVF::SVFUtil::isReallocExtFun</a></div><div class="ttdeci">bool isReallocExtFun(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a heap reallocator. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00387">SVFUtil.h:387</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a42748153e4845f3eee0ca58a1e151f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42748153e4845f3eee0ca58a1e151f97">&#9670;&nbsp;</a></span>isReallocExtCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isReallocExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00553">553</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;{</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;    <span class="keywordtype">bool</span> isPtrTy = inst-&gt;getType()-&gt;isPointerTy();</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;    <span class="keywordflow">return</span> isPtrTy &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">isReallocExtFun</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(inst));</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a97c74c642ad43d955ac8a3f3ad8907b4"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">SVF::SVFUtil::isReallocExtFun</a></div><div class="ttdeci">bool isReallocExtFun(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a heap reallocator. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00387">SVFUtil.h:387</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a97c74c642ad43d955ac8a3f3ad8907b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c74c642ad43d955ac8a3f3ad8907b4">&#9670;&nbsp;</a></span>isReallocExtFun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isReallocExtFun </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the call is a heap reallocator. </p>
<p>note that this function is not suppose to be used externally </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00387">387</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;{</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; (ExtAPI::getExtAPI()-&gt;is_realloc(fun));</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="abd525a2e3b7b9167b61b2304cc2cbdf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd525a2e3b7b9167b61b2304cc2cbdf2">&#9670;&nbsp;</a></span>isReturn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isReturn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether an instruction is a return instruction. </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00068">68</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;{</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keywordflow">return</span> SVFUtil::isa&lt;ReturnInst&gt;(inst);</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a07d991d5bfccce9ebdef0cbb6f4bf739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d991d5bfccce9ebdef0cbb6f4bf739">&#9670;&nbsp;</a></span>isSelectConstantExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* SVF::SVFUtil::isSelectConstantExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00225">225</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;{</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* constExpr = SVFUtil::dyn_cast&lt;ConstantExpr&gt;(val))</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    {</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        <span class="keywordflow">if</span>(constExpr-&gt;getOpcode() == Instruction::Select)</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;            <span class="keywordflow">return</span> constExpr;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    }</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;}</div><div class="ttc" id="SVF-FE_2BasicTypes_8h_html_a60115de303225d173fb935cf7619a2cb"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a></div><div class="ttdeci">llvm::ConstantExpr ConstantExpr</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00057">BasicTypes.h:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae62938f722543d6d7fc201b685be1abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62938f722543d6d7fc201b685be1abf">&#9670;&nbsp;</a></span>isStaticExtCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isStaticExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00571">571</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;{</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;    <span class="keywordtype">bool</span> isPtrTy = cs.getInstruction()-&gt;getType()-&gt;isPointerTy();</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;    <span class="keywordflow">return</span> isPtrTy &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a1bc9bb7bd6c9682debf3ffab7182abf5">isStaticExtFun</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(cs));</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a1bc9bb7bd6c9682debf3ffab7182abf5"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a1bc9bb7bd6c9682debf3ffab7182abf5">SVF::SVFUtil::isStaticExtFun</a></div><div class="ttdeci">bool isStaticExtFun(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a static global call. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00403">SVFUtil.h:403</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aab8ac16a9a2961f98001ab94aeaedf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8ac16a9a2961f98001ab94aeaedf64">&#9670;&nbsp;</a></span>isStaticExtCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isStaticExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00577">577</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;{</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;    <span class="keywordtype">bool</span> isPtrTy = inst-&gt;getType()-&gt;isPointerTy();</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;    <span class="keywordflow">return</span> isPtrTy &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a1bc9bb7bd6c9682debf3ffab7182abf5">isStaticExtFun</a>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">getCallee</a>(inst));</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a1bc9bb7bd6c9682debf3ffab7182abf5"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a1bc9bb7bd6c9682debf3ffab7182abf5">SVF::SVFUtil::isStaticExtFun</a></div><div class="ttdeci">bool isStaticExtFun(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a static global call. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00403">SVFUtil.h:403</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_af26c7636bfef7ab2a36cccdcf12c3538"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a></div><div class="ttdeci">const SVFFunction * getCallee(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00288">SVFUtil.h:288</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1bc9bb7bd6c9682debf3ffab7182abf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc9bb7bd6c9682debf3ffab7182abf5">&#9670;&nbsp;</a></span>isStaticExtFun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isStaticExtFun </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the call is a static global call. </p>
<p>note that this function is not suppose to be used externally </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00403">403</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;{</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; ExtAPI::getExtAPI()-&gt;has_static(fun);</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a3af5073a1cdc000678f7e4bbc943f5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af5073a1cdc000678f7e4bbc943f5d5">&#9670;&nbsp;</a></span>isThreadExitCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isThreadExitCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a thread exit call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00635">635</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;{</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDExit(cs);</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aae025d6727ef34fbeaa7ad48a4dabdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae025d6727ef34fbeaa7ad48a4dabdcd">&#9670;&nbsp;</a></span>isThreadExitCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isThreadExitCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00639">639</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;{</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDExit(inst);</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5c2abeb363081381c3dc939ab511e3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2abeb363081381c3dc939ab511e3f0">&#9670;&nbsp;</a></span>isThreadForkCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isThreadForkCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a thread creation call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00599">599</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;{</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDFork(cs);</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a834afc0042c24ed5a1dd00cadc1f00c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834afc0042c24ed5a1dd00cadc1f00c3">&#9670;&nbsp;</a></span>isThreadForkCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isThreadForkCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00603">603</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;{</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDFork(inst);</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a194a8cf292726bd6cd54307b555c068a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194a8cf292726bd6cd54307b555c068a">&#9670;&nbsp;</a></span>isThreadJoinCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isThreadJoinCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallSite.html">CallSite</a>&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a thread join call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00623">623</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;{</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDJoin(cs);</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a14793b41b05439a8a82fdce02e0587d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14793b41b05439a8a82fdce02e0587d5">&#9670;&nbsp;</a></span>isThreadJoinCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isThreadJoinCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a7875172ff434b2210eea7cecfbbd959e">Instruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00627">627</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;{</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDJoin(inst);</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a1373688c6faba4dcdb640106575ea433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1373688c6faba4dcdb640106575ea433">&#9670;&nbsp;</a></span>isTruncConstantExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* SVF::SVFUtil::isTruncConstantExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00235">235</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;{</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* constExpr = SVFUtil::dyn_cast&lt;ConstantExpr&gt;(val))</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    {</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        <span class="keywordflow">if</span>(constExpr-&gt;getOpcode() == Instruction::Trunc ||</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;                constExpr-&gt;getOpcode() == Instruction::FPTrunc ||</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                constExpr-&gt;getOpcode() == Instruction::ZExt ||</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                constExpr-&gt;getOpcode() == Instruction::SExt ||</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                constExpr-&gt;getOpcode() == Instruction::FPExt)</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;            <span class="keywordflow">return</span> constExpr;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    }</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;}</div><div class="ttc" id="SVF-FE_2BasicTypes_8h_html_a60115de303225d173fb935cf7619a2cb"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a></div><div class="ttdeci">llvm::ConstantExpr ConstantExpr</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00057">BasicTypes.h:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af14757d5cf466bba20a125f118378560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14757d5cf466bba20a125f118378560">&#9670;&nbsp;</a></span>isUnaryConstantExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* SVF::SVFUtil::isUnaryConstantExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8h_source.html#l00269">269</a> of file <a class="el" href="LLVMUtil_8h_source.html">LLVMUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;{</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a>* constExpr = SVFUtil::dyn_cast&lt;ConstantExpr&gt;(val))</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    {</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        <span class="keywordflow">if</span>((constExpr-&gt;getOpcode() &gt;= Instruction::UnaryOpsBegin) &amp;&amp; (constExpr-&gt;getOpcode() &lt;= Instruction::UnaryOpsEnd))</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;            <span class="keywordflow">return</span> constExpr;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    }</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;}</div><div class="ttc" id="SVF-FE_2BasicTypes_8h_html_a60115de303225d173fb935cf7619a2cb"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a></div><div class="ttdeci">llvm::ConstantExpr ConstantExpr</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00057">BasicTypes.h:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a36c91f952a69875c33d4bd0b05a27ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c91f952a69875c33d4bd0b05a27ff2">&#9670;&nbsp;</a></span>mergePtsOccMaps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::mergePtsOccMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; Data, unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; Data, unsigned &gt;&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a map mapping points-to sets to a count, adds from into to. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00306">306</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;{</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">typename</span> Map&lt;Data, unsigned&gt;::value_type &amp;ptocc : from)</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    {</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        to[ptocc.first] += ptocc.second;</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    }</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aed0b0b9f035057552a6a82154fd88e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0b0b9f035057552a6a82154fd88e61">&#9670;&nbsp;</a></span>outs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; SVF::SVFUtil::outs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrite <a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61" title="Overwrite llvm::outs() ">llvm::outs()</a> </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00049">49</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;{</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="keywordflow">return</span> std::cout;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a609eea630a8f88fe9eaba15ce7e48738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609eea630a8f88fe9eaba15ce7e48738">&#9670;&nbsp;</a></span>pasMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::pasMsg </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print each pass/phase message by converting a string into blue string output. </p>
<p>print each pass/phase message by converting a string into blue string output </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00100">100</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;{</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#a3f838f2fc3a9a3b434be606fc908964b">KBLU</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;}</div><div class="ttc" id="SVFUtil_8cpp_html_a3f838f2fc3a9a3b434be606fc908964b"><div class="ttname"><a href="SVFUtil_8cpp.html#a3f838f2fc3a9a3b434be606fc908964b">KBLU</a></div><div class="ttdeci">#define KBLU</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00045">SVFUtil.cpp:45</a></div></div>
<div class="ttc" id="SVFUtil_8cpp_html_a137aa83ec74421d226a90c92ec032ac9"><div class="ttname"><a href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a></div><div class="ttdeci">#define KNRM</div><div class="ttdoc">Color for output format. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00041">SVFUtil.cpp:41</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a62ca9a79ce7b6960e3fc42d8b183bd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ca9a79ce7b6960e3fc42d8b183bd50">&#9670;&nbsp;</a></span>processArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::processArguments </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>arg_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>arg_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>moduleNameVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse argument for multi-module analysis. </p>
<p>Get the names of all modules into a vector And process arguments </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00427">427</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;{</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    <span class="keywordtype">bool</span> first_ir_file = <span class="keyword">true</span>;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; argc; ++i)</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    {</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;        std::string argument(argv[i]);</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1SVFUtil.html#aa1657ceed1953f96329fe7226bf7da4c">SVFUtil::isIRFile</a>(argument))</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;        {</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;            <span class="keywordflow">if</span> (find(moduleNameVec.begin(), moduleNameVec.end(), argument)</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;                    == moduleNameVec.end())</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;                moduleNameVec.push_back(argument);</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;            <span class="keywordflow">if</span> (first_ir_file)</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;            {</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;                arg_value[arg_num] = argv[i];</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;                arg_num++;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;                first_ir_file = <span class="keyword">false</span>;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;            }</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;        }</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;        {</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;            arg_value[arg_num] = argv[i];</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;            arg_num++;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;        }</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    }</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aa1657ceed1953f96329fe7226bf7da4c"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aa1657ceed1953f96329fe7226bf7da4c">SVF::SVFUtil::isIRFile</a></div><div class="ttdeci">bool isIRFile(const std::string &amp;filename)</div><div class="ttdoc">Check whether a file is an LLVM IR file. </div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8cpp_source.html#l00410">LLVMUtil.cpp:410</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a86ebab122895189be57637b84adc7642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ebab122895189be57637b84adc7642">&#9670;&nbsp;</a></span>ptsToNodeBS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> SVF::SVFUtil::ptsToNodeBS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;&#160;</td>
          <td class="paramname"><em>pts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00157">157</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;{</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <a class="code" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> nbs;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> o : pts) nbs.set(o);</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    <span class="keywordflow">return</span> nbs;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_a43a65e0d33af3c743294f7a1139d2301"><div class="ttname"><a href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">SVF::NodeID</a></div><div class="ttdeci">unsigned NodeID</div><div class="ttdef"><b>Definition:</b> <a href="MTAResultValidator_8h_source.html#l00019">MTAResultValidator.h:19</a></div></div>
<div class="ttc" id="namespaceSVF_html_a740396763e377643790c8b803ab3e4ea"><div class="ttname"><a href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">SVF::NodeBS</a></div><div class="ttdeci">llvm::SparseBitVector NodeBS</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00095">SVFBasicTypes.h:95</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aee74719d33695e4da6fee5fc83f745d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee74719d33695e4da6fee5fc83f745d9">&#9670;&nbsp;</a></span>removeKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename KeySet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::removeKey </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet &amp;&#160;</td>
          <td class="paramname"><em>keySet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an element from a Set/CondSet (or anything implementing ::erase). </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00332">332</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;{</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    keySet.erase(key);</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="aa59af7fc01a534662b3b1524186ef97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59af7fc01a534662b3b1524186ef97e">&#9670;&nbsp;</a></span>removeKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::removeKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>keySet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a NodeID from a NodeBS. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00338">338</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;{</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    keySet.reset(key);</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a6cfe12afa463d0ceddeee11540c33ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfe12afa463d0ceddeee11540c33ab3">&#9670;&nbsp;</a></span>reportMemoryUsageKB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::reportMemoryUsageKB </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>infor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;&#160;</td>
          <td class="paramname"><em>O</em> = <code><a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print memory usage in KB. </p>
<p>Print memory usage </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00168">168</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;{</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <a class="code" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> vmrss, vmsize;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">getMemoryUsageKB</a>(&amp;vmrss, &amp;vmsize))</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        O &lt;&lt; infor &lt;&lt; <span class="stringliteral">&quot;\tVmRSS: &quot;</span> &lt;&lt; vmrss &lt;&lt; <span class="stringliteral">&quot;\tVmSize: &quot;</span> &lt;&lt; vmsize &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;}</div><div class="ttc" id="namespaceSVF_html_ad42bff8d0a7d60a085aa32d10f4955af"><div class="ttname"><a href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">SVF::u32_t</a></div><div class="ttdeci">unsigned u32_t</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00084">SVFBasicTypes.h:84</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a630ff9c47f58f9b8df7c8a2b3711477c"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">SVF::SVFUtil::getMemoryUsageKB</a></div><div class="ttdeci">bool getMemoryUsageKB(u32_t *vmrss_kb, u32_t *vmsize_kb)</div><div class="ttdoc">Get memory usage from system file. Return TRUE if succeed. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00178">SVFUtil.cpp:178</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af54e70082388bbd70868250aaa0bc86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54e70082388bbd70868250aaa0bc86b">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; SVF::SVFUtil::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>seperator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split into two substrings around the first occurrence of a separator string. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00243">243</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;{</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    std::vector&lt;std::string&gt; output;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    std::string::size_type prev_pos = 0, pos = 0;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    <span class="keywordflow">while</span>((pos = s.find(seperator, pos)) != std::string::npos)</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    {</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        std::string substring( s.substr(prev_pos, pos-prev_pos) );</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        output.push_back(substring);</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        prev_pos = ++pos;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    }</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    output.push_back(s.substr(prev_pos, pos-prev_pos));</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    <span class="keywordflow">return</span> output;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a757815a2c758695176120509ceb0ce70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757815a2c758695176120509ceb0ce70">&#9670;&nbsp;</a></span>startAnalysisLimitTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::startAnalysisLimitTimer </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeLimit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts an analysis timer. If timeLimit is 0, sets no timer. If an alarm has already been set, does not set another. Returns whether we set a timer or not. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00431">431</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;{</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    <span class="keywordflow">if</span> (timeLimit == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    <span class="comment">// If an alarm is already set, don&#39;t set another. That means this analysis</span></div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    <span class="comment">// is part of another which has a time limit.</span></div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    <span class="keywordtype">unsigned</span> remainingSeconds = alarm(0);</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    <span class="keywordflow">if</span> (remainingSeconds != 0)</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    {</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        <span class="comment">// Continue the previous alarm and move on.</span></div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;        alarm(remainingSeconds);</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    }</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    signal(SIGALRM, &amp;<a class="code" href="namespaceSVF_1_1SVFUtil.html#add4cd21115988f9f5eec12e268ddf1d9">timeLimitReached</a>);</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    alarm(timeLimit);</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_add4cd21115988f9f5eec12e268ddf1d9"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#add4cd21115988f9f5eec12e268ddf1d9">SVF::SVFUtil::timeLimitReached</a></div><div class="ttdeci">void timeLimitReached(int signum)</div><div class="ttdoc">Function to call when alarm for time limit hits. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00422">SVFUtil.cpp:422</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a168f7f7a3a8c70dbf2b5b4269cd4c7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168f7f7a3a8c70dbf2b5b4269cd4c7c5">&#9670;&nbsp;</a></span>stopAnalysisLimitTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::stopAnalysisLimitTimer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>limitTimerSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops an analysis timer. limitTimerSet indicates whether the caller set the timer or not (return value of startLimitTimer). </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00452">452</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;{</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    <span class="keywordflow">if</span> (limitTimerSet) alarm(0);</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a69991ab4e9a7705202c1357079ab5fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69991ab4e9a7705202c1357079ab5fa8">&#9670;&nbsp;</a></span>stripAllCasts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> * SVF::SVFUtil::stripAllCasts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strip off the all casts. </p>
<p>Strip all casts </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00226">226</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;{</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    {</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="SVF-FE_2BasicTypes_8h.html#a20b13f90796ee748f58e6c5faa7c63da">CastInst</a> *ci = SVFUtil::dyn_cast&lt;CastInst&gt;(val))</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        {</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            val = ci-&gt;getOperand(0);</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        }</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a> *ce = SVFUtil::dyn_cast&lt;ConstantExpr&gt;(val))</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        {</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            <span class="keywordflow">if</span>(ce-&gt;isCast())</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;                val = ce-&gt;getOperand(0);</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                <span class="keywordflow">return</span> val;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        }</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        {</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;            <span class="keywordflow">return</span> val;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        }</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    }</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;}</div><div class="ttc" id="SVF-FE_2BasicTypes_8h_html_a20b13f90796ee748f58e6c5faa7c63da"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#a20b13f90796ee748f58e6c5faa7c63da">CastInst</a></div><div class="ttdeci">llvm::CastInst CastInst</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00071">BasicTypes.h:71</a></div></div>
<div class="ttc" id="SVF-FE_2BasicTypes_8h_html_a60115de303225d173fb935cf7619a2cb"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a></div><div class="ttdeci">llvm::ConstantExpr ConstantExpr</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00057">BasicTypes.h:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a86763e6a3606598580cd0172aecb5bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86763e6a3606598580cd0172aecb5bc7">&#9670;&nbsp;</a></span>stripConstantCasts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> * SVF::SVFUtil::stripConstantCasts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strip off the constant casts. </p>
<p>Strip constant casts </p>

<p class="definition">Definition at line <a class="el" href="LLVMUtil_8cpp_source.html#l00211">211</a> of file <a class="el" href="LLVMUtil_8cpp_source.html">LLVMUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;{</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="keywordflow">if</span> (SVFUtil::isa&lt;GlobalValue&gt;(val) || <a class="code" href="namespaceSVF_1_1SVFUtil.html#a6bc4376ada53ddfbf8df2ca817153555">isInt2PtrConstantExpr</a>(val))</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        <span class="keywordflow">return</span> val;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a> *CE = SVFUtil::dyn_cast&lt;ConstantExpr&gt;(val))</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    {</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        <span class="keywordflow">if</span> (Instruction::isCast(CE-&gt;getOpcode()))</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;            <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a86763e6a3606598580cd0172aecb5bc7">stripConstantCasts</a>(CE-&gt;getOperand(0));</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    }</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    <span class="keywordflow">return</span> val;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a6bc4376ada53ddfbf8df2ca817153555"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a6bc4376ada53ddfbf8df2ca817153555">SVF::SVFUtil::isInt2PtrConstantExpr</a></div><div class="ttdeci">const ConstantExpr * isInt2PtrConstantExpr(const Value *val)</div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8h_source.html#l00195">LLVMUtil.h:195</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a86763e6a3606598580cd0172aecb5bc7"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a86763e6a3606598580cd0172aecb5bc7">SVF::SVFUtil::stripConstantCasts</a></div><div class="ttdeci">const Value * stripConstantCasts(const Value *val)</div><div class="ttdoc">Strip off the constant casts. </div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8cpp_source.html#l00211">LLVMUtil.cpp:211</a></div></div>
<div class="ttc" id="SVF-FE_2BasicTypes_8h_html_a60115de303225d173fb935cf7619a2cb"><div class="ttname"><a href="SVF-FE_2BasicTypes_8h.html#a60115de303225d173fb935cf7619a2cb">ConstantExpr</a></div><div class="ttdeci">llvm::ConstantExpr ConstantExpr</div><div class="ttdef"><b>Definition:</b> <a href="SVF-FE_2BasicTypes_8h_source.html#l00057">BasicTypes.h:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a55f1f8598998a3ffbbc67d32eaf8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a55f1f8598998a3ffbbc67d32eaf8c4">&#9670;&nbsp;</a></span>sucMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::sucMsg </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns successful message by converting a string into green string output. </p>
<p>print successful message by converting a string into green string output </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00055">55</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;{</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#ac081c83b067273757f7a2e54a5957d41">KGRN</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;}</div><div class="ttc" id="SVFUtil_8cpp_html_ac081c83b067273757f7a2e54a5957d41"><div class="ttname"><a href="SVFUtil_8cpp.html#ac081c83b067273757f7a2e54a5957d41">KGRN</a></div><div class="ttdeci">#define KGRN</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00043">SVFUtil.cpp:43</a></div></div>
<div class="ttc" id="SVFUtil_8cpp_html_a137aa83ec74421d226a90c92ec032ac9"><div class="ttname"><a href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a></div><div class="ttdeci">#define KNRM</div><div class="ttdoc">Color for output format. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00041">SVFUtil.cpp:41</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="add4cd21115988f9f5eec12e268ddf1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4cd21115988f9f5eec12e268ddf1d9">&#9670;&nbsp;</a></span>timeLimitReached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::timeLimitReached </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to call when alarm for time limit hits. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00422">422</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;{</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>().flush();</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    <span class="comment">// TODO: output does not indicate which time limit is reached.</span></div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <span class="comment">//       This can be better in the future.</span></div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>() &lt;&lt; <span class="stringliteral">&quot;WPA: time limit reached\n&quot;</span>;</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    <a class="code" href="util_8h.html#a43b6ea6be735bb828bc062c70cadeff8">exit</a>(101);</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;}</div><div class="ttc" id="util_8h_html_a43b6ea6be735bb828bc062c70cadeff8"><div class="ttname"><a href="util_8h.html#a43b6ea6be735bb828bc062c70cadeff8">exit</a></div><div class="ttdeci">VOID_OR_INT exit()</div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aed0b0b9f035057552a6a82154fd88e61"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVF::SVFUtil::outs</a></div><div class="ttdeci">std::ostream &amp; outs()</div><div class="ttdoc">Overwrite llvm::outs() </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00049">SVFUtil.h:49</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a817a63e8330530cb18e077556f7ce518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817a63e8330530cb18e077556f7ce518">&#9670;&nbsp;</a></span>type2String()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::SVFUtil::type2String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a1d008c0666c145622b81d427be64c52d">Type</a> *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00457">457</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;{</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    std::string str;</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    <a class="code" href="namespaceSVF.html#a726981481ac082dcda3e4921416b65a0">llvm::raw_string_ostream</a> rawstr(str);</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(type != <span class="keyword">nullptr</span> &amp;&amp; <span class="stringliteral">&quot;Given null type!&quot;</span>);</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    rawstr &lt;&lt; *type;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    <span class="keywordflow">return</span> rawstr.str();</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;}</div><div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
<div class="ttc" id="namespaceSVF_html_a726981481ac082dcda3e4921416b65a0"><div class="ttname"><a href="namespaceSVF.html#a726981481ac082dcda3e4921416b65a0">SVF::raw_string_ostream</a></div><div class="ttdeci">llvm::raw_string_ostream raw_string_ostream</div><div class="ttdoc">LLVM outputs. </div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00083">BasicTypes.h:83</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7486fd8e5350879ed1cbd835c0d4e191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7486fd8e5350879ed1cbd835c0d4e191">&#9670;&nbsp;</a></span>value2String()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::SVFUtil::value2String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return string of an LLVM Value </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00391">391</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;{</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    std::string str;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    <a class="code" href="namespaceSVF.html#a726981481ac082dcda3e4921416b65a0">raw_string_ostream</a> rawstr(str);</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    <span class="keywordflow">if</span>(value)</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    {</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;        <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">SVF::Function</a>* fun = SVFUtil::dyn_cast&lt;Function&gt;(value))</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;            rawstr &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; fun-&gt;getName() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;            rawstr &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *value &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        rawstr &lt;&lt; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a28c0ede7e4765d2a686fc8ae0f5641a4">getSourceLoc</a>(value);</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    }</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="keywordflow">return</span> rawstr.str();</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a28c0ede7e4765d2a686fc8ae0f5641a4"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a28c0ede7e4765d2a686fc8ae0f5641a4">SVF::SVFUtil::getSourceLoc</a></div><div class="ttdeci">std::string getSourceLoc(const Value *val)</div><div class="ttdoc">Return source code including line number and file name from debug information. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00268">SVFUtil.cpp:268</a></div></div>
<div class="ttc" id="namespaceSVF_html_a5faee14fa1dd41447bc73ac365fe33c1"><div class="ttname"><a href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">SVF::Function</a></div><div class="ttdeci">llvm::Function Function</div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00070">BasicTypes.h:70</a></div></div>
<div class="ttc" id="namespaceSVF_html_a726981481ac082dcda3e4921416b65a0"><div class="ttname"><a href="namespaceSVF.html#a726981481ac082dcda3e4921416b65a0">SVF::raw_string_ostream</a></div><div class="ttdeci">llvm::raw_string_ostream raw_string_ostream</div><div class="ttdoc">LLVM outputs. </div><div class="ttdef"><b>Definition:</b> <a href="Util_2BasicTypes_8h_source.html#l00083">BasicTypes.h:83</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a077caa1b10ab84d101d79fc7ea50db2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077caa1b10ab84d101d79fc7ea50db2d">&#9670;&nbsp;</a></span>writeWrnMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::writeWrnMsg </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a message run through wrnMsg. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00068">68</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;{</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keywordflow">if</span>(Options::DisableWarn) <span class="keywordflow">return</span>;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a6c06020737f7dff22a666b75c28c5e7d">wrnMsg</a>(msg) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;}</div><div class="ttc" id="namespaceSVF_1_1SVFUtil_html_aed0b0b9f035057552a6a82154fd88e61"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVF::SVFUtil::outs</a></div><div class="ttdeci">std::ostream &amp; outs()</div><div class="ttdoc">Overwrite llvm::outs() </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00049">SVFUtil.h:49</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a6c06020737f7dff22a666b75c28c5e7d"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a6c06020737f7dff22a666b75c28c5e7d">SVF::SVFUtil::wrnMsg</a></div><div class="ttdeci">std::string wrnMsg(std::string msg)</div><div class="ttdoc">Returns warning message by converting a string into yellow string output. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00063">SVFUtil.cpp:63</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6c06020737f7dff22a666b75c28c5e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c06020737f7dff22a666b75c28c5e7d">&#9670;&nbsp;</a></span>wrnMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::wrnMsg </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns warning message by converting a string into yellow string output. </p>
<p>print warning message by converting a string into yellow string output </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00063">63</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;{</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#a897b10d246533c95ba86cb79f92e465a">KYEL</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;}</div><div class="ttc" id="SVFUtil_8cpp_html_a897b10d246533c95ba86cb79f92e465a"><div class="ttname"><a href="SVFUtil_8cpp.html#a897b10d246533c95ba86cb79f92e465a">KYEL</a></div><div class="ttdeci">#define KYEL</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00044">SVFUtil.cpp:44</a></div></div>
<div class="ttc" id="SVFUtil_8cpp_html_a137aa83ec74421d226a90c92ec032ac9"><div class="ttname"><a href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a></div><div class="ttdeci">#define KNRM</div><div class="ttdoc">Color for output format. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00041">SVFUtil.cpp:41</a></div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
