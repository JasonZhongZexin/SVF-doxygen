<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_class_s_v_f_1_1_p_a_g" xml:lang="en-US">
<title>SVF::PAG Class Reference</title>
<indexterm><primary>SVF::PAG</primary></indexterm>
<para>
<computeroutput>#include &lt;PAG.h&gt;</computeroutput>
</para>
<para>Inheritance diagram for SVF::PAG:    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="class_s_v_f_1_1_p_a_g.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
<simplesect>
    <title>Public Types    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1af34fb84e6a39ff6b23aa5e9381c7c80c"/>typedef Set&lt; const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> * &gt; <emphasis role="strong">CallSiteSet</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a52d16d0b3547a61b174424b91670e2ff"/>typedef OrderedMap&lt; const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> *, NodeID &gt; <emphasis role="strong">CallSiteToFunPtrMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ac24bbcc45a1c868705dac9204ff17316"/>typedef Map&lt; NodeID, CallSiteSet &gt; <emphasis role="strong">FunPtrToCallSitesMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a49da7e7d6273a0d8798166f95ce6bb16"/>typedef Map&lt; NodeID, NodeBS &gt; <emphasis role="strong">MemObjToFieldsMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ab18ceda2810981f4d4bb47ac88705577"/>typedef Set&lt; const <link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link> * &gt; <emphasis role="strong">PAGEdgeSet</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a3b70f1f3b785d735243962e83e210652"/>typedef std::vector&lt; const <link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link> * &gt; <emphasis role="strong">PAGEdgeList</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a1aedb70211aa31a4741615e611d64397"/>typedef std::vector&lt; const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> * &gt; <emphasis role="strong">PAGNodeList</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a7bdc824c927d79b624e93c1135ab98a6"/>typedef std::vector&lt; const <link linkend="_class_s_v_f_1_1_copy_p_e">CopyPE</link> * &gt; <emphasis role="strong">CopyPEList</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a22595c35a89f82adf447c6924dbbb8b2"/>typedef std::vector&lt; const <link linkend="_class_s_v_f_1_1_binary_o_p_p_e">BinaryOPPE</link> * &gt; <emphasis role="strong">BinaryOPList</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a6b8c71339e37338402b82734145898b6"/>typedef std::vector&lt; const <link linkend="_class_s_v_f_1_1_unary_o_p_p_e">UnaryOPPE</link> * &gt; <emphasis role="strong">UnaryOPList</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ab33607f8f36bf0a47e91ac510872a60e"/>typedef std::vector&lt; const <link linkend="_class_s_v_f_1_1_cmp_p_e">CmpPE</link> * &gt; <emphasis role="strong">CmpPEList</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1aaf91fa0a5807355e276eeaeee0638aea"/>typedef Map&lt; const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *, CopyPEList &gt; <emphasis role="strong">PHINodeMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1aa9479778e9fe166b17bb765a7a1668a2"/>typedef Map&lt; const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *, BinaryOPList &gt; <emphasis role="strong">BinaryNodeMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a471804c7fbdfacd90915c3a9cec7fccd"/>typedef Map&lt; const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *, UnaryOPList &gt; <emphasis role="strong">UnaryNodeMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a373335a3c28622cfc0aeb1ef7ae8ccf7"/>typedef Map&lt; const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *, CmpPEList &gt; <emphasis role="strong">CmpNodeMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a11b3e5d1aacf8a199b4ad35ce8cbca04"/>typedef Map&lt; const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> *, PAGNodeList &gt; <emphasis role="strong">FunToArgsListMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1aeb293a1fc183c51053bdeb749d094e5a"/>typedef Map&lt; const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> *, PAGNodeList &gt; <emphasis role="strong">CSToArgsListMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a7b983e115709d3461be9f24395c87ab4"/>typedef Map&lt; const <link linkend="_class_s_v_f_1_1_ret_block_node">RetBlockNode</link> *, const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> * &gt; <emphasis role="strong">CSToRetMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a46ce928b6bfa06c0b4a08cd3c282f696"/>typedef Map&lt; const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> *, const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> * &gt; <emphasis role="strong">FunToRetMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a369ea2832e74716757a7d4afa7cb5d60"/>typedef Map&lt; const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> *, PAGEdgeSet &gt; <emphasis role="strong">FunToPAGEdgeSetMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a8fb39e9156bb5cf07dc2329bfcfcd6f7"/>typedef Map&lt; const <link linkend="_class_s_v_f_1_1_i_c_f_g_node">ICFGNode</link> *, PAGEdgeList &gt; <emphasis role="strong">Inst2PAGEdgesMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a8974543192816d31127076f5f7292825"/>typedef Map&lt; NodeID, NodeID &gt; <emphasis role="strong">NodeToNodeMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ab17a2bedce0f05951ff19934c317460e"/>typedef std::pair&lt; NodeID, Size_t &gt; <emphasis role="strong">NodeOffset</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a3aea90fd18662381bb601779b7c63275"/>typedef std::pair&lt; NodeID, <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &gt; <emphasis role="strong">NodeLocationSet</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1afc24739cd11b6a85e1e62b8a409a2e56"/>typedef Map&lt; NodeOffset, NodeID &gt; <emphasis role="strong">NodeOffsetMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a80b31ccc3263c7d5d93aa1247eea0853"/>typedef Map&lt; NodeLocationSet, NodeID &gt; <emphasis role="strong">NodeLocationSetMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a213d27e032e81e61a72be710e5f0de74"/>typedef Map&lt; const Value *, NodeLocationSetMap &gt; <emphasis role="strong">GepValPNMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1af77e6ff9106bcb2502ceb7ce885d11a6"/>typedef Map&lt; NodePair, NodeID &gt; <emphasis role="strong">NodePairSetMap</emphasis></para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Public Member Functions    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ad274c5c15ac51cea5d09ad08febe8c14"/><link linkend="_class_s_v_f_1_1_i_c_f_g">ICFG</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1ad274c5c15ac51cea5d09ad08febe8c14">getICFG</link> ()</para>

<para>Return <link linkend="_class_s_v_f_1_1_i_c_f_g">ICFG</link>. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1af771436bf36e2831d9c945c4dbc0be16"/>OrderedNodeSet &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1af771436bf36e2831d9c945c4dbc0be16">getAllValidPtrs</link> ()</para>

<para>Return valid pointers. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1af4e69fb580bc8eec1064ac967f4f7cb2"/>void <link linkend="_class_s_v_f_1_1_p_a_g_1af4e69fb580bc8eec1064ac967f4f7cb2">initialiseCandidatePointers</link> ()</para>

<para>Initialize candidate pointers. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a79b6cf7f3c13a96513b33670ef2c8df1"/>virtual <link linkend="_class_s_v_f_1_1_p_a_g_1a79b6cf7f3c13a96513b33670ef2c8df1">~PAG</link> ()</para>

<para>Destructor. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1aa814a179b4e96ef9f6c8e00fb063eb0b"/>bool <link linkend="_class_s_v_f_1_1_p_a_g_1aa814a179b4e96ef9f6c8e00fb063eb0b">isBuiltFromFile</link> ()</para>

<para>Whether this <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> built from a txt file. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a74f9e22acb40bf952c00168a221c0b00"/><link linkend="_class_s_v_f_1_1_s_v_f_module">SVFModule</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1a74f9e22acb40bf952c00168a221c0b00">getModule</link> ()</para>

<para>Get LLVM Module. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a3767933efc81430ecd242879552f8a18"/>void <emphasis role="strong">addCallSite</emphasis> (const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> *call)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a4309ced29efb4f351dafb867206bb38b"/>const CallSiteSet &amp; <emphasis role="strong">getCallSiteSet</emphasis> () const</para>
</listitem>
            <listitem><para>PAGEdge::PAGEdgeSetTy &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1a4b89e254837eca47e09e41cf67dba722">getEdgeSet</link> (<link linkend="_class_s_v_f_1_1_p_a_g_edge_1a79080505b4744aa8806b55215ac2b0f6">PAGEdge::PEDGEK</link> kind)</para>

<para>Get/set methods to get control flow information of a <link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link>. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ae5125dd33403e055078e1c9d6ce6d778"/>PAGEdge::PAGEdgeSetTy &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1ae5125dd33403e055078e1c9d6ce6d778">getPTAEdgeSet</link> (<link linkend="_class_s_v_f_1_1_p_a_g_edge_1a79080505b4744aa8806b55215ac2b0f6">PAGEdge::PEDGEK</link> kind)</para>

<para>Get PTA edges set according to its kind. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a8b498249185812b2bd1e9bd2aac50e4e"/>bool <link linkend="_class_s_v_f_1_1_p_a_g_1a8b498249185812b2bd1e9bd2aac50e4e">hasPAGEdgeList</link> (const <link linkend="_class_s_v_f_1_1_i_c_f_g_node">ICFGNode</link> *inst) const</para>

<para>Whether this instruction has <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> Edge. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ad6d3a47e27f3aa9f3729fd9097da27d4"/>bool <emphasis role="strong">hasPTAPAGEdgeList</emphasis> (const <link linkend="_class_s_v_f_1_1_i_c_f_g_node">ICFGNode</link> *inst) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a0f59371e012da5b8e030d11d84e7154b"/>PAGEdgeList &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1a0f59371e012da5b8e030d11d84e7154b">getInstPAGEdgeList</link> (const <link linkend="_class_s_v_f_1_1_i_c_f_g_node">ICFGNode</link> *inst)</para>

<para>Given an instruction, get all its PAGEdges. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a05751b2d055ea53b8a3452ead8380813"/>PAGEdgeList &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1a05751b2d055ea53b8a3452ead8380813">getInstPTAPAGEdgeList</link> (const <link linkend="_class_s_v_f_1_1_i_c_f_g_node">ICFGNode</link> *inst)</para>

<para>Given an instruction, get all its PTA PAGEdges. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a13028887a4b608ace787c683cbd01209"/>void <link linkend="_class_s_v_f_1_1_p_a_g_1a13028887a4b608ace787c683cbd01209">addToInstPAGEdgeList</link> (<link linkend="_class_s_v_f_1_1_i_c_f_g_node">ICFGNode</link> *inst, <link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link> *edge)</para>

<para>Add a <link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link> into instruction map. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1adfd70b02bb37f3e17cb7d2edda2cf047"/>void <link linkend="_class_s_v_f_1_1_p_a_g_1adfd70b02bb37f3e17cb7d2edda2cf047">addGlobalPAGEdge</link> (const <link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link> *edge)</para>

<para>Get global PAGEdges (not in a procedure) </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1acb2c9f92f0ed39f1cd823876c37510d3"/>PAGEdgeSet &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1acb2c9f92f0ed39f1cd823876c37510d3">getGlobalPAGEdgeSet</link> ()</para>

<para>Get global PAGEdges (not in a procedure) </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ad117554c86d9e1ed90231032c96504b0"/>void <link linkend="_class_s_v_f_1_1_p_a_g_1ad117554c86d9e1ed90231032c96504b0">addPhiNode</link> (const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *res, const <link linkend="_class_s_v_f_1_1_copy_p_e">CopyPE</link> *edge)</para>

<para>Add phi node information. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a9f33422f70dc4efeb741042564aac0ba"/>bool <link linkend="_class_s_v_f_1_1_p_a_g_1a9f33422f70dc4efeb741042564aac0ba">isPhiNode</link> (const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *node) const</para>

<para>Whether this <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> is a result operand a of phi node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ad81e9de87891387c6fc860d964316d4f"/>PHINodeMap &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1ad81e9de87891387c6fc860d964316d4f">getPhiNodeMap</link> ()</para>

<para>Get all phi copy edges. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ad7b5d745134fa564934aa892f38a6990"/>void <link linkend="_class_s_v_f_1_1_p_a_g_1ad7b5d745134fa564934aa892f38a6990">addBinaryNode</link> (const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *res, const <link linkend="_class_s_v_f_1_1_binary_o_p_p_e">BinaryOPPE</link> *edge)</para>

<para>Add phi node information. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ab5292b85206dfa622cff12146755d616"/>bool <link linkend="_class_s_v_f_1_1_p_a_g_1ab5292b85206dfa622cff12146755d616">isBinaryNode</link> (const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *node) const</para>

<para>Whether this <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> is a result operand a of phi node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a6931eafe066036139d2538340ef9b95b"/>BinaryNodeMap &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1a6931eafe066036139d2538340ef9b95b">getBinaryNodeMap</link> ()</para>

<para>Get all phi copy edges. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a6b0f6fd131875d60b51d6c29577b8f29"/>void <link linkend="_class_s_v_f_1_1_p_a_g_1a6b0f6fd131875d60b51d6c29577b8f29">addUnaryNode</link> (const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *res, const <link linkend="_class_s_v_f_1_1_unary_o_p_p_e">UnaryOPPE</link> *edge)</para>

<para>Add unary node information. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ac0e8f9b3b7255479b70aecb97e9f8f00"/>bool <link linkend="_class_s_v_f_1_1_p_a_g_1ac0e8f9b3b7255479b70aecb97e9f8f00">isUnaryNode</link> (const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *node) const</para>

<para>Whether this <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> is an unary node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a71a4647b6ac6a67d69ba580b3f5cac6a"/>UnaryNodeMap &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1a71a4647b6ac6a67d69ba580b3f5cac6a">getUnaryNodeMap</link> ()</para>

<para>Get all unary edges. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a8485560177f2e3a4098b4b7d5ba3282c"/>void <link linkend="_class_s_v_f_1_1_p_a_g_1a8485560177f2e3a4098b4b7d5ba3282c">addCmpNode</link> (const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *res, const <link linkend="_class_s_v_f_1_1_cmp_p_e">CmpPE</link> *edge)</para>

<para>Add phi node information. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ab10f10221807584aa4547a612cb40a8b"/>bool <link linkend="_class_s_v_f_1_1_p_a_g_1ab10f10221807584aa4547a612cb40a8b">isCmpNode</link> (const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *node) const</para>

<para>Whether this <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> is a result operand a of phi node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a667b240e083d720b486a47308e36ae55"/>CmpNodeMap &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1a667b240e083d720b486a47308e36ae55">getCmpNodeMap</link> ()</para>

<para>Get all phi copy edges. </para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_p_a_g_1ac74bc9bfdba81862977b6148dba5becc">addFunArgs</link> (const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> *fun, const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *arg)</para>

<para>Get/set method for function/callsite arguments and returns. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ae99451bef14af36312dbf45e3447bb22"/>void <link linkend="_class_s_v_f_1_1_p_a_g_1ae99451bef14af36312dbf45e3447bb22">addFunRet</link> (const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> *fun, const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *ret)</para>

<para>Add function returns. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1aa7cdda6d4397975f27dfa524ce7cfc80"/>void <link linkend="_class_s_v_f_1_1_p_a_g_1aa7cdda6d4397975f27dfa524ce7cfc80">addCallSiteArgs</link> (<link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> *callBlockNode, const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *arg)</para>

<para>Add callsite arguments. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1af10b739e5d4459cbf954e7edfd5dc268"/>void <link linkend="_class_s_v_f_1_1_p_a_g_1af10b739e5d4459cbf954e7edfd5dc268">addCallSiteRets</link> (<link linkend="_class_s_v_f_1_1_ret_block_node">RetBlockNode</link> *retBlockNode, const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *arg)</para>

<para>Add callsite returns. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1abfb24b0a57ffe59f345a7490ce64e63d"/>bool <link linkend="_class_s_v_f_1_1_p_a_g_1abfb24b0a57ffe59f345a7490ce64e63d">hasFunArgsList</link> (const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> *func) const</para>

<para>Function has arguments list. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ab6779cc646bc50965722984f1a708811"/>FunToArgsListMap &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1ab6779cc646bc50965722984f1a708811">getFunArgsMap</link> ()</para>

<para>Get function arguments list. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ad2ff2e50f8e5234979ba9cacc6a6268c"/>const PAGNodeList &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1ad2ff2e50f8e5234979ba9cacc6a6268c">getFunArgsList</link> (const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> *func) const</para>

<para>Get function arguments list. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a157df68295822a17ad07a850a230bae1"/>bool <link linkend="_class_s_v_f_1_1_p_a_g_1a157df68295822a17ad07a850a230bae1">hasCallSiteArgsMap</link> (const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> *cs) const</para>

<para>Callsite has argument list. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ae0151d49c9199a2899d8b872dc1ebcfc"/>CSToArgsListMap &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1ae0151d49c9199a2899d8b872dc1ebcfc">getCallSiteArgsMap</link> ()</para>

<para>Get callsite argument list. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a4dac2dc4756bf3f84e6fa034a8b906da"/>const PAGNodeList &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1a4dac2dc4756bf3f84e6fa034a8b906da">getCallSiteArgsList</link> (const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> *cs) const</para>

<para>Get callsite argument list. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1af46a20842683fbbc52ac554c0777fbdc"/>CSToRetMap &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1af46a20842683fbbc52ac554c0777fbdc">getCallSiteRets</link> ()</para>

<para>Get callsite return. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ae455de4db007a5bebffd3a9c16e0b107"/>const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1ae455de4db007a5bebffd3a9c16e0b107">getCallSiteRet</link> (const <link linkend="_class_s_v_f_1_1_ret_block_node">RetBlockNode</link> *cs) const</para>

<para>Get callsite return. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a0ed3da89d9cba90888e04969dc43f5a3"/>bool <emphasis role="strong">callsiteHasRet</emphasis> (const <link linkend="_class_s_v_f_1_1_ret_block_node">RetBlockNode</link> *cs) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ac0835eaa3f23a53eb56a122bebe2ac6c"/>FunToRetMap &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1ac0835eaa3f23a53eb56a122bebe2ac6c">getFunRets</link> ()</para>

<para>Get function return list. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a838a9fa42e68b5f32853f73fa05a7c09"/>const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1a838a9fa42e68b5f32853f73fa05a7c09">getFunRet</link> (const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> *func) const</para>

<para>Get function return list. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a08f1b7f68a267b6cc5ad9cb3f1efede0"/>bool <emphasis role="strong">funHasRet</emphasis> (const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> *func) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a42a7abab6a762d75455b0954097dddc4"/>Size_t <link linkend="_class_s_v_f_1_1_p_a_g_1a42a7abab6a762d75455b0954097dddc4">getPAGNodeNum</link> () const</para>

<para>Node and edge statistics. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a74de66edb19a534fe85d4621085021ec"/>Size_t <emphasis role="strong">getPAGEdgeNum</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ad8c9f6134aa97d310f8eebbd7bf9bc8f"/>Size_t <emphasis role="strong">getValueNodeNum</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1afe02872115f15623178cb1ed8f737992"/>Size_t <emphasis role="strong">getObjectNodeNum</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a815b0acd760c050c7b352b2000675fc5"/>Size_t <emphasis role="strong">getFieldValNodeNum</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1acde529dcb2054bf50a0793d8aa51bb07"/>Size_t <emphasis role="strong">getFieldObjNodeNum</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ac2e844bdb316b2ab4bc780fbf8f48914"/>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1ac2e844bdb316b2ab4bc780fbf8f48914">getGepValNode</link> (const Value *curInst, NodeID base, const <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp;ls) const</para>

<para>Due to constaint expression, curInst is used to distinguish different instructions (e.g., memorycpy) when creating <link linkend="_class_s_v_f_1_1_gep_val_p_n">GepValPN</link>. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a6a468180bff1e8f6143587546a2e7742"/>const CallSiteToFunPtrMap &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1a6a468180bff1e8f6143587546a2e7742">getIndirectCallsites</link> () const</para>

<para>Add/get indirect callsites. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ae5d8ac3f715f0afdee0aa6194ad4a14a"/>void <emphasis role="strong">addIndirectCallsites</emphasis> (const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> *cs, NodeID funPtr)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ae4bfb3e30a81cd8ece36f59a60f0f0ca"/>NodeID <emphasis role="strong">getFunPtr</emphasis> (const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> *cs) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a63a8131c082052fc4a8c61430ce196af"/>const CallSiteSet &amp; <emphasis role="strong">getIndCallSites</emphasis> (NodeID funPtr) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1abe123c69769f8edb29acb32aaef1449d"/>bool <emphasis role="strong">isIndirectCallSites</emphasis> (const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> *cs) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a20e9df3a6397153dc3741ad5b370dc94"/>bool <emphasis role="strong">isFunPtr</emphasis> (NodeID id) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a8ea029c95a38473b1611ce7323818fe5"/>bool <link linkend="_class_s_v_f_1_1_p_a_g_1a8ea029c95a38473b1611ce7323818fe5">findPAGNode</link> (NodeID id) const</para>

<para>Get a pag node according to its ID. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a0398b47429454e019884f0867262430a"/><link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1a0398b47429454e019884f0867262430a">getIntraPAGEdge</link> (NodeID src, NodeID dst, <link linkend="_class_s_v_f_1_1_p_a_g_edge_1a79080505b4744aa8806b55215ac2b0f6">PAGEdge::PEDGEK</link> kind)</para>

<para>Get an edge according to src, dst and kind. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ae73900fac2a97736976bfad011c3cdb5"/><link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link> * <emphasis role="strong">getIntraPAGEdge</emphasis> (<link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *src, <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *dst, <link linkend="_class_s_v_f_1_1_p_a_g_edge_1a79080505b4744aa8806b55215ac2b0f6">PAGEdge::PEDGEK</link> kind)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a3aa1c92eb8a6fab72996964de80f19ac"/><link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1a3aa1c92eb8a6fab72996964de80f19ac">getPAGNode</link> (NodeID id) const</para>

<para>Get <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> ID. </para>
</listitem>
            <listitem><para>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1a5f49b7da110a626ed6605d1f108dfa25">getValueNode</link> (const Value *V)</para>

<para>Get <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> Node according to LLVM value. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ae3cdf8c2139ba043595b420624f25427"/>bool <emphasis role="strong">hasValueNode</emphasis> (const Value *V)</para>
</listitem>
            <listitem><para>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1a9e35f1d6a30c6200fb3c0c43ba4f36cb">getObjectNode</link> (const Value *V)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a12be35fbe2d830fb23fd0173eb66c108"/>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1a12be35fbe2d830fb23fd0173eb66c108">getObjectNode</link> (const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> *mem)</para>

<para>getObject - return mem object id </para>
</listitem>
            <listitem><para>const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1a2b288fce8efa1b0b1b620efec2c96eb6">getObject</link> (NodeID id) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a45017000af4946b27878bd1fbf58050f"/>const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> * <emphasis role="strong">getObject</emphasis> (const <link linkend="_class_s_v_f_1_1_obj_p_n">ObjPN</link> *node) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a4419b16246ed90e275a7be38d683d36d"/>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1a4419b16246ed90e275a7be38d683d36d">getReturnNode</link> (const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> *func) const</para>

<para>GetReturnNode - Return the unique node representing the return value of a function. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1aa7b2e9e0b3386e27af8413be4c36f519"/>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1aa7b2e9e0b3386e27af8413be4c36f519">getVarargNode</link> (const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> *func) const</para>

<para>getVarargNode - Return the unique node representing the variadic argument of a variadic function. </para>
</listitem>
            <listitem><para>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1aad5fc74d2a9baf3630ba6546a74053e7">getGepObjNode</link> (const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> *obj, const <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp;ls)</para>

<para>Get a field <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> Object node according to base mem obj and offset. </para>
</listitem>
            <listitem><para>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1ac1dd6570b74bec2a0f2ffd7d2ee064b6">getGepObjNode</link> (NodeID id, const <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp;ls)</para>

<para>Get a field obj <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> node according to a mem obj and a given offset. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1afc69b91408401d2a92d68c3414f3402d"/>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1afc69b91408401d2a92d68c3414f3402d">getFIObjNode</link> (const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> *obj) const</para>

<para>Get a field-insensitive obj <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> node according to a mem obj. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1afc4c57a4d200296cc8f7e2a8aa62fcb4"/>NodeID <emphasis role="strong">getFIObjNode</emphasis> (NodeID id) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1adc2f52d5c95c6b8718fe3f899d19cc2f"/>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1adc2f52d5c95c6b8718fe3f899d19cc2f">getBlackHoleNode</link> () const</para>

<para>Get black hole and constant id. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ad1f9568cf8b514d1fe86fa3473836580"/>NodeID <emphasis role="strong">getConstantNode</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a67dc43e25a29ff81f3e12c7b70061261"/>NodeID <emphasis role="strong">getBlkPtr</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a745eddbb75d513d9cbf76709e3d7057e"/>NodeID <emphasis role="strong">getNullPtr</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a45573c6019303fc731875df31636b059"/>bool <emphasis role="strong">isBlkPtr</emphasis> (NodeID id) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1abad086cfecdab2d71033574456eb4eb6"/>bool <emphasis role="strong">isNullPtr</emphasis> (NodeID id) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1aa9b2a2aa2e0f34c659b4728e7b0fe1ba"/>bool <emphasis role="strong">isBlkObjOrConstantObj</emphasis> (NodeID id) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a34ac3687d4f4cec9df4cd450c0019c6d"/>bool <emphasis role="strong">isBlkObj</emphasis> (NodeID id) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a5382518f3bc9c3bbb3148b9499ae5ae2"/>bool <emphasis role="strong">isConstantObj</emphasis> (NodeID id) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a2bd0a705705138be2bbc7e0b6ef3bf0f"/>bool <emphasis role="strong">isNonPointerObj</emphasis> (NodeID id) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a536287335ff3d05ff94b163b5334d935"/>const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> * <emphasis role="strong">getBlackHoleObj</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1adbc0b23c24bc25f96540f011a08d02f2"/>const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> * <emphasis role="strong">getConstantObj</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a941d6160fe0081816616f7369126ed21"/>u32_t <emphasis role="strong">getNodeNumAfterPAGBuild</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a703bb4b820a92c72e17d3290e68a39d8"/>void <emphasis role="strong">setNodeNumAfterPAGBuild</emphasis> (u32_t num)</para>
</listitem>
            <listitem><para>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1afc1e86e9690bb30138c9927368069f11">getBaseValNode</link> (NodeID nodeId)</para>

<para>Base and Offset methods for Value and Object node. </para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> <link linkend="_class_s_v_f_1_1_p_a_g_1a7cd89e53bb857f6b8ee09e291f5aad3f">getLocationSetFromBaseNode</link> (NodeID nodeId)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ae1e22e620954e3e9ede3f2bf0ac90c36"/>NodeID <emphasis role="strong">getBaseObjNode</emphasis> (NodeID id) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a459e2ef671d002ef6edf25cf0bfb7924"/>const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> * <emphasis role="strong">getBaseObj</emphasis> (NodeID id) const</para>
</listitem>
            <listitem><para>NodeBS &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1a049069cb76eada008e65b71e08ccdf46">getAllFieldsObjNode</link> (const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> *obj)</para>

<para>Get all fields of an object. </para>
</listitem>
            <listitem><para>NodeBS &amp; <link linkend="_class_s_v_f_1_1_p_a_g_1a1eb0e444364673333ff6b97f14e70a17">getAllFieldsObjNode</link> (NodeID id)</para>
</listitem>
            <listitem><para>NodeBS <link linkend="_class_s_v_f_1_1_p_a_g_1a19c4e63ab6129d4e7aeae8b280bb057b">getFieldsAfterCollapse</link> (NodeID id)</para>
</listitem>
            <listitem><para>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1af97b7459e24b23498acece32fafd82ef">addNode</link> (<link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *node, NodeID i)</para>

<para>add node into <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a7a7929598197f300b97393ecdffd81f1"/>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1a7a7929598197f300b97393ecdffd81f1">addValNode</link> (const Value *val, NodeID i)</para>

<para>Add a value (pointer) node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ab867cf7056089872daf2b27eb7ff1a8a"/>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1ab867cf7056089872daf2b27eb7ff1a8a">addObjNode</link> (const Value *val, NodeID i)</para>

<para>Add a memory obj node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a51f03f1d0fdc9ccb0e0f150877e01eb1"/>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1a51f03f1d0fdc9ccb0e0f150877e01eb1">addRetNode</link> (const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> *val, NodeID i)</para>

<para>Add a unique return node for a procedure. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a86e660bbb9764bce241bdb5c91a6705c"/>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1a86e660bbb9764bce241bdb5c91a6705c">addVarargNode</link> (const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> *val, NodeID i)</para>

<para>Add a unique vararg node for a procedure. </para>
</listitem>
            <listitem><para>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1a4f4cd384fe1b4bead9bfadb386e3f328">addGepValNode</link> (const Value *curInst, const Value *val, const <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp;ls, NodeID i, const Type *type, u32_t fieldidx)</para>

<para>Add a temp field value node, this method can only invoked by getGepValNode. </para>
</listitem>
            <listitem><para>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1a39028e2fb42dec9e0b25a48400948d48">addGepObjNode</link> (const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> *obj, const <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp;ls)</para>

<para>Add a field obj node, this method can only invoked by getGepObjNode. </para>
</listitem>
            <listitem><para>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1ae3ae274db4f5a4f86a0579cb47530f8c">addFIObjNode</link> (const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> *obj)</para>

<para>Add a field-insensitive node, this method can only invoked by getFIGepObjNode. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a98b4beb7f17585173072f3bbea20eeb6"/>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1a98b4beb7f17585173072f3bbea20eeb6">addDummyValNode</link> ()</para>

<para>Add a dummy value/object node according to node ID (llvm value is null) </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a279f9a8361c4fb438879713674455b35"/>NodeID <emphasis role="strong">addDummyValNode</emphasis> (NodeID i)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a37163a408fec4c43131efa79314f0fea"/>NodeID <emphasis role="strong">addDummyObjNode</emphasis> (const Type *type=NULL)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a6d2c4132c03661348cf61aa62f35e25b"/>NodeID <emphasis role="strong">addDummyObjNode</emphasis> (NodeID i, const Type *type)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a2e17a208081f29c33180a5de2b4dd0e9"/>const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> * <emphasis role="strong">addDummyMemObj</emphasis> (NodeID i, const Type *type)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a6b017ac98185865180d1442881278667"/>NodeID <emphasis role="strong">addBlackholeObjNode</emphasis> ()</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1adb2e3171f5c5fe98093c8a27c43e068c"/>NodeID <emphasis role="strong">addConstantObjNode</emphasis> ()</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1afdd76ad274ec1ebe31587c459c6254aa"/>NodeID <emphasis role="strong">addBlackholePtrNode</emphasis> ()</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a20fef02062c6047810907f0f8973ba2b"/>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1a20fef02062c6047810907f0f8973ba2b">addValNode</link> (const Value *, <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *node, NodeID i)</para>

<para>Add a value (pointer) node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1adfb70002cc08313c43c403c1203bf091"/>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1adfb70002cc08313c43c403c1203bf091">addObjNode</link> (const Value *, <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *node, NodeID i)</para>

<para>Add a memory obj node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1af520c7fb9b396d8f159f7254b3828f31"/>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1af520c7fb9b396d8f159f7254b3828f31">addRetNode</link> (const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> *, <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *node, NodeID i)</para>

<para>Add a unique return node for a procedure. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a10e33feca283850034891af28d7da43f"/>NodeID <link linkend="_class_s_v_f_1_1_p_a_g_1a10e33feca283850034891af28d7da43f">addVarargNode</link> (const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> *, <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *node, NodeID i)</para>

<para>Add a unique vararg node for a procedure. </para>
</listitem>
            <listitem><para>bool <link linkend="_class_s_v_f_1_1_p_a_g_1a277706ab8f62e6f95c660be9cb825a27">addEdge</link> (<link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *src, <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *dst, <link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link> *edge)</para>

<para>Add an edge into <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link>. </para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1a0c7cea14374ff762a9933b803853286e">hasNonlabeledEdge</link> (<link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *src, <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *dst, <link linkend="_class_s_v_f_1_1_p_a_g_edge_1a79080505b4744aa8806b55215ac2b0f6">PAGEdge::PEDGEK</link> kind)</para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1ab2a0e681184accace607464278525cba">hasLabeledEdge</link> (<link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *src, <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *dst, <link linkend="_class_s_v_f_1_1_p_a_g_edge_1a79080505b4744aa8806b55215ac2b0f6">PAGEdge::PEDGEK</link> kind, const <link linkend="_class_s_v_f_1_1_i_c_f_g_node">ICFGNode</link> *cs)</para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_addr_p_e">AddrPE</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1a6ac3b5eb1f34ac2257d0ba2556ed52c0">addAddrPE</link> (NodeID src, NodeID dst)</para>

<para>Add Address edge. </para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_copy_p_e">CopyPE</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1aa50bf9fbf8ff2dff0392bff0319be622">addCopyPE</link> (NodeID src, NodeID dst)</para>

<para>Add Copy edge. </para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_cmp_p_e">CmpPE</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1af88ceecaac4e20ac1dd85908b3d190c8">addCmpPE</link> (NodeID src, NodeID dst)</para>

<para>Add Copy edge. </para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_binary_o_p_p_e">BinaryOPPE</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1acf01961e2d9f3eba91c6e44c1f0137af">addBinaryOPPE</link> (NodeID src, NodeID dst)</para>

<para>Add Copy edge. </para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_unary_o_p_p_e">UnaryOPPE</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1a44e671995575a58c4a92dc892b0b7239">addUnaryOPPE</link> (NodeID src, NodeID dst)</para>

<para>Add Unary edge. </para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_load_p_e">LoadPE</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1a0dc823946e0b86027b6093fe7c907543">addLoadPE</link> (NodeID src, NodeID dst)</para>

<para>Add Load edge. </para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_store_p_e">StorePE</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1adbe031ff60dbcd981ff68e30a2e677ef">addStorePE</link> (NodeID src, NodeID dst, const <link linkend="_class_s_v_f_1_1_intra_block_node">IntraBlockNode</link> *val)</para>

<para>Add Store edge. </para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_call_p_e">CallPE</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1aa8bb3b659b70041e82aee15e8a595afb">addCallPE</link> (NodeID src, NodeID dst, const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> *cs)</para>

<para>Add Call edge. </para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_ret_p_e">RetPE</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1a2887310a7757f92063c5598ea694edbb">addRetPE</link> (NodeID src, NodeID dst, const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> *cs)</para>

<para>Add Return edge. </para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_gep_p_e">GepPE</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1a49d8956f5723957509cbc620c3e12d2e">addGepPE</link> (NodeID src, NodeID dst, const <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp;ls, bool constGep)</para>

<para>Add Gep edge. </para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_normal_gep_p_e">NormalGepPE</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1a4606d6ff072f5ac5974719035676792e">addNormalGepPE</link> (NodeID src, NodeID dst, const <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp;ls)</para>

<para>Add Offset(Gep) edge. </para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_variant_gep_p_e">VariantGepPE</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1a9d575070ab5234078590f9e8bf80bbf4">addVariantGepPE</link> (NodeID src, NodeID dst)</para>

<para>Add Variant(Gep) edge. </para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_t_d_fork_p_e">TDForkPE</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1a806249f7589b55d57a62a5473bebc2e4">addThreadForkPE</link> (NodeID src, NodeID dst, const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> *cs)</para>

<para>Add Thread fork edge for parameter passing. </para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_t_d_join_p_e">TDJoinPE</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1a37c31f1829f540fb0a4b57b7de3e7bca">addThreadJoinPE</link> (NodeID src, NodeID dst, const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> *cs)</para>

<para>Add Thread join edge for parameter passing. </para>
</listitem>
            <listitem><para><link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1addb513f5571acf2854adc878e58cf523">addBlackHoleAddrPE</link> (NodeID node)</para>

<para>Set a pointer points-to black hole (e.g. int2ptr) </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a17fab82554f5a81c22c037b5813999e3"/>bool <link linkend="_class_s_v_f_1_1_p_a_g_1a17fab82554f5a81c22c037b5813999e3">isValidPointer</link> (NodeID nodeId) const</para>

<para>Whether a node is a valid pointer. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a107c329c9524b2c029ff3fd8088dab67"/>bool <emphasis role="strong">isValidTopLevelPtr</emphasis> (const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> *node)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1aa18a51570a397eabffdd613fdb15b4ac"/>std::string <link linkend="_class_s_v_f_1_1_p_a_g_1aa18a51570a397eabffdd613fdb15b4ac">getGraphName</link> () const</para>

<para>Return graph name. </para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_p_a_g_1aa432bbc7c4e83abecdc8706972a9635b">print</link> ()</para>

<para>Print <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link>. </para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_p_a_g_1ab4326448a536de1c8c1513fcf6d45aa2">dump</link> (std::string name)</para>

<para>Dump <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link>. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Static Public Member Functions    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ac8910c7330638bdf31c23d4cc03ba9c5"/>static <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> * <link linkend="_class_s_v_f_1_1_p_a_g_1ac8910c7330638bdf31c23d4cc03ba9c5">getPAG</link> (bool buildFromFile=false)</para>

<para>Singleton design here to make sure we only have one instance during any analysis. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ac606fa72b7f1d0b4901519f6bba02fc7"/>static void <emphasis role="strong">releasePAG</emphasis> ()</para>
</listitem>
            <listitem><para>static void <link linkend="_class_s_v_f_1_1_p_a_g_1ab6f0bc584f351839c9dba440e8d382a0">handleBlackHole</link> (bool b)</para>

<para><link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> build configurations. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Public Attributes    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a7bd46d36d58cc8ec70d8a42e5eb93683"/>u32_t <emphasis role="strong">totalPTAPAGEdge</emphasis></para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Additional Inherited Members    </title>
</simplesect>
<section>
<title>Detailed Description</title>

<para>Program Assignment Graph for pointer analysis SymID and NodeID are equal here (same numbering). </para>
</section>
<section>
<title>Member Function Documentation</title>
<anchor xml:id="_class_s_v_f_1_1_p_a_g_1a6ac3b5eb1f34ac2257d0ba2556ed52c0"/>    <section>
    <title>addAddrPE()</title>
<indexterm><primary>addAddrPE</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addAddrPE</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_addr_p_e">AddrPE</link> * PAG::addAddrPE (NodeID src, NodeID dst)</computeroutput></para><para>

<para>Add Address edge. </para>
</para>

<para>Add Address edge </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1acf01961e2d9f3eba91c6e44c1f0137af"/>    <section>
    <title>addBinaryOPPE()</title>
<indexterm><primary>addBinaryOPPE</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addBinaryOPPE</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_binary_o_p_p_e">BinaryOPPE</link> * PAG::addBinaryOPPE (NodeID src, NodeID dst)</computeroutput></para><para>

<para>Add Copy edge. </para>
</para>

<para>Add Compare edge </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1addb513f5571acf2854adc878e58cf523"/>    <section>
    <title>addBlackHoleAddrPE()</title>
<indexterm><primary>addBlackHoleAddrPE</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addBlackHoleAddrPE</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link> * PAG::addBlackHoleAddrPE (NodeID node)</computeroutput></para><para>

<para>Set a pointer points-to black hole (e.g. int2ptr) </para>
</para>

<para>Add blackhole/constant edge </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1aa8bb3b659b70041e82aee15e8a595afb"/>    <section>
    <title>addCallPE()</title>
<indexterm><primary>addCallPE</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addCallPE</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_call_p_e">CallPE</link> * PAG::addCallPE (NodeID src, NodeID dst, const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> * cs)</computeroutput></para><para>

<para>Add Call edge. </para>
</para>

<para>Add Call edge </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1af88ceecaac4e20ac1dd85908b3d190c8"/>    <section>
    <title>addCmpPE()</title>
<indexterm><primary>addCmpPE</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addCmpPE</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_cmp_p_e">CmpPE</link> * PAG::addCmpPE (NodeID src, NodeID dst)</computeroutput></para><para>

<para>Add Copy edge. </para>
</para>

<para>Add Compare edge </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1aa50bf9fbf8ff2dff0392bff0319be622"/>    <section>
    <title>addCopyPE()</title>
<indexterm><primary>addCopyPE</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addCopyPE</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_copy_p_e">CopyPE</link> * PAG::addCopyPE (NodeID src, NodeID dst)</computeroutput></para><para>

<para>Add Copy edge. </para>
</para>

<para>Add Copy edge </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a277706ab8f62e6f95c660be9cb825a27"/>    <section>
    <title>addEdge()</title>
<indexterm><primary>addEdge</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addEdge</secondary></indexterm>
<para><computeroutput>bool PAG::addEdge (<link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> * src, <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> * dst, <link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link> * edge)</computeroutput></para><para>

<para>Add an edge into <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link>. </para>
</para>

<para>Add a <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> edge</para>

<para>Add a <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> edge into edge map </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ae3ae274db4f5a4f86a0579cb47530f8c"/>    <section>
    <title>addFIObjNode()</title>
<indexterm><primary>addFIObjNode</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addFIObjNode</secondary></indexterm>
<para><computeroutput>NodeID PAG::addFIObjNode (const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> * obj)</computeroutput></para><para>

<para>Add a field-insensitive node, this method can only invoked by getFIGepObjNode. </para>
</para>

<para>Add a field-insensitive node, this method can only invoked by getFIGepObjNode </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ac74bc9bfdba81862977b6148dba5becc"/>    <section>
    <title>addFunArgs()</title>
<indexterm><primary>addFunArgs</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addFunArgs</secondary></indexterm>
<para><computeroutput>void SVF::PAG::addFunArgs (const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> * fun, const <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> * arg)<computeroutput>[inline]</computeroutput></computeroutput></para><para>

<para>Get/set method for function/callsite arguments and returns. </para>
</para>

<para>Add function arguments </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a39028e2fb42dec9e0b25a48400948d48"/>    <section>
    <title>addGepObjNode()</title>
<indexterm><primary>addGepObjNode</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addGepObjNode</secondary></indexterm>
<para><computeroutput>NodeID PAG::addGepObjNode (const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> * obj, const <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp; ls)</computeroutput></para><para>

<para>Add a field obj node, this method can only invoked by getGepObjNode. </para>
</para>

<para>Add a field obj node, this method can only invoked by getGepObjNode </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a49d8956f5723957509cbc620c3e12d2e"/>    <section>
    <title>addGepPE()</title>
<indexterm><primary>addGepPE</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addGepPE</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_gep_p_e">GepPE</link> * PAG::addGepPE (NodeID src, NodeID dst, const <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp; ls, bool constGep)</computeroutput></para><para>

<para>Add Gep edge. </para>
</para>

<para>Add Offset(Gep) edge Find the base node id of src and connect base node to dst node Create gep offset: (offset + baseOff &lt;nested struct gep size&gt;) </para>

<para>Since the offset from base to src is variant, the new gep edge being created is also a <link linkend="_class_s_v_f_1_1_variant_gep_p_e">VariantGepPE</link> edge.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a4f4cd384fe1b4bead9bfadb386e3f328"/>    <section>
    <title>addGepValNode()</title>
<indexterm><primary>addGepValNode</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addGepValNode</secondary></indexterm>
<para><computeroutput>NodeID PAG::addGepValNode (const Value * curInst, const Value * gepVal, const <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp; ls, NodeID i, const Type * type, u32_t fieldidx)</computeroutput></para><para>

<para>Add a temp field value node, this method can only invoked by getGepValNode. </para>
</para>

<para>Add a temp field value node, this method can only invoked by getGepValNode due to constaint expression, curInst is used to distinguish different instructions (e.g., memorycpy) when creating <link linkend="_class_s_v_f_1_1_gep_val_p_n">GepValPN</link>. </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a0dc823946e0b86027b6093fe7c907543"/>    <section>
    <title>addLoadPE()</title>
<indexterm><primary>addLoadPE</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addLoadPE</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_load_p_e">LoadPE</link> * PAG::addLoadPE (NodeID src, NodeID dst)</computeroutput></para><para>

<para>Add Load edge. </para>
</para>

<para>Add Load edge </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1af97b7459e24b23498acece32fafd82ef"/>    <section>
    <title>addNode()</title>
<indexterm><primary>addNode</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addNode</secondary></indexterm>
<para><computeroutput>NodeID SVF::PAG::addNode (<link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> * node, NodeID i)<computeroutput>[inline]</computeroutput></computeroutput></para><para>

<para>add node into <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> </para>
</para>

<para>Add a <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> node into Node map </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a4606d6ff072f5ac5974719035676792e"/>    <section>
    <title>addNormalGepPE()</title>
<indexterm><primary>addNormalGepPE</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addNormalGepPE</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_normal_gep_p_e">NormalGepPE</link> * PAG::addNormalGepPE (NodeID src, NodeID dst, const <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp; ls)</computeroutput></para><para>

<para>Add Offset(Gep) edge. </para>
</para>

<para>Add normal (Gep) edge </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a2887310a7757f92063c5598ea694edbb"/>    <section>
    <title>addRetPE()</title>
<indexterm><primary>addRetPE</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addRetPE</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_ret_p_e">RetPE</link> * PAG::addRetPE (NodeID src, NodeID dst, const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> * cs)</computeroutput></para><para>

<para>Add Return edge. </para>
</para>

<para>Add Return edge </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1adbe031ff60dbcd981ff68e30a2e677ef"/>    <section>
    <title>addStorePE()</title>
<indexterm><primary>addStorePE</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addStorePE</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_store_p_e">StorePE</link> * PAG::addStorePE (NodeID src, NodeID dst, const <link linkend="_class_s_v_f_1_1_intra_block_node">IntraBlockNode</link> * curVal)</computeroutput></para><para>

<para>Add Store edge. </para>
</para>

<para>Add Store edge Note that two store instructions may share the same Store <link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link> </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a806249f7589b55d57a62a5473bebc2e4"/>    <section>
    <title>addThreadForkPE()</title>
<indexterm><primary>addThreadForkPE</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addThreadForkPE</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_t_d_fork_p_e">TDForkPE</link> * PAG::addThreadForkPE (NodeID src, NodeID dst, const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> * cs)</computeroutput></para><para>

<para>Add Thread fork edge for parameter passing. </para>
</para>

<para>Add Thread fork edge for parameter passing from a spawner to its spawnees </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a37c31f1829f540fb0a4b57b7de3e7bca"/>    <section>
    <title>addThreadJoinPE()</title>
<indexterm><primary>addThreadJoinPE</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addThreadJoinPE</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_t_d_join_p_e">TDJoinPE</link> * PAG::addThreadJoinPE (NodeID src, NodeID dst, const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> * cs)</computeroutput></para><para>

<para>Add Thread join edge for parameter passing. </para>
</para>

<para>Add Thread fork edge for parameter passing from a spawnee back to its spawners </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a44e671995575a58c4a92dc892b0b7239"/>    <section>
    <title>addUnaryOPPE()</title>
<indexterm><primary>addUnaryOPPE</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addUnaryOPPE</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_unary_o_p_p_e">UnaryOPPE</link> * PAG::addUnaryOPPE (NodeID src, NodeID dst)</computeroutput></para><para>

<para>Add Unary edge. </para>
</para>

<para>Add Unary edge </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a9d575070ab5234078590f9e8bf80bbf4"/>    <section>
    <title>addVariantGepPE()</title>
<indexterm><primary>addVariantGepPE</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>addVariantGepPE</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_variant_gep_p_e">VariantGepPE</link> * PAG::addVariantGepPE (NodeID src, NodeID dst)</computeroutput></para><para>

<para>Add Variant(Gep) edge. </para>
</para>

<para>Add variant(Gep) edge Find the base node id of src and connect base node to dst node </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ab4326448a536de1c8c1513fcf6d45aa2"/>    <section>
    <title>dump()</title>
<indexterm><primary>dump</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>dump</secondary></indexterm>
<para><computeroutput>void PAG::dump (std::string name)</computeroutput></para><para>

<para>Dump <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link>. </para>
</para>

<para>Dump this <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a049069cb76eada008e65b71e08ccdf46"/>    <section>
    <title>getAllFieldsObjNode()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>getAllFieldsObjNode</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>getAllFieldsObjNode</secondary></indexterm>
<para><computeroutput>NodeBS &amp; PAG::getAllFieldsObjNode (const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> * obj)</computeroutput></para><para>

<para>Get all fields of an object. </para>
</para>

<para>Get all fields object nodes of an object </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a1eb0e444364673333ff6b97f14e70a17"/>    <section>
    <title>getAllFieldsObjNode()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>getAllFieldsObjNode</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>getAllFieldsObjNode</secondary></indexterm>
<para><computeroutput>NodeBS &amp; PAG::getAllFieldsObjNode (NodeID id)</computeroutput></para>
<para>Get all fields object nodes of an object </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1afc1e86e9690bb30138c9927368069f11"/>    <section>
    <title>getBaseValNode()</title>
<indexterm><primary>getBaseValNode</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>getBaseValNode</secondary></indexterm>
<para><computeroutput>NodeID PAG::getBaseValNode (NodeID nodeId)</computeroutput></para><para>

<para>Base and Offset methods for Value and Object node. </para>
</para>

<para>Get a base pointer node given a field pointer</para>

<para>Get a base pointer given a pointer Return the source node of its connected gep edge if this pointer has Otherwise return the node id itself </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a4b89e254837eca47e09e41cf67dba722"/>    <section>
    <title>getEdgeSet()</title>
<indexterm><primary>getEdgeSet</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>getEdgeSet</secondary></indexterm>
<para><computeroutput>PAGEdge::PAGEdgeSetTy&amp; SVF::PAG::getEdgeSet (<link linkend="_class_s_v_f_1_1_p_a_g_edge_1a79080505b4744aa8806b55215ac2b0f6">PAGEdge::PEDGEK</link> kind)<computeroutput>[inline]</computeroutput></computeroutput></para><para>

<para>Get/set methods to get control flow information of a <link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link>. </para>
</para>

<para>Get edges set according to its kind </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a19c4e63ab6129d4e7aeae8b280bb057b"/>    <section>
    <title>getFieldsAfterCollapse()</title>
<indexterm><primary>getFieldsAfterCollapse</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>getFieldsAfterCollapse</secondary></indexterm>
<para><computeroutput>NodeBS PAG::getFieldsAfterCollapse (NodeID id)</computeroutput></para>
<para>Get all fields object nodes of an object If this object is collapsed into one field insensitive object Then only return this field insensitive object </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1aad5fc74d2a9baf3630ba6546a74053e7"/>    <section>
    <title>getGepObjNode()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>getGepObjNode</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>getGepObjNode</secondary></indexterm>
<para><computeroutput>NodeID PAG::getGepObjNode (const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> * obj, const <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp; ls)</computeroutput></para><para>

<para>Get a field <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> Object node according to base mem obj and offset. </para>
</para>

<para>Get a field obj <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> node according to base mem obj and offset To support flexible field sensitive analysis with regard to MaxFieldOffset offset = offset % obj-&gt;getMaxFieldOffsetLimit() to create limited number of mem objects maximum number of field object creation is obj-&gt;getMaxFieldOffsetLimit() </para>

<para>if this obj is field-insensitive, just return the field-insensitive node.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ac1dd6570b74bec2a0f2ffd7d2ee064b6"/>    <section>
    <title>getGepObjNode()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>getGepObjNode</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>getGepObjNode</secondary></indexterm>
<para><computeroutput>NodeID PAG::getGepObjNode (NodeID id, const <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp; ls)</computeroutput></para><para>

<para>Get a field obj <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> node according to a mem obj and a given offset. </para>
</para>

<para>Given an object node, find its field object node </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a7cd89e53bb857f6b8ee09e291f5aad3f"/>    <section>
    <title>getLocationSetFromBaseNode()</title>
<indexterm><primary>getLocationSetFromBaseNode</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>getLocationSetFromBaseNode</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> PAG::getLocationSetFromBaseNode (NodeID nodeId)</computeroutput></para>
<para>Get a base <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> given a pointer Return the source node of its connected normal gep edge Otherwise return the node id itself Size_t offset : gep offset </para>

<para>if this node is already a base node</para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a2b288fce8efa1b0b1b620efec2c96eb6"/>    <section>
    <title>getObject()</title>
<indexterm><primary>getObject</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>getObject</secondary></indexterm>
<para><computeroutput>const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link>* SVF::PAG::getObject (NodeID id) const<computeroutput>[inline]</computeroutput></computeroutput></para>
<para>Get memory object - Return memory object according to pag node id return whole allocated memory object if this node is a gep obj node return NULL is this node is not a <link linkend="_class_s_v_f_1_1_obj_p_n">ObjPN</link> type </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a9e35f1d6a30c6200fb3c0c43ba4f36cb"/>    <section>
    <title>getObjectNode()</title>
<indexterm><primary>getObjectNode</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>getObjectNode</secondary></indexterm>
<para><computeroutput>NodeID SVF::PAG::getObjectNode (const Value * V)<computeroutput>[inline]</computeroutput></computeroutput></para>
<para>getObject - Return the obj node id refer to the memory object for the specified global, heap or alloca instruction according to llvm value. </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a5f49b7da110a626ed6605d1f108dfa25"/>    <section>
    <title>getValueNode()</title>
<indexterm><primary>getValueNode</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>getValueNode</secondary></indexterm>
<para><computeroutput>NodeID SVF::PAG::getValueNode (const Value * V)<computeroutput>[inline]</computeroutput></computeroutput></para><para>

<para>Get <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> Node according to LLVM value. </para>
</para>

<para>getNode - Return the node corresponding to the specified pointer. </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ab6f0bc584f351839c9dba440e8d382a0"/>    <section>
    <title>handleBlackHole()</title>
<indexterm><primary>handleBlackHole</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>handleBlackHole</secondary></indexterm>
<para><computeroutput>void PAG::handleBlackHole (bool b)<computeroutput>[static]</computeroutput></computeroutput></para><para>

<para><link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> build configurations. </para>
</para>

<para>Whether to handle blackhole edge </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1ab2a0e681184accace607464278525cba"/>    <section>
    <title>hasLabeledEdge()</title>
<indexterm><primary>hasLabeledEdge</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>hasLabeledEdge</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link> * PAG::hasLabeledEdge (<link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> * src, <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> * dst, <link linkend="_class_s_v_f_1_1_p_a_g_edge_1a79080505b4744aa8806b55215ac2b0f6">PAGEdge::PEDGEK</link> kind, const <link linkend="_class_s_v_f_1_1_i_c_f_g_node">ICFGNode</link> * callInst)</computeroutput></para>
<para>Return true if this labeled edge exits, including store, call and load two store edge can have same dst and src but located in different basic blocks, thus flags are needed to distinguish them</para>

<para>Return true if it is an inter-procedural edge </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1a0c7cea14374ff762a9933b803853286e"/>    <section>
    <title>hasNonlabeledEdge()</title>
<indexterm><primary>hasNonlabeledEdge</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>hasNonlabeledEdge</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_p_a_g_edge">PAGEdge</link> * PAG::hasNonlabeledEdge (<link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> * src, <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> * dst, <link linkend="_class_s_v_f_1_1_p_a_g_edge_1a79080505b4744aa8806b55215ac2b0f6">PAGEdge::PEDGEK</link> kind)</computeroutput></para>
<para>Return true if it is an intra-procedural edge </para>
    </section><anchor xml:id="_class_s_v_f_1_1_p_a_g_1aa432bbc7c4e83abecdc8706972a9635b"/>    <section>
    <title>print()</title>
<indexterm><primary>print</primary><secondary>SVF::PAG</secondary></indexterm>
<indexterm><primary>SVF::PAG</primary><secondary>print</secondary></indexterm>
<para><computeroutput>void PAG::print ( )</computeroutput></para><para>

<para>Print <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link>. </para>
</para>

<para>Print this <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> graph including its nodes and edges </para>
</section>
<para>
The documentation for this class was generated from the following files:</para>
include/Graphs/PAG.hlib/Graphs/PAG.cpp</section>
</section>
