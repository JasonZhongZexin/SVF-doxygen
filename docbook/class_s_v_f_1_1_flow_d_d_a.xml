<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_class_s_v_f_1_1_flow_d_d_a" xml:lang="en-US">
<title>SVF::FlowDDA Class Reference</title>
<indexterm><primary>SVF::FlowDDA</primary></indexterm>
<para>
<computeroutput>#include &lt;FlowDDA.h&gt;</computeroutput>
</para>
<para>Inheritance diagram for SVF::FlowDDA:    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="class_s_v_f_1_1_flow_d_d_a.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
<simplesect>
    <title>Public Types    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1a5f51c3ba53410fa31225b8ff6fb5e4b4"/>typedef BVDataPTAImpl::CallSiteSet <emphasis role="strong">CallSiteSet</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1a5a5548577e4a3e225185c4001386fc84"/>typedef BVDataPTAImpl::CallEdgeMap <emphasis role="strong">CallEdgeMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1ae1ec4e6e9b967a7fd36c32f21e05ba11"/>typedef BVDataPTAImpl::FunctionSet <emphasis role="strong">FunctionSet</emphasis></para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Public Member Functions    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1af0459d7277ed2dfcf0e97c0c998f5710"/><link linkend="_class_s_v_f_1_1_flow_d_d_a_1af0459d7277ed2dfcf0e97c0c998f5710">FlowDDA</link> (<link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> *<link linkend="_class_s_v_f_1_1_d_d_a_v_f_solver_1af08857f907caa32c090eed2c1b404729">_pag</link>, <link linkend="_class_s_v_f_1_1_d_d_a_client">DDAClient</link> *client)</para>

<para>Constructor. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1a2f67714c2dc72384de9c80bf0848adfd"/>virtual <link linkend="_class_s_v_f_1_1_flow_d_d_a_1a2f67714c2dc72384de9c80bf0848adfd">~FlowDDA</link> ()</para>

<para>Destructor. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1aa26f9b5ba2e51f904d8ede1db8584460"/>virtual void <link linkend="_class_s_v_f_1_1_flow_d_d_a_1aa26f9b5ba2e51f904d8ede1db8584460">analyze</link> () override</para>

<para>dummy analyze method </para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_flow_d_d_a_1a113faa56ee75eff39da19fd4b47a47e0">computeDDAPts</link> (NodeID id) override</para>

<para>Compute points-to set for all top variable. </para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_flow_d_d_a_1a8930c3b8f3b58dca8da6017310bb74ae">handleOutOfBudgetDpm</link> (const <link linkend="_class_s_v_f_1_1_stmt_d_p_item">LocDPItem</link> &amp;dpm)</para>

<para>Handle out-of-budget dpm. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1addb412dc03c7684889693ce263585867"/>virtual bool <link linkend="_class_s_v_f_1_1_flow_d_d_a_1addb412dc03c7684889693ce263585867">handleBKCondition</link> (<link linkend="_class_s_v_f_1_1_stmt_d_p_item">LocDPItem</link> &amp;dpm, const <link linkend="_class_s_v_f_1_1_v_f_g_edge">SVFGEdge</link> *edge) override</para>

<para>Handle condition for flow analysis (backward analysis) </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1ae48534b36222578855708c298f81f554"/>bool <link linkend="_class_s_v_f_1_1_flow_d_d_a_1ae48534b36222578855708c298f81f554">testIndCallReachability</link> (<link linkend="_class_s_v_f_1_1_stmt_d_p_item">LocDPItem</link> &amp;dpm, const <link linkend="_class_s_v_f_1_1_s_v_f_function">SVFFunction</link> *callee, CallSiteID csId)</para>

<para>refine indirect call edge </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1af1fcf058a9feefeda63f07d4189513a1"/>virtual void <link linkend="_class_s_v_f_1_1_flow_d_d_a_1af1fcf058a9feefeda63f07d4189513a1">initialize</link> () override</para>

<para>Initialization of the analysis. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1a5abae08577ab24684653421dc712431a"/>virtual void <link linkend="_class_s_v_f_1_1_flow_d_d_a_1a5abae08577ab24684653421dc712431a">finalize</link> () override</para>

<para>Finalize analysis. </para>
</listitem>
            <listitem><para>virtual bool <link linkend="_class_s_v_f_1_1_flow_d_d_a_1afc3b2b4e0da7a2484ec35c3ce84a9d60">isHeapCondMemObj</link> (const NodeID &amp;var, const <link linkend="_class_s_v_f_1_1_store_v_f_g_node">StoreSVFGNode</link> *store) override</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1a086e428c83c2c3ed7fdfbbfd17abdf78"/>virtual PointsTo <link linkend="_class_s_v_f_1_1_flow_d_d_a_1a086e428c83c2c3ed7fdfbbfd17abdf78">getConservativeCPts</link> (const <link linkend="_class_s_v_f_1_1_stmt_d_p_item">LocDPItem</link> &amp;dpm) override</para>

<para>Override parent method. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1a9749c82c1164adb17e2ae53e725ded9a"/>virtual NodeID <link linkend="_class_s_v_f_1_1_flow_d_d_a_1a9749c82c1164adb17e2ae53e725ded9a">getPtrNodeID</link> (const NodeID &amp;var) const override</para>

<para>Override parent method. </para>
</listitem>
            <listitem><para>virtual void <link linkend="_class_s_v_f_1_1_flow_d_d_a_1a1b8d66dbe8c6587e74d70f5d231eb69d">handleAddr</link> (PointsTo &amp;pts, const <link linkend="_class_s_v_f_1_1_stmt_d_p_item">LocDPItem</link> &amp;dpm, const <link linkend="_class_s_v_f_1_1_addr_v_f_g_node">AddrSVFGNode</link> *addr) override</para>

<para>Handle Address SVFGNode to add proper points-to. </para>
</listitem>
            <listitem><para>virtual PointsTo <link linkend="_class_s_v_f_1_1_flow_d_d_a_1ac48be374351dad54ee2418dde841cf24">processGepPts</link> (const <link linkend="_class_s_v_f_1_1_gep_v_f_g_node">GepSVFGNode</link> *gep, const PointsTo &amp;srcPts) override</para>

<para>processGep node </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1ad6f9b84e18367f40c7c2d26bedda7684"/>virtual void <link linkend="_class_s_v_f_1_1_flow_d_d_a_1ad6f9b84e18367f40c7c2d26bedda7684">updateCallGraphAndSVFG</link> (const <link linkend="_class_s_v_f_1_1_stmt_d_p_item">LocDPItem</link> &amp;dpm, const <link linkend="_class_s_v_f_1_1_call_block_node">CallBlockNode</link> *cs, SVFGEdgeSet &amp;svfgEdges) override</para>

<para>Update call graph. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1a950d653b249cfc2d20932adb3498b99b"/>virtual const PointsTo &amp; <link linkend="_class_s_v_f_1_1_flow_d_d_a_1a950d653b249cfc2d20932adb3498b99b">getCachedTLPointsTo</link> (const <link linkend="_class_s_v_f_1_1_stmt_d_p_item">LocDPItem</link> &amp;dpm) override</para>

<para>Override parent class functions to get/add cached points-to directly via <link linkend="_class_s_v_f_1_1_p_a_g_node">PAGNode</link> ID. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1a3d08dfe5a1571f5d631afcd304905a05"/>virtual bool <link linkend="_class_s_v_f_1_1_flow_d_d_a_1a3d08dfe5a1571f5d631afcd304905a05">unionDDAPts</link> (<link linkend="_class_s_v_f_1_1_stmt_d_p_item">LocDPItem</link> dpm, const PointsTo &amp;targetPts) override</para>

<para>Union pts. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1ab3edece1bfb076bc01d60829615f2fa9"/>virtual const std::string <link linkend="_class_s_v_f_1_1_flow_d_d_a_1ab3edece1bfb076bc01d60829615f2fa9">PTAName</link> () const override</para>

<para>Return PTA name. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Additional Inherited Members    </title>
</simplesect>
<section>
<title>Detailed Description</title>

<para>Flow sensitive demand-driven analysis on value-flow graph </para>
</section>
<section>
<title>Member Function Documentation</title>
<anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1a113faa56ee75eff39da19fd4b47a47e0"/>    <section>
    <title>computeDDAPts()</title>
<indexterm><primary>computeDDAPts</primary><secondary>SVF::FlowDDA</secondary></indexterm>
<indexterm><primary>SVF::FlowDDA</primary><secondary>computeDDAPts</secondary></indexterm>
<para><computeroutput>void FlowDDA::computeDDAPts (NodeID id)<computeroutput>[override]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Compute points-to set for all top variable. </para>
</para>

<para>Compute points-to set for queries </para>

<para>start DDA analysis</para>
<para>
Reimplemented from <link linkend="_class_s_v_f_1_1_pointer_analysis_1a0bb90b398ef85504bcd816ae57bee01d">SVF::PointerAnalysis</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1a1b8d66dbe8c6587e74d70f5d231eb69d"/>    <section>
    <title>handleAddr()</title>
<indexterm><primary>handleAddr</primary><secondary>SVF::FlowDDA</secondary></indexterm>
<indexterm><primary>SVF::FlowDDA</primary><secondary>handleAddr</secondary></indexterm>
<para><computeroutput>virtual void SVF::FlowDDA::handleAddr (PointsTo &amp; pts, const <link linkend="_class_s_v_f_1_1_stmt_d_p_item">LocDPItem</link> &amp; dpm, const <link linkend="_class_s_v_f_1_1_addr_v_f_g_node">AddrSVFGNode</link> * addr)<computeroutput>[inline]</computeroutput>, <computeroutput>[override]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Handle Address SVFGNode to add proper points-to. </para>
</para>

<para>whether this object is set field-insensitive during pre-analysis</para>
<para>
Implements <link linkend="_class_s_v_f_1_1_d_d_a_v_f_solver_1acfe7d961caac8f0f558881a9a006b1fa">SVF::DDAVFSolver&lt; NodeID, PointsTo, LocDPItem &gt;</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1a8930c3b8f3b58dca8da6017310bb74ae"/>    <section>
    <title>handleOutOfBudgetDpm()</title>
<indexterm><primary>handleOutOfBudgetDpm</primary><secondary>SVF::FlowDDA</secondary></indexterm>
<indexterm><primary>SVF::FlowDDA</primary><secondary>handleOutOfBudgetDpm</secondary></indexterm>
<para><computeroutput>void FlowDDA::handleOutOfBudgetDpm (const <link linkend="_class_s_v_f_1_1_stmt_d_p_item">LocDPItem</link> &amp; dpm)</computeroutput></para><para>

<para>Handle out-of-budget dpm. </para>
</para>

<para>Handle out-of-budget dpm </para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1afc3b2b4e0da7a2484ec35c3ce84a9d60"/>    <section>
    <title>isHeapCondMemObj()</title>
<indexterm><primary>isHeapCondMemObj</primary><secondary>SVF::FlowDDA</secondary></indexterm>
<indexterm><primary>SVF::FlowDDA</primary><secondary>isHeapCondMemObj</secondary></indexterm>
<para><computeroutput>bool FlowDDA::isHeapCondMemObj (const NodeID &amp; var, const <link linkend="_class_s_v_f_1_1_store_v_f_g_node">StoreSVFGNode</link> * store)<computeroutput>[override]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para>
<para>we exclude concrete heap here following the conditions: (1) local allocated heap and (2) not escaped to the scope outside the current function (3) not inside loop (4) not involved in recursion </para>
<para>
Reimplemented from <link linkend="_class_s_v_f_1_1_d_d_a_v_f_solver_1a645c7d0637b49e139898016ff652e1f3">SVF::DDAVFSolver&lt; NodeID, PointsTo, LocDPItem &gt;</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_d_d_a_1ac48be374351dad54ee2418dde841cf24"/>    <section>
    <title>processGepPts()</title>
<indexterm><primary>processGepPts</primary><secondary>SVF::FlowDDA</secondary></indexterm>
<indexterm><primary>SVF::FlowDDA</primary><secondary>processGepPts</secondary></indexterm>
<para><computeroutput>PointsTo FlowDDA::processGepPts (const <link linkend="_class_s_v_f_1_1_gep_v_f_g_node">GepSVFGNode</link> * gep, const PointsTo &amp; srcPts)<computeroutput>[override]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>processGep node </para>
</para>

<para>Generate field objects for structs </para>
<para>
Implements <link linkend="_class_s_v_f_1_1_d_d_a_v_f_solver_1ab10a34efa1acb6125ea32cf7a8cf919f">SVF::DDAVFSolver&lt; NodeID, PointsTo, LocDPItem &gt;</link>.</para>
</section>
<para>
The documentation for this class was generated from the following files:</para>
include/DDA/FlowDDA.hlib/DDA/FlowDDA.cpp</section>
</section>
