.TH "SVF::VersionedFlowSensitive" 3 "Sun Feb 14 2021" "SVF" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SVF::VersionedFlowSensitive
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <VersionedFlowSensitive\&.h>\fP
.PP
Inherits \fBSVF::FlowSensitive\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBVersionType\fP { \fBCONSUME\fP, \fBYIELD\fP }"
.br
.ti -1c
.RI "typedef Map< NodeID, Version > \fBObjToVersionMap\fP"
.br
.ti -1c
.RI "typedef Map< NodeID, MeldVersion > \fBObjToMeldVersionMap\fP"
.br
.ti -1c
.RI "typedef Map< NodeID, ObjToVersionMap > \fBLocVersionMap\fP"
.br
.ti -1c
.RI "typedef Map< NodeID, ObjToMeldVersionMap > \fBLocMeldVersionMap\fP"
.br
.RI "Maps locations to all versions it sees (through objects)\&. "
.ti -1c
.RI "typedef Map< NodeID, Map< Version, Set< Version > > > \fBVersionRelianceMap\fP"
.br
.RI "(o -> (v -> versions with rely on o:v)\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVersionedFlowSensitive\fP (\fBPAG\fP *_pag, \fBPTATY\fP type=\fBVFS_WPA\fP)"
.br
.RI "Constructor\&. "
.ti -1c
.RI "virtual void \fBinitialize\fP () override"
.br
.RI "Initialize analysis\&. "
.ti -1c
.RI "virtual void \fBfinalize\fP () override"
.br
.RI "Finalize analysis\&. "
.ti -1c
.RI "virtual const std::string \fBPTAName\fP () const override"
.br
.RI "Get PTA name\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static VersionedVar \fBatKey\fP (NodeID, Version)"
.br
.RI "Return key into vPtD for address-taken var of a specific version\&. "
.ti -1c
.RI "static bool \fBclassof\fP (const \fBVersionedFlowSensitive\fP *)"
.br
.RI "Methods to support type inquiry through isa, cast, and dyn_cast\&. "
.ti -1c
.RI "static bool \fBclassof\fP (const \fBPointerAnalysis\fP *pta)"
.br
.ti -1c
.RI "static \fBVersionedFlowSensitive\fP * \fBcreateVFSWPA\fP (\fBPAG\fP *_pag)"
.br
.RI "Create single instance of versioned flow-sensitive points-to analysis\&. "
.ti -1c
.RI "static void \fBreleaseVFSWPA\fP ()"
.br
.RI "Release flow-sensitive pointer analysis\&. "
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const Version \fBinvalidVersion\fP = 0"
.br
.RI "If this version appears, there has been an error\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual bool \fBprocessLoad\fP (const \fBLoadSVFGNode\fP *load) override"
.br
.ti -1c
.RI "virtual bool \fBprocessStore\fP (const \fBStoreSVFGNode\fP *store) override"
.br
.ti -1c
.RI "virtual void \fBprocessNode\fP (NodeID n) override"
.br
.RI "Handle various constraints\&. "
.ti -1c
.RI "virtual void \fBupdateConnectedNodes\fP (const SVFGEdgeSetTy &newEdges) override"
.br
.RI "Update nodes connected during updating call graph\&. "
.ti -1c
.RI "virtual bool \fBpropAlongIndirectEdge\fP (const \fBIndirectSVFGEdge\fP *edge) override"
.br
.RI "Override to do nothing\&. Instead, we will use propagateVersion when necessary\&. "
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBVersionedFlowSensitiveStat\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Versioned flow sensitive whole program pointer analysis 
.SH "Member Function Documentation"
.PP 
.SS "bool VersionedFlowSensitive::processLoad (const \fBLoadSVFGNode\fP * load)\fC [override]\fP, \fC [protected]\fP, \fC [virtual]\fP"
Process load node
.PP
Foreach node \\in src pts(dst) = union pts(node) If o is a field-insensitive object, we should also get all field nodes' points-to sets and pass them to p\&.
.PP
If the ptd is a field-insensitive node, we should also get all field nodes' points-to sets and pass them to pagDst\&.
.PP
Reimplemented from \fBSVF::FlowSensitive\fP\&.
.SS "void VersionedFlowSensitive::processNode (NodeID nodeId)\fC [override]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Handle various constraints\&. Process each \fBSVFG\fP node 
.PP
Reimplemented from \fBSVF::FlowSensitive\fP\&.
.SS "bool VersionedFlowSensitive::processStore (const \fBStoreSVFGNode\fP * store)\fC [override]\fP, \fC [protected]\fP, \fC [virtual]\fP"
Process store node
.PP
foreach node \\in dst pts(node) = union pts(src) STORE statement can only be processed if the pointer on the LHS points to something\&. If we handle STORE with an empty points-to set, the OUT set will be updated from IN set\&. Then if LHS pointer points-to one target and it has been identified as a strong update, we can't remove those points-to information computed before this strong update from the OUT set\&.
.PP
check if this is a strong updates store
.PP
Reimplemented from \fBSVF::FlowSensitive\fP\&.
.SS "void VersionedFlowSensitive::updateConnectedNodes (const SVFGEdgeSetTy & edges)\fC [override]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Update nodes connected during updating call graph\&. Push nodes connected during update call graph into worklist so they will be solved during next iteration\&. If this is a formal-param or actual-ret node, we need to solve this phi node in next iteration
.PP
If this is a formal-in or actual-out node, we need to propagate points-to information from its predecessor node\&.
.PP
If this is a field-insensitive obj, propagate all field node's pts
.PP
Reimplemented from \fBSVF::FlowSensitive\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for SVF from the source code\&.
