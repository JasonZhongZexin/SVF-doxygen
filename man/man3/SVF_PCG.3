.TH "SVF::PCG" 3 "Sun Feb 14 2021" "SVF" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SVF::PCG
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <PCG\&.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef Set< const Function * > \fBFunSet\fP"
.br
.ti -1c
.RI "typedef std::vector< const Function * > \fBFunVec\fP"
.br
.ti -1c
.RI "typedef Set< const Instruction * > \fBCallInstSet\fP"
.br
.ti -1c
.RI "typedef \fBFIFOWorkList\fP< const Function * > \fBFunWorkList\fP"
.br
.ti -1c
.RI "typedef \fBFIFOWorkList\fP< const BasicBlock * > \fBBBWorkList\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPCG\fP (\fBPointerAnalysis\fP *an)"
.br
.RI "Constructor\&. "
.ti -1c
.RI "virtual bool \fBanalyze\fP ()"
.br
.RI "We start the pass here\&. "
.ti -1c
.RI "virtual \fB~PCG\fP ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "virtual bool \fBmayHappenInParallel\fP (const Instruction *i1, const Instruction *i2) const"
.br
.RI "Interface to query whether two function may happen-in-parallel\&. "
.ti -1c
.RI "bool \fBmayHappenInParallelBetweenFunctions\fP (const Function *fun1, const Function *fun2) const"
.br
.ti -1c
.RI "const FunSet & \fBgetMHPFunctions\fP () const"
.br
.ti -1c
.RI "void \fBinitFromThreadAPI\fP (\fBSVFModule\fP *module)"
.br
.RI "Initialize spawner and spawnee sets with threadAPI\&. "
.ti -1c
.RI "void \fBinferFromCallGraph\fP ()"
.br
.RI "Infer spawner spawnee and followers sets by traversing on callGraph\&. "
.ti -1c
.RI "void \fBcollectSpawners\fP ()"
.br
.ti -1c
.RI "void \fBcollectSpawnees\fP ()"
.br
.ti -1c
.RI "void \fBcollectFollowers\fP ()"
.br
.ti -1c
.RI "void \fBidentifyFollowers\fP ()"
.br
.ti -1c
.RI "const FunSet & \fBgetSpawners\fP () const"
.br
.RI "Get spawners/spawnees/followers\&. "
.ti -1c
.RI "const FunSet & \fBgetSpawnees\fP () const"
.br
.ti -1c
.RI "const FunSet & \fBgetFollowers\fP () const"
.br
.ti -1c
.RI "FunSet::iterator \fBspawnersBegin\fP (const Function *fun) const"
.br
.RI "Iterators for thread properties of a procedure\&. "
.ti -1c
.RI "FunSet::iterator \fBspawnersEnd\fP (const Function *fun) const"
.br
.ti -1c
.RI "FunSet::iterator \fBspawneesBegin\fP (const Function *fun) const"
.br
.ti -1c
.RI "FunSet::iterator \fBspawneesEnd\fP (const Function *fun) const"
.br
.ti -1c
.RI "FunSet::iterator \fBfollowersBegin\fP (const Function *fun) const"
.br
.ti -1c
.RI "FunSet::iterator \fBfollowersEnd\fP (const Function *fun) const"
.br
.ti -1c
.RI "void \fBinterferenceAnalysis\fP ()"
.br
.RI "Thread interferenceAnalysis\&. "
.ti -1c
.RI "void \fBprintResults\fP ()"
.br
.RI "Print analysis results\&. "
.ti -1c
.RI "void \fBprintTDFuns\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class serves as a base may-happen in parallel analysis for multithreaded program It distinguish thread spawner, spawnee, follower in procedure level by modeling pthread_create, pthread_join, pthread_exit, pthread_cancel synchronization operations 
.SH "Member Function Documentation"
.PP 
.SS "bool PCG::analyze ()\fC [virtual]\fP"

.PP
We start the pass here\&. Whether two functions may happen in parallel 
.SS "void PCG::collectFollowers ()"
collect follower procedures which may be called after pthread_create is invoked directly or indirectly a procedure which is called from a follower is also a follower\&. identify initial followers
.PP
find all the followers recursively on call graph
.SS "void PCG::collectSpawnees ()"
spawnee: given a spawnee, all its callees on callgraph are spawnees find all the spawnees recursively on call graph
.SS "void PCG::collectSpawners ()"
spawner: given a spawner, all its callers on callgraph are spawners find all the spawners recursively on call graph
.PP
add all the callsites from callers to callee (spawner) as a spawn site\&.
.SS "void PCG::identifyFollowers ()"
Identify initial followers a procedure whose callsite lies in a control flow path that starts just after a spawner's callsite 
.SS "void PCG::inferFromCallGraph ()"

.PP
Infer spawner spawnee and followers sets by traversing on callGraph\&. Infer spawners and spawnees from call graph\&. The inference are recursively done spawners: procedures may create a thread and return with the created thread still running spawnees: procedures may be executed as a spawned thread followers: procedures may be invoked by a thread after the thread returns from a spawner (procedure may be called after pthread_creat is called)\&. 
.SS "void PCG::initFromThreadAPI (\fBSVFModule\fP * module)"

.PP
Initialize spawner and spawnee sets with threadAPI\&. Initialize thread spawners and spawnees from threadAPI functions a procedure is a spawner if it creates a thread and the created thread is still existent on its return a procedure is a spawnee if it is created by fork call TODO: handle indirect call here for the fork Fun
.SS "void PCG::interferenceAnalysis ()"

.PP
Thread interferenceAnalysis\&. Thread interference analysis, Suppose we have a undirected graph G = {F,E,I} F denotes procedure, E represents interference edge (x,y) \\in E, x \\in F, y \\in F means execution of x in one thread may overlap execution of y in another thread I(x,y) is a set of memory locations for this interference edge 
.SS "void PCG::printResults ()"

.PP
Print analysis results\&. Print analysis results 
.SS "void PCG::printTDFuns ()"
Print Thread sensitive properties for each function 

.SH "Author"
.PP 
Generated automatically by Doxygen for SVF from the source code\&.
