.TH "SVF::MRGenerator" 3 "Sun Feb 14 2021" "SVF" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SVF::MRGenerator
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <MemRegion\&.h>\fP
.PP
Inherited by \fBSVF::DistinctMRG\fP, and \fBSVF::IntraDisjointMRG\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBFIFOWorkList\fP< NodeID > \fBWorkList\fP"
.br
.ti -1c
.RI "typedef OrderedSet< const \fBMemRegion\fP *, \fBMemRegion::equalMemRegion\fP > \fBMRSet\fP"
.br
.RI "Get typedef from Pointer Analysis\&. "
.ti -1c
.RI "typedef Map< const \fBPAGEdge\fP *, const \fBSVFFunction\fP * > \fBPAGEdgeToFunMap\fP"
.br
.ti -1c
.RI "typedef OrderedSet< PointsTo, \fBMemRegion::equalPointsTo\fP > \fBPointsToList\fP"
.br
.ti -1c
.RI "typedef Map< const \fBSVFFunction\fP *, PointsToList > \fBFunToPointsToMap\fP"
.br
.ti -1c
.RI "typedef OrderedMap< PointsTo, PointsTo, \fBMemRegion::equalPointsTo\fP > \fBPtsToRepPtsSetMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBSVFFunction\fP *, \fBMRSet\fP > \fBFunToMRsMap\fP"
.br
.RI "Map a function to its region set\&. "
.ti -1c
.RI "typedef Map< const \fBLoadPE\fP *, \fBMRSet\fP > \fBLoadsToMRsMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBStorePE\fP *, \fBMRSet\fP > \fBStoresToMRsMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBCallBlockNode\fP *, \fBMRSet\fP > \fBCallSiteToMRsMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBLoadPE\fP *, PointsTo > \fBLoadsToPointsToMap\fP"
.br
.RI "Map loads/stores/callsites to their cpts set\&. "
.ti -1c
.RI "typedef Map< const \fBStorePE\fP *, PointsTo > \fBStoresToPointsToMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBCallBlockNode\fP *, PointsTo > \fBCallSiteToPointsToMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBSVFFunction\fP *, NodeBS > \fBFunToNodeBSMap\fP"
.br
.RI "Maps Mod-Ref analysis\&. "
.ti -1c
.RI "typedef Map< const \fBCallBlockNode\fP *, NodeBS > \fBCallSiteToNodeBSMap\fP"
.br
.RI "Map a callsite to its indirect refs/mods of memory objects\&. "
.ti -1c
.RI "typedef Map< NodeID, NodeBS > \fBNodeToPTSSMap\fP"
.br
.ti -1c
.RI "typedef PAG::PAGEdgeList \fBPAGEdgeList\fP"
.br
.RI "\fBPAG\fP edge list\&. "
.ti -1c
.RI "typedef \fBSCCDetection\fP< \fBPTACallGraph\fP * > \fBSCC\fP"
.br
.RI "Call Graph SCC\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMRSet\fP & \fBgetMRSet\fP ()"
.br
.ti -1c
.RI "const PointsTo & \fBgetRepPointsTo\fP (const PointsTo &cpts) const"
.br
.RI "Get superset cpts set\&. "
.ti -1c
.RI "const \fBMemRegion\fP * \fBgetMR\fP (const PointsTo &cpts) const"
.br
.RI "Get a memory region according to cpts\&. "
.ti -1c
.RI "Size_t \fBgetMRNum\fP () const"
.br
.ti -1c
.RI "virtual \fB~MRGenerator\fP ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "virtual void \fBgenerateMRs\fP ()"
.br
.RI "Start generating memory regions\&. "
.ti -1c
.RI "const \fBSVFFunction\fP * \fBgetFunction\fP (const \fBPAGEdge\fP *pagEdge) const"
.br
.RI "Get the function which \fBPAG\fP Edge located\&. "
.ti -1c
.RI "\fBMRSet\fP & \fBgetFunMRSet\fP (const \fBSVFFunction\fP *fun)"
.br
.RI "Get Memory Region set\&. "
.ti -1c
.RI "\fBMRSet\fP & \fBgetLoadMRSet\fP (const \fBLoadPE\fP *load)"
.br
.ti -1c
.RI "\fBMRSet\fP & \fBgetStoreMRSet\fP (const \fBStorePE\fP *store)"
.br
.ti -1c
.RI "bool \fBhasRefMRSet\fP (const \fBCallBlockNode\fP *cs)"
.br
.ti -1c
.RI "bool \fBhasModMRSet\fP (const \fBCallBlockNode\fP *cs)"
.br
.ti -1c
.RI "\fBMRSet\fP & \fBgetCallSiteRefMRSet\fP (const \fBCallBlockNode\fP *cs)"
.br
.ti -1c
.RI "\fBMRSet\fP & \fBgetCallSiteModMRSet\fP (const \fBCallBlockNode\fP *cs)"
.br
.ti -1c
.RI "bool \fBhasPAGEdgeList\fP (const Instruction *inst)"
.br
.RI "Whether this instruction has \fBPAG\fP Edge\&. "
.ti -1c
.RI "\fBPAGEdgeList\fP & \fBgetPAGEdgesFromInst\fP (const Instruction *inst)"
.br
.RI "Given an instruction, get all its the \fBPAGEdge\fP (statement) in sequence\&. "
.ti -1c
.RI "PointsTo \fBgetModInfoForCall\fP (const \fBCallBlockNode\fP *cs)"
.br
.RI "getModRefInfo APIs "
.ti -1c
.RI "PointsTo \fBgetRefInfoForCall\fP (const \fBCallBlockNode\fP *cs)"
.br
.ti -1c
.RI "ModRefInfo \fBgetModRefInfo\fP (const \fBCallBlockNode\fP *cs)"
.br
.ti -1c
.RI "ModRefInfo \fBgetModRefInfo\fP (const \fBCallBlockNode\fP *cs, const Value *V)"
.br
.ti -1c
.RI "ModRefInfo \fBgetModRefInfo\fP (const \fBCallBlockNode\fP *cs1, const \fBCallBlockNode\fP *cs2)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBMRGenerator\fP (\fBBVDataPTAImpl\fP *p, bool ptrOnly)"
.br
.ti -1c
.RI "void \fBcreateMR\fP (const \fBSVFFunction\fP *fun, const PointsTo &cpts)"
.br
.RI "Generate a memory region and put in into functions which use it\&. "
.ti -1c
.RI "void \fBcollectGlobals\fP ()"
.br
.RI "Collect all global variables for later escape analysis\&. "
.ti -1c
.RI "virtual void \fBcollectModRefForLoadStore\fP ()"
.br
.RI "Generate regions for loads/stores\&. "
.ti -1c
.RI "virtual void \fBcollectModRefForCall\fP ()"
.br
.RI "Generate regions for calls/rets\&. "
.ti -1c
.RI "virtual void \fBpartitionMRs\fP ()"
.br
.RI "Partition regions\&. "
.ti -1c
.RI "virtual void \fBupdateAliasMRs\fP ()"
.br
.RI "Update aliased regions for loads/stores/callsites\&. "
.ti -1c
.RI "virtual void \fBsortPointsTo\fP (const PointsTo &cpts)"
.br
.RI "Given a condition pts, insert into cptsToRepCPtsMap for region generation\&. "
.ti -1c
.RI "virtual bool \fBisAliasedMR\fP (const PointsTo &cpts, const \fBMemRegion\fP *mr)"
.br
.RI "Whether a region is aliased with a conditional points-to\&. "
.ti -1c
.RI "virtual void \fBgetAliasMemRegions\fP (\fBMRSet\fP &aliasMRs, const PointsTo &cpts, const \fBSVFFunction\fP *fun)"
.br
.RI "Get all aliased mem regions from function fun according to cpts\&. "
.ti -1c
.RI "virtual void \fBgetMRsForLoad\fP (\fBMRSet\fP &aliasMRs, const PointsTo &cpts, const \fBSVFFunction\fP *)"
.br
.RI "Get memory regions for a load statement according to cpts\&. "
.ti -1c
.RI "virtual void \fBgetMRsForCallSiteRef\fP (\fBMRSet\fP &aliasMRs, const PointsTo &cpts, const \fBSVFFunction\fP *)"
.br
.RI "Get memory regions for call site ref according to cpts\&. "
.ti -1c
.RI "virtual void \fBmodRefAnalysis\fP (\fBPTACallGraphNode\fP *callGraphNode, \fBWorkList\fP &worklist)"
.br
.RI "Mod-Ref analysis for callsite invoking this callGraphNode\&. "
.ti -1c
.RI "virtual bool \fBhandleCallsiteModRef\fP (NodeBS &mod, NodeBS &ref, const \fBCallBlockNode\fP *cs, const \fBSVFFunction\fP *fun)"
.br
.RI "Get Mod-Ref of a callee function\&. "
.ti -1c
.RI "void \fBaddCPtsToStore\fP (PointsTo &cpts, const \fBStorePE\fP *st, const \fBSVFFunction\fP *fun)"
.br
.RI "Add cpts to store/load\&. "
.ti -1c
.RI "void \fBaddCPtsToLoad\fP (PointsTo &cpts, const \fBLoadPE\fP *ld, const \fBSVFFunction\fP *fun)"
.br
.ti -1c
.RI "void \fBaddCPtsToCallSiteRefs\fP (PointsTo &cpts, const \fBCallBlockNode\fP *cs)"
.br
.ti -1c
.RI "void \fBaddCPtsToCallSiteMods\fP (PointsTo &cpts, const \fBCallBlockNode\fP *cs)"
.br
.ti -1c
.RI "bool \fBhasCPtsList\fP (const \fBSVFFunction\fP *fun) const"
.br
.ti -1c
.RI "PointsToList & \fBgetPointsToList\fP (const \fBSVFFunction\fP *fun)"
.br
.ti -1c
.RI "FunToPointsToMap & \fBgetFunToPointsToList\fP ()"
.br
.ti -1c
.RI "void \fBaddRefSideEffectOfFunction\fP (const \fBSVFFunction\fP *fun, const NodeBS &refs)"
.br
.RI "Add/Get methods for side-effect of functions and callsites\&. "
.ti -1c
.RI "void \fBaddModSideEffectOfFunction\fP (const \fBSVFFunction\fP *fun, const NodeBS &mods)"
.br
.RI "Add indirect def an memory object in the function\&. "
.ti -1c
.RI "bool \fBaddRefSideEffectOfCallSite\fP (const \fBCallBlockNode\fP *cs, const NodeBS &refs)"
.br
.RI "Add indirect uses an memory object in the function\&. "
.ti -1c
.RI "bool \fBaddModSideEffectOfCallSite\fP (const \fBCallBlockNode\fP *cs, const NodeBS &mods)"
.br
.RI "Add indirect def an memory object in the function\&. "
.ti -1c
.RI "const NodeBS & \fBgetRefSideEffectOfFunction\fP (const \fBSVFFunction\fP *fun)"
.br
.RI "Get indirect refs of a function\&. "
.ti -1c
.RI "const NodeBS & \fBgetModSideEffectOfFunction\fP (const \fBSVFFunction\fP *fun)"
.br
.RI "Get indirect mods of a function\&. "
.ti -1c
.RI "const NodeBS & \fBgetRefSideEffectOfCallSite\fP (const \fBCallBlockNode\fP *cs)"
.br
.RI "Get indirect refs of a callsite\&. "
.ti -1c
.RI "const NodeBS & \fBgetModSideEffectOfCallSite\fP (const \fBCallBlockNode\fP *cs)"
.br
.RI "Get indirect mods of a callsite\&. "
.ti -1c
.RI "bool \fBhasRefSideEffectOfCallSite\fP (const \fBCallBlockNode\fP *cs)"
.br
.RI "Has indirect refs of a callsite\&. "
.ti -1c
.RI "bool \fBhasModSideEffectOfCallSite\fP (const \fBCallBlockNode\fP *cs)"
.br
.RI "Has indirect mods of a callsite\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBMRSet\fP \fBmemRegSet\fP"
.br
.RI "A set of All memory regions\&. "
.ti -1c
.RI "PtsToRepPtsSetMap \fBcptsToRepCPtsMap\fP"
.br
.RI "Map a condition pts to its rep conditional pts (super set points-to) "
.in -1c
.SH "Detailed Description"
.PP 
Memory Region Partitioning 
.SH "Member Typedef Documentation"
.PP 
.SS "typedef Map<const \fBSVFFunction\fP*, NodeBS> \fBSVF::MRGenerator::FunToNodeBSMap\fP"

.PP
Maps Mod-Ref analysis\&. Map a function to its indirect refs/mods of memory objects 
.SS "typedef Map<const \fBLoadPE\fP*, \fBMRSet\fP> \fBSVF::MRGenerator::LoadsToMRsMap\fP"
Map loads/stores to its mem regions, TODO:visitAtomicCmpXchgInst, visitAtomicRMWInst?? 
.SS "typedef OrderedSet<const \fBMemRegion\fP*, \fBMemRegion::equalMemRegion\fP> \fBSVF::MRGenerator::MRSet\fP"

.PP
Get typedef from Pointer Analysis\&. Define mem region set 
.SH "Member Function Documentation"
.PP 
.SS "bool MRGenerator::addModSideEffectOfCallSite (const \fBCallBlockNode\fP * cs, const NodeBS & mods)\fC [protected]\fP"

.PP
Add indirect def an memory object in the function\&. Add indirect def an memory object in the function 
.SS "void MRGenerator::addModSideEffectOfFunction (const \fBSVFFunction\fP * fun, const NodeBS & mods)\fC [protected]\fP"

.PP
Add indirect def an memory object in the function\&. Add indirect def an memory object in the function 
.SS "bool MRGenerator::addRefSideEffectOfCallSite (const \fBCallBlockNode\fP * cs, const NodeBS & refs)\fC [protected]\fP"

.PP
Add indirect uses an memory object in the function\&. Add indirect uses an memory object in the function 
.SS "void MRGenerator::addRefSideEffectOfFunction (const \fBSVFFunction\fP * fun, const NodeBS & refs)\fC [protected]\fP"

.PP
Add/Get methods for side-effect of functions and callsites\&. Add indirect uses an memory object in the function 
.SS "void MRGenerator::collectGlobals ()\fC [protected]\fP"

.PP
Collect all global variables for later escape analysis\&. Collect globals for escape analysis 
.SS "void MRGenerator::collectModRefForCall ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Generate regions for calls/rets\&. Generate memory regions for calls collect points-to information for callsites
.PP
handle all sub scc nodes of this rep node
.PP
Get mod-ref of all callsites calling callGraphNode
.PP
mods are treated as both def and use of memory objects
.SS "void MRGenerator::collectModRefForLoadStore ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Generate regions for loads/stores\&. Generate memory regions for loads/stores if this function does not have any caller, then we do not care its MSSA
.SS "void MRGenerator::createMR (const \fBSVFFunction\fP * fun, const PointsTo & cpts)\fC [protected]\fP"

.PP
Generate a memory region and put in into functions which use it\&. Generate a memory region and put in into functions which use it 
.SS "void MRGenerator::generateMRs ()\fC [virtual]\fP"

.PP
Start generating memory regions\&. Generate memory regions according to pointer analysis results Attach regions on loads/stores collect mod-ref for loads/stores
.PP
collect mod-ref for calls
.PP
Partition memory regions
.PP
attach memory regions for loads/stores/calls
.SS "PointsTo MRGenerator::getModInfoForCall (const \fBCallBlockNode\fP * cs)"

.PP
getModRefInfo APIs Collect mod ref for external callsite other than heap alloc external call
.PP
Obtain the mod sets for a call, used for external ModRefInfo queries 
.SS "ModRefInfo MRGenerator::getModRefInfo (const \fBCallBlockNode\fP * cs)"
Determine whether a CallSite instruction can mod or ref any memory location 
.SS "ModRefInfo MRGenerator::getModRefInfo (const \fBCallBlockNode\fP * cs, const Value * V)"
Determine whether a const CallBlockNode* instruction can mod or ref a specific memory location pointed by V 
.SS "ModRefInfo MRGenerator::getModRefInfo (const \fBCallBlockNode\fP * cs1, const \fBCallBlockNode\fP * cs2)"
Determine mod-ref relations between two const CallBlockNode* instructions return NoModRef neither two callsites ref or mod any memory
.PP
Ref: cs1 ref memory mod by cs2
.PP
Mod: cs1 mod memory ref or mod by cs2
.PP
ModRef: cs1 ref and mod memory mod by cs2
.SS "const \fBMemRegion\fP * MRGenerator::getMR (const PointsTo & cpts) const"

.PP
Get a memory region according to cpts\&. Generate a memory region and put in into functions which use it 
.SS "PointsTo MRGenerator::getRefInfoForCall (const \fBCallBlockNode\fP * cs)"
Obtain the ref sets for a call, used for external ModRefInfo queries 
.SS "bool MRGenerator::handleCallsiteModRef (NodeBS & mod, NodeBS & ref, const \fBCallBlockNode\fP * cs, const \fBSVFFunction\fP * callee)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Get Mod-Ref of a callee function\&. Get Mod-Ref of a callee function if a callee is a heap allocator function, then its mod set of this callsite is the heap object\&.
.PP
otherwise, we find the mod/ref sets from the callee function, who has definition and been processed
.SS "void MRGenerator::modRefAnalysis (\fBPTACallGraphNode\fP * callGraphNode, \fBWorkList\fP & worklist)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Mod-Ref analysis for callsite invoking this callGraphNode\&. Call site mod-ref analysis Compute mod-ref of all callsites invoking this call graph node add ref/mod set of callee to its invocation callsites at caller
.PP
handle direct callsites
.PP
handle indirect callsites
.SS "void MRGenerator::partitionMRs ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Partition regions\&. Partition memory regions Compute all superset of all condition points-to sets TODO: we may need some refined region partitioning algorithm here For now, we just collapse all refs/mods objects at callsites into one region Consider modularly partition memory regions to speed up analysis (only partition regions within function scope)
.PP
Generate memory regions according to condition pts after computing superset
.PP
Reimplemented in \fBSVF::InterDisjointMRG\fP, \fBSVF::IntraDisjointMRG\fP, and \fBSVF::DistinctMRG\fP\&.
.SS "void MRGenerator::sortPointsTo (const PointsTo & cpts)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Given a condition pts, insert into cptsToRepCPtsMap for region generation\&. Given a condition pts, insert into cptsToRepCPtsMap Always map it to its superset(rep) cpts according to existing items 1) map cpts to its superset(rep) which exists in the map, otherwise its superset is itself 2) adjust existing items in the map if their supersets are cpts 
.SS "void MRGenerator::updateAliasMRs ()\fC [protected]\fP, \fC [virtual]\fP"

.PP
Update aliased regions for loads/stores/callsites\&. Update aliased regions for loads/stores/callsites update stores with its aliased regions
.PP
update callsites with its aliased regions

.SH "Author"
.PP 
Generated automatically by Doxygen for SVF from the source code\&.
