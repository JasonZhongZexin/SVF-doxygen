<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_class_s_v_f_1_1_flow_sensitive" xml:lang="en-US">
<title>SVF::FlowSensitive Class Reference</title>
<indexterm><primary>SVF::FlowSensitive</primary></indexterm>
<para>Inheritance diagram for SVF::FlowSensitive:    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="class_s_v_f_1_1_flow_sensitive.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
<simplesect>
    <title>Public Types    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a03a3178d88db4efc0593fedb22938e7d"/>typedef <link linkend="_class_s_v_f_1_1_mutable_d_f_p_t_data">BVDataPTAImpl::MutDFPTDataTy</link> <emphasis role="strong">MutDFPTDataTy</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1af9a2bd5b490f1cc5335ce696173c78dd"/>typedef <link linkend="_class_s_v_f_1_1_mutable_d_f_p_t_data_1accdcfd0e05c36f1df08c884b85e00be4">BVDataPTAImpl::MutDFPTDataTy::DFPtsMap</link> <emphasis role="strong">DFInOutMap</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a7bb300f30f4f8cee208229ae10faa291"/>typedef BVDataPTAImpl::MutDFPTDataTy::PtsMap <emphasis role="strong">PtsMap</emphasis></para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Public Member Functions    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1aefb9169c4d5c60edf73ccc24d40fa7e8"/><link linkend="_class_s_v_f_1_1_flow_sensitive_1aefb9169c4d5c60edf73ccc24d40fa7e8">FlowSensitive</link> (<link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> *_pag, <link linkend="_class_s_v_f_1_1_pointer_analysis_1a0b182ac680cce0547dbe7714c870ca85">PTATY</link> type=<link linkend="_class_s_v_f_1_1_pointer_analysis_1a0b182ac680cce0547dbe7714c870ca85ad6ccf1ce66083278349c5c3111172d78">FSSPARSE_WPA</link>)</para>

<para>Constructor. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a7bb33faaa7081ef3346de3f30ab3a8da"/>virtual <link linkend="_class_s_v_f_1_1_flow_sensitive_1a7bb33faaa7081ef3346de3f30ab3a8da">~FlowSensitive</link> ()</para>

<para>Destructor. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a611608ccc9659bd320670f1ec31ad18e"/>virtual bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1a611608ccc9659bd320670f1ec31ad18e">runOnModule</link> (<link linkend="_class_s_v_f_1_1_s_v_f_module">SVFModule</link> *)</para>

<para>We start from here. </para>
</listitem>
            <listitem><para>virtual void <link linkend="_class_s_v_f_1_1_flow_sensitive_1a267f7198600dde3054feb40def7a6681">analyze</link> ()</para>

<para>Flow sensitive analysis. </para>
</listitem>
            <listitem><para>virtual void <link linkend="_class_s_v_f_1_1_flow_sensitive_1ad6243c1317503bed39411dab47c83da7">initialize</link> ()</para>

<para>Initialize analysis. </para>
</listitem>
            <listitem><para>virtual void <link linkend="_class_s_v_f_1_1_flow_sensitive_1afed358369102f01f6fe88b1433e704c3">finalize</link> ()</para>

<para>Finalize analysis. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a4f1a0d533381660055210be1e2d7d72a"/>virtual const std::string <link linkend="_class_s_v_f_1_1_flow_sensitive_1a4f1a0d533381660055210be1e2d7d72a">PTAName</link> () const</para>

<para>Get PTA name. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a74f35ec76e2c7cf39355e0c148d973be"/><link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link> * <link linkend="_class_s_v_f_1_1_flow_sensitive_1a74f35ec76e2c7cf39355e0c148d973be">getSVFG</link> () const</para>

<para>Return <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link>. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Static Public Member Functions    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a6099f16d3f890c16507f482a8b2ca903"/>static <link linkend="_class_s_v_f_1_1_flow_sensitive">FlowSensitive</link> * <link linkend="_class_s_v_f_1_1_flow_sensitive_1a6099f16d3f890c16507f482a8b2ca903">createFSWPA</link> (<link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> *_pag)</para>

<para>Create signle instance of flow-sensitive pointer analysis. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1ae6aed22a79ac6567446dfcba82cb17b8"/>static void <link linkend="_class_s_v_f_1_1_flow_sensitive_1ae6aed22a79ac6567446dfcba82cb17b8">releaseFSWPA</link> ()</para>

<para>Release flow-sensitive pointer analysis. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1ac76934c9ba15742e470a785af54bd958"/>static bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1ac76934c9ba15742e470a785af54bd958">classof</link> (const <link linkend="_class_s_v_f_1_1_flow_sensitive">FlowSensitive</link> *)</para>

<para>Methods for support type inquiry through isa, cast, and dyn_cast. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a12dea7b6057daddcc5c0d975aebf3f11"/>static bool <emphasis role="strong">classof</emphasis> (const <link linkend="_class_s_v_f_1_1_pointer_analysis">PointerAnalysis</link> *pta)</para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Protected Types    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a69289c48fa91f850da90de080b9d26e5"/>typedef SVFG::SVFGEdgeSetTy <emphasis role="strong">SVFGEdgeSetTy</emphasis></para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Protected Member Functions    </title>
        <itemizedlist>
            <listitem><para>virtual NodeStack &amp; <link linkend="_class_s_v_f_1_1_flow_sensitive_1a5f8a1493f7550a3f7a295e25d87bce12">SCCDetect</link> ()</para>

<para>SCC detection. </para>
</listitem>
            <listitem><para>virtual bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1af849ab5a07049cb08e6b0d8023577862">propFromSrcToDst</link> (<link linkend="_class_s_v_f_1_1_v_f_g_edge">SVFGEdge</link> *edge)</para>

<para>Propagation. </para>
</listitem>
            <listitem><para>virtual bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1ad3518931d3b8a0671cbeb975f853b956">propAlongDirectEdge</link> (const <link linkend="_class_s_v_f_1_1_direct_s_v_f_g_edge">DirectSVFGEdge</link> *edge)</para>

<para>Propagate points-to information along a DIRECT <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link> edge. </para>
</listitem>
            <listitem><para>virtual bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1aeb1e002519123a67f8d18f78cda04bac">propAlongIndirectEdge</link> (const <link linkend="_class_s_v_f_1_1_indirect_s_v_f_g_edge">IndirectSVFGEdge</link> *edge)</para>

<para>Propagate points-to information along an INDIRECT <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link> edge. </para>
</listitem>
            <listitem><para>virtual bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1ae571767cc5936cf631a44976d8277e91">propVarPtsFromSrcToDst</link> (NodeID var, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *src, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *dst)</para>

<para>Propagate points-to information of a certain variable from src to dst. </para>
</listitem>
            <listitem><para>virtual bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1a3574977acd161925cadcb05de6d3247d">propagateFromAPToFP</link> (const <link linkend="_class_s_v_f_1_1_actual_parm_v_f_g_node">ActualParmSVFGNode</link> *ap, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *dst)</para>
</listitem>
            <listitem><para>virtual bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1a3abffe1434386b1ce349fbed0cfe0967">propagateFromFRToAR</link> (const <link linkend="_class_s_v_f_1_1_formal_ret_v_f_g_node">FormalRetSVFGNode</link> *fr, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *dst)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1ab492c283e2264b4cbd4c192e805b7750"/>virtual bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1ab492c283e2264b4cbd4c192e805b7750">weakUpdateOutFromIn</link> (const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *node)</para>

<para>Handle weak updates. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a8ebe4342c1496b906ee1b6450558c3e8"/>virtual bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1a8ebe4342c1496b906ee1b6450558c3e8">strongUpdateOutFromIn</link> (const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *node, NodeID singleton)</para>

<para>Handle strong updates. </para>
</listitem>
            <listitem><para>bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1a9e7fbc4c1d056fbef07498de8cbb1cd9">propVarPtsAfterCGUpdated</link> (NodeID var, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *src, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *dst)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a5e97c3fe32f60b0e8e96323ceb9a10cf"/>virtual bool <emphasis role="strong">propDFOutToIn</emphasis> (const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *srcStmt, NodeID srcVar, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *dstStmt, NodeID dstVar)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a3be364754863bbbee6dfd0b5490dec47"/>virtual bool <emphasis role="strong">propDFInToIn</emphasis> (const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *srcStmt, NodeID srcVar, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *dstStmt, NodeID dstVar)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a06fe840604fdb4b50f08617c48acd44f"/>bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1a06fe840604fdb4b50f08617c48acd44f">updateOutFromIn</link> (const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *srcStmt, NodeID srcVar, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *dstStmt, NodeID dstVar)</para>

<para>Update data-flow points-to data. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a88120b9cec26620d4982798ea530353a"/>virtual bool <emphasis role="strong">updateInFromIn</emphasis> (const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *srcStmt, NodeID srcVar, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *dstStmt, NodeID dstVar)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1af5d90b4bd5c16dd64cd10afea6b3be93"/>virtual bool <emphasis role="strong">updateInFromOut</emphasis> (const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *srcStmt, NodeID srcVar, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *dstStmt, NodeID dstVar)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a16d757abf69ad77951b808dc18ca2999"/>virtual bool <emphasis role="strong">unionPtsFromIn</emphasis> (const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *stmt, NodeID srcVar, NodeID dstVar)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a49104435f8d20015907a1c8f58a76577"/>virtual bool <emphasis role="strong">unionPtsFromTop</emphasis> (const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *stmt, NodeID srcVar, NodeID dstVar)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a9622f0b7b16694b0c74b07834f598e67"/>void <emphasis role="strong">clearAllDFOutVarFlag</emphasis> (const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *stmt)</para>
</listitem>
            <listitem><para>virtual void <link linkend="_class_s_v_f_1_1_flow_sensitive_1a16f594356ea565eb1fed2acea516a16b">processNode</link> (NodeID nodeId)</para>

<para>Handle various constraints. </para>
</listitem>
            <listitem><para>bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1a979f89495966d71f9b470d832384ebd6">processSVFGNode</link> (<link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *node)</para>
</listitem>
            <listitem><para>virtual bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1abb37c5e4e6fa4742e8dbcf397aea086e">processAddr</link> (const <link linkend="_class_s_v_f_1_1_addr_v_f_g_node">AddrSVFGNode</link> *addr)</para>
</listitem>
            <listitem><para>virtual bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1aa401cc90de4e1c6842f08a43a28c5aa1">processCopy</link> (const <link linkend="_class_s_v_f_1_1_copy_v_f_g_node">CopySVFGNode</link> *copy)</para>
</listitem>
            <listitem><para>virtual bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1aa36fd1387e948e83107431179d819067">processPhi</link> (const <link linkend="_class_s_v_f_1_1_p_h_i_v_f_g_node">PHISVFGNode</link> *phi)</para>
</listitem>
            <listitem><para>virtual bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1ae017c39ac471727d06868e0eacafd791">processGep</link> (const <link linkend="_class_s_v_f_1_1_gep_v_f_g_node">GepSVFGNode</link> *edge)</para>
</listitem>
            <listitem><para>virtual bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1a9968530b3dee876f55e6659530decf27">processLoad</link> (const <link linkend="_class_s_v_f_1_1_load_v_f_g_node">LoadSVFGNode</link> *load)</para>
</listitem>
            <listitem><para>virtual bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1aa37d591d2d4f65957e840bef4d142a6a">processStore</link> (const <link linkend="_class_s_v_f_1_1_store_v_f_g_node">StoreSVFGNode</link> *store)</para>
</listitem>
            <listitem><para>bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1a9d81537ec20196315a9a2541477ec5bf">updateCallGraph</link> (const CallSiteToFunPtrMap &amp;callsites)</para>

<para>Update call graph. </para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_flow_sensitive_1ad7640ada31b5cb542e492e27ab4fe1af">connectCallerAndCallee</link> (const CallEdgeMap &amp;newEdges, SVFGEdgeSetTy &amp;edges)</para>

<para>Connect nodes in <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link>. </para>
</listitem>
            <listitem><para>virtual void <link linkend="_class_s_v_f_1_1_flow_sensitive_1a1886b4964efa92cfff761493d12768b8">updateConnectedNodes</link> (const SVFGEdgeSetTy &amp;edges)</para>

<para>Update nodes connected during updating call graph. </para>
</listitem>
            <listitem><para>bool <link linkend="_class_s_v_f_1_1_flow_sensitive_1a42a7e39e0e15576742f8ba7c32579ea2">isStrongUpdate</link> (const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *node, NodeID &amp;singleton)</para>

<para>Return TRUE if this is a strong update STORE statement. </para>
</listitem>
            <listitem><para>virtual void <link linkend="_class_s_v_f_1_1_flow_sensitive_1a023d0b492deaba40c593332cf1b2e3f6">printCTirAliasStats</link> (void)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a94dc671f524ed3ed00f5a54b13f18e18"/>virtual void <link linkend="_class_s_v_f_1_1_flow_sensitive_1a94dc671f524ed3ed00f5a54b13f18e18">countAliases</link> (Set&lt; std::pair&lt; NodeID, NodeID &gt;&gt; cmp, unsigned *mayAliases, unsigned *noAliases)</para>

<para>Fills may/noAliases for the location/pointer pairs in cmp. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a9379acbe349ee652416765b335dfdeab"/>const PointsTo &amp; <link linkend="_class_s_v_f_1_1_flow_sensitive_1a9379acbe349ee652416765b335dfdeab">getDFInPtsSet</link> (const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *stmt, const NodeID node)</para>

<para>Get points-to set for a node from data flow IN/OUT set at a statement. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a808dc8a242f168174339d7ca3196bb58"/>const PointsTo &amp; <emphasis role="strong">getDFOutPtsSet</emphasis> (const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> *stmt, const NodeID node)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a5f015d8f2b0956306822172d02b415c3"/>void <emphasis role="strong">svfgStat</emphasis> ()</para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect><title></title>
        <itemizedlist>
            <listitem><para>const DFInOutMap &amp; <link linkend="_class_s_v_f_1_1_flow_sensitive_1a9717517387c14c2e64c7ae3c3149bb57">getDFInputMap</link> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a661c4c1d5902c924060cc81219591d6f"/>const DFInOutMap &amp; <emphasis role="strong">getDFOutputMap</emphasis> () const</para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Protected Attributes    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1aae032e5f5d53b131d0112dc8faa464a9"/><link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link> * <emphasis role="strong">svfg</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a76f6f19ac2b58ab4a10a2d7e6e24e42a"/><link linkend="_class_s_v_f_1_1_s_v_f_g_builder">SVFGBuilder</link> <emphasis role="strong">memSSA</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a5cfee013a1a5821ef0c449842dd8690d"/><link linkend="_class_s_v_f_1_1_andersen_wave_diff">AndersenWaveDiff</link> * <emphasis role="strong">ander</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1aae57c806e973735cdae52622c73b85ae"/>Size_t <link linkend="_class_s_v_f_1_1_flow_sensitive_1aae57c806e973735cdae52622c73b85ae">numOfProcessedAddr</link></para>

<para>Statistics. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1abbc5289ac5600ae96a2b4cf4e16fc849"/>Size_t <link linkend="_class_s_v_f_1_1_flow_sensitive_1abbc5289ac5600ae96a2b4cf4e16fc849">numOfProcessedCopy</link></para>

<para>Number of processed Addr node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a30ef94f44ad3ec0a5ab91da29ce1ee86"/>Size_t <link linkend="_class_s_v_f_1_1_flow_sensitive_1a30ef94f44ad3ec0a5ab91da29ce1ee86">numOfProcessedGep</link></para>

<para>Number of processed Copy node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1aea6b283c4e0078655ba22fde3548689a"/>Size_t <link linkend="_class_s_v_f_1_1_flow_sensitive_1aea6b283c4e0078655ba22fde3548689a">numOfProcessedPhi</link></para>

<para>Number of processed Gep node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1afd1b49d94168d5353611e6adbdf8e1c0"/>Size_t <link linkend="_class_s_v_f_1_1_flow_sensitive_1afd1b49d94168d5353611e6adbdf8e1c0">numOfProcessedLoad</link></para>

<para>Number of processed Phi node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1ae0cfed89e63939da4ee9bbdf4a4e2837"/>Size_t <link linkend="_class_s_v_f_1_1_flow_sensitive_1ae0cfed89e63939da4ee9bbdf4a4e2837">numOfProcessedStore</link></para>

<para>Number of processed Load node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1ab4ebfae609e467ea9316de9764151889"/>Size_t <link linkend="_class_s_v_f_1_1_flow_sensitive_1ab4ebfae609e467ea9316de9764151889">numOfProcessedActualParam</link></para>

<para>Number of processed Store node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a9c2d3c7f9c2ace0c478114d18408946b"/>Size_t <link linkend="_class_s_v_f_1_1_flow_sensitive_1a9c2d3c7f9c2ace0c478114d18408946b">numOfProcessedFormalRet</link></para>

<para>Number of processed actual param node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a67d008a8316996c8743f8dbb3082d3c7"/>Size_t <link linkend="_class_s_v_f_1_1_flow_sensitive_1a67d008a8316996c8743f8dbb3082d3c7">numOfProcessedMSSANode</link></para>

<para>Number of processed formal ret node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a90deaa3c1afa762f568ceab0fe174353"/>Size_t <link linkend="_class_s_v_f_1_1_flow_sensitive_1a90deaa3c1afa762f568ceab0fe174353">maxSCCSize</link></para>

<para>Number of processed mssa node. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1ab6c2494ca36cefb5409c5c20befb326f"/>Size_t <emphasis role="strong">numOfSCC</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1ad2a7c4ec5e08b6ae423e305d01d432e4"/>Size_t <emphasis role="strong">numOfNodesInSCC</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a4202f837e863a48712765cc346d8b514"/>double <link linkend="_class_s_v_f_1_1_flow_sensitive_1a4202f837e863a48712765cc346d8b514">solveTime</link></para>

<para>time of solve. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1af496fa9aa2f4d59594950b2ad121deff"/>double <link linkend="_class_s_v_f_1_1_flow_sensitive_1af496fa9aa2f4d59594950b2ad121deff">sccTime</link></para>

<para>time of SCC detection. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1ae2e58d18abcdddc7a5a87f4edc5f3b72"/>double <link linkend="_class_s_v_f_1_1_flow_sensitive_1ae2e58d18abcdddc7a5a87f4edc5f3b72">processTime</link></para>

<para>time of processNode. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1ac4d4b42bb96006801597f81ed3c4b337"/>double <link linkend="_class_s_v_f_1_1_flow_sensitive_1ac4d4b42bb96006801597f81ed3c4b337">propagationTime</link></para>

<para>time of points-to propagation. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1ae086de68233375be42185f0af706687a"/>double <link linkend="_class_s_v_f_1_1_flow_sensitive_1ae086de68233375be42185f0af706687a">directPropaTime</link></para>

<para>time of points-to propagation of address-taken objects </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a2feaa4b7a72989b311e9084a81320254"/>double <link linkend="_class_s_v_f_1_1_flow_sensitive_1a2feaa4b7a72989b311e9084a81320254">indirectPropaTime</link></para>

<para>time of points-to propagation of top-level pointers </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1af5a94d14096ae2bbc47b3b3b9f723226"/>double <link linkend="_class_s_v_f_1_1_flow_sensitive_1af5a94d14096ae2bbc47b3b3b9f723226">updateTime</link></para>

<para>time of strong/weak updates. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a38f3ed35185addf701d4401bfdd5f29b"/>double <link linkend="_class_s_v_f_1_1_flow_sensitive_1a38f3ed35185addf701d4401bfdd5f29b">addrTime</link></para>

<para>time of handling address edges </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a888d6334e5e226c634680e4c0674dcfb"/>double <link linkend="_class_s_v_f_1_1_flow_sensitive_1a888d6334e5e226c634680e4c0674dcfb">copyTime</link></para>

<para>time of handling copy edges </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a282126e5b67ed4e19aa40c81180b8290"/>double <link linkend="_class_s_v_f_1_1_flow_sensitive_1a282126e5b67ed4e19aa40c81180b8290">gepTime</link></para>

<para>time of handling gep edges </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1aab4f70210eb1e6447a24697d3b459067"/>double <link linkend="_class_s_v_f_1_1_flow_sensitive_1aab4f70210eb1e6447a24697d3b459067">loadTime</link></para>

<para>time of load edges </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a82b76087363b26fbe749653935569de7"/>double <link linkend="_class_s_v_f_1_1_flow_sensitive_1a82b76087363b26fbe749653935569de7">storeTime</link></para>

<para>time of store edges </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1aee7d59b7ad00cf1cf6e3fba19513aa42"/>double <link linkend="_class_s_v_f_1_1_flow_sensitive_1aee7d59b7ad00cf1cf6e3fba19513aa42">phiTime</link></para>

<para>time of phi nodes. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1afc140b6c8e78dc2d962f64fdf53b1e07"/>double <link linkend="_class_s_v_f_1_1_flow_sensitive_1afc140b6c8e78dc2d962f64fdf53b1e07">updateCallGraphTime</link></para>

<para>time of updating call graph </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a43e8ca2e69e6e8643c9abd1fa231d305"/>NodeBS <emphasis role="strong">svfgHasSU</emphasis></para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Static Protected Attributes    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a4ad2095dc708df07602de25e4a004776"/>static <link linkend="_class_s_v_f_1_1_flow_sensitive">FlowSensitive</link> * <emphasis role="strong">fspta</emphasis> = NULL</para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Friends    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a88f9752372eabb71f47f13a89e4d6d9c"/>class <emphasis role="strong">FlowSensitiveStat</emphasis></para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Additional Inherited Members    </title>
</simplesect>
<section>
<title>Member Function Documentation</title>
<anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a267f7198600dde3054feb40def7a6681"/>    <section>
    <title>analyze()</title>
<indexterm><primary>analyze</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>analyze</secondary></indexterm>
<para><computeroutput>void FlowSensitive::analyze ( )<computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Flow sensitive analysis. </para>
</para>

<para>Start analysis </para>

<para>Initialization for the Solver</para>

<para>Start solving constraints</para>

<para>finalize the analysis</para>
<para>
Implements <link linkend="_class_s_v_f_1_1_pointer_analysis_1ae1e217dc18be0ce70bee5ad930cb54c6">SVF::PointerAnalysis</link>.</para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_flow_sensitive_t_b_h_c_1abcab6281cced08d90c92d67d43a37c2c">SVF::FlowSensitiveTBHC</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1ad7640ada31b5cb542e492e27ab4fe1af"/>    <section>
    <title>connectCallerAndCallee()</title>
<indexterm><primary>connectCallerAndCallee</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>connectCallerAndCallee</secondary></indexterm>
<para><computeroutput>void FlowSensitive::connectCallerAndCallee (const CallEdgeMap &amp; newEdges, SVFGEdgeSetTy &amp; edges)<computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Connect nodes in <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link>. </para>
</para>

<para>Handle parameter passing in <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link> </para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1afed358369102f01f6fe88b1433e704c3"/>    <section>
    <title>finalize()</title>
<indexterm><primary>finalize</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>finalize</secondary></indexterm>
<para><computeroutput>void FlowSensitive::finalize (void )<computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Finalize analysis. </para>
</para>

<para>Finalize analysis </para>
<para>
Reimplemented from <link linkend="_class_s_v_f_1_1_pointer_analysis_1a118dabc50024b5cd91095814ade47166">SVF::PointerAnalysis</link>.</para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_versioned_flow_sensitive_1ad955fda89f4f749151a1bd14562b03f6">SVF::VersionedFlowSensitive</link>, and <link linkend="_class_s_v_f_1_1_flow_sensitive_t_b_h_c_1a3564d6ad7e12e0a833b4cea203a809e4">SVF::FlowSensitiveTBHC</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a9717517387c14c2e64c7ae3c3149bb57"/>    <section>
    <title>getDFInputMap()</title>
<indexterm><primary>getDFInputMap</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>getDFInputMap</secondary></indexterm>
<para><computeroutput>const DFInOutMap&amp; SVF::FlowSensitive::getDFInputMap ( ) const<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput></computeroutput></para>
<para>Get IN/OUT data flow map. May only be called when the backing is MUTABLE. </para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1ad6243c1317503bed39411dab47c83da7"/>    <section>
    <title>initialize()</title>
<indexterm><primary>initialize</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>initialize</secondary></indexterm>
<para><computeroutput>void FlowSensitive::initialize ( )<computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Initialize analysis. </para>
</para>

<para>Initialize analysis </para>
<para>
Reimplemented from <link linkend="_class_s_v_f_1_1_pointer_analysis_1a431ec4f85eb0f029e5740b92fd9ceb32">SVF::PointerAnalysis</link>.</para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_versioned_flow_sensitive_1a81d3528fd082018e4345f0b026bf3584">SVF::VersionedFlowSensitive</link>, and <link linkend="_class_s_v_f_1_1_flow_sensitive_t_b_h_c_1a4c5fb70aafc3a589b7b1e82ba8f61a6f">SVF::FlowSensitiveTBHC</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a42a7e39e0e15576742f8ba7c32579ea2"/>    <section>
    <title>isStrongUpdate()</title>
<indexterm><primary>isStrongUpdate</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>isStrongUpdate</secondary></indexterm>
<para><computeroutput>bool FlowSensitive::isStrongUpdate (const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> * node, NodeID &amp; singleton)<computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Return TRUE if this is a strong update STORE statement. </para>
</para>

<para>Return TRUE if this is a strong update STORE statement. </para>

<para>Find the unique element in cpts</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a023d0b492deaba40c593332cf1b2e3f6"/>    <section>
    <title>printCTirAliasStats()</title>
<indexterm><primary>printCTirAliasStats</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>printCTirAliasStats</secondary></indexterm>
<para><computeroutput>void FlowSensitive::printCTirAliasStats (void )<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para>
<para>Prints some easily parseable stats on aliasing of relevant CTir TL PTS. Format: eval-ctir-aliases #TOTAL_TESTS #MAY_ALIAS #NO_ALIAS </para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1abb37c5e4e6fa4742e8dbcf397aea086e"/>    <section>
    <title>processAddr()</title>
<indexterm><primary>processAddr</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>processAddr</secondary></indexterm>
<para><computeroutput>bool FlowSensitive::processAddr (const <link linkend="_class_s_v_f_1_1_addr_v_f_g_node">AddrSVFGNode</link> * addr)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para>
<para>Process address node </para>

<para>TODO: If this object has been set as field-insensitive, just add the insensitive object node into dst pointer&apos;s pts.</para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_flow_sensitive_t_b_h_c_1abce5580e93cba1e591a0bac4e9070816">SVF::FlowSensitiveTBHC</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1aa401cc90de4e1c6842f08a43a28c5aa1"/>    <section>
    <title>processCopy()</title>
<indexterm><primary>processCopy</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>processCopy</secondary></indexterm>
<para><computeroutput>bool FlowSensitive::processCopy (const <link linkend="_class_s_v_f_1_1_copy_v_f_g_node">CopySVFGNode</link> * copy)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para>
<para>Process copy node </para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_flow_sensitive_t_b_h_c_1ab6525ac133151692176a03227f81bcac">SVF::FlowSensitiveTBHC</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1ae017c39ac471727d06868e0eacafd791"/>    <section>
    <title>processGep()</title>
<indexterm><primary>processGep</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>processGep</secondary></indexterm>
<para><computeroutput>bool FlowSensitive::processGep (const <link linkend="_class_s_v_f_1_1_gep_v_f_g_node">GepSVFGNode</link> * edge)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para>
<para>Process gep node </para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_flow_sensitive_t_b_h_c_1abf96f7329d8c50dcd75da048548d2c85">SVF::FlowSensitiveTBHC</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a9968530b3dee876f55e6659530decf27"/>    <section>
    <title>processLoad()</title>
<indexterm><primary>processLoad</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>processLoad</secondary></indexterm>
<para><computeroutput>bool FlowSensitive::processLoad (const <link linkend="_class_s_v_f_1_1_load_v_f_g_node">LoadSVFGNode</link> * load)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para>
<para>Process load node</para>

<para>Foreach node \in src pts(dst) = union pts(node) </para>

<para>If the ptd is a field-insensitive node, we should also get all field nodes&apos; points-to sets and pass them to pagDst.</para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_versioned_flow_sensitive_1a1d1f71c41cc3e81e636b58f4436e6d9b">SVF::VersionedFlowSensitive</link>, and <link linkend="_class_s_v_f_1_1_flow_sensitive_t_b_h_c_1a42c8023e0e60e8701ec197b3d775b423">SVF::FlowSensitiveTBHC</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a16f594356ea565eb1fed2acea516a16b"/>    <section>
    <title>processNode()</title>
<indexterm><primary>processNode</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>processNode</secondary></indexterm>
<para><computeroutput>void FlowSensitive::processNode (NodeID nodeId)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Handle various constraints. </para>
</para>

<para>Process each <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link> node </para>
<para>
Reimplemented from <link linkend="_class_s_v_f_1_1_w_p_a_solver_1abd7fd785e70f66d394088101d78598ca">SVF::WPASolver&lt; GraphType &gt;</link>.</para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_versioned_flow_sensitive_1a8cad0df2ae7df81dc2a966e694a0f7a2">SVF::VersionedFlowSensitive</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1aa36fd1387e948e83107431179d819067"/>    <section>
    <title>processPhi()</title>
<indexterm><primary>processPhi</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>processPhi</secondary></indexterm>
<para><computeroutput>bool FlowSensitive::processPhi (const <link linkend="_class_s_v_f_1_1_p_h_i_v_f_g_node">PHISVFGNode</link> * phi)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para>
<para>Process mssa phi node </para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_flow_sensitive_t_b_h_c_1a0eb8335dd45b35b20d34c981b86b059c">SVF::FlowSensitiveTBHC</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1aa37d591d2d4f65957e840bef4d142a6a"/>    <section>
    <title>processStore()</title>
<indexterm><primary>processStore</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>processStore</secondary></indexterm>
<para><computeroutput>bool FlowSensitive::processStore (const <link linkend="_class_s_v_f_1_1_store_v_f_g_node">StoreSVFGNode</link> * store)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para>
<para>Process store node</para>

<para>foreach node \in dst pts(node) = union pts(src) </para>

<para>STORE statement can only be processed if the pointer on the LHS points to something. If we handle STORE with an empty points-to set, the OUT set will be updated from IN set. Then if LHS pointer points-to one target and it has been identified as a strong update, we can&apos;t remove those points-to information computed before this strong update from the OUT set.</para>

<para>check if this is a strong updates store</para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_versioned_flow_sensitive_1aa96f517740420665168e9b0c7d2347f1">SVF::VersionedFlowSensitive</link>, and <link linkend="_class_s_v_f_1_1_flow_sensitive_t_b_h_c_1ac937e0e388071bbf94a477e1880663eb">SVF::FlowSensitiveTBHC</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a979f89495966d71f9b470d832384ebd6"/>    <section>
    <title>processSVFGNode()</title>
<indexterm><primary>processSVFGNode</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>processSVFGNode</secondary></indexterm>
<para><computeroutput>bool FlowSensitive::processSVFGNode (<link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> * node)<computeroutput>[protected]</computeroutput></computeroutput></para>
<para>Process each <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link> node </para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a3574977acd161925cadcb05de6d3247d"/>    <section>
    <title>propagateFromAPToFP()</title>
<indexterm><primary>propagateFromAPToFP</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>propagateFromAPToFP</secondary></indexterm>
<para><computeroutput>bool FlowSensitive::propagateFromAPToFP (const <link linkend="_class_s_v_f_1_1_actual_parm_v_f_g_node">ActualParmSVFGNode</link> * ap, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> * dst)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para>
<para>Propagate points-to information from an actual-param to a formal-param. Not necessary if <link linkend="_class_s_v_f_1_1_s_v_f_g_o_p_t">SVFGOPT</link> is used instead of original <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link>.</para>

<para>Propagate points-to information from actual-param to formal-param. Not necessary if <link linkend="_class_s_v_f_1_1_s_v_f_g_o_p_t">SVFGOPT</link> is used instead of original <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link>. </para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a3abffe1434386b1ce349fbed0cfe0967"/>    <section>
    <title>propagateFromFRToAR()</title>
<indexterm><primary>propagateFromFRToAR</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>propagateFromFRToAR</secondary></indexterm>
<para><computeroutput>bool FlowSensitive::propagateFromFRToAR (const <link linkend="_class_s_v_f_1_1_formal_ret_v_f_g_node">FormalRetSVFGNode</link> * fr, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> * dst)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para>
<para>Propagate points-to information from a formal-ret to an actual-ret. Not necessary if <link linkend="_class_s_v_f_1_1_s_v_f_g_o_p_t">SVFGOPT</link> is used instead of original <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link>.</para>

<para>Propagate points-to information from formal-ret to actual-ret. Not necessary if <link linkend="_class_s_v_f_1_1_s_v_f_g_o_p_t">SVFGOPT</link> is used instead of original <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link>. </para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1ad3518931d3b8a0671cbeb975f853b956"/>    <section>
    <title>propAlongDirectEdge()</title>
<indexterm><primary>propAlongDirectEdge</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>propAlongDirectEdge</secondary></indexterm>
<para><computeroutput>bool FlowSensitive::propAlongDirectEdge (const <link linkend="_class_s_v_f_1_1_direct_s_v_f_g_edge">DirectSVFGEdge</link> * edge)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Propagate points-to information along a DIRECT <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link> edge. </para>
</para>

<para>Propagate points-to information along DIRECT <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link> edge. </para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_flow_sensitive_t_b_h_c_1a15b8610fd7456d158a9e640c69d401a0">SVF::FlowSensitiveTBHC</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1aeb1e002519123a67f8d18f78cda04bac"/>    <section>
    <title>propAlongIndirectEdge()</title>
<indexterm><primary>propAlongIndirectEdge</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>propAlongIndirectEdge</secondary></indexterm>
<para><computeroutput>bool FlowSensitive::propAlongIndirectEdge (const <link linkend="_class_s_v_f_1_1_indirect_s_v_f_g_edge">IndirectSVFGEdge</link> * edge)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Propagate points-to information along an INDIRECT <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link> edge. </para>
</para>

<para>Propagate points-to information along INDIRECT <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link> edge. </para>

<para>If this is a field-insensitive obj, propagate all field node&apos;s pts</para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_versioned_flow_sensitive_1a7add83046cc87c22e81bffb80c04bf58">SVF::VersionedFlowSensitive</link>, and <link linkend="_class_s_v_f_1_1_flow_sensitive_t_b_h_c_1a83a4defe2bcb1c99c66aea8c8325d5fd">SVF::FlowSensitiveTBHC</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1af849ab5a07049cb08e6b0d8023577862"/>    <section>
    <title>propFromSrcToDst()</title>
<indexterm><primary>propFromSrcToDst</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>propFromSrcToDst</secondary></indexterm>
<para><computeroutput>bool FlowSensitive::propFromSrcToDst (<link linkend="_class_s_v_f_1_1_v_f_g_edge">SVFGEdge</link> * edge)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Propagation. </para>
</para>

<para>Propagate points-to information from an edge&apos;s src node to its dst node.</para>

<para>Propagate points-to information from source to destination node Union dfOutput of src to dfInput of dst. Only propagate points-to set of node which exists on the <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link> edge.<orderedlist>
<listitem>
<para>propagation along direct edge will always return TRUE.</para>
</listitem><listitem>
<para>propagation along indirect edge will return TRUE if destination node&apos;s IN set has been updated. </para>
</listitem></orderedlist>
</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a9e7fbc4c1d056fbef07498de8cbb1cd9"/>    <section>
    <title>propVarPtsAfterCGUpdated()</title>
<indexterm><primary>propVarPtsAfterCGUpdated</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>propVarPtsAfterCGUpdated</secondary></indexterm>
<para><computeroutput>bool FlowSensitive::propVarPtsAfterCGUpdated (NodeID var, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> * src, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> * dst)<computeroutput>[protected]</computeroutput></computeroutput></para>
<para>Propagation between newly connected <link linkend="_class_s_v_f_1_1_s_v_f_g">SVFG</link> nodes during updateCallGraph. Can only be used during updateCallGraph.</para>

<para>Propagate points-to information of a certain variable from src to dst. </para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1ae571767cc5936cf631a44976d8277e91"/>    <section>
    <title>propVarPtsFromSrcToDst()</title>
<indexterm><primary>propVarPtsFromSrcToDst</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>propVarPtsFromSrcToDst</secondary></indexterm>
<para><computeroutput>bool FlowSensitive::propVarPtsFromSrcToDst (NodeID var, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> * src, const <link linkend="_class_s_v_f_1_1_v_f_g_node">SVFGNode</link> * dst)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Propagate points-to information of a certain variable from src to dst. </para>
</para>

<para>Propagate points-to information of a certain variable from src to dst. </para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a5f8a1493f7550a3f7a295e25d87bce12"/>    <section>
    <title>SCCDetect()</title>
<indexterm><primary>SCCDetect</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>SCCDetect</secondary></indexterm>
<para><computeroutput>NodeStack &amp; FlowSensitive::SCCDetect ( )<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>SCC detection. </para>
</para>

<para>SCC detection </para>
<para>
Reimplemented from <link linkend="_class_s_v_f_1_1_w_p_a_f_s_solver_1a2d4cfae34bd4a55f1fe03881c87f8708">SVF::WPAFSSolver&lt; GraphType &gt;</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a9d81537ec20196315a9a2541477ec5bf"/>    <section>
    <title>updateCallGraph()</title>
<indexterm><primary>updateCallGraph</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>updateCallGraph</secondary></indexterm>
<para><computeroutput>bool FlowSensitive::updateCallGraph (const CallSiteToFunPtrMap &amp; callsites)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Update call graph. </para>
</para>

<para>Update call graph.</para>

<para>Update call graph </para>
<para>
Reimplemented from <link linkend="_class_s_v_f_1_1_b_v_data_p_t_a_impl_1aa534e475fa34fa322c567bc376a3da70">SVF::BVDataPTAImpl</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_flow_sensitive_1a1886b4964efa92cfff761493d12768b8"/>    <section>
    <title>updateConnectedNodes()</title>
<indexterm><primary>updateConnectedNodes</primary><secondary>SVF::FlowSensitive</secondary></indexterm>
<indexterm><primary>SVF::FlowSensitive</primary><secondary>updateConnectedNodes</secondary></indexterm>
<para><computeroutput>void FlowSensitive::updateConnectedNodes (const SVFGEdgeSetTy &amp; edges)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Update nodes connected during updating call graph. </para>
</para>

<para>Push nodes connected during update call graph into worklist so they will be solved during next iteration. </para>

<para>If this is a formal-param or actual-ret node, we need to solve this phi node in next iteration</para>

<para>If this is a formal-in or actual-out node, we need to propagate points-to information from its predecessor node.</para>

<para>If this is a field-insensitive obj, propagate all field node&apos;s pts</para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_versioned_flow_sensitive_1a18f24fe34af677e2a8c78ee89b89be1c">SVF::VersionedFlowSensitive</link>.</para>
</section>
<para>
The documentation for this class was generated from the following files:</para>
include/WPA/FlowSensitive.hlib/WPA/FlowSensitive.cpp</section>
</section>
