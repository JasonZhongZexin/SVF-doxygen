.TH "SVF::PathCondAllocator" 3 "Sun Feb 14 2021" "SVF" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SVF::PathCondAllocator
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <PathCondAllocator\&.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef \fBDdNode\fP \fBCondition\fP"
.br
.ti -1c
.RI "typedef Map< u32_t, \fBCondition\fP * > \fBCondPosMap\fP"
.br
.RI "map a branch to its Condition "
.ti -1c
.RI "typedef Map< const BasicBlock *, \fBCondPosMap\fP > \fBBBCondMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBCondition\fP *, const Instruction * > \fBCondToTermInstMap\fP"
.br
.ti -1c
.RI "typedef Set< const BasicBlock * > \fBBasicBlockSet\fP"
.br
.ti -1c
.RI "typedef Map< const Function *, BasicBlockSet > \fBFunToExitBBsMap\fP"
.br
.RI "map a function to all its basic blocks calling program exit "
.ti -1c
.RI "typedef Map< const BasicBlock *, \fBCondition\fP * > \fBBBToCondMap\fP"
.br
.RI "map a basic block to its condition during control-flow guard computation "
.ti -1c
.RI "typedef \fBFIFOWorkList\fP< const BasicBlock * > \fBCFWorkList\fP"
.br
.RI "worklist for control-flow guard computation "
.ti -1c
.RI "typedef Map< u32_t, \fBCondition\fP * > \fBIndexToConditionMap\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPathCondAllocator\fP ()"
.br
.RI "Constructor\&. "
.ti -1c
.RI "virtual \fB~PathCondAllocator\fP ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "void \fBallocate\fP (const \fBSVFModule\fP *module)"
.br
.RI "Perform path allocation\&. "
.ti -1c
.RI "const Instruction * \fBgetCondInst\fP (const \fBCondition\fP *cond) const"
.br
.RI "Get llvm conditional expression\&. "
.ti -1c
.RI "DominatorTree * \fBgetDT\fP (const Function *fun)"
.br
.RI "Get dominators\&. "
.ti -1c
.RI "PostDominatorTree * \fBgetPostDT\fP (const Function *fun)"
.br
.RI "Get Postdominators\&. "
.ti -1c
.RI "LoopInfo * \fBgetLoopInfo\fP (const Function *f)"
.br
.RI "Get LoopInfo\&. "
.ti -1c
.RI "\fBCondition\fP * \fBcondAnd\fP (\fBCondition\fP *lhs, \fBCondition\fP *rhs)"
.br
.RI "Condition operations\&. "
.ti -1c
.RI "\fBCondition\fP * \fBcondOr\fP (\fBCondition\fP *lhs, \fBCondition\fP *rhs)"
.br
.ti -1c
.RI "\fBCondition\fP * \fBcondNeg\fP (\fBCondition\fP *cond)"
.br
.ti -1c
.RI "\fBCondition\fP * \fBgetTrueCond\fP () const"
.br
.ti -1c
.RI "\fBCondition\fP * \fBgetFalseCond\fP () const"
.br
.ti -1c
.RI "\fBCondition\fP * \fBgetCond\fP (u32_t i) const"
.br
.RI "Given an index, get its condition\&. "
.ti -1c
.RI "NodeBS \fBexactCondElem\fP (\fBCondition\fP *cond)"
.br
.RI "Iterator every element of the bdd\&. "
.ti -1c
.RI "void \fBmarkForRelease\fP (\fBCondition\fP *cond)"
.br
.RI "Decrease reference counting for the bdd\&. "
.ti -1c
.RI "void \fBprintDbg\fP (\fBCondition\fP *cond)"
.br
.RI "Print debug information for this condition\&. "
.ti -1c
.RI "std::string \fBdumpCond\fP (\fBCondition\fP *cond) const"
.br
.ti -1c
.RI "virtual \fBCondition\fP * \fBComputeIntraVFGGuard\fP (const BasicBlock *src, const BasicBlock *dst)"
.br
.RI "Guard Computation for a value-flow (between two basic blocks) "
.ti -1c
.RI "virtual \fBCondition\fP * \fBComputeInterCallVFGGuard\fP (const BasicBlock *src, const BasicBlock *dst, const BasicBlock *callBB)"
.br
.ti -1c
.RI "virtual \fBCondition\fP * \fBComputeInterRetVFGGuard\fP (const BasicBlock *src, const BasicBlock *dst, const BasicBlock *retBB)"
.br
.ti -1c
.RI "virtual \fBCondition\fP * \fBgetPHIComplementCond\fP (const BasicBlock *BB1, const BasicBlock *BB2, const BasicBlock *BB0)"
.br
.ti -1c
.RI "void \fBclearCFCond\fP ()"
.br
.ti -1c
.RI "void \fBsetCurEvalVal\fP (const Value *val)"
.br
.RI "Set current value for branch condition evaluation\&. "
.ti -1c
.RI "const Value * \fBgetCurEvalVal\fP () const"
.br
.RI "Get current value for branch condition evaluation\&. "
.ti -1c
.RI "void \fBprintPathCond\fP ()"
.br
.RI "Print out the path condition information\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBCondition\fP * \fBtrueCond\fP ()"
.br
.ti -1c
.RI "static \fBCondition\fP * \fBfalseCond\fP ()"
.br
.ti -1c
.RI "static u32_t \fBgetMemUsage\fP ()"
.br
.RI "Statistics\&. "
.ti -1c
.RI "static u32_t \fBgetCondNum\fP ()"
.br
.ti -1c
.RI "static u32_t \fBgetMaxLiveCondNumber\fP ()"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static u32_t \fBtotalCondNum\fP = 0"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "BBCondMap \fBbbConds\fP"
.br
.RI "map basic block to its successors/predecessors branch conditions "
.ti -1c
.RI "IndexToConditionMap \fBindexToDDNodeMap\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static \fBBddCondManager\fP * \fBbddCondMgr\fP = NULL"
.br
.RI "bbd manager "
.in -1c
.SH "Detailed Description"
.PP 
\fBPathCondAllocator\fP allocates conditions for each basic block of a certain CFG\&. 
.SH "Member Function Documentation"
.PP 
.SS "void PathCondAllocator::allocate (const \fBSVFModule\fP * M)"

.PP
Perform path allocation\&. Allocate path condition for each branch 
.SS "\fBPathCondAllocator::Condition\fP * PathCondAllocator::ComputeInterCallVFGGuard (const BasicBlock * srcBB, const BasicBlock * dstBB, const BasicBlock * callBB)\fC [virtual]\fP"
Compute calling inter-procedural guards between two SVFGNodes (from caller to callee) src --c1--> callBB --true--> funEntryBB --c2--> dst the InterCallVFGGuard is c1 ^ c2 
.SS "\fBPathCondAllocator::Condition\fP * PathCondAllocator::ComputeInterRetVFGGuard (const BasicBlock * srcBB, const BasicBlock * dstBB, const BasicBlock * retBB)\fC [virtual]\fP"
Compute return inter-procedural guards between two SVFGNodes (from callee to caller) src --c1--> funExitBB --true--> retBB --c2--> dst the InterRetVFGGuard is c1 ^ c2 
.SS "\fBPathCondAllocator::Condition\fP * PathCondAllocator::ComputeIntraVFGGuard (const BasicBlock * srcBB, const BasicBlock * dstBB)\fC [virtual]\fP"

.PP
Guard Computation for a value-flow (between two basic blocks) Compute intra-procedural guards between two SVFGNodes (inside same function) if the dstBB is the eligible loop exit of the current basic block we can early terminate the computation
.PP
calculate the branch condition if succ post dominate bb, then we get brCond quicker by using postDT note that we assume loop exit always post dominate loop bodys which means loops are approximated only once\&.
.SS "\fBPathCondAllocator::Condition\fP * PathCondAllocator::getPHIComplementCond (const BasicBlock * BB1, const BasicBlock * BB2, const BasicBlock * BB0)\fC [virtual]\fP"
Get complement condition (from B1 to B0) according to a complementBB (BB2) at a phi e\&.g\&., B0: dstBB; B1:incomingBB; B2:complementBB
.PP
Get complement phi condition e\&.g\&., B0: dstBB; B1:incomingBB; B2:complementBB Assume B0 (phi node) is the successor of both B1 and B2\&. If B1 dominates B2, and B0 not dominate B2 then condition from B1-->B0 = neg(B1-->B2)^(B1-->B0) avoid both BB0 and BB1 dominate BB2 (e\&.g\&., while loop), then BB2 is not necessaryly a complement BB
.SS "void PathCondAllocator::printPathCond ()"

.PP
Print out the path condition information\&. Print path conditions 

.SH "Author"
.PP 
Generated automatically by Doxygen for SVF from the source code\&.
