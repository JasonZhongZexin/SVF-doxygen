.TH "SVF::PAG" 3 "Sun Feb 14 2021" "SVF" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SVF::PAG
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <PAG\&.h>\fP
.PP
Inherits \fBSVF::GenericGraph< PAGNode, PAGEdge >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef Set< const \fBCallBlockNode\fP * > \fBCallSiteSet\fP"
.br
.ti -1c
.RI "typedef OrderedMap< const \fBCallBlockNode\fP *, NodeID > \fBCallSiteToFunPtrMap\fP"
.br
.ti -1c
.RI "typedef Map< NodeID, CallSiteSet > \fBFunPtrToCallSitesMap\fP"
.br
.ti -1c
.RI "typedef Map< NodeID, NodeBS > \fBMemObjToFieldsMap\fP"
.br
.ti -1c
.RI "typedef Set< const \fBPAGEdge\fP * > \fBPAGEdgeSet\fP"
.br
.ti -1c
.RI "typedef std::vector< const \fBPAGEdge\fP * > \fBPAGEdgeList\fP"
.br
.ti -1c
.RI "typedef std::vector< const \fBPAGNode\fP * > \fBPAGNodeList\fP"
.br
.ti -1c
.RI "typedef std::vector< const \fBCopyPE\fP * > \fBCopyPEList\fP"
.br
.ti -1c
.RI "typedef std::vector< const \fBBinaryOPPE\fP * > \fBBinaryOPList\fP"
.br
.ti -1c
.RI "typedef std::vector< const \fBUnaryOPPE\fP * > \fBUnaryOPList\fP"
.br
.ti -1c
.RI "typedef std::vector< const \fBCmpPE\fP * > \fBCmpPEList\fP"
.br
.ti -1c
.RI "typedef Map< const \fBPAGNode\fP *, CopyPEList > \fBPHINodeMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBPAGNode\fP *, BinaryOPList > \fBBinaryNodeMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBPAGNode\fP *, UnaryOPList > \fBUnaryNodeMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBPAGNode\fP *, CmpPEList > \fBCmpNodeMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBSVFFunction\fP *, PAGNodeList > \fBFunToArgsListMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBCallBlockNode\fP *, PAGNodeList > \fBCSToArgsListMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBRetBlockNode\fP *, const \fBPAGNode\fP * > \fBCSToRetMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBSVFFunction\fP *, const \fBPAGNode\fP * > \fBFunToRetMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBSVFFunction\fP *, PAGEdgeSet > \fBFunToPAGEdgeSetMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBICFGNode\fP *, PAGEdgeList > \fBInst2PAGEdgesMap\fP"
.br
.ti -1c
.RI "typedef Map< NodeID, NodeID > \fBNodeToNodeMap\fP"
.br
.ti -1c
.RI "typedef std::pair< NodeID, Size_t > \fBNodeOffset\fP"
.br
.ti -1c
.RI "typedef std::pair< NodeID, \fBLocationSet\fP > \fBNodeLocationSet\fP"
.br
.ti -1c
.RI "typedef Map< NodeOffset, NodeID > \fBNodeOffsetMap\fP"
.br
.ti -1c
.RI "typedef Map< NodeLocationSet, NodeID > \fBNodeLocationSetMap\fP"
.br
.ti -1c
.RI "typedef Map< const Value *, NodeLocationSetMap > \fBGepValPNMap\fP"
.br
.ti -1c
.RI "typedef Map< NodePair, NodeID > \fBNodePairSetMap\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBICFG\fP * \fBgetICFG\fP ()"
.br
.RI "Return \fBICFG\fP\&. "
.ti -1c
.RI "OrderedNodeSet & \fBgetAllValidPtrs\fP ()"
.br
.RI "Return valid pointers\&. "
.ti -1c
.RI "void \fBinitialiseCandidatePointers\fP ()"
.br
.RI "Initialize candidate pointers\&. "
.ti -1c
.RI "virtual \fB~PAG\fP ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "bool \fBisBuiltFromFile\fP ()"
.br
.RI "Whether this \fBPAG\fP built from a txt file\&. "
.ti -1c
.RI "\fBSVFModule\fP * \fBgetModule\fP ()"
.br
.RI "Get LLVM Module\&. "
.ti -1c
.RI "void \fBaddCallSite\fP (const \fBCallBlockNode\fP *call)"
.br
.ti -1c
.RI "const CallSiteSet & \fBgetCallSiteSet\fP () const"
.br
.ti -1c
.RI "PAGEdge::PAGEdgeSetTy & \fBgetEdgeSet\fP (\fBPAGEdge::PEDGEK\fP kind)"
.br
.RI "Get/set methods to get control flow information of a \fBPAGEdge\fP\&. "
.ti -1c
.RI "PAGEdge::PAGEdgeSetTy & \fBgetPTAEdgeSet\fP (\fBPAGEdge::PEDGEK\fP kind)"
.br
.RI "Get PTA edges set according to its kind\&. "
.ti -1c
.RI "bool \fBhasPAGEdgeList\fP (const \fBICFGNode\fP *inst) const"
.br
.RI "Whether this instruction has \fBPAG\fP Edge\&. "
.ti -1c
.RI "bool \fBhasPTAPAGEdgeList\fP (const \fBICFGNode\fP *inst) const"
.br
.ti -1c
.RI "PAGEdgeList & \fBgetInstPAGEdgeList\fP (const \fBICFGNode\fP *inst)"
.br
.RI "Given an instruction, get all its PAGEdges\&. "
.ti -1c
.RI "PAGEdgeList & \fBgetInstPTAPAGEdgeList\fP (const \fBICFGNode\fP *inst)"
.br
.RI "Given an instruction, get all its PTA PAGEdges\&. "
.ti -1c
.RI "void \fBaddToInstPAGEdgeList\fP (\fBICFGNode\fP *inst, \fBPAGEdge\fP *edge)"
.br
.RI "Add a \fBPAGEdge\fP into instruction map\&. "
.ti -1c
.RI "void \fBaddGlobalPAGEdge\fP (const \fBPAGEdge\fP *edge)"
.br
.RI "Get global PAGEdges (not in a procedure) "
.ti -1c
.RI "PAGEdgeSet & \fBgetGlobalPAGEdgeSet\fP ()"
.br
.RI "Get global PAGEdges (not in a procedure) "
.ti -1c
.RI "void \fBaddPhiNode\fP (const \fBPAGNode\fP *res, const \fBCopyPE\fP *edge)"
.br
.RI "Add phi node information\&. "
.ti -1c
.RI "bool \fBisPhiNode\fP (const \fBPAGNode\fP *node) const"
.br
.RI "Whether this \fBPAGNode\fP is a result operand a of phi node\&. "
.ti -1c
.RI "PHINodeMap & \fBgetPhiNodeMap\fP ()"
.br
.RI "Get all phi copy edges\&. "
.ti -1c
.RI "void \fBaddBinaryNode\fP (const \fBPAGNode\fP *res, const \fBBinaryOPPE\fP *edge)"
.br
.RI "Add phi node information\&. "
.ti -1c
.RI "bool \fBisBinaryNode\fP (const \fBPAGNode\fP *node) const"
.br
.RI "Whether this \fBPAGNode\fP is a result operand a of phi node\&. "
.ti -1c
.RI "BinaryNodeMap & \fBgetBinaryNodeMap\fP ()"
.br
.RI "Get all phi copy edges\&. "
.ti -1c
.RI "void \fBaddUnaryNode\fP (const \fBPAGNode\fP *res, const \fBUnaryOPPE\fP *edge)"
.br
.RI "Add unary node information\&. "
.ti -1c
.RI "bool \fBisUnaryNode\fP (const \fBPAGNode\fP *node) const"
.br
.RI "Whether this \fBPAGNode\fP is an unary node\&. "
.ti -1c
.RI "UnaryNodeMap & \fBgetUnaryNodeMap\fP ()"
.br
.RI "Get all unary edges\&. "
.ti -1c
.RI "void \fBaddCmpNode\fP (const \fBPAGNode\fP *res, const \fBCmpPE\fP *edge)"
.br
.RI "Add phi node information\&. "
.ti -1c
.RI "bool \fBisCmpNode\fP (const \fBPAGNode\fP *node) const"
.br
.RI "Whether this \fBPAGNode\fP is a result operand a of phi node\&. "
.ti -1c
.RI "CmpNodeMap & \fBgetCmpNodeMap\fP ()"
.br
.RI "Get all phi copy edges\&. "
.ti -1c
.RI "void \fBaddFunArgs\fP (const \fBSVFFunction\fP *fun, const \fBPAGNode\fP *arg)"
.br
.RI "Get/set method for function/callsite arguments and returns\&. "
.ti -1c
.RI "void \fBaddFunRet\fP (const \fBSVFFunction\fP *fun, const \fBPAGNode\fP *ret)"
.br
.RI "Add function returns\&. "
.ti -1c
.RI "void \fBaddCallSiteArgs\fP (\fBCallBlockNode\fP *callBlockNode, const \fBPAGNode\fP *arg)"
.br
.RI "Add callsite arguments\&. "
.ti -1c
.RI "void \fBaddCallSiteRets\fP (\fBRetBlockNode\fP *retBlockNode, const \fBPAGNode\fP *arg)"
.br
.RI "Add callsite returns\&. "
.ti -1c
.RI "bool \fBhasFunArgsList\fP (const \fBSVFFunction\fP *func) const"
.br
.RI "Function has arguments list\&. "
.ti -1c
.RI "FunToArgsListMap & \fBgetFunArgsMap\fP ()"
.br
.RI "Get function arguments list\&. "
.ti -1c
.RI "const PAGNodeList & \fBgetFunArgsList\fP (const \fBSVFFunction\fP *func) const"
.br
.RI "Get function arguments list\&. "
.ti -1c
.RI "bool \fBhasCallSiteArgsMap\fP (const \fBCallBlockNode\fP *cs) const"
.br
.RI "Callsite has argument list\&. "
.ti -1c
.RI "CSToArgsListMap & \fBgetCallSiteArgsMap\fP ()"
.br
.RI "Get callsite argument list\&. "
.ti -1c
.RI "const PAGNodeList & \fBgetCallSiteArgsList\fP (const \fBCallBlockNode\fP *cs) const"
.br
.RI "Get callsite argument list\&. "
.ti -1c
.RI "CSToRetMap & \fBgetCallSiteRets\fP ()"
.br
.RI "Get callsite return\&. "
.ti -1c
.RI "const \fBPAGNode\fP * \fBgetCallSiteRet\fP (const \fBRetBlockNode\fP *cs) const"
.br
.RI "Get callsite return\&. "
.ti -1c
.RI "bool \fBcallsiteHasRet\fP (const \fBRetBlockNode\fP *cs) const"
.br
.ti -1c
.RI "FunToRetMap & \fBgetFunRets\fP ()"
.br
.RI "Get function return list\&. "
.ti -1c
.RI "const \fBPAGNode\fP * \fBgetFunRet\fP (const \fBSVFFunction\fP *func) const"
.br
.RI "Get function return list\&. "
.ti -1c
.RI "bool \fBfunHasRet\fP (const \fBSVFFunction\fP *func) const"
.br
.ti -1c
.RI "Size_t \fBgetPAGNodeNum\fP () const"
.br
.RI "Node and edge statistics\&. "
.ti -1c
.RI "Size_t \fBgetPAGEdgeNum\fP () const"
.br
.ti -1c
.RI "Size_t \fBgetValueNodeNum\fP () const"
.br
.ti -1c
.RI "Size_t \fBgetObjectNodeNum\fP () const"
.br
.ti -1c
.RI "Size_t \fBgetFieldValNodeNum\fP () const"
.br
.ti -1c
.RI "Size_t \fBgetFieldObjNodeNum\fP () const"
.br
.ti -1c
.RI "NodeID \fBgetGepValNode\fP (const Value *curInst, NodeID base, const \fBLocationSet\fP &ls) const"
.br
.RI "Due to constaint expression, curInst is used to distinguish different instructions (e\&.g\&., memorycpy) when creating \fBGepValPN\fP\&. "
.ti -1c
.RI "const CallSiteToFunPtrMap & \fBgetIndirectCallsites\fP () const"
.br
.RI "Add/get indirect callsites\&. "
.ti -1c
.RI "void \fBaddIndirectCallsites\fP (const \fBCallBlockNode\fP *cs, NodeID funPtr)"
.br
.ti -1c
.RI "NodeID \fBgetFunPtr\fP (const \fBCallBlockNode\fP *cs) const"
.br
.ti -1c
.RI "const CallSiteSet & \fBgetIndCallSites\fP (NodeID funPtr) const"
.br
.ti -1c
.RI "bool \fBisIndirectCallSites\fP (const \fBCallBlockNode\fP *cs) const"
.br
.ti -1c
.RI "bool \fBisFunPtr\fP (NodeID id) const"
.br
.ti -1c
.RI "bool \fBfindPAGNode\fP (NodeID id) const"
.br
.RI "Get a pag node according to its ID\&. "
.ti -1c
.RI "\fBPAGEdge\fP * \fBgetIntraPAGEdge\fP (NodeID src, NodeID dst, \fBPAGEdge::PEDGEK\fP kind)"
.br
.RI "Get an edge according to src, dst and kind\&. "
.ti -1c
.RI "\fBPAGEdge\fP * \fBgetIntraPAGEdge\fP (\fBPAGNode\fP *src, \fBPAGNode\fP *dst, \fBPAGEdge::PEDGEK\fP kind)"
.br
.ti -1c
.RI "\fBPAGNode\fP * \fBgetPAGNode\fP (NodeID id) const"
.br
.RI "Get \fBPAGNode\fP ID\&. "
.ti -1c
.RI "NodeID \fBgetValueNode\fP (const Value *V)"
.br
.RI "Get \fBPAG\fP Node according to LLVM value\&. "
.ti -1c
.RI "bool \fBhasValueNode\fP (const Value *V)"
.br
.ti -1c
.RI "NodeID \fBgetObjectNode\fP (const Value *V)"
.br
.ti -1c
.RI "NodeID \fBgetObjectNode\fP (const \fBMemObj\fP *mem)"
.br
.RI "getObject - return mem object id "
.ti -1c
.RI "const \fBMemObj\fP * \fBgetObject\fP (NodeID id) const"
.br
.ti -1c
.RI "const \fBMemObj\fP * \fBgetObject\fP (const \fBObjPN\fP *node) const"
.br
.ti -1c
.RI "NodeID \fBgetReturnNode\fP (const \fBSVFFunction\fP *func) const"
.br
.RI "GetReturnNode - Return the unique node representing the return value of a function\&. "
.ti -1c
.RI "NodeID \fBgetVarargNode\fP (const \fBSVFFunction\fP *func) const"
.br
.RI "getVarargNode - Return the unique node representing the variadic argument of a variadic function\&. "
.ti -1c
.RI "NodeID \fBgetGepObjNode\fP (const \fBMemObj\fP *obj, const \fBLocationSet\fP &ls)"
.br
.RI "Get a field \fBPAG\fP Object node according to base mem obj and offset\&. "
.ti -1c
.RI "NodeID \fBgetGepObjNode\fP (NodeID id, const \fBLocationSet\fP &ls)"
.br
.RI "Get a field obj \fBPAG\fP node according to a mem obj and a given offset\&. "
.ti -1c
.RI "NodeID \fBgetFIObjNode\fP (const \fBMemObj\fP *obj) const"
.br
.RI "Get a field-insensitive obj \fBPAG\fP node according to a mem obj\&. "
.ti -1c
.RI "NodeID \fBgetFIObjNode\fP (NodeID id) const"
.br
.ti -1c
.RI "NodeID \fBgetBlackHoleNode\fP () const"
.br
.RI "Get black hole and constant id\&. "
.ti -1c
.RI "NodeID \fBgetConstantNode\fP () const"
.br
.ti -1c
.RI "NodeID \fBgetBlkPtr\fP () const"
.br
.ti -1c
.RI "NodeID \fBgetNullPtr\fP () const"
.br
.ti -1c
.RI "bool \fBisBlkPtr\fP (NodeID id) const"
.br
.ti -1c
.RI "bool \fBisNullPtr\fP (NodeID id) const"
.br
.ti -1c
.RI "bool \fBisBlkObjOrConstantObj\fP (NodeID id) const"
.br
.ti -1c
.RI "bool \fBisBlkObj\fP (NodeID id) const"
.br
.ti -1c
.RI "bool \fBisConstantObj\fP (NodeID id) const"
.br
.ti -1c
.RI "bool \fBisNonPointerObj\fP (NodeID id) const"
.br
.ti -1c
.RI "const \fBMemObj\fP * \fBgetBlackHoleObj\fP () const"
.br
.ti -1c
.RI "const \fBMemObj\fP * \fBgetConstantObj\fP () const"
.br
.ti -1c
.RI "u32_t \fBgetNodeNumAfterPAGBuild\fP () const"
.br
.ti -1c
.RI "void \fBsetNodeNumAfterPAGBuild\fP (u32_t num)"
.br
.ti -1c
.RI "NodeID \fBgetBaseValNode\fP (NodeID nodeId)"
.br
.RI "Base and Offset methods for Value and Object node\&. "
.ti -1c
.RI "\fBLocationSet\fP \fBgetLocationSetFromBaseNode\fP (NodeID nodeId)"
.br
.ti -1c
.RI "NodeID \fBgetBaseObjNode\fP (NodeID id) const"
.br
.ti -1c
.RI "const \fBMemObj\fP * \fBgetBaseObj\fP (NodeID id) const"
.br
.ti -1c
.RI "NodeBS & \fBgetAllFieldsObjNode\fP (const \fBMemObj\fP *obj)"
.br
.RI "Get all fields of an object\&. "
.ti -1c
.RI "NodeBS & \fBgetAllFieldsObjNode\fP (NodeID id)"
.br
.ti -1c
.RI "NodeBS \fBgetFieldsAfterCollapse\fP (NodeID id)"
.br
.ti -1c
.RI "NodeID \fBaddNode\fP (\fBPAGNode\fP *node, NodeID i)"
.br
.RI "add node into \fBPAG\fP "
.ti -1c
.RI "NodeID \fBaddValNode\fP (const Value *val, NodeID i)"
.br
.RI "Add a value (pointer) node\&. "
.ti -1c
.RI "NodeID \fBaddObjNode\fP (const Value *val, NodeID i)"
.br
.RI "Add a memory obj node\&. "
.ti -1c
.RI "NodeID \fBaddRetNode\fP (const \fBSVFFunction\fP *val, NodeID i)"
.br
.RI "Add a unique return node for a procedure\&. "
.ti -1c
.RI "NodeID \fBaddVarargNode\fP (const \fBSVFFunction\fP *val, NodeID i)"
.br
.RI "Add a unique vararg node for a procedure\&. "
.ti -1c
.RI "NodeID \fBaddGepValNode\fP (const Value *curInst, const Value *val, const \fBLocationSet\fP &ls, NodeID i, const Type *type, u32_t fieldidx)"
.br
.RI "Add a temp field value node, this method can only invoked by getGepValNode\&. "
.ti -1c
.RI "NodeID \fBaddGepObjNode\fP (const \fBMemObj\fP *obj, const \fBLocationSet\fP &ls)"
.br
.RI "Add a field obj node, this method can only invoked by getGepObjNode\&. "
.ti -1c
.RI "NodeID \fBaddFIObjNode\fP (const \fBMemObj\fP *obj)"
.br
.RI "Add a field-insensitive node, this method can only invoked by getFIGepObjNode\&. "
.ti -1c
.RI "NodeID \fBaddDummyValNode\fP ()"
.br
.RI "Add a dummy value/object node according to node ID (llvm value is null) "
.ti -1c
.RI "NodeID \fBaddDummyValNode\fP (NodeID i)"
.br
.ti -1c
.RI "NodeID \fBaddDummyObjNode\fP (const Type *type=NULL)"
.br
.ti -1c
.RI "NodeID \fBaddDummyObjNode\fP (NodeID i, const Type *type)"
.br
.ti -1c
.RI "const \fBMemObj\fP * \fBaddDummyMemObj\fP (NodeID i, const Type *type)"
.br
.ti -1c
.RI "NodeID \fBaddBlackholeObjNode\fP ()"
.br
.ti -1c
.RI "NodeID \fBaddConstantObjNode\fP ()"
.br
.ti -1c
.RI "NodeID \fBaddBlackholePtrNode\fP ()"
.br
.ti -1c
.RI "NodeID \fBaddValNode\fP (const Value *, \fBPAGNode\fP *node, NodeID i)"
.br
.RI "Add a value (pointer) node\&. "
.ti -1c
.RI "NodeID \fBaddObjNode\fP (const Value *, \fBPAGNode\fP *node, NodeID i)"
.br
.RI "Add a memory obj node\&. "
.ti -1c
.RI "NodeID \fBaddRetNode\fP (const \fBSVFFunction\fP *, \fBPAGNode\fP *node, NodeID i)"
.br
.RI "Add a unique return node for a procedure\&. "
.ti -1c
.RI "NodeID \fBaddVarargNode\fP (const \fBSVFFunction\fP *, \fBPAGNode\fP *node, NodeID i)"
.br
.RI "Add a unique vararg node for a procedure\&. "
.ti -1c
.RI "bool \fBaddEdge\fP (\fBPAGNode\fP *src, \fBPAGNode\fP *dst, \fBPAGEdge\fP *edge)"
.br
.RI "Add an edge into \fBPAG\fP\&. "
.ti -1c
.RI "\fBPAGEdge\fP * \fBhasNonlabeledEdge\fP (\fBPAGNode\fP *src, \fBPAGNode\fP *dst, \fBPAGEdge::PEDGEK\fP kind)"
.br
.ti -1c
.RI "\fBPAGEdge\fP * \fBhasLabeledEdge\fP (\fBPAGNode\fP *src, \fBPAGNode\fP *dst, \fBPAGEdge::PEDGEK\fP kind, const \fBICFGNode\fP *cs)"
.br
.ti -1c
.RI "\fBAddrPE\fP * \fBaddAddrPE\fP (NodeID src, NodeID dst)"
.br
.RI "Add Address edge\&. "
.ti -1c
.RI "\fBCopyPE\fP * \fBaddCopyPE\fP (NodeID src, NodeID dst)"
.br
.RI "Add Copy edge\&. "
.ti -1c
.RI "\fBCmpPE\fP * \fBaddCmpPE\fP (NodeID src, NodeID dst)"
.br
.RI "Add Copy edge\&. "
.ti -1c
.RI "\fBBinaryOPPE\fP * \fBaddBinaryOPPE\fP (NodeID src, NodeID dst)"
.br
.RI "Add Copy edge\&. "
.ti -1c
.RI "\fBUnaryOPPE\fP * \fBaddUnaryOPPE\fP (NodeID src, NodeID dst)"
.br
.RI "Add Unary edge\&. "
.ti -1c
.RI "\fBLoadPE\fP * \fBaddLoadPE\fP (NodeID src, NodeID dst)"
.br
.RI "Add Load edge\&. "
.ti -1c
.RI "\fBStorePE\fP * \fBaddStorePE\fP (NodeID src, NodeID dst, const \fBIntraBlockNode\fP *val)"
.br
.RI "Add Store edge\&. "
.ti -1c
.RI "\fBCallPE\fP * \fBaddCallPE\fP (NodeID src, NodeID dst, const \fBCallBlockNode\fP *cs)"
.br
.RI "Add Call edge\&. "
.ti -1c
.RI "\fBRetPE\fP * \fBaddRetPE\fP (NodeID src, NodeID dst, const \fBCallBlockNode\fP *cs)"
.br
.RI "Add Return edge\&. "
.ti -1c
.RI "\fBGepPE\fP * \fBaddGepPE\fP (NodeID src, NodeID dst, const \fBLocationSet\fP &ls, bool constGep)"
.br
.RI "Add Gep edge\&. "
.ti -1c
.RI "\fBNormalGepPE\fP * \fBaddNormalGepPE\fP (NodeID src, NodeID dst, const \fBLocationSet\fP &ls)"
.br
.RI "Add Offset(Gep) edge\&. "
.ti -1c
.RI "\fBVariantGepPE\fP * \fBaddVariantGepPE\fP (NodeID src, NodeID dst)"
.br
.RI "Add Variant(Gep) edge\&. "
.ti -1c
.RI "\fBTDForkPE\fP * \fBaddThreadForkPE\fP (NodeID src, NodeID dst, const \fBCallBlockNode\fP *cs)"
.br
.RI "Add Thread fork edge for parameter passing\&. "
.ti -1c
.RI "\fBTDJoinPE\fP * \fBaddThreadJoinPE\fP (NodeID src, NodeID dst, const \fBCallBlockNode\fP *cs)"
.br
.RI "Add Thread join edge for parameter passing\&. "
.ti -1c
.RI "\fBPAGEdge\fP * \fBaddBlackHoleAddrPE\fP (NodeID node)"
.br
.RI "Set a pointer points-to black hole (e\&.g\&. int2ptr) "
.ti -1c
.RI "bool \fBisValidPointer\fP (NodeID nodeId) const"
.br
.RI "Whether a node is a valid pointer\&. "
.ti -1c
.RI "bool \fBisValidTopLevelPtr\fP (const \fBPAGNode\fP *node)"
.br
.ti -1c
.RI "std::string \fBgetGraphName\fP () const"
.br
.RI "Return graph name\&. "
.ti -1c
.RI "void \fBprint\fP ()"
.br
.RI "Print \fBPAG\fP\&. "
.ti -1c
.RI "void \fBdump\fP (std::string name)"
.br
.RI "Dump \fBPAG\fP\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBPAG\fP * \fBgetPAG\fP (bool buildFromFile=false)"
.br
.RI "Singleton design here to make sure we only have one instance during any analysis\&. "
.ti -1c
.RI "static void \fBreleasePAG\fP ()"
.br
.ti -1c
.RI "static void \fBhandleBlackHole\fP (bool b)"
.br
.RI "\fBPAG\fP build configurations\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "u32_t \fBtotalPTAPAGEdge\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Program Assignment Graph for pointer analysis SymID and NodeID are equal here (same numbering)\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBAddrPE\fP * PAG::addAddrPE (NodeID src, NodeID dst)"

.PP
Add Address edge\&. Add Address edge 
.SS "\fBBinaryOPPE\fP * PAG::addBinaryOPPE (NodeID src, NodeID dst)"

.PP
Add Copy edge\&. Add Compare edge 
.SS "\fBPAGEdge\fP * PAG::addBlackHoleAddrPE (NodeID node)"

.PP
Set a pointer points-to black hole (e\&.g\&. int2ptr) Add blackhole/constant edge 
.SS "\fBCallPE\fP * PAG::addCallPE (NodeID src, NodeID dst, const \fBCallBlockNode\fP * cs)"

.PP
Add Call edge\&. Add Call edge 
.SS "\fBCmpPE\fP * PAG::addCmpPE (NodeID src, NodeID dst)"

.PP
Add Copy edge\&. Add Compare edge 
.SS "\fBCopyPE\fP * PAG::addCopyPE (NodeID src, NodeID dst)"

.PP
Add Copy edge\&. Add Copy edge 
.SS "bool PAG::addEdge (\fBPAGNode\fP * src, \fBPAGNode\fP * dst, \fBPAGEdge\fP * edge)"

.PP
Add an edge into \fBPAG\fP\&. Add a \fBPAG\fP edge
.PP
Add a \fBPAG\fP edge into edge map 
.SS "NodeID PAG::addFIObjNode (const \fBMemObj\fP * obj)"

.PP
Add a field-insensitive node, this method can only invoked by getFIGepObjNode\&. Add a field-insensitive node, this method can only invoked by getFIGepObjNode 
.SS "void SVF::PAG::addFunArgs (const \fBSVFFunction\fP * fun, const \fBPAGNode\fP * arg)\fC [inline]\fP"

.PP
Get/set method for function/callsite arguments and returns\&. Add function arguments 
.SS "NodeID PAG::addGepObjNode (const \fBMemObj\fP * obj, const \fBLocationSet\fP & ls)"

.PP
Add a field obj node, this method can only invoked by getGepObjNode\&. Add a field obj node, this method can only invoked by getGepObjNode 
.SS "\fBGepPE\fP * PAG::addGepPE (NodeID src, NodeID dst, const \fBLocationSet\fP & ls, bool constGep)"

.PP
Add Gep edge\&. Add Offset(Gep) edge Find the base node id of src and connect base node to dst node Create gep offset: (offset + baseOff <nested struct gep size>) Since the offset from base to src is variant, the new gep edge being created is also a \fBVariantGepPE\fP edge\&.
.SS "NodeID PAG::addGepValNode (const Value * curInst, const Value * gepVal, const \fBLocationSet\fP & ls, NodeID i, const Type * type, u32_t fieldidx)"

.PP
Add a temp field value node, this method can only invoked by getGepValNode\&. Add a temp field value node, this method can only invoked by getGepValNode due to constaint expression, curInst is used to distinguish different instructions (e\&.g\&., memorycpy) when creating \fBGepValPN\fP\&. 
.SS "\fBLoadPE\fP * PAG::addLoadPE (NodeID src, NodeID dst)"

.PP
Add Load edge\&. Add Load edge 
.SS "NodeID SVF::PAG::addNode (\fBPAGNode\fP * node, NodeID i)\fC [inline]\fP"

.PP
add node into \fBPAG\fP Add a \fBPAG\fP node into Node map 
.SS "\fBNormalGepPE\fP * PAG::addNormalGepPE (NodeID src, NodeID dst, const \fBLocationSet\fP & ls)"

.PP
Add Offset(Gep) edge\&. Add normal (Gep) edge 
.SS "\fBRetPE\fP * PAG::addRetPE (NodeID src, NodeID dst, const \fBCallBlockNode\fP * cs)"

.PP
Add Return edge\&. Add Return edge 
.SS "\fBStorePE\fP * PAG::addStorePE (NodeID src, NodeID dst, const \fBIntraBlockNode\fP * curVal)"

.PP
Add Store edge\&. Add Store edge Note that two store instructions may share the same Store \fBPAGEdge\fP 
.SS "\fBTDForkPE\fP * PAG::addThreadForkPE (NodeID src, NodeID dst, const \fBCallBlockNode\fP * cs)"

.PP
Add Thread fork edge for parameter passing\&. Add Thread fork edge for parameter passing from a spawner to its spawnees 
.SS "\fBTDJoinPE\fP * PAG::addThreadJoinPE (NodeID src, NodeID dst, const \fBCallBlockNode\fP * cs)"

.PP
Add Thread join edge for parameter passing\&. Add Thread fork edge for parameter passing from a spawnee back to its spawners 
.SS "\fBUnaryOPPE\fP * PAG::addUnaryOPPE (NodeID src, NodeID dst)"

.PP
Add Unary edge\&. Add Unary edge 
.SS "\fBVariantGepPE\fP * PAG::addVariantGepPE (NodeID src, NodeID dst)"

.PP
Add Variant(Gep) edge\&. Add variant(Gep) edge Find the base node id of src and connect base node to dst node 
.SS "void PAG::dump (std::string name)"

.PP
Dump \fBPAG\fP\&. Dump this \fBPAG\fP 
.SS "NodeBS & PAG::getAllFieldsObjNode (const \fBMemObj\fP * obj)"

.PP
Get all fields of an object\&. Get all fields object nodes of an object 
.SS "NodeBS & PAG::getAllFieldsObjNode (NodeID id)"
Get all fields object nodes of an object 
.SS "NodeID PAG::getBaseValNode (NodeID nodeId)"

.PP
Base and Offset methods for Value and Object node\&. Get a base pointer node given a field pointer
.PP
Get a base pointer given a pointer Return the source node of its connected gep edge if this pointer has Otherwise return the node id itself 
.SS "PAGEdge::PAGEdgeSetTy& SVF::PAG::getEdgeSet (\fBPAGEdge::PEDGEK\fP kind)\fC [inline]\fP"

.PP
Get/set methods to get control flow information of a \fBPAGEdge\fP\&. Get edges set according to its kind 
.SS "NodeBS PAG::getFieldsAfterCollapse (NodeID id)"
Get all fields object nodes of an object If this object is collapsed into one field insensitive object Then only return this field insensitive object 
.SS "NodeID PAG::getGepObjNode (const \fBMemObj\fP * obj, const \fBLocationSet\fP & ls)"

.PP
Get a field \fBPAG\fP Object node according to base mem obj and offset\&. Get a field obj \fBPAG\fP node according to base mem obj and offset To support flexible field sensitive analysis with regard to MaxFieldOffset offset = offset % obj->getMaxFieldOffsetLimit() to create limited number of mem objects maximum number of field object creation is obj->getMaxFieldOffsetLimit() if this obj is field-insensitive, just return the field-insensitive node\&.
.SS "NodeID PAG::getGepObjNode (NodeID id, const \fBLocationSet\fP & ls)"

.PP
Get a field obj \fBPAG\fP node according to a mem obj and a given offset\&. Given an object node, find its field object node 
.SS "\fBLocationSet\fP PAG::getLocationSetFromBaseNode (NodeID nodeId)"
Get a base \fBPAGNode\fP given a pointer Return the source node of its connected normal gep edge Otherwise return the node id itself Size_t offset : gep offset if this node is already a base node
.SS "const \fBMemObj\fP* SVF::PAG::getObject (NodeID id) const\fC [inline]\fP"
Get memory object - Return memory object according to pag node id return whole allocated memory object if this node is a gep obj node return NULL is this node is not a \fBObjPN\fP type 
.SS "NodeID SVF::PAG::getObjectNode (const Value * V)\fC [inline]\fP"
getObject - Return the obj node id refer to the memory object for the specified global, heap or alloca instruction according to llvm value\&. 
.SS "NodeID SVF::PAG::getValueNode (const Value * V)\fC [inline]\fP"

.PP
Get \fBPAG\fP Node according to LLVM value\&. getNode - Return the node corresponding to the specified pointer\&. 
.SS "void PAG::handleBlackHole (bool b)\fC [static]\fP"

.PP
\fBPAG\fP build configurations\&. Whether to handle blackhole edge 
.SS "\fBPAGEdge\fP * PAG::hasLabeledEdge (\fBPAGNode\fP * src, \fBPAGNode\fP * dst, \fBPAGEdge::PEDGEK\fP kind, const \fBICFGNode\fP * callInst)"
Return true if this labeled edge exits, including store, call and load two store edge can have same dst and src but located in different basic blocks, thus flags are needed to distinguish them
.PP
Return true if it is an inter-procedural edge 
.SS "\fBPAGEdge\fP * PAG::hasNonlabeledEdge (\fBPAGNode\fP * src, \fBPAGNode\fP * dst, \fBPAGEdge::PEDGEK\fP kind)"
Return true if it is an intra-procedural edge 
.SS "void PAG::print ()"

.PP
Print \fBPAG\fP\&. Print this \fBPAG\fP graph including its nodes and edges 

.SH "Author"
.PP 
Generated automatically by Doxygen for SVF from the source code\&.
