\hypertarget{class_s_v_f_1_1_type_based_heap_cloning}{}\doxysection{SVF\+::Type\+Based\+Heap\+Cloning Class Reference}
\label{class_s_v_f_1_1_type_based_heap_cloning}\index{SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}}
Inheritance diagram for SVF\+::Type\+Based\+Heap\+Cloning\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_s_v_f_1_1_type_based_heap_cloning}
\end{center}
\end{figure}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_a21d2fd8bbef0c6f6ddddb5387569a7fa}\label{class_s_v_f_1_1_type_based_heap_cloning_a21d2fd8bbef0c6f6ddddb5387569a7fa}} 
static const MDNode $\ast$ \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_a21d2fd8bbef0c6f6ddddb5387569a7fa}{get\+Raw\+CTir\+Metadata}} (const Value $\ast$)
\begin{DoxyCompactList}\small\item\em Returns raw ctir metadata of a Value. Returns null if it doesn\textquotesingle{}t exist. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_af4d0abf53755a070478c142add3322d8}\label{class_s_v_f_1_1_type_based_heap_cloning_af4d0abf53755a070478c142add3322d8}} 
\mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_af4d0abf53755a070478c142add3322d8}{Type\+Based\+Heap\+Cloning}} (\mbox{\hyperlink{class_s_v_f_1_1_b_v_data_p_t_a_impl}{BVData\+PTAImpl}} $\ast$pta)
\begin{DoxyCompactList}\small\item\em Constructor. pta is the pointer analysis using this object (i.\+e. that which is extending). \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_a1d48cd7ccbcd9bdf1470a5d9aca3298d}{back\+Propagate}} (Node\+ID clone)=0
\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_aaaf50870e50b45b44d4ecaaaab662770}\label{class_s_v_f_1_1_type_based_heap_cloning_aaaf50870e50b45b44d4ecaaaab662770}} 
void \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_aaaf50870e50b45b44d4ecaaaab662770}{set\+DCHG}} (\mbox{\hyperlink{class_s_v_f_1_1_d_c_h_graph}{DCHGraph}} $\ast$\mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_a465e67781977e83526df7e36d576e539}{dchg}})
\begin{DoxyCompactList}\small\item\em DCHG {\itshape must} be set by extending class once the DCHG is available. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_a4ae27b3d09bbb83b21ed6c7fd6c4e653}\label{class_s_v_f_1_1_type_based_heap_cloning_a4ae27b3d09bbb83b21ed6c7fd6c4e653}} 
void \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_a4ae27b3d09bbb83b21ed6c7fd6c4e653}{set\+PAG}} (\mbox{\hyperlink{class_s_v_f_1_1_p_a_g}{PAG}} $\ast$pag)
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{class_s_v_f_1_1_p_a_g}{PAG}} {\itshape must} be set by extending class once the \mbox{\hyperlink{class_s_v_f_1_1_p_a_g}{PAG}} is available. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_a59a9c7b8a7ec392ac609f10c8dac8d7f}{is\+Blk\+Obj\+Or\+Constant\+Obj}} (Node\+ID o) const
\item 
bool \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_add00f1c20a524c0be903af679bd6f638}{is\+Base}} (const DIType $\ast$a, const DIType $\ast$b) const
\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_abce2ba326af69312c5971246cc4c10dc}\label{class_s_v_f_1_1_type_based_heap_cloning_abce2ba326af69312c5971246cc4c10dc}} 
bool \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_abce2ba326af69312c5971246cc4c10dc}{is\+Clone}} (Node\+ID o) const
\begin{DoxyCompactList}\small\item\em Returns true if o is a clone. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_ac51cd735739a2499196a87323172a6a6}\label{class_s_v_f_1_1_type_based_heap_cloning_ac51cd735739a2499196a87323172a6a6}} 
void \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_ac51cd735739a2499196a87323172a6a6}{set\+Type}} (Node\+ID o, const DIType $\ast$t)
\begin{DoxyCompactList}\small\item\em Sets the type (in obj\+To\+Type) of o. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_a219edef6c013a953ed12ee3c56bde6de}\label{class_s_v_f_1_1_type_based_heap_cloning_a219edef6c013a953ed12ee3c56bde6de}} 
const DIType $\ast$ \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_a219edef6c013a953ed12ee3c56bde6de}{get\+Type}} (Node\+ID o) const
\begin{DoxyCompactList}\small\item\em Returns the type (from obj\+To\+Type) of o. Asserts existence. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_a006243a1416f4950de254d0d62ba40b0}\label{class_s_v_f_1_1_type_based_heap_cloning_a006243a1416f4950de254d0d62ba40b0}} 
void \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_a006243a1416f4950de254d0d62ba40b0}{set\+Allocation\+Site}} (Node\+ID o, Node\+ID site)
\begin{DoxyCompactList}\small\item\em Sets the allocation site (in obj\+To\+Allocation) of o. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_a5681d78630ca8770dd493ef3841ec683}\label{class_s_v_f_1_1_type_based_heap_cloning_a5681d78630ca8770dd493ef3841ec683}} 
Node\+ID \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_a5681d78630ca8770dd493ef3841ec683}{get\+Allocation\+Site}} (Node\+ID o) const
\begin{DoxyCompactList}\small\item\em Returns the allocation site (from obj\+To\+Allocation) of o. Asserts existence. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_ad1c67da3aac128ca8a69907fdad53fcd}\label{class_s_v_f_1_1_type_based_heap_cloning_ad1c67da3aac128ca8a69907fdad53fcd}} 
const Node\+BS \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_ad1c67da3aac128ca8a69907fdad53fcd}{get\+Objs\+With\+Clones}} (void)
\begin{DoxyCompactList}\small\item\em Returns objects that have clones (any key in obj\+To\+Clones). \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_ae83ef821386b3fd4b86f29477cdda3e1}\label{class_s_v_f_1_1_type_based_heap_cloning_ae83ef821386b3fd4b86f29477cdda3e1}} 
void \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_ae83ef821386b3fd4b86f29477cdda3e1}{add\+Clone}} (Node\+ID o, Node\+ID c)
\begin{DoxyCompactList}\small\item\em Add a clone c to object o. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_af127bed600087b1ace26088a76ca8998}\label{class_s_v_f_1_1_type_based_heap_cloning_af127bed600087b1ace26088a76ca8998}} 
const Node\+BS \& \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_af127bed600087b1ace26088a76ca8998}{get\+Clones}} (Node\+ID o)
\begin{DoxyCompactList}\small\item\em Returns all the clones of o. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_a14027d92c4f8e33d7487fe81acce6a85}\label{class_s_v_f_1_1_type_based_heap_cloning_a14027d92c4f8e33d7487fe81acce6a85}} 
void {\bfseries set\+Original\+Obj} (Node\+ID c, Node\+ID o)
\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_aeea7089c6f54b44f0509d41686b649f6}\label{class_s_v_f_1_1_type_based_heap_cloning_aeea7089c6f54b44f0509d41686b649f6}} 
Node\+ID \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_aeea7089c6f54b44f0509d41686b649f6}{get\+Original\+Obj}} (Node\+ID c) const
\begin{DoxyCompactList}\small\item\em Returns the original object c is cloned from. If c is not a clone, returns itself. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_ae520e0551e63223a908f92a6b9667356}\label{class_s_v_f_1_1_type_based_heap_cloning_ae520e0551e63223a908f92a6b9667356}} 
Points\+To \& \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_ae520e0551e63223a908f92a6b9667356}{get\+Filter\+Set}} (Node\+ID loc)
\begin{DoxyCompactList}\small\item\em Returns the filter set of a location. Not const; could create empty Points\+To. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_ad07fb204258fccda89053514338e3804}\label{class_s_v_f_1_1_type_based_heap_cloning_ad07fb204258fccda89053514338e3804}} 
void \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_ad07fb204258fccda89053514338e3804}{add\+Gep\+To\+Obj}} (Node\+ID gep, Node\+ID base, unsigned offset)
\begin{DoxyCompactList}\small\item\em Associates gep with base (through obj\+To\+Geps and mem\+Obj\+To\+Geps). \end{DoxyCompactList}\item 
const Node\+BS \& \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_ad043ab95900849a5a894ca4bada4e032}{get\+Gep\+Objs\+From\+Mem\+Obj}} (const \mbox{\hyperlink{class_s_v_f_1_1_mem_obj}{Mem\+Obj}} $\ast$mem\+Obj, unsigned offset)
\item 
const Node\+BS \& \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_afe416f9ec57923f34ef1db3890a3f9e1}{get\+Gep\+Objs}} (Node\+ID base)
\item 
const Node\+BS \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_aa175b5db473eb57c03b6f908791d1133}{get\+Gep\+Obj\+Clones}} (Node\+ID base, unsigned offset)
\item 
bool \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_a34064efe336ada815b31050f683c7ce1}{init}} (Node\+ID loc, Node\+ID p, const DIType $\ast$tildet, bool reuse, bool gep=false)
\item 
Node\+ID \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_a11c3d1b7f10e4aad2525d428f5855db5}{clone\+Object}} (Node\+ID o, const DIType $\ast$type, bool reuse)
\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_ac6ebb2fd24fc4272faf5db6ddd1e464b}\label{class_s_v_f_1_1_type_based_heap_cloning_ac6ebb2fd24fc4272faf5db6ddd1e464b}} 
Node\+ID \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_ac6ebb2fd24fc4272faf5db6ddd1e464b}{add\+Clone\+Dummy\+Obj\+Node}} (const \mbox{\hyperlink{class_s_v_f_1_1_mem_obj}{Mem\+Obj}} $\ast$mem)
\begin{DoxyCompactList}\small\item\em Add clone dummy object node to \mbox{\hyperlink{class_s_v_f_1_1_p_a_g}{PAG}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_a16ad9c601a044731b982305a177dbda3}\label{class_s_v_f_1_1_type_based_heap_cloning_a16ad9c601a044731b982305a177dbda3}} 
Node\+ID \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_a16ad9c601a044731b982305a177dbda3}{add\+Clone\+Gep\+Obj\+Node}} (const \mbox{\hyperlink{class_s_v_f_1_1_mem_obj}{Mem\+Obj}} $\ast$mem, const \mbox{\hyperlink{class_s_v_f_1_1_location_set}{Location\+Set}} \&l)
\begin{DoxyCompactList}\small\item\em Add clone GEP object node to \mbox{\hyperlink{class_s_v_f_1_1_p_a_g}{PAG}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_a83fb1e2a7b66d5f33fa34698a52250af}\label{class_s_v_f_1_1_type_based_heap_cloning_a83fb1e2a7b66d5f33fa34698a52250af}} 
Node\+ID \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_a83fb1e2a7b66d5f33fa34698a52250af}{add\+Clone\+FIObj\+Node}} (const \mbox{\hyperlink{class_s_v_f_1_1_mem_obj}{Mem\+Obj}} $\ast$mem)
\begin{DoxyCompactList}\small\item\em Add clone FI object node to \mbox{\hyperlink{class_s_v_f_1_1_p_a_g}{PAG}}. \end{DoxyCompactList}\item 
const DIType $\ast$ \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_ac4565775cced4444ba007e310c4a02d8}{get\+Type\+From\+CTir\+Metadata}} (const Value $\ast$)
\item 
void \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_ae42ec334a7dfc96a5ead2d2845ca3b22}{validate\+TBHCTests}} (\mbox{\hyperlink{class_s_v_f_1_1_s_v_f_module}{SVFModule}} $\ast$svf\+Mod)
\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_a1a7b51e7d959795c00383721b013834d}\label{class_s_v_f_1_1_type_based_heap_cloning_a1a7b51e7d959795c00383721b013834d}} 
void \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_a1a7b51e7d959795c00383721b013834d}{dump\+Stats}} (void)
\begin{DoxyCompactList}\small\item\em Dump some statistics we tracked. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_s_v_f_1_1_d_c_h_graph}{DCHGraph}} $\ast$ \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_a465e67781977e83526df7e36d576e539}{dchg}} = nullptr
\end{DoxyCompactItemize}
\doxysubsection*{Static Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_a6363466e64eee4405806568d26206d2e}\label{class_s_v_f_1_1_type_based_heap_cloning_a6363466e64eee4405806568d26206d2e}} 
static const DIType $\ast$ \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_a6363466e64eee4405806568d26206d2e}{undef\+Type}} = nullptr
\begin{DoxyCompactList}\small\item\em The undefined type (•); void. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_a03ef2decb80ba07f4d98cae0a4497212}\label{class_s_v_f_1_1_type_based_heap_cloning_a03ef2decb80ba07f4d98cae0a4497212}} 
static const std\+::string \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_a03ef2decb80ba07f4d98cae0a4497212}{deref\+Fn\+Name}} = \char`\"{}deref\char`\"{}
\begin{DoxyCompactList}\small\item\em deref function for TBHC alias tests. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_ab1467e374b238b0f68d3fdd8f3ef6596}\label{class_s_v_f_1_1_type_based_heap_cloning_ab1467e374b238b0f68d3fdd8f3ef6596}} 
static const std\+::string \mbox{\hyperlink{class_s_v_f_1_1_type_based_heap_cloning_ab1467e374b238b0f68d3fdd8f3ef6596}{mangled\+Deref\+Fn\+Name}} = \char`\"{}\+\_\+\+Z5derefv\char`\"{}
\begin{DoxyCompactList}\small\item\em deref function (mangled) for TBHC alias tests. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_a1d48cd7ccbcd9bdf1470a5d9aca3298d}\label{class_s_v_f_1_1_type_based_heap_cloning_a1d48cd7ccbcd9bdf1470a5d9aca3298d}} 
\index{SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}!backPropagate@{backPropagate}}
\index{backPropagate@{backPropagate}!SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}}
\doxysubsubsection{\texorpdfstring{backPropagate()}{backPropagate()}}
{\footnotesize\ttfamily virtual void SVF\+::\+Type\+Based\+Heap\+Cloning\+::back\+Propagate (\begin{DoxyParamCaption}\item[{Node\+ID}]{clone }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

Required by user. Handles back-\/propagation of newly created clone after all metadata has been set. Used by clone\+Object. 

Implemented in \mbox{\hyperlink{class_s_v_f_1_1_flow_sensitive_t_b_h_c_a81ce8b1e98db245d3f4ccf189ca11e47}{SVF\+::\+Flow\+Sensitive\+TBHC}}.

\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_a11c3d1b7f10e4aad2525d428f5855db5}\label{class_s_v_f_1_1_type_based_heap_cloning_a11c3d1b7f10e4aad2525d428f5855db5}} 
\index{SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}!cloneObject@{cloneObject}}
\index{cloneObject@{cloneObject}!SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}}
\doxysubsubsection{\texorpdfstring{cloneObject()}{cloneObject()}}
{\footnotesize\ttfamily Node\+ID Type\+Based\+Heap\+Cloning\+::clone\+Object (\begin{DoxyParamCaption}\item[{Node\+ID}]{o,  }\item[{const DIType $\ast$}]{type,  }\item[{bool}]{reuse }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Returns a clone of o with type type. reuse indicates whether we are cloning as a result of reuse. \mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_aa175b5db473eb57c03b6f908791d1133}\label{class_s_v_f_1_1_type_based_heap_cloning_aa175b5db473eb57c03b6f908791d1133}} 
\index{SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}!getGepObjClones@{getGepObjClones}}
\index{getGepObjClones@{getGepObjClones}!SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}}
\doxysubsubsection{\texorpdfstring{getGepObjClones()}{getGepObjClones()}}
{\footnotesize\ttfamily const Node\+BS Type\+Based\+Heap\+Cloning\+::get\+Gep\+Obj\+Clones (\begin{DoxyParamCaption}\item[{Node\+ID}]{base,  }\item[{unsigned}]{offset }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Returns the GEP object node(s) of base for ls. This may include clones. If there are no GEP objects, then get\+Gep\+Obj\+Node is called on the \mbox{\hyperlink{class_s_v_f_1_1_p_a_g}{PAG}} (through base\textquotesingle{}s get\+Gep\+Obj\+Node) which will create one. \mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_afe416f9ec57923f34ef1db3890a3f9e1}\label{class_s_v_f_1_1_type_based_heap_cloning_afe416f9ec57923f34ef1db3890a3f9e1}} 
\index{SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}!getGepObjs@{getGepObjs}}
\index{getGepObjs@{getGepObjs}!SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}}
\doxysubsubsection{\texorpdfstring{getGepObjs()}{getGepObjs()}}
{\footnotesize\ttfamily const Node\+BS \& Type\+Based\+Heap\+Cloning\+::get\+Gep\+Objs (\begin{DoxyParamCaption}\item[{Node\+ID}]{base }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Returns all gep objects under an object. Not const; could create empty set. \mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_ad043ab95900849a5a894ca4bada4e032}\label{class_s_v_f_1_1_type_based_heap_cloning_ad043ab95900849a5a894ca4bada4e032}} 
\index{SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}!getGepObjsFromMemObj@{getGepObjsFromMemObj}}
\index{getGepObjsFromMemObj@{getGepObjsFromMemObj}!SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}}
\doxysubsubsection{\texorpdfstring{getGepObjsFromMemObj()}{getGepObjsFromMemObj()}}
{\footnotesize\ttfamily const Node\+BS \& Type\+Based\+Heap\+Cloning\+::get\+Gep\+Objs\+From\+Mem\+Obj (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_s_v_f_1_1_mem_obj}{Mem\+Obj}} $\ast$}]{mem\+Obj,  }\item[{unsigned}]{offset }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Returns all gep objects at a particular offset for memory object. Not const; could create empty set. \mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_ac4565775cced4444ba007e310c4a02d8}\label{class_s_v_f_1_1_type_based_heap_cloning_ac4565775cced4444ba007e310c4a02d8}} 
\index{SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}!getTypeFromCTirMetadata@{getTypeFromCTirMetadata}}
\index{getTypeFromCTirMetadata@{getTypeFromCTirMetadata}!SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}}
\doxysubsubsection{\texorpdfstring{getTypeFromCTirMetadata()}{getTypeFromCTirMetadata()}}
{\footnotesize\ttfamily const DIType $\ast$ Type\+Based\+Heap\+Cloning\+::get\+Type\+From\+CTir\+Metadata (\begin{DoxyParamCaption}\item[{const Value $\ast$}]{v }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Returns the ctir type attached to the value, nullptr if non-\/existant. Not static because it needs the DCHG to return the canonical type. Not static because we need dchg\textquotesingle{}s get\+Canonical\+Type. \mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_a34064efe336ada815b31050f683c7ce1}\label{class_s_v_f_1_1_type_based_heap_cloning_a34064efe336ada815b31050f683c7ce1}} 
\index{SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}!init@{init}}
\index{init@{init}!SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}}
\doxysubsubsection{\texorpdfstring{init()}{init()}}
{\footnotesize\ttfamily bool Type\+Based\+Heap\+Cloning\+::init (\begin{DoxyParamCaption}\item[{Node\+ID}]{loc,  }\item[{Node\+ID}]{p,  }\item[{const DIType $\ast$}]{tildet,  }\item[{bool}]{reuse,  }\item[{bool}]{gep = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Initialise the pointees of p at loc (which is type tildet $\ast$). reuse indicates whether reuse is a possibility for this initialisation. Returns whether p changed. \mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_add00f1c20a524c0be903af679bd6f638}\label{class_s_v_f_1_1_type_based_heap_cloning_add00f1c20a524c0be903af679bd6f638}} 
\index{SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}!isBase@{isBase}}
\index{isBase@{isBase}!SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}}
\doxysubsubsection{\texorpdfstring{isBase()}{isBase()}}
{\footnotesize\ttfamily bool Type\+Based\+Heap\+Cloning\+::is\+Base (\begin{DoxyParamCaption}\item[{const DIType $\ast$}]{a,  }\item[{const DIType $\ast$}]{b }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [protected]}}

Wrapper around \mbox{\hyperlink{class_s_v_f_1_1_d_c_h_graph_ab33f9af6ad22eb99dd0d9950fb0e50e6}{DCHGraph\+::is\+Base}}. Purpose is to keep our conditions clean by only passing two parameters like the rules. \mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_a59a9c7b8a7ec392ac609f10c8dac8d7f}\label{class_s_v_f_1_1_type_based_heap_cloning_a59a9c7b8a7ec392ac609f10c8dac8d7f}} 
\index{SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}!isBlkObjOrConstantObj@{isBlkObjOrConstantObj}}
\index{isBlkObjOrConstantObj@{isBlkObjOrConstantObj}!SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}}
\doxysubsubsection{\texorpdfstring{isBlkObjOrConstantObj()}{isBlkObjOrConstantObj()}}
{\footnotesize\ttfamily bool Type\+Based\+Heap\+Cloning\+::is\+Blk\+Obj\+Or\+Constant\+Obj (\begin{DoxyParamCaption}\item[{Node\+ID}]{o }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [protected]}}

Check if an object is a black hole obj or a constant object. Required since other implementations obviously do not account for clones. \mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_ae42ec334a7dfc96a5ead2d2845ca3b22}\label{class_s_v_f_1_1_type_based_heap_cloning_ae42ec334a7dfc96a5ead2d2845ca3b22}} 
\index{SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}!validateTBHCTests@{validateTBHCTests}}
\index{validateTBHCTests@{validateTBHCTests}!SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}}
\doxysubsubsection{\texorpdfstring{validateTBHCTests()}{validateTBHCTests()}}
{\footnotesize\ttfamily void Type\+Based\+Heap\+Cloning\+::validate\+TBHCTests (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_s_v_f_1_1_s_v_f_module}{SVFModule}} $\ast$}]{svf\+Mod }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Runs tests on MAYALIAS, NOALIAS, etc. built from TBHC\+\_\+\+MAYALIAS, TBHC\+\_\+\+NOALIAS, etc. macros. TBHC\+\_\+\+XALIAS macros produce\+: call XALIAS(...) \%1 = load ... ... n = load p store ... n-\/1, ...$\ast$ n !ctir !t1 call deref() n+1 = load ... ... n+n = load q store ... n+n-\/1, ...$\ast$ n+n !ctir !t2 call deref() We want to test the points-\/to sets of n and n+n after filtering with !t1 and !t2 respectively. 

\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{class_s_v_f_1_1_type_based_heap_cloning_a465e67781977e83526df7e36d576e539}\label{class_s_v_f_1_1_type_based_heap_cloning_a465e67781977e83526df7e36d576e539}} 
\index{SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}!dchg@{dchg}}
\index{dchg@{dchg}!SVF::TypeBasedHeapCloning@{SVF::TypeBasedHeapCloning}}
\doxysubsubsection{\texorpdfstring{dchg}{dchg}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_s_v_f_1_1_d_c_h_graph}{DCHGraph}}$\ast$ SVF\+::\+Type\+Based\+Heap\+Cloning\+::dchg = nullptr\hspace{0.3cm}{\ttfamily [protected]}}

Class hierarchy graph built from debug information. Required, CHG from IR is insufficient. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/\+Util/Type\+Based\+Heap\+Cloning.\+h\item 
lib/\+Util/Type\+Based\+Heap\+Cloning.\+cpp\end{DoxyCompactItemize}
