<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_class_s_v_f_1_1_symbol_table_info" xml:lang="en-US">
<title>SVF::SymbolTableInfo Class Reference</title>
<indexterm><primary>SVF::SymbolTableInfo</primary></indexterm>
<para>
<computeroutput>#include &lt;SymbolTableInfo.h&gt;</computeroutput>
</para>
<para>Inheritance diagram for SVF::SymbolTableInfo:    <informalfigure>
        <mediaobject>
            <imageobject>
                <imagedata width="50%" align="center" valign="middle" scalefit="0" fileref="class_s_v_f_1_1_symbol_table_info.png"></imagedata>
            </imageobject>
        </mediaobject>
    </informalfigure>
</para>
<simplesect>
    <title>Public Types    </title>
        <itemizedlist>
            <listitem><para>typedef OrderedMap&lt; const Value *, SymID &gt; <link linkend="_class_s_v_f_1_1_symbol_table_info_1a03a11c48d748990ddac1ac5866ecb48e">ValueToIDMapTy</link></para>

<para>various maps defined </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a0371b60485199175b011cf3a42b404aa"/>typedef OrderedMap&lt; SymID, <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> * &gt; <link linkend="_class_s_v_f_1_1_symbol_table_info_1a0371b60485199175b011cf3a42b404aa">IDToMemMapTy</link></para>

<para>sym id to memory object map </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1ada2191cb0e3798ba29aa442dca762290"/>typedef OrderedMap&lt; const Function *, SymID &gt; <link linkend="_class_s_v_f_1_1_symbol_table_info_1ada2191cb0e3798ba29aa442dca762290">FunToIDMapTy</link></para>

<para>function to sym id map </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a9353c7d2c0d6ae7dc495911b1ce24e06"/>typedef OrderedMap&lt; SymID, <link linkend="_namespace_s_v_f_1afe243912c982fde7d6beb4d046f9d42b">SYMTYPE</link> &gt; <link linkend="_class_s_v_f_1_1_symbol_table_info_1a9353c7d2c0d6ae7dc495911b1ce24e06">IDToSymTyMapTy</link></para>

<para>sym id to sym type map </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a9c9a9da876d41ab48e55f25efc266494"/>typedef OrderedMap&lt; const Type *, <link linkend="_class_s_v_f_1_1_st_info">StInfo</link> * &gt; <link linkend="_class_s_v_f_1_1_symbol_table_info_1a9c9a9da876d41ab48e55f25efc266494">TypeToFieldInfoMap</link></para>

<para>struct type to struct info map </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a1b5fe6a59527983c80906261190fc864"/>typedef Set&lt; CallSite &gt; <emphasis role="strong">CallSiteSet</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a52fa7c8a2c7064b415f373fdea0fdf69"/>typedef OrderedMap&lt; const Instruction *, CallSiteID &gt; <emphasis role="strong">CallSiteToIDMapTy</emphasis></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a5af399ccac6ec809ade8f778379027bb"/>typedef OrderedMap&lt; CallSiteID, const Instruction * &gt; <emphasis role="strong">IDToCallSiteMapTy</emphasis></para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Public Member Functions    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a4decfc9e7f5dc096d7bfa42d6965763d"/>void <link linkend="_class_s_v_f_1_1_symbol_table_info_1a4decfc9e7f5dc096d7bfa42d6965763d">setModelConstants</link> (bool _modelConstants)</para>

<para>Set / Get modelConstants. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a89e9c6da843e5eef25c51afd5d0937e5"/>bool <emphasis role="strong">getModelConstants</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1adc8e9a6cd5d27391beb1a88706e77a77"/>const CallSiteSet &amp; <link linkend="_class_s_v_f_1_1_symbol_table_info_1adc8e9a6cd5d27391beb1a88706e77a77">getCallSiteSet</link> () const</para>

<para>Get callsite set. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a40387a4893ae5caf58d6f786533d2f44"/><link linkend="_class_s_v_f_1_1_s_v_f_module">SVFModule</link> * <link linkend="_class_s_v_f_1_1_symbol_table_info_1a40387a4893ae5caf58d6f786533d2f44">getModule</link> ()</para>

<para>Module. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1af4239ff717303dee25f1f4ba60070f9e"/>u32_t <link linkend="_class_s_v_f_1_1_symbol_table_info_1af4239ff717303dee25f1f4ba60070f9e">getTypeSizeInBytes</link> (const Type *type)</para>

<para>Helper method to get the size of the type from target data layout. </para>
</listitem>
            <listitem><para>u32_t <link linkend="_class_s_v_f_1_1_symbol_table_info_1ada63ac47515daa4402914083058baec8">getTypeSizeInBytes</link> (const <link linkend="_namespace_s_v_f_1a2bf58575ac7d068e0f1a4cf953b9e6cb">StructType</link> *sty, u32_t field_index)</para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_symbol_table_info_1a74481bb26d77d8c8bca91efd3e23c08e">buildMemModel</link> (<link linkend="_class_s_v_f_1_1_s_v_f_module">SVFModule</link> *svfModule)</para>

<para>Start building memory model. </para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_symbol_table_info_1a7c422651a6cb299b0c94a2e4597fbe7c">collectSym</link> (const Value *val)</para>

<para>collect the syms </para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_symbol_table_info_1a135ec0f7574d4bcb4bc411ce5775f1f5">collectVal</link> (const Value *val)</para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_symbol_table_info_1af639e9bc59f5fb9a6bf1748ef0d07d5e">collectObj</link> (const Value *val)</para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_symbol_table_info_1ae4a7d078322e99af965193c82b357239">collectRet</link> (const Function *val)</para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_symbol_table_info_1ae1fe33260d2a2d21f2c33aaf1b58fee3">collectVararg</link> (const Function *val)</para>
</listitem>
            <listitem><para>bool <link linkend="_class_s_v_f_1_1_symbol_table_info_1a61bda1c1c52fb765d0027d8141d35c35">isConstantObjSym</link> (const Value *val)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a6d14f88dbbb3190fd37b4cf4e1b6e032"/>void <emphasis role="strong">createBlkOrConstantObj</emphasis> (SymID symId)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1aebf96274e1ad2a523981487839a3025e"/><link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> * <emphasis role="strong">getBlkObj</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a661eb9ff1839c3af942517808414202b"/><link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> * <emphasis role="strong">getConstantObj</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a1689fa03795200b501ae3887906e7e72"/>SymID <emphasis role="strong">blkPtrSymID</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1adaed6e68c2f53260ed4c4fc38b5c4721"/>SymID <emphasis role="strong">nullPtrSymID</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1ab582424fdb6d9674c1bd4466cdfbe497"/>SymID <emphasis role="strong">constantSymID</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a05ca2987d9f8716c24e489bec53502f4"/>SymID <emphasis role="strong">blackholeSymID</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a2fede86948eeb07aacfed2575ea329d1"/>const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> * <link linkend="_class_s_v_f_1_1_symbol_table_info_1a2fede86948eeb07aacfed2575ea329d1">createDummyObj</link> (SymID symId, const Type *type)</para>

<para>Can only be invoked by PAG::addDummyNode() when creaing <link linkend="_class_s_v_f_1_1_p_a_g">PAG</link> from file. </para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_symbol_table_info_1a4d616d922793e1d74bb4143f2d72bf10">handleGlobalCE</link> (const GlobalVariable *G)</para>

<para>Handle constant expression. </para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_symbol_table_info_1a005df6b86f4058114bf7a336e73e63df">handleGlobalInitializerCE</link> (const Constant *C, u32_t offset)</para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_symbol_table_info_1ad92842613ac245ad06875a012a5549ab">handleCE</link> (const Value *val)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1aec7ee137f828c9d61a11df7fc2241161"/>SymID <link linkend="_class_s_v_f_1_1_symbol_table_info_1aec7ee137f828c9d61a11df7fc2241161">getValSym</link> (const Value *val)</para>

<para>Get different kinds of syms. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1acbcd5035240fab0b809c3334a27159ae"/>bool <emphasis role="strong">hasValSym</emphasis> (const Value *val)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a1e2a66bd0cd01ff957ac50b22a2a8735"/>const Value * <link linkend="_class_s_v_f_1_1_symbol_table_info_1a1e2a66bd0cd01ff957ac50b22a2a8735">getGlobalRep</link> (const Value *val) const</para>

<para>find the unique defined global across multiple modules </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1afca5a68d1825326e3ec6302ce0afee66"/>SymID <emphasis role="strong">getObjSym</emphasis> (const Value *val) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a65f49178a948380c2d6105178509a906"/><link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> * <emphasis role="strong">getObj</emphasis> (SymID id) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1afc8b0b6aea972f34a0c099b75114b81e"/>SymID <emphasis role="strong">getRetSym</emphasis> (const Function *val) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1aec3fd21a11f760ca8684e390c6948f02"/>SymID <emphasis role="strong">getVarargSym</emphasis> (const Function *val) const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a7dda4943de0ed174a1d20fcdfde6c61c"/>Size_t <link linkend="_class_s_v_f_1_1_symbol_table_info_1a7dda4943de0ed174a1d20fcdfde6c61c">getTotalSymNum</link> () const</para>

<para>Statistics. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1abc7e567209010286a68634c700d76cca"/>u32_t <emphasis role="strong">getMaxStructSize</emphasis> () const</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a8f3cb8a1db34dd692ee04561f4edeebf"/><link linkend="_class_s_v_f_1_1_symbol_table_info_1a03a11c48d748990ddac1ac5866ecb48e">ValueToIDMapTy</link> &amp; <link linkend="_class_s_v_f_1_1_symbol_table_info_1a8f3cb8a1db34dd692ee04561f4edeebf">valSyms</link> ()</para>

<para>Get different kinds of syms maps. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a3f9612f32c651220386beb0514f8fcff"/><link linkend="_class_s_v_f_1_1_symbol_table_info_1a03a11c48d748990ddac1ac5866ecb48e">ValueToIDMapTy</link> &amp; <emphasis role="strong">objSyms</emphasis> ()</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a929a20dc8f2eb4d82e93938b8339d697"/><link linkend="_class_s_v_f_1_1_symbol_table_info_1a0371b60485199175b011cf3a42b404aa">IDToMemMapTy</link> &amp; <emphasis role="strong">idToObjMap</emphasis> ()</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1aafd4da7cef6387bb974abe20185b7b96"/><link linkend="_class_s_v_f_1_1_symbol_table_info_1ada2191cb0e3798ba29aa442dca762290">FunToIDMapTy</link> &amp; <emphasis role="strong">retSyms</emphasis> ()</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1ac449cd925dc05758c990179c0748e1d5"/><link linkend="_class_s_v_f_1_1_symbol_table_info_1ada2191cb0e3798ba29aa442dca762290">FunToIDMapTy</link> &amp; <emphasis role="strong">varargSyms</emphasis> ()</para>
</listitem>
            <listitem><para>TypeToFieldInfoMap::iterator <link linkend="_class_s_v_f_1_1_symbol_table_info_1a075a16b154514e282fcdd6f116a99e43">getStructInfoIter</link> (const Type *T)</para>

<para>Get struct info. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a90bca8ff906ea48fb5e3a69da463ccab"/><link linkend="_class_s_v_f_1_1_st_info">StInfo</link> * <link linkend="_class_s_v_f_1_1_symbol_table_info_1a90bca8ff906ea48fb5e3a69da463ccab">getStructInfo</link> (const Type *T)</para>

<para>Get a reference to StructInfo. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1abfad1554a3803ff131f2a8682f329354"/>const std::vector&lt; u32_t &gt; &amp; <link linkend="_class_s_v_f_1_1_symbol_table_info_1abfad1554a3803ff131f2a8682f329354">getFattenFieldIdxVec</link> (const Type *T)</para>

<para>Get a reference to the components of struct_info. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a5ff8a2f4afdb2cc26be0430f0310815b"/>const std::vector&lt; u32_t &gt; &amp; <emphasis role="strong">getFattenFieldOffsetVec</emphasis> (const Type *T)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1aed11023ad3dfe7c5f5c559e2f2b23e23"/>const std::vector&lt; <link linkend="_class_s_v_f_1_1_field_info">FieldInfo</link> &gt; &amp; <emphasis role="strong">getFlattenFieldInfoVec</emphasis> (const Type *T)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1aa203d9bb3c3e567ff49a2beb19631de2"/>const Type * <emphasis role="strong">getOrigSubTypeWithFldInx</emphasis> (const Type *baseType, u32_t field_idx)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a294a42ee0bc466104fb96a3136c34bd2"/>const Type * <emphasis role="strong">getOrigSubTypeWithByteOffset</emphasis> (const Type *baseType, u32_t byteOffset)</para>
</listitem>
            <listitem><para>virtual bool <link linkend="_class_s_v_f_1_1_symbol_table_info_1a86b742ca197b3505b3246d6bed2484db">computeGepOffset</link> (const User *V, <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp;ls)</para>

<para>Compute gep offset. </para>
</listitem>
            <listitem><para>const Type * <link linkend="_class_s_v_f_1_1_symbol_table_info_1a6243a2a002784b2ee1f0b1cfe9d3ea0f">getBaseTypeAndFlattenedFields</link> (const Value *V, std::vector&lt; <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &gt; &amp;fields)</para>

<para>Get the base type and max offset. </para>
</listitem>
            <listitem><para>u32_t <link linkend="_class_s_v_f_1_1_symbol_table_info_1ac26583169a343e7a9f751e4ec60f7b3d">getFields</link> (std::vector&lt; <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &gt; &amp;fields, const Type *T, u32_t msz)</para>

<para>Replace fields with flatten fields of T if the number of its fields is larger than msz. </para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_symbol_table_info_1aa99cab5480116905dd41ab0ad24b9462">collectTypeInfo</link> (const Type *T)</para>

<para>Collect type info. </para>
</listitem>
            <listitem><para>virtual <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> <link linkend="_class_s_v_f_1_1_symbol_table_info_1a480a7565dcb5d9a94f4b0ffb44b127ee">getModulusOffset</link> (const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> *obj, const <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp;ls)</para>

<para>Given an offset from a Gep Instruction, return it modulus offset by considering memory layout. </para>
</listitem>
            <listitem><para>void <link linkend="_class_s_v_f_1_1_symbol_table_info_1aa40ff2fcaba3d4297d63269b74738737">printFlattenFields</link> (const Type *type)</para>

<para>Debug method. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Static Public Member Functions    </title>
        <itemizedlist>
            <listitem><para>static <link linkend="_class_s_v_f_1_1_symbol_table_info">SymbolTableInfo</link> * <link linkend="_class_s_v_f_1_1_symbol_table_info_1a267169023fc4f8dd66b145f7231fec11">SymbolInfo</link> ()</para>

<para>Singleton design here to make sure we only have one instance during any analysis. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a9f8d99c761f3c7108d797b3702fcbfec"/>static void <emphasis role="strong">releaseSymbolInfo</emphasis> ()</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a5fad3e11fbba831ed0940fb715e7dc2d"/>static <link linkend="_namespace_s_v_f_1a03db82b8a7914367024723dba4d6ca3c">DataLayout</link> * <link linkend="_class_s_v_f_1_1_symbol_table_info_1a5fad3e11fbba831ed0940fb715e7dc2d">getDataLayout</link> (Module *mod)</para>

<para>Get target machine data layout. </para>
</listitem>
            <listitem><para>static bool <link linkend="_class_s_v_f_1_1_symbol_table_info_1a65a7e9d6d238a04291cb7d0aa15ece90">isNullPtrSym</link> (const Value *val)</para>

<para>special value </para>
</listitem>
            <listitem><para>static bool <link linkend="_class_s_v_f_1_1_symbol_table_info_1ab15112d3900f28525848cbe5fad37deb">isBlackholeSym</link> (const Value *val)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1acba43b6e9cdf07afaf3d30351aa8df7c"/>static bool <emphasis role="strong">isBlkPtr</emphasis> (NodeID id)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1ad095e4a569d399cadc03ce864f61c394"/>static bool <emphasis role="strong">isNullPtr</emphasis> (NodeID id)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1ad9cdb21e20182f3bc95f04bbb97712f3"/>static bool <emphasis role="strong">isBlkObj</emphasis> (NodeID id)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a704b917b1e1dbaf9cd758fa9acc1083b"/>static bool <emphasis role="strong">isConstantObj</emphasis> (NodeID id)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a2fc4bfb83b71a4c14e16168382cb8f5d"/>static bool <emphasis role="strong">isBlkObjOrConstantObj</emphasis> (NodeID id)</para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Static Public Attributes    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a71a7084f88f2b303381c89769b53573a"/>static SymID <link linkend="_class_s_v_f_1_1_symbol_table_info_1a71a7084f88f2b303381c89769b53573a">totalSymNum</link> = 0</para>

<para>Statistics. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Protected Member Functions    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1aff272bc1d00f2e57b7677d1826a31237"/><link linkend="_class_s_v_f_1_1_symbol_table_info_1aff272bc1d00f2e57b7677d1826a31237">SymbolTableInfo</link> (void)</para>

<para>Constructor. </para>
</listitem>
            <listitem><para>virtual void <link linkend="_class_s_v_f_1_1_symbol_table_info_1ab5297b79a02d8afce647a8b61bdab804">collectStructInfo</link> (const <link linkend="_namespace_s_v_f_1a2bf58575ac7d068e0f1a4cf953b9e6cb">StructType</link> *T)</para>

<para>Collect the struct info. </para>
</listitem>
            <listitem><para>virtual void <link linkend="_class_s_v_f_1_1_symbol_table_info_1aea1c4ec32c307feb5da455a41cc51b5e">collectArrayInfo</link> (const ArrayType *T)</para>

<para>Collect the array info. </para>
</listitem>
            <listitem><para>virtual void <link linkend="_class_s_v_f_1_1_symbol_table_info_1abf7567c655499d6744de8df689c11fad">collectSimpleTypeInfo</link> (const Type *T)</para>

<para>Collect simple type (non-aggregate) info. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Protected Attributes    </title>
        <itemizedlist>
            <listitem><para><link linkend="_class_s_v_f_1_1_symbol_table_info_1a9c9a9da876d41ab48e55f25efc266494">TypeToFieldInfoMap</link> <link linkend="_class_s_v_f_1_1_symbol_table_info_1ad8b9fa0a4e4b91efb80586e692bd0dcd">typeToFieldInfo</link></para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a4e33a01e203f07a8154af6ee65f5ba46"/>const Type * <link linkend="_class_s_v_f_1_1_symbol_table_info_1a4e33a01e203f07a8154af6ee65f5ba46">maxStruct</link></para>

<para>The struct type with the most fields. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1abb8550c9ef856e45cb7675c3796f9a35"/>u32_t <link linkend="_class_s_v_f_1_1_symbol_table_info_1abb8550c9ef856e45cb7675c3796f9a35">maxStSize</link></para>

<para>The number of fields in max_struct. </para>
</listitem>
        </itemizedlist>
</simplesect>
<section>
<title>Detailed Description</title>

<para>Symbol table of the memory model for analysis </para>
</section>
<section>
<title>Member Typedef Documentation</title>
<anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a03a11c48d748990ddac1ac5866ecb48e"/>    <section>
    <title>ValueToIDMapTy</title>
<indexterm><primary>ValueToIDMapTy</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>ValueToIDMapTy</secondary></indexterm>
<para><computeroutput>typedef OrderedMap&lt;const Value *, SymID&gt; <link linkend="_class_s_v_f_1_1_symbol_table_info_1a03a11c48d748990ddac1ac5866ecb48e">SVF::SymbolTableInfo::ValueToIDMapTy</link></computeroutput></para><para>

<para>various maps defined </para>
</para>

<para>llvm value to sym id map local (%) and global (@) identifiers are pointer types which have a value node id. </para>
</section>
</section>
<section>
<title>Member Function Documentation</title>
<anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a74481bb26d77d8c8bca91efd3e23c08e"/>    <section>
    <title>buildMemModel()</title>
<indexterm><primary>buildMemModel</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>buildMemModel</secondary></indexterm>
<para><computeroutput>void SymbolTableInfo::buildMemModel (<link linkend="_class_s_v_f_1_1_s_v_f_module">SVFModule</link> * svfModule)</computeroutput></para><para>

<para>Start building memory model. </para>
</para>

<para>This method identify which is value sym and which is object sym </para>

<para>if (SVFUtil::isa&lt;InlineAsm&gt;(Callee))</para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1aea1c4ec32c307feb5da455a41cc51b5e"/>    <section>
    <title>collectArrayInfo()</title>
<indexterm><primary>collectArrayInfo</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>collectArrayInfo</secondary></indexterm>
<para><computeroutput>void SymbolTableInfo::collectArrayInfo (const ArrayType * ty)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Collect the array info. </para>
</para>

<para>Fill in <link linkend="_class_s_v_f_1_1_st_info">StInfo</link> for an array type. </para>

<para>Array itself only has one field which is the inner most element</para>

<para>Array&apos;s flatten field infor is the same as its element&apos;s flatten infor.</para>

<para>append the additional number</para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_loc_sym_table_info_1a45b52cb8f8634ecf8bfb33f8e71bb82f">SVF::LocSymTableInfo</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1af639e9bc59f5fb9a6bf1748ef0d07d5e"/>    <section>
    <title>collectObj()</title>
<indexterm><primary>collectObj</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>collectObj</secondary></indexterm>
<para><computeroutput>void SymbolTableInfo::collectObj (const Value * val)</computeroutput></para>
<para>Get memory object sym, if not available create a new one </para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1ae4a7d078322e99af965193c82b357239"/>    <section>
    <title>collectRet()</title>
<indexterm><primary>collectRet</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>collectRet</secondary></indexterm>
<para><computeroutput>void SymbolTableInfo::collectRet (const Function * val)</computeroutput></para>
<para>Create unique return sym, if not available create a new one </para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1abf7567c655499d6744de8df689c11fad"/>    <section>
    <title>collectSimpleTypeInfo()</title>
<indexterm><primary>collectSimpleTypeInfo</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>collectSimpleTypeInfo</secondary></indexterm>
<para><computeroutput>void SymbolTableInfo::collectSimpleTypeInfo (const Type * ty)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Collect simple type (non-aggregate) info. </para>
</para>

<para>Collect simple type (non-aggregate) info </para>

<para>Only one field</para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1ab5297b79a02d8afce647a8b61bdab804"/>    <section>
    <title>collectStructInfo()</title>
<indexterm><primary>collectStructInfo</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>collectStructInfo</secondary></indexterm>
<para><computeroutput>void SymbolTableInfo::collectStructInfo (const <link linkend="_namespace_s_v_f_1a2bf58575ac7d068e0f1a4cf953b9e6cb">StructType</link> * sty)<computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Collect the struct info. </para>
</para>

<para>Fill in struct_info for T. Given a Struct type, we recursively extend and record its fields and types. </para>

<para>The struct info should not be processed before</para>

<para>FIXME: As the layout size is uint_64, here we assume offset with uint_32 (Size_t) is large enough and will not cause overflow</para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_loc_sym_table_info_1aedca0dbfb8641cefe68d547e3f4d62e8">SVF::LocSymTableInfo</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a7c422651a6cb299b0c94a2e4597fbe7c"/>    <section>
    <title>collectSym()</title>
<indexterm><primary>collectSym</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>collectSym</secondary></indexterm>
<para><computeroutput>void SymbolTableInfo::collectSym (const Value * val)</computeroutput></para><para>

<para>collect the syms </para>
</para>

<para>Collect symbols, including value and object syms </para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1aa99cab5480116905dd41ab0ad24b9462"/>    <section>
    <title>collectTypeInfo()</title>
<indexterm><primary>collectTypeInfo</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>collectTypeInfo</secondary></indexterm>
<para><computeroutput>void SymbolTableInfo::collectTypeInfo (const Type * ty)</computeroutput></para><para>

<para>Collect type info. </para>
</para>

<para>Collect a LLVM type info </para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a135ec0f7574d4bcb4bc411ce5775f1f5"/>    <section>
    <title>collectVal()</title>
<indexterm><primary>collectVal</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>collectVal</secondary></indexterm>
<para><computeroutput>void SymbolTableInfo::collectVal (const Value * val)</computeroutput></para>
<para>Get value sym, if not available create a new one </para>

<para>handle global constant expression here</para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1ae1fe33260d2a2d21f2c33aaf1b58fee3"/>    <section>
    <title>collectVararg()</title>
<indexterm><primary>collectVararg</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>collectVararg</secondary></indexterm>
<para><computeroutput>void SymbolTableInfo::collectVararg (const Function * val)</computeroutput></para>
<para>Create vararg sym, if not available create a new one </para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a86b742ca197b3505b3246d6bed2484db"/>    <section>
    <title>computeGepOffset()</title>
<indexterm><primary>computeGepOffset</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>computeGepOffset</secondary></indexterm>
<para><computeroutput>bool SymbolTableInfo::computeGepOffset (const User * V, <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp; ls)<computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Compute gep offset. </para>
</para>

<para>Compute gep offset </para>

<para>given a gep edge p = q + i,</para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_loc_sym_table_info_1a4aa6bf984692e879ad12806d35a6d2be">SVF::LocSymTableInfo</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a6243a2a002784b2ee1f0b1cfe9d3ea0f"/>    <section>
    <title>getBaseTypeAndFlattenedFields()</title>
<indexterm><primary>getBaseTypeAndFlattenedFields</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>getBaseTypeAndFlattenedFields</secondary></indexterm>
<para><computeroutput>const Type * SymbolTableInfo::getBaseTypeAndFlattenedFields (const Value * V, std::vector&lt; <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &gt; &amp; fields)</computeroutput></para><para>

<para>Get the base type and max offset. </para>
</para>

<para>Find the base type and the max possible offset for an object pointed to by (V). </para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1ac26583169a343e7a9f751e4ec60f7b3d"/>    <section>
    <title>getFields()</title>
<indexterm><primary>getFields</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>getFields</secondary></indexterm>
<para><computeroutput>u32_t SymbolTableInfo::getFields (std::vector&lt; <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &gt; &amp; fields, const Type * T, u32_t msz)</computeroutput></para><para>

<para>Replace fields with flatten fields of T if the number of its fields is larger than msz. </para>
</para>

<para>Replace fields with flatten fields of T if the number of its fields is larger than msz. </para>

<para>Replace fields with T&apos;s flatten fields.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a480a7565dcb5d9a94f4b0ffb44b127ee"/>    <section>
    <title>getModulusOffset()</title>
<indexterm><primary>getModulusOffset</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>getModulusOffset</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> SymbolTableInfo::getModulusOffset (const <link linkend="_class_s_v_f_1_1_mem_obj">MemObj</link> * obj, const <link linkend="_class_s_v_f_1_1_location_set">LocationSet</link> &amp; ls)<computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Given an offset from a Gep Instruction, return it modulus offset by considering memory layout. </para>
</para>

<para>Get modulus offset given the type information </para>

<para>if the offset is negative, it&apos;s possible that we&apos;re looking for an obj node out of range of current struct. Make the offset positive so we can still get a node within current struct to represent this obj.</para>
<para>
Reimplemented in <link linkend="_class_s_v_f_1_1_loc_sym_table_info_1a81763320f531da09014b4f5019dc8144">SVF::LocSymTableInfo</link>.</para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a075a16b154514e282fcdd6f116a99e43"/>    <section>
    <title>getStructInfoIter()</title>
<indexterm><primary>getStructInfoIter</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>getStructInfoIter</secondary></indexterm>
<para><computeroutput>TypeToFieldInfoMap::iterator SVF::SymbolTableInfo::getStructInfoIter (const Type * T)<computeroutput>[inline]</computeroutput></computeroutput></para><para>

<para>Get struct info. </para>
</para>

<para>Get an iterator for StructInfo, designed as internal methods </para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1ada63ac47515daa4402914083058baec8"/>    <section>
    <title>getTypeSizeInBytes()</title>
<indexterm><primary>getTypeSizeInBytes</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>getTypeSizeInBytes</secondary></indexterm>
<para><computeroutput>u32_t SymbolTableInfo::getTypeSizeInBytes (const <link linkend="_namespace_s_v_f_1a2bf58575ac7d068e0f1a4cf953b9e6cb">StructType</link> * sty, u32_t field_index)</computeroutput></para>
<para>if this struct type does not have any element, i.e., opaque</para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1ad92842613ac245ad06875a012a5549ab"/>    <section>
    <title>handleCE()</title>
<indexterm><primary>handleCE</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>handleCE</secondary></indexterm>
<para><computeroutput>void SymbolTableInfo::handleCE (const Value * val)</computeroutput></para>
<para>Handle constant expression </para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a4d616d922793e1d74bb4143f2d72bf10"/>    <section>
    <title>handleGlobalCE()</title>
<indexterm><primary>handleGlobalCE</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>handleGlobalCE</secondary></indexterm>
<para><computeroutput>void SymbolTableInfo::handleGlobalCE (const GlobalVariable * G)</computeroutput></para><para>

<para>Handle constant expression. </para>
</para>

<para>Handle global constant expression </para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a005df6b86f4058114bf7a336e73e63df"/>    <section>
    <title>handleGlobalInitializerCE()</title>
<indexterm><primary>handleGlobalInitializerCE</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>handleGlobalInitializerCE</secondary></indexterm>
<para><computeroutput>void SymbolTableInfo::handleGlobalInitializerCE (const Constant * C, u32_t offset)</computeroutput></para>
<para>Handle global variable initialization </para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1ab15112d3900f28525848cbe5fad37deb"/>    <section>
    <title>isBlackholeSym()</title>
<indexterm><primary>isBlackholeSym</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>isBlackholeSym</secondary></indexterm>
<para><computeroutput>bool SymbolTableInfo::isBlackholeSym (const Value * val)<computeroutput>[static]</computeroutput></computeroutput></para>
<para>Check whether this value is a black hole </para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a61bda1c1c52fb765d0027d8141d35c35"/>    <section>
    <title>isConstantObjSym()</title>
<indexterm><primary>isConstantObjSym</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>isConstantObjSym</secondary></indexterm>
<para><computeroutput>bool SymbolTableInfo::isConstantObjSym (const Value * val)</computeroutput></para>
<para>Check whether this value points-to a constant object </para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a65a7e9d6d238a04291cb7d0aa15ece90"/>    <section>
    <title>isNullPtrSym()</title>
<indexterm><primary>isNullPtrSym</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>isNullPtrSym</secondary></indexterm>
<para><computeroutput>bool SymbolTableInfo::isNullPtrSym (const Value * val)<computeroutput>[static]</computeroutput></computeroutput></para><para>

<para>special value </para>
</para>

<para>Check whether this value is null pointer </para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1aa40ff2fcaba3d4297d63269b74738737"/>    <section>
    <title>printFlattenFields()</title>
<indexterm><primary>printFlattenFields</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>printFlattenFields</secondary></indexterm>
<para><computeroutput>void SymbolTableInfo::printFlattenFields (const Type * type)</computeroutput></para><para>

<para>Debug method. </para>
</para>

<para>All rest types are scalar type?</para>
    </section><anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1a267169023fc4f8dd66b145f7231fec11"/>    <section>
    <title>SymbolInfo()</title>
<indexterm><primary>SymbolInfo</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>SymbolInfo</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_symbol_table_info">SymbolTableInfo</link> * SymbolTableInfo::SymbolInfo ( )<computeroutput>[static]</computeroutput></computeroutput></para><para>

<para>Singleton design here to make sure we only have one instance during any analysis. </para>
</para>

<para>Get the symbol table instance </para>
</section>
</section>
<section>
<title>Member Data Documentation</title>
<anchor xml:id="_class_s_v_f_1_1_symbol_table_info_1ad8b9fa0a4e4b91efb80586e692bd0dcd"/>    <section>
    <title>typeToFieldInfo</title>
<indexterm><primary>typeToFieldInfo</primary><secondary>SVF::SymbolTableInfo</secondary></indexterm>
<indexterm><primary>SVF::SymbolTableInfo</primary><secondary>typeToFieldInfo</secondary></indexterm>
<para><computeroutput><link linkend="_class_s_v_f_1_1_symbol_table_info_1a9c9a9da876d41ab48e55f25efc266494">TypeToFieldInfoMap</link> SVF::SymbolTableInfo::typeToFieldInfo<computeroutput>[protected]</computeroutput></computeroutput></para>
<para>Every type T is mapped to <link linkend="_class_s_v_f_1_1_st_info">StInfo</link> which contains size (fsize) , offset(foffset) fsize[i] is the number of fields in the largest such struct, else fsize[i] = 1. fsize[0] is always the size of the expanded struct. </para>
</section>
<para>
The documentation for this class was generated from the following files:</para>
include/SVF-FE/SymbolTableInfo.hlib/SVF-FE/SymbolTableInfo.cpp</section>
</section>
