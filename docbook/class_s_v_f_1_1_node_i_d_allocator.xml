<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_class_s_v_f_1_1_node_i_d_allocator" xml:lang="en-US">
<title>SVF::NodeIDAllocator Class Reference</title>
<indexterm><primary>SVF::NodeIDAllocator</primary></indexterm>
<para>
<computeroutput>#include &lt;NodeIDAllocator.h&gt;</computeroutput>
</para>
<simplesect>
    <title>Public Types    </title>
        <itemizedlist>
            <listitem><para>enum <link linkend="_class_s_v_f_1_1_node_i_d_allocator_1a8cf553cd07768aad3f3b91bf3d7c6228">Strategy</link> { <link linkend="_class_s_v_f_1_1_node_i_d_allocator_1a8cf553cd07768aad3f3b91bf3d7c6228a2c3d4f4bad7343cdd57c8bd0dbecd1e3">NONE</link>
, <link linkend="_class_s_v_f_1_1_node_i_d_allocator_1a8cf553cd07768aad3f3b91bf3d7c6228a9df17b1222681bba5e649895deb726f0">DENSE</link>
, <link linkend="_class_s_v_f_1_1_node_i_d_allocator_1a8cf553cd07768aad3f3b91bf3d7c6228a06987883653f3b0961962f2cdda3747f">DEBUG</link>
 }</para>

<para>Allocation strategy to use. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Public Member Functions    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_node_i_d_allocator_1a6ce6b40b8291c6378dda07d943d66e53"/>NodeID <link linkend="_class_s_v_f_1_1_node_i_d_allocator_1a6ce6b40b8291c6378dda07d943d66e53">allocateObjectId</link> (void)</para>

<para>Allocate an object ID as determined by the strategy. </para>
</listitem>
            <listitem><para>NodeID <link linkend="_class_s_v_f_1_1_node_i_d_allocator_1abaff066537f06c4891c199ebfc9624e3">allocateGepObjectId</link> (NodeID base, u32_t offset, u32_t maxFieldLimit)</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_node_i_d_allocator_1a26b5e09e10448694435f74a8b622a7e8"/>NodeID <link linkend="_class_s_v_f_1_1_node_i_d_allocator_1a26b5e09e10448694435f74a8b622a7e8">allocateValueId</link> (void)</para>

<para>Allocate a value ID as determined by the strategy. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_node_i_d_allocator_1ae42c5bb7db4d2142adc2e7e904eb36c7"/>void <link linkend="_class_s_v_f_1_1_node_i_d_allocator_1ae42c5bb7db4d2142adc2e7e904eb36c7">endSymbolAllocation</link> (void)</para>

<para>Notify the allocator that all symbols have had IDs allocated. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Static Public Member Functions    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_node_i_d_allocator_1a2bd3ca30fc9669d9a0327544bdb4557b"/>static <link linkend="_class_s_v_f_1_1_node_i_d_allocator">NodeIDAllocator</link> * <link linkend="_class_s_v_f_1_1_node_i_d_allocator_1a2bd3ca30fc9669d9a0327544bdb4557b">get</link> (void)</para>

<para>Return (singleton) allocator. </para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_node_i_d_allocator_1af7952ef5667039c9be86a589419b35a8"/>static void <link linkend="_class_s_v_f_1_1_node_i_d_allocator_1af7952ef5667039c9be86a589419b35a8">unset</link> (void)</para>

<para>Deletes the (singleton) allocator. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Static Public Attributes    </title>
<simplesect><title></title>
        <itemizedlist>
            <listitem><para>static const std::string <link linkend="_class_s_v_f_1_1_node_i_d_allocator_1ac223b8eab03df7ccbbe0c37ac29f55ad">userStrategyDense</link> = &quot;dense&quot;</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_node_i_d_allocator_1a3147ca964f609da10f323d489669801c"/>static const std::string <emphasis role="strong">userStrategyDebug</emphasis> = &quot;debug&quot;</para>
</listitem>
        </itemizedlist>
</simplesect>
</simplesect>
<simplesect><title></title>
        <itemizedlist>
            <listitem><para>static const NodeID <link linkend="_class_s_v_f_1_1_node_i_d_allocator_1a79ee84d7efb8abbfcd80d31d966ce20b">blackHoleObjectId</link> = 0</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_node_i_d_allocator_1a6a300a5b455fe4b8bace2f1d66fb5f9d"/>static const NodeID <emphasis role="strong">constantObjectId</emphasis> = 1</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_node_i_d_allocator_1a535be344f97496d8086e2861ea6dc2ea"/>static const NodeID <emphasis role="strong">blackHolePointerId</emphasis> = 2</para>
</listitem>
            <listitem><para><anchor xml:id="_class_s_v_f_1_1_node_i_d_allocator_1a1e3a98be74d5dfd3b4c1b5f9c0941353"/>static const NodeID <emphasis role="strong">nullPointerId</emphasis> = 3</para>
</listitem>
        </itemizedlist>
</simplesect>
<section>
<title>Detailed Description</title>

<para>Allocates node IDs for objects and values, upon request, according to some strategy which can be user-defined. It is the job of <link linkend="_class_s_v_f_1_1_symbol_table_info">SymbolTableInfo</link> to tell the <link linkend="_class_s_v_f_1_1_node_i_d_allocator">NodeIDAllocator</link> when all symbols have been allocated through endSymbolAllocation. </para>
</section>
<section>
<title>Member Enumeration Documentation</title>
<anchor xml:id="_class_s_v_f_1_1_node_i_d_allocator_1a8cf553cd07768aad3f3b91bf3d7c6228"/>    <section>
    <title>Strategy</title>
<indexterm><primary>Strategy</primary><secondary>SVF::NodeIDAllocator</secondary></indexterm>
<indexterm><primary>SVF::NodeIDAllocator</primary><secondary>Strategy</secondary></indexterm>
<para><computeroutput>enum <link linkend="_class_s_v_f_1_1_node_i_d_allocator_1a8cf553cd07768aad3f3b91bf3d7c6228">SVF::NodeIDAllocator::Strategy</link></computeroutput></para><para>

<para>Allocation strategy to use. </para>
</para>
<informaltable frame="all">
<title>Enumerator</title>
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
      <colspec colname='c1'/>
      <colspec colname='c2'/>
<tbody>
<row><entry><indexterm><primary>NONE</primary><secondary>SVF::NodeIDAllocator</secondary></indexterm>
<indexterm><primary>SVF::NodeIDAllocator</primary><secondary>NONE</secondary></indexterm>
<anchor xml:id="_class_s_v_f_1_1_node_i_d_allocator_1a8cf553cd07768aad3f3b91bf3d7c6228a2c3d4f4bad7343cdd57c8bd0dbecd1e3"/>NONE</entry><entry>
<para>Used to initialise from llvm::cl::opt. </para>
</entry></row><row><entry><indexterm><primary>DENSE</primary><secondary>SVF::NodeIDAllocator</secondary></indexterm>
<indexterm><primary>SVF::NodeIDAllocator</primary><secondary>DENSE</secondary></indexterm>
<anchor xml:id="_class_s_v_f_1_1_node_i_d_allocator_1a8cf553cd07768aad3f3b91bf3d7c6228a9df17b1222681bba5e649895deb726f0"/>DENSE</entry><entry>
<para>Allocate objects contiguously, separate from values, and vice versa. If [****...*****] is the space of unsigned integers, we allocate as, [ssssooooooo...vvvvvvv] (o = object, v = value, s = special). </para>
</entry></row><row><entry><indexterm><primary>DEBUG</primary><secondary>SVF::NodeIDAllocator</secondary></indexterm>
<indexterm><primary>SVF::NodeIDAllocator</primary><secondary>DEBUG</secondary></indexterm>
<anchor xml:id="_class_s_v_f_1_1_node_i_d_allocator_1a8cf553cd07768aad3f3b91bf3d7c6228a06987883653f3b0961962f2cdda3747f"/>DEBUG</entry><entry>
<para>Allocate values and objects as they come in with a single counter. GEP objects are allocated as an offset from their base (see implementation of allocateGepObjectId). The purpose of this allocation strategy is human readability. </para>
</entry></row>    </tbody>
    </tgroup>
</informaltable>
</section>
</section>
<section>
<title>Member Function Documentation</title>
<anchor xml:id="_class_s_v_f_1_1_node_i_d_allocator_1abaff066537f06c4891c199ebfc9624e3"/>    <section>
    <title>allocateGepObjectId()</title>
<indexterm><primary>allocateGepObjectId</primary><secondary>SVF::NodeIDAllocator</secondary></indexterm>
<indexterm><primary>SVF::NodeIDAllocator</primary><secondary>allocateGepObjectId</secondary></indexterm>
<para><computeroutput>NodeID SVF::NodeIDAllocator::allocateGepObjectId (NodeID base, u32_t offset, u32_t maxFieldLimit)</computeroutput></para>
<para>Allocate a GEP object ID as determined by the strategy. allocateObjectId is still fine for GEP objects, but for some strategies (DEBUG, namely), GEP objects can be allocated differently (more readable, for DEBUG). Regardless, numObjects is shared; there is no special numGepObjects. </para>
</section>
</section>
<section>
<title>Member Data Documentation</title>
<anchor xml:id="_class_s_v_f_1_1_node_i_d_allocator_1a79ee84d7efb8abbfcd80d31d966ce20b"/>    <section>
    <title>blackHoleObjectId</title>
<indexterm><primary>blackHoleObjectId</primary><secondary>SVF::NodeIDAllocator</secondary></indexterm>
<indexterm><primary>SVF::NodeIDAllocator</primary><secondary>blackHoleObjectId</secondary></indexterm>
<para><computeroutput>const NodeID SVF::NodeIDAllocator::blackHoleObjectId = 0<computeroutput>[static]</computeroutput></computeroutput></para>
<para>These nodes, and any nodes before them are assumed allocated as objects and values. For simplicity&apos;s sake, numObjects and numVals thus start at 4 (and the other counters are set appropriately). </para>
    </section><anchor xml:id="_class_s_v_f_1_1_node_i_d_allocator_1ac223b8eab03df7ccbbe0c37ac29f55ad"/>    <section>
    <title>userStrategyDense</title>
<indexterm><primary>userStrategyDense</primary><secondary>SVF::NodeIDAllocator</secondary></indexterm>
<indexterm><primary>SVF::NodeIDAllocator</primary><secondary>userStrategyDense</secondary></indexterm>
<para><computeroutput>const std::string SVF::NodeIDAllocator::userStrategyDense = &quot;dense&quot;<computeroutput>[static]</computeroutput></computeroutput></para>
<para>Option strings as written by the user. </para>
</section>
<para>
The documentation for this class was generated from the following files:</para>
include/Util/NodeIDAllocator.hlib/Util/NodeIDAllocator.cpp</section>
</section>
