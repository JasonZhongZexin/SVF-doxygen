{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment SVF }SVF}
{\comment Generated by doxygen1.9.1.}
{\creatim \yr2021\mo2\dy14\hr17\min33\sec29}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt SVF}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Sun Feb 14 2021 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
News{\tc \v News}\par \pard\plain 
{\bkmkstart AAAAAAAIFV}
{\bkmkend AAAAAAAIFV}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b {\f2 VSFS} published in our {\f2 CGO paper} is now available in {\b SVF} } \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b {\f2 TypeClone} published in our {\f2 ECOOP paper} is now available in {\b SVF} } \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b {\b SVF} now uses a single script for its build. Just type {\f2 {\f2 source ./build.sh} } in your terminal, that's it!} \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b {\b SVF} now supports LLVM-10.0.0! } \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b We thank {\f2 bsauce} for writing a user manual of {\b SVF} ({\f2 link1} and {\f2 link2}) in Chinese } \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b {\b SVF} now supports LLVM-9.0.0 (Thank {\f2 Byoungyoung Lee} for his help!). } \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b {\b SVF} now supports a set of {\f2 field-sensitive pointer analyses}. } \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b {\f2 Use SVF as an external lib} for your own project (Contributed by {\f2 Hongxu Chen}). } \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b {\b SVF} now supports LLVM-7.0.0. } \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b {\b SVF} now supports Docker. {\f2 Try SVF in Docker}! } \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b {\b SVF} now supports {\f2 LLVM-6.0.0} (Contributed by {\f2 Jack Anthony}). } \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b {\b SVF} now supports {\f2 LLVM-4.0.0} (Contributed by Jared Carlson. Thank {\f2 Jared} and {\f2 Will} for their in-depth {\f2 discussions} about updating SVF!) } \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b {\b SVF} now supports analysis for C++ programs.}  \par
}
\par
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Documentation
\par}
{\tc\tcl2 \v Documentation}
If you want to build the documentation yourself go into doc and invoke doxygen: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid cd doc && doxygen doxygen.config\par
}
\par
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
We are looking for self-motivated PhD students and we welcome industry collaboration/sponsorship to improve SVF (Please contact yulei.sui@uts.edu.au if you are interested)
\par}
{\tc\tcl4 \v We are looking for self-motivated PhD students and we welcome industry collaboration/sponsorship to improve SVF (Please contact yulei.sui@uts.edu.au if you are interested)}
\par
 \par
 \par
 {\b SVF} is a source code analysis tool that enables interprocedural dependence analysis for LLVM-based languages. {\b SVF} is able to perform pointer alias analysis, memory SSA form construction, value-flow tracking for program variables and memory error checking. \par
 \par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{About {\b SVF}   \cell }{Setup Guide   \cell }{User Guide   \cell }{Developer Guide    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{   \cell }{   \cell }{   \cell }{    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Introducing {\b SVF} \'96 {\f2 what it does} and {\f2 how we design it}   \cell }{A step by step {\f2 setup guide} to build {\b SVF}   \cell }{Command-line options to {\f2 run SVF}, get {\f2 analysis outputs}, and test {\b SVF} with {\f2 an example} or {\f2 PTABen}   \cell }{Detailed {\f2 technical documentation} and how to {\f2 write your own analyses} in {\b SVF} or {\f2 use SVF as a lib} for your tool   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
\par
 \par
 \par
We release {\b SVF} source code in the hope of benefiting others. You are kindly asked to acknowledge usage of the tool by citing some of our publications listed {\f2 http://svf-tools.github.io/SVF}, especially the following two: \par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid @inproceedings\{sui2016svf,\par
  title=\{SVF: interprocedural static value-flow analysis in LLVM\},\par
  author=\{Sui, Yulei and Xue, Jingling\},\par
  booktitle=\{Proceedings of the 25th international conference on compiler construction\},\par
  pages=\{265--266\},\par
  year=\{2016\},\par
  organization=\{ACM\}\par
\}\par
}
\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid @article\{sui2014detecting,\par
  title=\{Detecting memory leaks statically with full-sparse value-flow analysis\},\par
  author=\{Sui, Yulei and Ye, Ding and Xue, Jingling\},\par
  journal=\{IEEE Transactions on Software Engineering\},\par
  volume=\{40\},\par
  number=\{2\},\par
  pages=\{107--122\},\par
  year=\{2014\},\par
  publisher=\{IEEE\}\par
\}\par
}
 \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented namespaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b llvm} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For isBitcode })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::cppUtil::ctir} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIDO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
RaceResultValidator::AccessPair\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::Annotator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGSG \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::MTAAnnotator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFQW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SaberAnnotator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFZW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::BddCondManager\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGUM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::CallGraphBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGDY \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::ThreadCallGraphBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::SVFUtil::cast_convert_val< To, From, SimpleFrom >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::cast_convert_val< To, FromTy, FromTy >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::cast_retty< To, From >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::cast_retty_impl< To, From >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::cast_retty_impl< To, const From * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::cast_retty_impl< To, const From *const >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::cast_retty_impl< To, const From >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::cast_retty_impl< To, From * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::cast_retty_impl< To, std::unique_ptr< From > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::cast_retty_wrap< To, From, SimpleFrom >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::cast_retty_wrap< To, FromTy, FromTy >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::CFLSolver< GraphType, DPIm >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGTN \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::SrcSnkDDA\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFXO \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::LeakChecker\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFWU \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::DoubleFreeChecker\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFWF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FileChecker\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFWL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
}\par
SVF::CommonCHGraph\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGGQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CHGraph\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGFD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::DCHGraph\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGJB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::CondPointsToSet< Cond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADZU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::CondStdSet< Element >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADYV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::CondVar< Cond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADYJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::ContextCond\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGYZ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::VFPathCond\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::CSC\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHTB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
cuddPathPair\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::CxtProc\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGWZ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CxtThreadProc\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGXN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::CxtStmt\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGVH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CxtThreadStmt\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGVV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::CxtThread\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGWF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::DDAClient\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBT \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::AliasDDAClient\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FunptrDDAClient\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::DDAVFSolver< CVar, CPtSet, DPIm >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::DDAVFSolver< CxtVar, CxtPtSet, CxtLocDPItem >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::ContextDDA\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::DDAVFSolver< NodeID, PointsTo, LocDPItem >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::FlowDDA\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
DdCache\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DdChildren\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DdGen\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DdHashItem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DdHashTable\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DdHook\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DdLevelQueue\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DdLocalCache\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DdLocalCacheItem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DdManager\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DdNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DdQueueItem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DdSubtable\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DefaultDOTGraphTraits
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
llvm::DOTGraphTraits< CHGraph * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::DOTGraphTraits< PAG * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPO \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
llvm::DOTGraphTraits< ConstraintGraph * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::DOTGraphTraits< ICFG * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::DOTGraphTraits< OfflineConsG * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::DOTGraphTraits< SVFG * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::DOTGraphTraits< VFG * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
llvm::DOTGraphTraits< PTACallGraph * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::DOTGraphTraits< TCT * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::cppUtil::DemangledName\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIDL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DominanceFrontier
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::MemSSADF\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFJN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
llvm::DominanceFrontierBase
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::IteratedDominanceFrontier\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGHV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::DPItem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGXX \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CxtDPItem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHCB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::StmtDPItem< LocCond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGYM \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CxtStmtDPItem< LocCond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGZX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::PathStmtDPItem< LocCond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHBL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
EpDoubleStruct\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
EpTypeUnion\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::GenericEdge< NodeTy >::equalGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::MemRegion::equalMemRegion\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEZX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::MemRegion::equalPointsTo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEZZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::ExtAPI\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHCN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::ExternalPAG\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FieldInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEBK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FIFOWorkList< Data >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHMB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FIFOWorkList< const MSSAPHISVFGNode * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHMB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FIFOWorkList< CxtLockProc >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHMB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FIFOWorkList< CxtStmt >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHMB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FIFOWorkList< CxtThreadProc >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHMB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FIFOWorkList< CxtThreadStmt >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHMB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FIFOWorkList< DPItem >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHMB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FIFOWorkList< NodeID >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHMB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FILOWorkList< Data >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHMH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::ForkJoinAnalysis\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFPK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::GenericEdge< NodeTy >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQL \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CHEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGEG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::ConstraintEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLL \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::AddrCGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::CopyCGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::GepCGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMM \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::NormalGepCGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::VariantGepCGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::LoadCGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::StoreCGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::ICFGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUV \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CallCFGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::IntraCFGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::RetCFGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::PAGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHK \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::AddrPE\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::BinaryOPPE\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::CallPE\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKT \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::TDForkPE\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::CmpPE\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::CopyPE\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::GepPE\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJX \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::NormalGepPE\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::VariantGepPE\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::LoadPE\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::RetPE\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLB \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::TDJoinPE\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::StorePE\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::UnaryOPPE\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::PTACallGraphEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQT \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::HareParForEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::ThreadForkEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADES \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::ThreadJoinEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::TCTEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFTM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::VFGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADLY \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::DirectSVFGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADMS \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CallDirSVFGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADNF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::IntraDirSVFGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADMY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::RetDirSVFGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADNN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::IndirectSVFGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACXV \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CallIndSVFGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::IntraIndSVFGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::RetIndSVFGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::ThreadMHPIndSVFGEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
}\par
SVF::GenericEdge< DCHNode >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQL \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::DCHEdge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGHZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::GenericGraph< NodeTy, EdgeTy >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSM \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CHGraph\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGFD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::ICFG\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTK \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::ICFGPrinter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGKL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::PTACallGraph\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSA \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::ThreadCallGraph\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::TCT\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFUC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::VFG\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADHK \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::SVFG\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTZ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::SVFGOPT\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADCH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
}\par
SVF::GenericGraph< ConstraintNode, ConstraintEdge >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSM \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::ConstraintGraph\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIU \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::OfflineConsG\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
SVF::GenericGraph< DCHNode, DCHEdge >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSM \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::DCHGraph\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGJB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::GenericGraph< PAGNode, PAGEdge >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSM \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::PAG\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::GenericNode< NodeTy, EdgeTy >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRB \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CHNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGEL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::ICFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWG \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::GlobalBlockNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::InterBlockNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXO \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CallBlockNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FunEntryBlockNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FunExitBlockNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::RetBlockNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::IntraBlockNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::PAGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLV \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::ObjPN\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::DummyObjPN\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPR \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CloneDummyObjPN\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::FIObjPN\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOO \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CloneFIObjPN\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::GepObjPN\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOC \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CloneGepObjPN\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
SVF::RetPN\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::ValPN\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNA \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::DummyValPN\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::GepValPN\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::VarArgPN\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::PTACallGraphNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACRR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::TCTNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFTU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::VFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADNV \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::ArgumentVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADSX \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::ActualParmVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADTF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::ActualRetVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADUA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FormalParmVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADTO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FormalRetVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADUK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::BinaryOPVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADQF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::CmpVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADPQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::MRSVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZK \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::ActualINSVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::ActualOUTSVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FormalINSVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FormalOUTSVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::MSSAPHISVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADAW \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::InterMSSAPHISVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::IntraMSSAPHISVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
SVF::NullPtrVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADVI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::PHIVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADRQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::InterPHIVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADUW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::IntraPHIVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADSG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::StmtVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADOI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::AddrVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADSQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::CopyVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADPJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::GepVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADRJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::LoadVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADOV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::StoreVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADPC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::UnaryOPVFGNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADQU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
SVF::GenericNode< ConstraintNode, ConstraintEdge >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRB \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::ConstraintNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::GenericNode< DCHNode, DCHEdge >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRB \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::DCHNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGIF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::SCCDetection< GraphType >::GNodeSCCInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHFY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphPrinter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
GraphTraits
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
llvm::GraphTraits< Inverse< SVF::CHNode * > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< Inverse< SVF::ConstraintNode * > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< Inverse< SVF::DCHNode * > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< Inverse< SVF::ICFGNode * > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< Inverse< SVF::PAGNode * > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< Inverse< SVF::PTACallGraphNode * > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< Inverse< SVF::TCTNode * > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< Inverse< SVF::VFGNode * > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::CHGraph * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::CHNode * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::ConstraintGraph * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::ConstraintNode * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::DCHGraph * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::DCHNode * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::ICFG * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::ICFGNode * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::OfflineConsG * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::PAG * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::PAGNode * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAND \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::PTACallGraph * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::PTACallGraphNode * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::SVFG * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::TCT * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::TCTNode * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::VFG * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::VFGNode * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
llvm::GraphTraits< Inverse< SVF::GenericNode< NodeTy, EdgeTy > * > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::GraphTraits< SVF::GenericNode< NodeTy, EdgeTy > * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALL \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
llvm::GraphTraits< SVF::GenericGraph< NodeTy, EdgeTy > * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
hack\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::hash< const SVF::CondVar< Cond > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::hash< const SVF::ContextCond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::hash< llvm::SparseBitVector<> >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::hash< std::pair< T, U > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::hash< SVF::CallSite >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::hash< SVF::CondVar< Cond > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::hash< SVF::ContextCond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::hash< SVF::CxtDPItem >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::hash< SVF::CxtStmtDPItem< LocCond > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::hash< SVF::LocationSet >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAART \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::hash< SVF::SmallVector< T, N > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::hash< SVF::StmtDPItem< LocCond > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::ICFGBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGKQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
IeeeDoubleStruct\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
IeeeNanStruct\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
llvm::InstVisitor
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::PAGBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGLZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::SVFUtil::is_simple_type< X >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::isa_impl< To, From, Enabler >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::isa_impl< To, From, typename std::enable_if< std::is_base_of< To, From >::value >::type >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::isa_impl_cl< To, From >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::isa_impl_cl< To, const From * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::isa_impl_cl< To, const From *const >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::isa_impl_cl< To, const From >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::isa_impl_cl< To, const std::unique_ptr< From > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::isa_impl_cl< To, From * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::isa_impl_cl< To, From *const >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::isa_impl_wrap< To, From, SimpleFrom >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIET \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::isa_impl_wrap< To, FromTy, FromTy >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::iterator
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
llvm::generic_bridge_gep_type_iterator< ItTy >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::List< Data >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHLW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::LLVMModuleSet\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGKW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::LocationSet\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEBT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::LockAnalysis\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFLL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::MemObj\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::MemRegion\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEZO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::MemSSA\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFCT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::MHP\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFOE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ModulePass
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::BreakConstantGEPs\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGDM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::DDAPass\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::MTA\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFQE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::MergeFunctionRets\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGDR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::WPAPass\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Move\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::MRGenerator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFAB \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::DistinctMRG\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEYR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::IntraDisjointMRG\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEYZ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::InterDisjointMRG\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEZM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
SVF::MRVer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::MSSADEF\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::MSSACHI< Cond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHU \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CallCHI< Cond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFIL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::EntryCHI< Cond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::StoreCHI< Cond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::MSSAPHI< Cond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFJA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::MSSAMU< Cond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGA \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CallMU< Cond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::LoadMU< Cond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::RetMU< Cond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MTAResultValidator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MtrNode\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::NodeIDAllocator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHDB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::ObjTypeInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEDA \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::LocObjTypeInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGSD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::PAGBuilderFromFile\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEKW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::PathCondAllocator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHDS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::PCG\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFSI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::PointerAnalysis\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAELD \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::CondPTAImpl< ContextCond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAESQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::ContextDDA\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::BVDataPTAImpl\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQW \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::AndersenBase\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHMN \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::Andersen\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHNN \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::AndersenHCD\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHRM \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::AndersenHLCD\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHRZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::AndersenLCD\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHRB \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::AndersenHLCD\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHRZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::AndersenSCD\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHSE \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::AndersenSFR\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHSR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::AndersenWaveDiff\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHQH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::AndersenWaveDiffWithType\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHQR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
SVF::Steensgaard\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHXW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::TypeAnalysis\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHYN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::FlowDDA\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FlowSensitive\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHTL \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::FSMPTA\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFLE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FlowSensitiveTBHC\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHXG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::VersionedFlowSensitive\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHYU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
SVF::CondPTAImpl< Cond >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAESQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::ProgSlice\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFXS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::PTACFInfoBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::PTASCEV\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGGZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::PTAStat\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEG \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::AndersenStat\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAICG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::DDAStat\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::FlowSensitiveStat\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAICV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::ICFGStat\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::MTAStat\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFRX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::MemSSAStat\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADCS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFGStat\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::VersionedFlowSensitiveStat\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIDB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::PTAType\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEXD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::PTData< Key, Datum, Data >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADVQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::MutablePTData< VersionedKey, Datum, Data >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEHD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::VersionedPTData< NodeID, NodeID, PointsTo, VersionedVar >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADXS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::DFPTData< Key, Datum, Data >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADWS \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::MutableDFPTData< Key, Datum, Data >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEFH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::IncMutableDFPTData< Key, Datum, Data >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEJA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
SVF::DiffPTData< Key, Datum, Data >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADWG \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::MutableDiffPTData< Key, Datum, Data >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::MutablePTData< Key, Datum, Data >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEHD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::VersionedPTData< Key, Datum, Data, VersionedKey >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADXS \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::MutableVersionedPTData< Key, Datum, Data, VersionedKey >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEJV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
RaceResultValidator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::LockValidator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIDF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::MHPValidator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIDI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::SaberCheckerAPI\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SCCDetection< GraphType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHFK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::simplify_type< From >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIDT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFUtil::simplify_type< const From >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIDW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
st_generator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
st_table\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
st_table_entry\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::StInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAECP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFGBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFJP \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::MTASVFGBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SaberSVFGBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::SVFModule\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHGU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFValue\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHGI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::SVFBasicBlock\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGTJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFFunction\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGSZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFGlobal\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGTH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::SVFInstruction\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGTL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::SymbolTableInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGOV \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::LocSymTableInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGRZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::ThreadAPI\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHIH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::TypeBasedHeapCloning\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHKM \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::FlowSensitiveTBHC\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHXG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
SVF::TypeSet\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEXL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::TypeSystem\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEXY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::WPASolver< GraphType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHQQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::AndersenBase\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHMN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::WPAFSSolver< GraphType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHZK \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::FlowSensitive\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHTL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SVF::WPASCCSolver< GraphType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHZP \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SVF::WPAMinimumSolver< GraphType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b RaceResultValidator::AccessPair} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ActualINSVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ActualOUTSVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ActualParmVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADTF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ActualRetVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADUA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::AddrCGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::AddrPE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::AddrVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADSQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::AliasDDAClient} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::Andersen} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHNN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::AndersenBase} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHMN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::AndersenHCD} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHRM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::AndersenHLCD} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHRZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::AndersenLCD} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHRB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::AndersenSCD} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHSE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::AndersenSFR} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHSR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::AndersenStat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAICG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::AndersenWaveDiff} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHQH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::AndersenWaveDiffWithType} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHQR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::Annotator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGSG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ArgumentVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADSX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::BddCondManager} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGUM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::BinaryOPPE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::BinaryOPVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADQF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::BreakConstantGEPs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGDM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::BVDataPTAImpl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CallBlockNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CallCFGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CallCHI< Cond >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFIL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CallDirSVFGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADNF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CallGraphBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGDY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CallIndSVFGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CallMU< Cond >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CallPE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::cast_convert_val< To, From, SimpleFrom >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::cast_convert_val< To, FromTy, FromTy >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::cast_retty< To, From >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::cast_retty_impl< To, From >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::cast_retty_impl< To, const From * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::cast_retty_impl< To, const From *const >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::cast_retty_impl< To, const From >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::cast_retty_impl< To, From * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::cast_retty_impl< To, std::unique_ptr< From > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::cast_retty_wrap< To, From, SimpleFrom >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::cast_retty_wrap< To, FromTy, FromTy >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CFLSolver< GraphType, DPIm >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGTN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CHEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGEG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CHGraph} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGFD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CHNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGEL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CloneDummyObjPN} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CloneFIObjPN} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CloneGepObjPN} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CmpPE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CmpVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADPQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CommonCHGraph} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Common base for class hierarchy graph. Only implements what {\b PointerAnalysis} needs })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGGQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CondPointsToSet< Cond >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADZU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CondPTAImpl< Cond >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAESQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CondStdSet< Element >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADYV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CondVar< Cond >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADYJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ConstraintEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ConstraintGraph} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ConstraintNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ContextCond} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGYZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ContextDDA} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CopyCGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CopyPE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CopyVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADPJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CSC} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHTB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b cuddPathPair} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CxtDPItem} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHCB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CxtProc} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGWZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CxtStmt} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGVH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CxtStmtDPItem< LocCond >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGZX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CxtThread} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGWF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CxtThreadProc} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGXN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::CxtThreadStmt} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGVV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::DCHEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGHZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::DCHGraph} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dwarf based CHG })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGJB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::DCHNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGIF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::DDAClient} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::DDAPass} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::DDAStat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::DDAVFSolver< CVar, CPtSet, DPIm >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DdCache} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DdChildren} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DdGen} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DdHashItem} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DdHashTable} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DdHook} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DdLevelQueue} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DdLocalCache} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DdLocalCacheItem} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DdManager} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DdNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DdQueueItem} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DdSubtable} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::cppUtil::DemangledName} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIDL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::DFPTData< Key, Datum, Data >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADWS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::DiffPTData< Key, Datum, Data >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADWG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::DirectSVFGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADMS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::DistinctMRG} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEYR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::DOTGraphTraits< CHGraph * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::DOTGraphTraits< ConstraintGraph * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::DOTGraphTraits< ICFG * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::DOTGraphTraits< OfflineConsG * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::DOTGraphTraits< PAG * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::DOTGraphTraits< PTACallGraph * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::DOTGraphTraits< SVFG * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::DOTGraphTraits< TCT * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::DOTGraphTraits< VFG * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::DoubleFreeChecker} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFWF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::DPItem} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGXX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::DummyObjPN} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::DummyValPN} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::EntryCHI< Cond >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EpDoubleStruct} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EpTypeUnion} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::GenericEdge< NodeTy >::equalGEdge} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add the hash function for std::set (we also can overload operator< to implement this) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MemRegion::equalMemRegion} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEZX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MemRegion::equalPointsTo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEZZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ExtAPI} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHCN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ExternalPAG} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FieldInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEBK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FIFOWorkList< Data >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHMB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FileChecker} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFWL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FILOWorkList< Data >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHMH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FIObjPN} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FlowDDA} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FlowSensitive} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHTL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FlowSensitiveStat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAICV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FlowSensitiveTBHC} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHXG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ForkJoinAnalysis} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFPK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FormalINSVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FormalOUTSVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FormalParmVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADTO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FormalRetVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADUK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FSMPTA} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFLE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FunEntryBlockNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FunExitBlockNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::FunptrDDAClient} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::generic_bridge_gep_type_iterator< ItTy >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::GenericEdge< NodeTy >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::GenericGraph< NodeTy, EdgeTy >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::GenericNode< NodeTy, EdgeTy >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::GepCGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::GepObjPN} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::GepPE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::GepValPN} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::GepVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADRJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::GlobalBlockNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SCCDetection< GraphType >::GNodeSCCInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHFY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphPrinter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< Inverse< SVF::CHNode * > >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< Inverse< SVF::ConstraintNode * > >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for Value flow node, it is used for inverse traversal })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< Inverse< SVF::DCHNode * > >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< Inverse< SVF::GenericNode< NodeTy, EdgeTy > * > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< Inverse< SVF::ICFGNode * > >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< Inverse< SVF::PAGNode * > >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for PAG node, it is used for inverse traversal })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< Inverse< SVF::PTACallGraphNode * > >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< Inverse< SVF::TCTNode * > >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for Value flow node, it is used for inverse traversal })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< Inverse< SVF::VFGNode * > >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::CHGraph * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::CHNode * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::ConstraintGraph * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::ConstraintNode * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::DCHGraph * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::DCHNode * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::GenericGraph< NodeTy, EdgeTy > * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::GenericNode< NodeTy, EdgeTy > * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::ICFG * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::ICFGNode * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::OfflineConsG * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::PAG * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::PAGNode * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAND \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::PTACallGraph * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::PTACallGraphNode * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::SVFG * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::TCT * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::TCTNode * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::VFG * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b llvm::GraphTraits< SVF::VFGNode * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b hack} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::HareParForEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::hash< const SVF::CondVar< Cond > >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for CondVar })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::hash< const SVF::ContextCond >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for ContextCond })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::hash< llvm::SparseBitVector<> >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for SparseBitVectors })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::hash< std::pair< T, U > >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for pairs })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::hash< SVF::CallSite >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for CallSites })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::hash< SVF::CondVar< Cond > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::hash< SVF::ContextCond >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::hash< SVF::CxtDPItem >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for CxtDPItem })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::hash< SVF::CxtStmtDPItem< LocCond > >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for CxtStmtDPItem })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::hash< SVF::LocationSet >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAART \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::hash< SVF::SmallVector< T, N > >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for SmallVectors })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::hash< SVF::StmtDPItem< LocCond > >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for StmtDPItem })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ICFG} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ICFGBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGKQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ICFGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ICFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ICFGPrinter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGKL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ICFGStat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b IeeeDoubleStruct} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b IeeeNanStruct} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::IncMutableDFPTData< Key, Datum, Data >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Incremental version of the mutable data-flow points-to data structure })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEJA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::IndirectSVFGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACXV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::InterBlockNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::InterDisjointMRG} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEZM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::InterMSSAPHISVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::InterPHIVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADUW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::IntraBlockNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::IntraCFGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::IntraDirSVFGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADMY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::IntraDisjointMRG} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEYZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::IntraIndSVFGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::IntraMSSAPHISVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::IntraPHIVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADSG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::is_simple_type< X >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIFT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::isa_impl< To, From, Enabler >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::isa_impl< To, From, typename std::enable_if< std::is_base_of< To, From >::value >::type >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Always allow upcasts, and perform no dynamic check for them })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::isa_impl_cl< To, From >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::isa_impl_cl< To, const From * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::isa_impl_cl< To, const From *const >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::isa_impl_cl< To, const From >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::isa_impl_cl< To, const std::unique_ptr< From > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::isa_impl_cl< To, From * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::isa_impl_cl< To, From *const >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::isa_impl_wrap< To, From, SimpleFrom >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIET \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::isa_impl_wrap< To, FromTy, FromTy >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::IteratedDominanceFrontier} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGHV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::LeakChecker} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFWU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::List< Data >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHLW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::LLVMModuleSet} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGKW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::LoadCGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::LoadMU< Cond >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::LoadPE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::LoadVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADOV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::LocationSet} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEBT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::LockAnalysis} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFLL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::LockValidator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIDF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::LocObjTypeInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGSD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::LocSymTableInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGRZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MemObj} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MemRegion} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory Region class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEZO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MemSSA} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFCT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MemSSADF} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFJN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MemSSAStat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADCS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MergeFunctionRets} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGDR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MHP} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFOE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MHPValidator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIDI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Move} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MRGenerator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MRSVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MRVer} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFFU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MSSACHI< Cond >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MSSADEF} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MSSAMU< Cond >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFGA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MSSAPHI< Cond >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFJA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MSSAPHISVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADAW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MTA} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFQE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MTAAnnotator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFQW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MTAResultValidator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MTAStat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFRX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MTASVFGBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MtrNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MutableDFPTData< Key, Datum, Data >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEFH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MutableDiffPTData< Key, Datum, Data >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b DiffPTData} implemented with points-to sets which are updated continuously })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MutablePTData< Key, Datum, Data >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PTData} implemented using points-to sets which are created once and updated continuously })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEHD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::MutableVersionedPTData< Key, Datum, Data, VersionedKey >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEJV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::NodeIDAllocator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHDB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::NormalGepCGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::NormalGepPE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::NullPtrVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADVI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ObjPN} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ObjTypeInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEDA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::OfflineConsG} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PAG} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PAGBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGLZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PAGBuilderFromFile} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEKW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PAGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PAGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PathCondAllocator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHDS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PathStmtDPItem< LocCond >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHBL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PCG} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFSI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PHIVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADRQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PointerAnalysis} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAELD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ProgSlice} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFXS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PTACallGraph} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PTACallGraphEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PTACallGraphNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACRR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PTACFInfoBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PTASCEV} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGGZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PTAStat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PTAType} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEXD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::PTData< Key, Datum, Data >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADVQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b RaceResultValidator} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Validate the result of concurrent analysis })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::RetBlockNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::RetCFGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::RetDirSVFGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADNN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::RetIndSVFGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::RetMU< Cond >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFHC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::RetPE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::RetPN} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SaberAnnotator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFZW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SaberCheckerAPI} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SaberSVFGBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SCCDetection< GraphType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHFK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::simplify_type< From >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIDT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFUtil::simplify_type< const From >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIDW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SrcSnkDDA} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFXO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b st_generator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b st_table} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b st_table_entry} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::Steensgaard} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHXW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::StInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAECP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::StmtDPItem< LocCond >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGYM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::StmtVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADOI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::StoreCGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::StoreCHI< Cond >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::StorePE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::StoreVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADPC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFBasicBlock} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGTJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFFunction} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGSZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFG} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFGBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFJP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFGlobal} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGTH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFGOPT} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADCH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFGStat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFInstruction} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGTL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFModule} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHGU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SVFValue} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHGI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::SymbolTableInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGOV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::TCT} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFUC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::TCTEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFTM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::TCTNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAFTU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::TDForkPE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::TDJoinPE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ThreadAPI} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHIH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ThreadCallGraph} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ThreadCallGraphBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAGED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ThreadForkEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADES \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ThreadJoinEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ThreadMHPIndSVFGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::TypeAnalysis} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHYN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::TypeBasedHeapCloning} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHKM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::TypeSet} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEXL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::TypeSystem} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAEXY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::UnaryOPPE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::UnaryOPVFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADQU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::ValPN} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::VarArgPN} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACPD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::VariantGepCGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::VariantGepPE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::VersionedFlowSensitive} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHYU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::VersionedFlowSensitiveStat} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIDB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::VersionedPTData< Key, Datum, Data, VersionedKey >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADXS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::VFG} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADHK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::VFGEdge} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADLY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::VFGNode} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADNV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::VFPathCond} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::WPAFSSolver< GraphType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHZK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::WPAMinimumSolver< GraphType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::WPAPass} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAIAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::WPASCCSolver< GraphType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHZP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SVF::WPASolver< GraphType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAHQQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm Namespace Reference\par \pard\plain 
{\tc\tcl2 \v llvm}
{\xe \v llvm}
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::ConstraintNode * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< Inverse< SVF::ConstraintNode * > >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for Value flow node, it is used for inverse traversal. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::ConstraintGraph * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::GenericNode< NodeTy, EdgeTy > * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< Inverse< SVF::GenericNode< NodeTy, EdgeTy > * > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::GenericGraph< NodeTy, EdgeTy > * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GraphPrinter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::ICFGNode * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< Inverse< SVF::ICFGNode * > >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::ICFG * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::OfflineConsG * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::PAGNode * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< Inverse< SVF::PAGNode * > >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for PAG node, it is used for inverse traversal. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::PAG * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::PTACallGraphNode * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< Inverse< SVF::PTACallGraphNode * > >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::PTACallGraph * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::SVFG * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::VFGNode * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< Inverse< SVF::VFGNode * > >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::VFG * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::TCTNode * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< Inverse< SVF::TCTNode * > >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for Value flow node, it is used for inverse traversal. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::TCT * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::CHNode * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< Inverse< SVF::CHNode * > >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::CHGraph * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::DCHNode * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< Inverse< SVF::DCHNode * > >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b GraphTraits< SVF::DCHGraph * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b generic_bridge_gep_type_iterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b DOTGraphTraits< ConstraintGraph * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b DOTGraphTraits< ICFG * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b DOTGraphTraits< OfflineConsG * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b DOTGraphTraits< PAG * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b DOTGraphTraits< PTACallGraph * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b DOTGraphTraits< SVFG * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b DOTGraphTraits< VFG * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b DOTGraphTraits< TCT * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b DOTGraphTraits< CHGraph * >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b generic_bridge_gep_type_iterator} {\b bridge_gep_iterator}{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b bridge_gep_iterator} {\b bridge_gep_begin} (const User *GEP){\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b bridge_gep_iterator} {\b bridge_gep_end} (const User *GEP){\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b bridge_gep_iterator} {\b bridge_gep_begin} (const User &GEP){\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b bridge_gep_iterator} {\b bridge_gep_end} (const User &GEP){\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<typename T > {\b generic_bridge_gep_type_iterator}< const T * > {\b bridge_gep_end} (Type *, ArrayRef< T > A){\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
GraphTraits specialization for constraint graph\par
GraphTraits specialization \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF Namespace Reference\par \pard\plain 
{\tc\tcl2 \v SVF}
{\xe \v SVF}
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
for isBitcode }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ContextDDA}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DDAClient}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FunptrDDAClient}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AliasDDAClient}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DDAPass}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DDAStat}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DDAVFSolver}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FlowDDA}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ConstraintGraph}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ConstraintEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AddrCGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CopyCGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StoreCGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LoadCGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GepCGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NormalGepCGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VariantGepCGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ConstraintNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ExternalPAG}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GenericEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GenericNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GenericGraph}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ICFG}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ICFGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IntraCFGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CallCFGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RetCFGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ICFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GlobalBlockNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IntraBlockNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InterBlockNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FunEntryBlockNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FunExitBlockNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CallBlockNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RetBlockNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ICFGStat}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b OfflineConsG}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PAG}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PAGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AddrPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CopyPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CmpPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BinaryOPPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UnaryOPPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StorePE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LoadPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GepPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NormalGepPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VariantGepPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CallPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RetPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TDForkPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TDJoinPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PAGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ValPN}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ObjPN}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GepValPN}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GepObjPN}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FIObjPN}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RetPN}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VarArgPN}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DummyValPN}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DummyObjPN}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CloneDummyObjPN}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CloneGepObjPN}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CloneFIObjPN}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PTACallGraphEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PTACallGraphNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PTACallGraph}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SVFG}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IndirectSVFGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IntraIndSVFGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CallIndSVFGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RetIndSVFGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ThreadMHPIndSVFGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MRSVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FormalINSVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FormalOUTSVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ActualINSVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ActualOUTSVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MSSAPHISVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IntraMSSAPHISVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InterMSSAPHISVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SVFGOPT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MemSSAStat}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SVFGStat}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ThreadForkEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ThreadJoinEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b HareParForEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ThreadCallGraph}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VFG}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VFGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DirectSVFGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IntraDirSVFGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CallDirSVFGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RetDirSVFGEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StmtVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LoadVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StoreVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CopyVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CmpVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BinaryOPVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UnaryOPVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GepVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PHIVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IntraPHIVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AddrVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ArgumentVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ActualParmVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FormalParmVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ActualRetVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FormalRetVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InterPHIVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NullPtrVFGNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PTData}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DiffPTData}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DFPTData}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VersionedPTData}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CondVar}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CondStdSet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CondPointsToSet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FieldInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LocationSet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ObjTypeInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MemObj}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MutableDFPTData}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MutablePTData}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PTData} implemented using points-to sets which are created once and updated continuously. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MutableDiffPTData}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b DiffPTData} implemented with points-to sets which are updated continuously. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IncMutableDFPTData}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Incremental version of the mutable data-flow points-to data structure. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MutableVersionedPTData}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PAGBuilderFromFile}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PointerAnalysis}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BVDataPTAImpl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CondPTAImpl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PTAStat}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PTAType}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TypeSet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TypeSystem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DistinctMRG}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IntraDisjointMRG}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InterDisjointMRG}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MemRegion}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory Region class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MRGenerator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MemSSA}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MRVer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MSSAMU}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LoadMU}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CallMU}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RetMU}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MSSADEF}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MSSACHI}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StoreCHI}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CallCHI}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EntryCHI}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MSSAPHI}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MemSSADF}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SVFGBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MTASVFGBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FSMPTA}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LockAnalysis}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MHP}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ForkJoinAnalysis}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MTA}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MTAAnnotator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MTAStat}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PCG}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TCTEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TCTNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TCT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DoubleFreeChecker}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FileChecker}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LeakChecker}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ProgSlice}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SaberAnnotator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SaberCheckerAPI}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SaberSVFGBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SrcSnkDDA}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BreakConstantGEPs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MergeFunctionRets}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CallGraphBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ThreadCallGraphBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CHEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CHNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CHGraph}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CommonCHGraph}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Common base for class hierarchy graph. Only implements what {\b PointerAnalysis} needs. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PTASCEV}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PTACFInfoBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IteratedDominanceFrontier}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCHEdge}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCHNode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DCHGraph}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dwarf based CHG. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ICFGPrinter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ICFGBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LLVMModuleSet}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PAGBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SymbolTableInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LocSymTableInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LocObjTypeInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Annotator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SVFFunction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SVFGlobal}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SVFBasicBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SVFInstruction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CFLSolver}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BddCondManager}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CxtStmt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CxtThreadStmt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CxtThread}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CxtProc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CxtThreadProc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DPItem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StmtDPItem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ContextCond}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CxtStmtDPItem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VFPathCond}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PathStmtDPItem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CxtDPItem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ExtAPI}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NodeIDAllocator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PathCondAllocator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SCCDetection}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SVFValue}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SVFModule}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ThreadAPI}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TypeBasedHeapCloning}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b List}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FIFOWorkList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FILOWorkList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AndersenBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Andersen}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AndersenWaveDiff}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AndersenWaveDiffWithType}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AndersenLCD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AndersenHCD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AndersenHLCD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AndersenSCD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AndersenSFR}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CSC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FlowSensitive}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FlowSensitiveTBHC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Steensgaard}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TypeAnalysis}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VersionedFlowSensitive}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b WPAFSSolver}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b WPASCCSolver}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b WPAMinimumSolver}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b WPAPass}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b WPASolver}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AndersenStat}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FlowSensitiveStat}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b VersionedFlowSensitiveStat}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LockValidator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MHPValidator}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b CxtStmtDPItem}< {\b SVFGNode} > {\b CxtLocDPItem}{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b StmtDPItem}< {\b SVFGNode} > {\b LocDPItem}{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GenericEdge}< {\b ConstraintNode} > {\b GenericConsEdgeTy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GenericNode}< {\b ConstraintNode}, {\b ConstraintEdge} > {\b GenericConsNodeTy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GenericGraph}< {\b ICFGNode}, {\b ICFGEdge} > {\b GenericICFGTy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GenericEdge}< {\b ICFGNode} > {\b GenericICFGEdgeTy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GenericNode}< {\b ICFGNode}, {\b ICFGEdge} > {\b GenericICFGNodeTy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericEdge}< {\b PAGNode} > {\b GenericPAGEdgeTy}{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericNode}< {\b PAGNode}, {\b PAGEdge} > {\b GenericPAGNodeTy}{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericEdge}< {\b PTACallGraphNode} > {\b GenericCallGraphEdgeTy}{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericNode}< {\b PTACallGraphNode}, {\b PTACallGraphEdge} > {\b GenericCallGraphNodeTy}{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GenericGraph}< {\b PTACallGraphNode}, {\b PTACallGraphEdge} > {\b GenericCallGraphTy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b VFGEdge} {\b SVFGEdge}{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b VFGNode} {\b SVFGNode}{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b ActualParmVFGNode} {\b ActualParmSVFGNode}{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b ActualRetVFGNode} {\b ActualRetSVFGNode}{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FormalParmVFGNode} {\b FormalParmSVFGNode}{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FormalRetVFGNode} {\b FormalRetSVFGNode}{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b NullPtrVFGNode} {\b NullPtrSVFGNode}{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b StmtVFGNode} {\b StmtSVFGNode}{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b AddrVFGNode} {\b AddrSVFGNode}{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b CopyVFGNode} {\b CopySVFGNode}{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b StoreVFGNode} {\b StoreSVFGNode}{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b LoadVFGNode} {\b LoadSVFGNode}{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GepVFGNode} {\b GepSVFGNode}{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b PHIVFGNode} {\b PHISVFGNode}{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b IntraPHIVFGNode} {\b IntraPHISVFGNode}{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b InterPHIVFGNode} {\b InterPHISVFGNode}{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GenericGraph}< {\b VFGNode}, {\b VFGEdge} > {\b GenericVFGTy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GenericEdge}< {\b VFGNode} > {\b GenericVFGEdgeTy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GenericNode}< {\b VFGNode}, {\b VFGEdge} > {\b GenericVFGNodeTy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeID {\b MRID}{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeID {\b MRVERID}{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeID {\b MRVERSION}{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericEdge}< {\b TCTNode} > {\b GenericTCTEdgeTy}{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericNode}< {\b TCTNode}, {\b TCTEdge} > {\b GenericTCTNodeTy}{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b GenericGraph}< {\b TCTNode}, {\b TCTEdge} > {\b GenericThreadCreateTreeTy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b CFLSolver}< {\b SVFG} *, {\b CxtDPItem} > {\b CFLSrcSnkSolver}{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericEdge}< {\b CHNode} > {\b GenericCHEdgeTy}{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericNode}< {\b CHNode}, {\b CHEdge} > {\b GenericCHNodeTy}{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericGraph}< {\b CHNode}, {\b CHEdge} > {\b GenericCHGraphTy}{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
class hierarchy graph }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const GlobalValue * > {\b VTableSet}{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b SVFFunction} * > {\b VFunSet}{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::SMDiagnostic {\b SMDiagnostic}{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LLVM Basic classes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::LLVMContext {\b LLVMContext}{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::Type {\b Type}{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::Function {\b Function}{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::BasicBlock {\b BasicBlock}{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::Value {\b Value}{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::Instruction {\b Instruction}{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::CallSite {\b CallSite}{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::GlobalObject {\b GlobalObject}{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::GlobalValue {\b GlobalValue}{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::GlobalVariable {\b GlobalVariable}{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::Module {\b Module}{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::CallGraph {\b LLVMCallGraph}{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::User {\b User}{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::Use {\b Use}{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::Loop {\b Loop}{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::LoopInfo {\b LoopInfo}{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::UnifyFunctionExitNodes {\b UnifyFunctionExitNodes}{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ModulePass {\b ModulePass}{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::AnalysisUsage {\b AnalysisUsage}{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::raw_ostream {\b raw_ostream}{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LLVM outputs. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::raw_string_ostream {\b raw_string_ostream}{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::raw_fd_ostream {\b raw_fd_ostream}{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::StringRef {\b StringRef}{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ToolOutputFile {\b ToolOutputFile}{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::StructType {\b StructType}{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LLVM types. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ArrayType {\b ArrayType}{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::PointerType {\b PointerType}{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::FunctionType {\b FunctionType}{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::VectorType {\b VectorType}{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::MetadataAsValue {\b MetadataAsValue}{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::BlockAddress {\b BlockAddress}{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::DataLayout {\b DataLayout}{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LLVM data layout. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::StructLayout {\b StructLayout}{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::SmallVector< BasicBlock *, 8 > {\b SmallBBVector}{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ConstantStruct {\b ConstantStruct}{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::MemoryLocation {\b MemoryLocation}{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::Argument {\b Argument}{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LLVM Aliases and constants. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::Constant {\b Constant}{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ConstantData {\b ConstantData}{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ConstantExpr {\b ConstantExpr}{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ConstantAggregate {\b ConstantAggregate}{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ConstantPointerNull {\b ConstantPointerNull}{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ConstantArray {\b ConstantArray}{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::GlobalAlias {\b GlobalAlias}{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::AliasResult {\b AliasResult}{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ModRefInfo {\b ModRefInfo}{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::AnalysisID {\b AnalysisID}{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ConstantDataArray {\b ConstantDataArray}{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::NamedMDNode {\b NamedMDNode}{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LLVM metadata. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::MDString {\b MDString}{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::MDNode {\b MDNode}{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::AllocaInst {\b AllocaInst}{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LLVM Instructions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::CallInst {\b CallInst}{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::InvokeInst {\b InvokeInst}{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::CallBrInst {\b CallBrInst}{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::StoreInst {\b StoreInst}{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::LoadInst {\b LoadInst}{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::PHINode {\b PHINode}{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::GetElementPtrInst {\b GetElementPtrInst}{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::CastInst {\b CastInst}{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::BitCastInst {\b BitCastInst}{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ReturnInst {\b ReturnInst}{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ConstantInt {\b ConstantInt}{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::SelectInst {\b SelectInst}{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::IntToPtrInst {\b IntToPtrInst}{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::CmpInst {\b CmpInst}{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::BranchInst {\b BranchInst}{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::SwitchInst {\b SwitchInst}{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ExtractValueInst {\b ExtractValueInst}{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::InsertValueInst {\b InsertValueInst}{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::BinaryOperator {\b BinaryOperator}{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::UnaryOperator {\b UnaryOperator}{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::PtrToIntInst {\b PtrToIntInst}{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::VAArgInst {\b VAArgInst}{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ExtractElementInst {\b ExtractElementInst}{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::InsertElementInst {\b InsertElementInst}{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ShuffleVectorInst {\b ShuffleVectorInst}{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::LandingPadInst {\b LandingPadInst}{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ResumeInst {\b ResumeInst}{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::UnreachableInst {\b UnreachableInst}{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::FenceInst {\b FenceInst}{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::AtomicCmpXchgInst {\b AtomicCmpXchgInst}{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::AtomicRMWInst {\b AtomicRMWInst}{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::UndefValue {\b UndefValue}{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ScalarEvolutionWrapperPass {\b ScalarEvolutionWrapperPass}{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LLVM scalar evolution. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::ScalarEvolution {\b ScalarEvolution}{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::SCEVAddRecExpr {\b SCEVAddRecExpr}{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::SCEVConstant {\b SCEVConstant}{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::SCEV {\b SCEV}{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::DominanceFrontier {\b DominanceFrontier}{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LLVM Dominators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::DominatorTree {\b DominatorTree}{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::PostDominatorTree {\b PostDominatorTree}{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::DomTreeNode {\b DomTreeNode}{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::DominanceFrontierBase< BasicBlock, false > {\b DominanceFrontierBase}{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::PostDominatorTreeWrapperPass {\b PostDominatorTreeWrapperPass}{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::LoopInfoWrapperPass {\b LoopInfoWrapperPass}{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::inst_iterator {\b inst_iterator}{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LLVM Iterators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::succ_const_iterator {\b succ_const_iterator}{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::const_inst_iterator {\b const_inst_iterator}{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::const_pred_iterator {\b const_pred_iterator}{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::gep_type_iterator {\b gep_type_iterator}{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b llvm::bridge_gep_iterator} {\b bridge_gep_iterator}{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b llvm::GraphPrinter} {\b GraphPrinter}{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::IRBuilder {\b IRBuilder}{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::IntegerType {\b IntegerType}{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::DebugInfoFinder {\b DebugInfoFinder}{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LLVM debug information. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::DIType {\b DIType}{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::DIBasicType {\b DIBasicType}{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::DICompositeType {\b DICompositeType}{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::DIDerivedType {\b DIDerivedType}{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::DISubroutineType {\b DISubroutineType}{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::DISubprogram {\b DISubprogram}{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::DISubrange {\b DISubrange}{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::DINode {\b DINode}{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::DINodeArray {\b DINodeArray}{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::DITypeRefArray {\b DITypeRefArray}{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b CondVar}< {\b ContextCond} > {\b CxtVar}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b CondStdSet}< {\b CxtVar} > {\b CxtPtSet}{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b CondVar}< {\b VFPathCond} > {\b VFPathVar}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b CondStdSet}< {\b VFPathVar} > {\b VFPathPtSet}{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef unsigned {\b u32_t}{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef unsigned long long {\b u64_t}{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef signed {\b s32_t}{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef signed long {\b Size_t}{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef u32_t {\b NodeID}{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef u32_t {\b EdgeID}{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef unsigned {\b SymID}{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef unsigned {\b CallSiteID}{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef unsigned {\b ThreadID}{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef unsigned {\b Version}{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::SparseBitVector {\b NodeBS}{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeBS {\b PointsTo}{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PointsTo {\b AliasSet}{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<typename Key , typename Hash  = std::hash<Key>, typename KeyEqual  = std::equal_to<Key>, typename Allocator  = std::allocator<Key>> using {\b Set} = std::unordered_set< Key, Hash, KeyEqual, Allocator >{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<typename Key , typename Value , typename Hash  = std::hash<Key>, typename KeyEqual  = std::equal_to<Key>, typename Allocator  = std::allocator<std::pair<const Key, Value>>> using {\b Map} = std::unordered_map< Key, Value, Hash, KeyEqual, Allocator >{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<typename Key , typename Compare  = std::less<Key>, typename Allocator  = std::allocator<Key>> using {\b OrderedSet} = std::set< Key, Compare, Allocator >{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<typename Key , typename Value , typename Compare  = std::less<Key>, typename Allocator  = std::allocator<std::pair<const Key, Value>>> using {\b OrderedMap} = std::map< Key, Value, Compare, Allocator >{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<typename T , unsigned N> using {\b SmallVector} = llvm::SmallVector< T, N >{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::pair< NodeID, NodeID > {\b NodePair}{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::pair< NodeID, Version > {\b VersionedVar}{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedSet< NodeID > {\b OrderedNodeSet}{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< NodeID > {\b NodeSet}{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< NodePair > {\b NodePairSet}{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodePair, NodeID > {\b NodePairMap}{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< NodeID > {\b NodeVector}{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< EdgeID > {\b EdgeVector}{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::stack< NodeID > {\b NodeStack}{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::list< NodeID > {\b NodeList}{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::deque< NodeID > {\b NodeDeque}{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef SmallVector< u32_t, 16 > {\b SmallVector16}{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef SmallVector< u32_t, 8 > {\b SmallVector8}{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeSet {\b EdgeSet}{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef SmallVector16 {\b CallStrCxt}{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::StringMap< u32_t > {\b StringMap}{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b WPASolver}< {\b ConstraintGraph} * > {\b WPAConstraintSolver}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SCCDetection}< {\b ConstraintGraph} * > {\b CGSCC}{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b WPAFSSolver}< {\b SVFG} * > {\b WPASVFGFSSolver}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SYMTYPE} \{ {\b BlackHole}
, {\b ConstantObj}
, {\b BlkPtr}
, {\b NullPtr}
, {\b ValSym}
, {\b ObjSym}
, {\b RetSym}
, {\b VarargSym}
 \}{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Symbol types. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<typename F , typename S > {\b raw_ostream} & {\b operator<<} ({\b raw_ostream} &o, const std::pair< F, S > &var){\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
for isBitcode \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains abstract classes for: {\b PTData}: basic points-to data structure derived by all others. {\b DiffPTData}: {\b PTData} which only propagates new changes, not entire points-to sets. {\b DFPTData}: flow-sensitive {\b PTData} as defined by Hardekopf and Lin (CGO '11).\par
Hierarchy (square brackets indicate abstract class): {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   +------------> [PTData] <----------------+---------------------+\par
  |                 ^                      |                     |\par
  |                 |                      |                     |\par
}
 {\b MutablePTData} [{\b DiffPTData}] [{\b DFPTData}] [{\b VersionedPTData}] ^ ^ ^ | | | {\b MutableDiffPTData} {\b MutableDFPTData} {\b MutableVersionedPTData} ^ | {\b IncMutableDFPTData}\par
{\b PTData} ({\b AbstractPointsToDS.h}) implementations with a mutable backend. Each Key is given a points-to set which is itself updated till the analysis terminates. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v CxtVar\:SVF}
{\xe \v SVF\:CxtVar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b CondVar}< {\b ContextCond} > {\b SVF::CxtVar}}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Context-, flow- sensitive {\b DPItem}\par
Context {\b DPItem} \par
}}
{\xe \v GenericCallGraphTy\:SVF}
{\xe \v SVF\:GenericCallGraphTy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GenericGraph}<{\b PTACallGraphNode},{\b PTACallGraphEdge}> {\b SVF::GenericCallGraphTy}}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer Analysis Call Graph used internally for various pointer analysis \par
}}
{\xe \v GenericConsEdgeTy\:SVF}
{\xe \v SVF\:GenericConsEdgeTy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GenericEdge}<{\b ConstraintNode}> {\b SVF::GenericConsEdgeTy}}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Self-defined edge for constraint resolution including add/remove/re-target, but all the operations do not affect original {\b PAG} Edges \par
}}
{\xe \v GenericConsNodeTy\:SVF}
{\xe \v SVF\:GenericConsNodeTy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GenericNode}<{\b ConstraintNode},{\b ConstraintEdge}> {\b SVF::GenericConsNodeTy}}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraint node \par
}}
{\xe \v GenericICFGEdgeTy\:SVF}
{\xe \v SVF\:GenericICFGEdgeTy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GenericEdge}<{\b ICFGNode}> {\b SVF::GenericICFGEdgeTy}}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interprocedural control-flow and value-flow edge, representing the control- and value-flow dependence between two nodes \par
}}
{\xe \v GenericICFGNodeTy\:SVF}
{\xe \v SVF\:GenericICFGNodeTy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GenericNode}<{\b ICFGNode}, {\b ICFGEdge}> {\b SVF::GenericICFGNodeTy}}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interprocedural control-flow graph node, representing different kinds of program statements including top-level pointers ({\b ValPN}) and address-taken objects ({\b ObjPN}) \par
}}
{\xe \v GenericICFGTy\:SVF}
{\xe \v SVF\:GenericICFGTy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GenericGraph}<{\b ICFGNode},{\b ICFGEdge}> {\b SVF::GenericICFGTy}}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interprocedural Control-Flow Graph ({\b ICFG}) \par
}}
{\xe \v GenericThreadCreateTreeTy\:SVF}
{\xe \v SVF\:GenericThreadCreateTreeTy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GenericGraph}<{\b TCTNode}, {\b TCTEdge}> {\b SVF::GenericThreadCreateTreeTy}}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer Analysis Call Graph used internally for various pointer analysis \par
}}
{\xe \v GenericVFGEdgeTy\:SVF}
{\xe \v SVF\:GenericVFGEdgeTy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GenericEdge}<{\b VFGNode}> {\b SVF::GenericVFGEdgeTy}}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interprocedural control-flow and value-flow edge, representing the control- and value-flow dependence between two nodes \par
}}
{\xe \v GenericVFGNodeTy\:SVF}
{\xe \v SVF\:GenericVFGNodeTy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GenericNode}<{\b VFGNode},{\b VFGEdge}> {\b SVF::GenericVFGNodeTy}}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interprocedural control-flow graph node, representing different kinds of program statements including top-level pointers ({\b ValPN}) and address-taken objects ({\b ObjPN}) \par
}}
{\xe \v GenericVFGTy\:SVF}
{\xe \v SVF\:GenericVFGTy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b GenericGraph}<{\b VFGNode},{\b VFGEdge}> {\b SVF::GenericVFGTy}}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interprocedural Control-Flow Graph ({\b VFG}) \par
}}
{\xe \v VFPathVar\:SVF}
{\xe \v SVF\:VFPathVar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b CondVar}<{\b VFPathCond}> {\b SVF::VFPathVar}}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Path-sensitive {\b DPItem} \par
}}
{\xe \v WPAConstraintSolver\:SVF}
{\xe \v SVF\:WPAConstraintSolver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b WPASolver}< {\b ConstraintGraph} * > {\b SVF::WPAConstraintSolver}}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract class of inclusion-based Pointer Analysis\par
Equivalence-based Pointer Analysis \par
}}
{\xe \v WPASVFGFSSolver\:SVF}
{\xe \v SVF\:WPASVFGFSSolver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b WPAFSSolver}<{\b SVFG}*> {\b SVF::WPASVFGFSSolver}}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flow sensitive whole program pointer analysis \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::cppUtil::ctir Namespace Reference\par \pard\plain 
{\tc\tcl2 \v SVF::cppUtil::ctir}
{\xe \v SVF::cppUtil::ctir}
{\bkmkstart AAAAAAAIDO}
{\bkmkend AAAAAAAIDO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string {\b derefMDName} = "ctir"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string {\b vtMDName} = "ctir.vt"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string {\b vtInitMDName} = "ctir.vt.init"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const uint32_t {\b moduleFlagValue} = 1{\bkmkstart AAAAAAAIDP}
{\bkmkend AAAAAAAIDP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Value we expect a ctir-annotated module to have. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constants pertaining to CTir, for C and C++. TODO: move helper functions here too? \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v derefMDName\:SVF::cppUtil::ctir}
{\xe \v SVF::cppUtil::ctir\:derefMDName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string SVF::cppUtil::ctir::derefMDName = "ctir"}}
\par
{\bkmkstart AAAAAAAIDQ}
{\bkmkend AAAAAAAIDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On loads, stores, GEPs representing dereferences, and calls representing virtual calls. (The static type.) \par
}}
{\xe \v vtInitMDName\:SVF::cppUtil::ctir}
{\xe \v SVF::cppUtil::ctir\:vtInitMDName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string SVF::cppUtil::ctir::vtInitMDName = "ctir.vt.init"}}
\par
{\bkmkstart AAAAAAAIDR}
{\bkmkend AAAAAAAIDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On the bitcast of {\f2 this}  to i8*. (The class the constructor it corresponds to.) \par
}}
{\xe \v vtMDName\:SVF::cppUtil::ctir}
{\xe \v SVF::cppUtil::ctir\:vtMDName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string SVF::cppUtil::ctir::vtMDName = "ctir.vt"}}
\par
{\bkmkstart AAAAAAAIDS}
{\bkmkend AAAAAAAIDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On the (global) virtual table itself. (The class it corresponds to.) \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RaceResultValidator::AccessPair Class Reference\par \pard\plain 
{\tc\tcl2 \v RaceResultValidator::AccessPair}
{\xe \v RaceResultValidator::AccessPair}
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
\par
{
{\f2 #include <MTAResultValidator.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b AccessPair} (const Instruction *I1, const Instruction *I2, const RC_FLAG flags){\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFlaged} (const RC_FLAG flag) const{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class member access. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Instruction * {\b getInstruction1} () const{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Instruction * {\b getInstruction2} () const{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Data structure for recording access pairs for the validation. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/MTAResultValidator.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ActualINSVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ActualINSVFGNode}
{\xe \v SVF::ActualINSVFGNode}
{\bkmkstart AAAAAAADAG}
{\bkmkend AAAAAAADAG}
Inheritance diagram for SVF::ActualINSVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_actual_i_n_s_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ActualINSVFGNode} (NodeID id, const {\b MemSSA::CALLMU} *m, const {\b CallBlockNode} *c){\bkmkstart AAAAAAADAH}
{\bkmkend AAAAAAADAH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getCallSite} () const{\bkmkstart AAAAAAADAI}
{\bkmkend AAAAAAADAI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemSSA::CALLMU} * {\b getCallMU} () const{\bkmkstart AAAAAAADAJ}
{\bkmkend AAAAAAADAJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CallMU}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADAK}
{\bkmkend AAAAAAADAK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ActualINSVFGNode} *){\bkmkstart AAAAAAADAL}
{\bkmkend AAAAAAADAL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADAM}
{\bkmkend AAAAAAADAM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADAN}
{\bkmkend AAAAAAADAN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ActualOUTSVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ActualOUTSVFGNode}
{\xe \v SVF::ActualOUTSVFGNode}
{\bkmkstart AAAAAAADAO}
{\bkmkend AAAAAAADAO}
Inheritance diagram for SVF::ActualOUTSVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_actual_o_u_t_s_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ActualOUTSVFGNode} (NodeID id, const {\b MemSSA::CALLCHI} *c, const {\b CallBlockNode} *cal){\bkmkstart AAAAAAADAP}
{\bkmkend AAAAAAADAP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getCallSite} () const{\bkmkstart AAAAAAADAQ}
{\bkmkend AAAAAAADAQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemSSA::CALLCHI} * {\b getCallCHI} () const{\bkmkstart AAAAAAADAR}
{\bkmkend AAAAAAADAR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CallCHI}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADAS}
{\bkmkend AAAAAAADAS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ActualOUTSVFGNode} *){\bkmkstart AAAAAAADAT}
{\bkmkend AAAAAAADAT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADAU}
{\bkmkend AAAAAAADAU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADAV}
{\bkmkend AAAAAAADAV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ActualParmVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ActualParmVFGNode}
{\xe \v SVF::ActualParmVFGNode}
{\bkmkstart AAAAAAADTF}
{\bkmkend AAAAAAADTF}
Inheritance diagram for SVF::ActualParmVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_actual_parm_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ActualParmVFGNode} (NodeID id, const {\b PAGNode} *n, const {\b CallBlockNode} *c){\bkmkstart AAAAAAADTG}
{\bkmkend AAAAAAADTG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getCallSite} () const{\bkmkstart AAAAAAADTH}
{\bkmkend AAAAAAADTH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getParam} () const{\bkmkstart AAAAAAADTI}
{\bkmkend AAAAAAADTI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return parameter. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADTJ}
{\bkmkend AAAAAAADTJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ActualParmVFGNode} *){\bkmkstart AAAAAAADTK}
{\bkmkend AAAAAAADTK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ArgumentVFGNode} *node){\bkmkstart AAAAAAADTL}
{\bkmkend AAAAAAADTL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADTM}
{\bkmkend AAAAAAADTM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADTN}
{\bkmkend AAAAAAADTN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ActualRetVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ActualRetVFGNode}
{\xe \v SVF::ActualRetVFGNode}
{\bkmkstart AAAAAAADUA}
{\bkmkend AAAAAAADUA}
\par
{
{\f2 #include <VFGNode.h>}}\par
Inheritance diagram for SVF::ActualRetVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_actual_ret_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ActualRetVFGNode} (NodeID id, const {\b PAGNode} *n, const {\b CallBlockNode} *c){\bkmkstart AAAAAAADUB}
{\bkmkend AAAAAAADUB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getCallSite} () const{\bkmkstart AAAAAAADUC}
{\bkmkend AAAAAAADUC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getCaller} () const{\bkmkstart AAAAAAADUD}
{\bkmkend AAAAAAADUD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Receive parameter at callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getRev} () const{\bkmkstart AAAAAAADUE}
{\bkmkend AAAAAAADUE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Receive parameter at callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADUF}
{\bkmkend AAAAAAADUF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ActualRetVFGNode} *){\bkmkstart AAAAAAADUG}
{\bkmkend AAAAAAADUG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ArgumentVFGNode} *node){\bkmkstart AAAAAAADUH}
{\bkmkend AAAAAAADUH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADUI}
{\bkmkend AAAAAAADUI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADUJ}
{\bkmkend AAAAAAADUJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Callsite receive paramter \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::AddrCGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::AddrCGEdge}
{\xe \v SVF::AddrCGEdge}
{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
\par
{
{\f2 #include <ConsGEdge.h>}}\par
Inheritance diagram for SVF::AddrCGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_addr_c_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AddrCGEdge} ({\b ConstraintNode} *s, {\b ConstraintNode} *d, EdgeID id)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b AddrCGEdge} *){\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ConstraintEdge} *edge){\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericConsEdgeTy} *edge){\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AddrCGEdge\:SVF::AddrCGEdge}
{\xe \v SVF::AddrCGEdge\:AddrCGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AddrCGEdge::AddrCGEdge ({\b ConstraintNode} *  {\i s}, {\b ConstraintNode} *  {\i d}, EdgeID  {\i id})}}
\par
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for address constraint graph edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ConsGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ConsG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::AddrPE Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::AddrPE}
{\xe \v SVF::AddrPE}
{\bkmkstart AAAAAAACIH}
{\bkmkend AAAAAAACIH}
\par
{
{\f2 #include <PAGEdge.h>}}\par
Inheritance diagram for SVF::AddrPE:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_addr_p_e.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b AddrPE} ({\b PAGNode} *s, {\b PAGNode} *d){\bkmkstart AAAAAAACII}
{\bkmkend AAAAAAACII}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACIJ}
{\bkmkend AAAAAAACIJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b AddrPE} *){\bkmkstart AAAAAAACIK}
{\bkmkend AAAAAAACIK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGEdge} *edge){\bkmkstart AAAAAAACIL}
{\bkmkend AAAAAAACIL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGEdgeTy} *edge){\bkmkstart AAAAAAACIM}
{\bkmkend AAAAAAACIM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::AddrVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::AddrVFGNode}
{\xe \v SVF::AddrVFGNode}
{\bkmkstart AAAAAAADSQ}
{\bkmkend AAAAAAADSQ}
Inheritance diagram for SVF::AddrVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_addr_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b AddrVFGNode} (NodeID id, const {\b AddrPE} *edge){\bkmkstart AAAAAAADSR}
{\bkmkend AAAAAAADSR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADSS}
{\bkmkend AAAAAAADSS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b AddrVFGNode} *){\bkmkstart AAAAAAADST}
{\bkmkend AAAAAAADST}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b StmtVFGNode} *node){\bkmkstart AAAAAAADSU}
{\bkmkend AAAAAAADSU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADSV}
{\bkmkend AAAAAAADSV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADSW}
{\bkmkend AAAAAAADSW}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::AliasDDAClient Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::AliasDDAClient}
{\xe \v SVF::AliasDDAClient}
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
\par
{
{\f2 #include <DDAClient.h>}}\par
Inheritance diagram for SVF::AliasDDAClient:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_alias_d_d_a_client.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedSet< const {\b PAGNode} * > {\b PAGNodeSet}{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b AliasDDAClient} ({\b SVFModule} *{\b module}){\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual OrderedNodeSet & {\b collectCandidateQueries} ({\b PAG} *{\b pag}){\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only collect function pointers as query candidates. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b performStat} ({\b PointerAnalysis} *pta){\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DDA client with function pointers as query candidates. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/DDA/DDAClient.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/DDA/DDAClient.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::Andersen Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::Andersen}
{\xe \v SVF::Andersen}
{\bkmkstart AAAAAAAHNN}
{\bkmkend AAAAAAAHNN}
\par
{
{\f2 #include <Andersen.h>}}\par
Inheritance diagram for SVF::Andersen:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_andersen.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SCCDetection}< {\b ConstraintGraph} * > {\b CGSCC}{\bkmkstart AAAAAAAHNO}
{\bkmkend AAAAAAAHNO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< CallSite, NodeID > {\b CallSite2DummyValPN}{\bkmkstart AAAAAAAHNP}
{\bkmkend AAAAAAAHNP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Andersen} ({\b PAG} *_pag, {\b PTATY} type={\b Andersen_WPA}, bool alias_check=true){\bkmkstart AAAAAAAHNQ}
{\bkmkend AAAAAAAHNQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~Andersen} (){\bkmkstart AAAAAAAHNR}
{\bkmkend AAAAAAAHNR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b finalize} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b resetData} (){\bkmkstart AAAAAAAHNS}
{\bkmkend AAAAAAAHNS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b sccRepNode} (NodeID id) const{\bkmkstart AAAAAAAHNT}
{\bkmkend AAAAAAAHNT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC methods. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeBS & {\b sccSubNodes} (NodeID repId){\bkmkstart AAAAAAAHNU}
{\bkmkend AAAAAAAHNU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const PointsTo & {\b getPts} (NodeID id){\bkmkstart AAAAAAAESJ}
{\bkmkend AAAAAAAESJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operation of points-to set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b unionPts} (NodeID id, const PointsTo &target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (NodeID id, NodeID ptd){\bkmkstart AAAAAAAHNV}
{\bkmkend AAAAAAAHNV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dumpTopLevelPtsTo} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setPWCOpt} (bool flag){\bkmkstart AAAAAAAHNW}
{\bkmkend AAAAAAAHNW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b mergePWC} () const{\bkmkstart AAAAAAAHNX}
{\bkmkend AAAAAAAHNX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setDiffOpt} (bool flag){\bkmkstart AAAAAAAHNY}
{\bkmkend AAAAAAAHNY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b enableDiff} () const{\bkmkstart AAAAAAAHNZ}
{\bkmkend AAAAAAAHNZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b Andersen} *){\bkmkstart AAAAAAAHOA}
{\bkmkend AAAAAAAHOA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PointerAnalysis} *pta){\bkmkstart AAAAAAAHOB}
{\bkmkend AAAAAAAHOB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b heapAllocatorViaIndCall} (CallSite cs, NodePairSet &cpySrcNodes){\bkmkstart AAAAAAAHOC}
{\bkmkend AAAAAAAHOC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b computeDiffPts} (NodeID id){\bkmkstart AAAAAAAHOD}
{\bkmkend AAAAAAAHOD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle diff points-to set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const PointsTo & {\b getDiffPts} (NodeID id){\bkmkstart AAAAAAAHOE}
{\bkmkend AAAAAAAHOE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b updatePropaPts} (NodeID dstId, NodeID srcId){\bkmkstart AAAAAAAHOF}
{\bkmkend AAAAAAAHOF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle propagated points-to set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b clearPropaPts} (NodeID src){\bkmkstart AAAAAAAHOG}
{\bkmkend AAAAAAAHOG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b initWorklist} (){\bkmkstart AAAAAAAHOH}
{\bkmkend AAAAAAAHOH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b setSCCEdgeFlag} (ConstraintNode::SCCEdgeFlag f){\bkmkstart AAAAAAAHOI}
{\bkmkend AAAAAAAHOI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b processNode} (NodeID nodeId)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Override {\b WPASolver} function in order to use the default solver. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b processAllAddr} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
handling various constraints }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processLoad} (NodeID node, const {\b ConstraintEdge} *load)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processStore} (NodeID node, const {\b ConstraintEdge} *load)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processCopy} (NodeID node, const {\b ConstraintEdge} *edge)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processGep} (NodeID node, const {\b GepCGEdge} *edge)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleCopyGep} ({\b ConstraintNode} *node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleLoadStore} ({\b ConstraintNode} *node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b processAddr} (const {\b AddrCGEdge} *addr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processGepPts} (const PointsTo &pts, const {\b GepCGEdge} *edge)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b addCopyEdge} (NodeID src, NodeID dst){\bkmkstart AAAAAAAHOJ}
{\bkmkend AAAAAAAHOJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add copy edge on constraint graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b updateCallGraph} (const CallSiteToFunPtrMap &callsites)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update call graph for the input indirect callsites. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateCallGraph} (){\bkmkstart AAAAAAAHOK}
{\bkmkend AAAAAAAHOK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update call graph for all the indirect callsites. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b connectCaller2CalleeParams} (CallSite cs, const {\b SVFFunction} *F, NodePairSet &cpySrcNodes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect formal and actual parameters for indirect callsites. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mergeNodeToRep} (NodeID nodeId, NodeID newRepId)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Merge sub node to its rep. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b mergeSrcToTgt} (NodeID srcId, NodeID tgtId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mergeSccNodes} (NodeID repNodeId, const NodeBS &subNodes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Merge sub node in a SCC cycle to their rep node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b mergeSccCycle} (){\bkmkstart AAAAAAAHOL}
{\bkmkend AAAAAAAHOL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b collapsePWCNode} (NodeID nodeId)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collapse a field object into its base for field insensitive anlaysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b collapseFields} (){\bkmkstart AAAAAAAHOM}
{\bkmkend AAAAAAAHOM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b collapseNodePts} (NodeID nodeId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b collapseField} (NodeID nodeId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateNodeRepAndSubs} (NodeID nodeId, NodeID newRepId)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Updates subnodes of its rep, and rep node of its subs. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual NodeStack & {\b SCCDetect} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC detection. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b sanitizePts} (){\bkmkstart AAAAAAAHON}
{\bkmkend AAAAAAAHON}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sanitize pts for field insensitive objects. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b PTAName} () const{\bkmkstart AAAAAAAHOO}
{\bkmkend AAAAAAAHOO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get PTA name. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b matchType} (NodeID, NodeID, const {\b NormalGepCGEdge} *){\bkmkstart AAAAAAAHOP}
{\bkmkend AAAAAAAHOP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
match types for Gep Edges }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b addTypeForGepObjNode} (NodeID, const {\b NormalGepCGEdge} *){\bkmkstart AAAAAAAHOQ}
{\bkmkend AAAAAAAHOQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add type for newly created GepObjNode }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSite2DummyValPN {\b callsite2DummyValPN}{\bkmkstart AAAAAAAHOR}
{\bkmkend AAAAAAAHOR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Map an instruction to a dummy obj which created at an indirect callsite, which invokes a heap allocator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b pwcOpt}{\bkmkstart AAAAAAAHOS}
{\bkmkend AAAAAAAHOS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b diffOpt}{\bkmkstart AAAAAAAHOT}
{\bkmkend AAAAAAAHOT}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inclusion-based Pointer Analysis \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v collapseField\:SVF::Andersen}
{\xe \v SVF::Andersen\:collapseField}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Andersen::collapseField (NodeID  {\i nodeId}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHOU}
{\bkmkend AAAAAAAHOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collapse field. make struct with the same base as nodeId become field-insensitive. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Black hole doesn't have structures, no collapse is needed. In later versions, instead of using base node to represent the struct, we'll create new field-insensitive node. To avoid creating a new "black hole" node, do not collapse field for black hole node.\par
}}
{\xe \v collapseNodePts\:SVF::Andersen}
{\xe \v SVF::Andersen\:collapseNodePts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Andersen::collapseNodePts (NodeID  {\i nodeId}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHOV}
{\bkmkend AAAAAAAHOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collapse node's points-to set. Change all points-to elements into field-insensitive. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Points to set may be changed during collapse, so use a clone instead.\par
}}
{\xe \v collapsePWCNode\:SVF::Andersen}
{\xe \v SVF::Andersen\:collapsePWCNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Andersen::collapsePWCNode (NodeID  {\i nodeId}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHOW}
{\bkmkend AAAAAAAHOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collapse a field object into its base for field insensitive anlaysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detect and collapse PWC nodes produced by processing gep edges, under the constraint of field limit. \par
}{
Reimplemented from {\b SVF::WPASolver< GraphType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHOX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v connectCaller2CalleeParams\:SVF::Andersen}
{\xe \v SVF::Andersen\:connectCaller2CalleeParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Andersen::connectCaller2CalleeParams (CallSite  {\i cs}, const {\b SVFFunction} *  {\i F}, NodePairSet &  {\i cpySrcNodes}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHOY}
{\bkmkend AAAAAAAHOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect formal and actual parameters for indirect callsites. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect formal and actual parameters for indirect callsites \par
}}
{\xe \v dumpTopLevelPtsTo\:SVF::Andersen}
{\xe \v SVF::Andersen\:dumpTopLevelPtsTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Andersen::dumpTopLevelPtsTo (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAESE}
{\bkmkend AAAAAAAESE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print pag nodes' pts by an ascending order \par
}{
Reimplemented from {\b SVF::BVDataPTAImpl} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAESD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v finalize\:SVF::Andersen}
{\xe \v SVF::Andersen\:finalize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Andersen::finalize (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEPV}
{\bkmkend AAAAAAAEPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalize analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalize analysis \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sanitize field insensitive obj TODO: Fields has been collapsed during {\b Andersen::collapseField()}.\par
}{
Reimplemented from {\b SVF::AndersenBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEPW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v handleCopyGep\:SVF::Andersen}
{\xe \v SVF::Andersen\:handleCopyGep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Andersen::handleCopyGep ({\b ConstraintNode} *  {\i node}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHOZ}
{\bkmkend AAAAAAAHOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process copy and gep edges \par
}{
Reimplemented in {\b SVF::AndersenSCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPA \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::AndersenHLCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPB \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::AndersenLCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPC \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::AndersenWaveDiff} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v handleLoadStore\:SVF::Andersen}
{\xe \v SVF::Andersen\:handleLoadStore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Andersen::handleLoadStore ({\b ConstraintNode} *  {\i node}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPE}
{\bkmkend AAAAAAAHPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process load and store edges \par
}{
Reimplemented in {\b SVF::AndersenSCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v initialize\:SVF::Andersen}
{\xe \v SVF::Andersen\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Andersen::initialize (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEQJ}
{\bkmkend AAAAAAAEQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initilize analysis \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize worklist\par
}{
Reimplemented from {\b SVF::AndersenBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::AndersenSFR} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQG \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::AndersenHLCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQH \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::AndersenHCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v mergeNodeToRep\:SVF::Andersen}
{\xe \v SVF::Andersen\:mergeNodeToRep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Andersen::mergeNodeToRep (NodeID  {\i nodeId}, NodeID  {\i newRepId}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPG}
{\bkmkend AAAAAAAHPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Merge sub node to its rep. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab if find gep edges inside SCC cycle, the rep node will become a PWC node and its pts should be collapsed later.\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab if the node to be merged is already a PWC node, the rep node will also become a PWC node as it will have a self-cycle gep edge.\par}
}{
Reimplemented in {\b SVF::AndersenWaveDiff} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v mergeSccNodes\:SVF::Andersen}
{\xe \v SVF::Andersen\:mergeSccNodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Andersen::mergeSccNodes (NodeID  {\i repNodeId}, const NodeBS &  {\i subNodes}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHPI}
{\bkmkend AAAAAAAHPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Merge sub node in a SCC cycle to their rep node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union points-to of subscc nodes into its rep nodes {\b Move} incoming/outgoing direct edges of sub node to rep node \par
}}
{\xe \v mergeSrcToTgt\:SVF::Andersen}
{\xe \v SVF::Andersen\:mergeSrcToTgt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Andersen::mergeSrcToTgt (NodeID  {\i nodeId}, NodeID  {\i newRepId}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPJ}
{\bkmkend AAAAAAAHPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
merge nodeId to newRepId. Return true if the newRepId is a PWC node \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
union pts of node to rep\par
move the edges from node to rep, and remove the node\par
set rep and sub relations\par
}{
Reimplemented in {\b SVF::AndersenSFR} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::AndersenHLCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPL \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::AndersenLCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processAddr\:SVF::Andersen}
{\xe \v SVF::Andersen\:processAddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Andersen::processAddr (const {\b AddrCGEdge} *  {\i addr}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPN}
{\bkmkend AAAAAAAHPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process address edges \par
}{
Reimplemented in {\b SVF::AndersenSCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processAllAddr\:SVF::Andersen}
{\xe \v SVF::Andersen\:processAllAddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Andersen::processAllAddr (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHPP}
{\bkmkend AAAAAAAHPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
handling various constraints }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process address edges \par
}}
{\xe \v processCopy\:SVF::Andersen}
{\xe \v SVF::Andersen\:processCopy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Andersen::processCopy (NodeID  {\i node}, const {\b ConstraintEdge} *  {\i edge}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPQ}
{\bkmkend AAAAAAAHPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process copy edges src \'96copy--> dst, union pts(dst) with pts(src) \par
}{
Reimplemented in {\b SVF::AndersenWaveDiff} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processGep\:SVF::Andersen}
{\xe \v SVF::Andersen\:processGep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Andersen::processGep (NodeID  {\i node}, const {\b GepCGEdge} *  {\i edge}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPS}
{\bkmkend AAAAAAAHPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process gep edges src \'96gep--> dst, for each srcPtdNode \\in pts(src) ==> add fieldSrcPtdNode into tmpDstPts union pts(dst) with tmpDstPts \par
}}
{\xe \v processGepPts\:SVF::Andersen}
{\xe \v SVF::Andersen\:processGepPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Andersen::processGepPts (const PointsTo &  {\i pts}, const {\b GepCGEdge} *  {\i edge}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPT}
{\bkmkend AAAAAAAHPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute points-to for gep edges \par
}}
{\xe \v processLoad\:SVF::Andersen}
{\xe \v SVF::Andersen\:processLoad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Andersen::processLoad (NodeID  {\i node}, const {\b ConstraintEdge} *  {\i load}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPU}
{\bkmkend AAAAAAAHPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process load edges src \'96load--> dst, node \\in pts(src) ==> node\'96copy-->dst \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO: New copy edges are also added for black hole obj node to make gcc in spec 2000 pass the flow-sensitive analysis. Try to handle black hole obj in an appropiate way.\par
}}
{\xe \v processNode\:SVF::Andersen}
{\xe \v SVF::Andersen\:processNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Andersen::processNode (NodeID  {\i nodeId}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPV}
{\bkmkend AAAAAAAHPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Override {\b WPASolver} function in order to use the default solver. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start constraint solving \par
}{
Reimplemented from {\b SVF::WPASolver< GraphType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::AndersenWaveDiff} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processStore\:SVF::Andersen}
{\xe \v SVF::Andersen\:processStore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Andersen::processStore (NodeID  {\i node}, const {\b ConstraintEdge} *  {\i store}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPY}
{\bkmkend AAAAAAAHPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process store edges src \'96store--> dst, node \\in pts(dst) ==> src\'96copy-->node \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO: New copy edges are also added for black hole obj node to make gcc in spec 2000 pass the flow-sensitive analysis. Try to handle black hole obj in an appropiate way\par
}}
{\xe \v SCCDetect\:SVF::Andersen}
{\xe \v SVF::Andersen\:SCCDetect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeStack & Andersen::SCCDetect (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPZ}
{\bkmkend AAAAAAAHPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC detection. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC detection on constraint graph \par
}{
Reimplemented from {\b SVF::WPASolver< GraphType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHQA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::AndersenSCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHQB \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::AndersenLCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHQC \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::AndersenWaveDiffWithType} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHQD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v unionPts\:SVF::Andersen}
{\xe \v SVF::Andersen\:unionPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool SVF::Andersen::unionPts (NodeID  {\i id}, const PointsTo &  {\i target}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAESO}
{\bkmkend AAAAAAAESO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union/add points-to. Add the reverse points-to for node collapse purpose To be noted that adding reverse pts might incur 10% total overhead during solving \par
}{
Reimplemented from {\b SVF::BVDataPTAImpl} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAESM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updateCallGraph\:SVF::Andersen}
{\xe \v SVF::Andersen\:updateCallGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Andersen::updateCallGraph (const CallSiteToFunPtrMap &  {\i callsites}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHQE}
{\bkmkend AAAAAAAHQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update call graph for the input indirect callsites. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update call graph for the input indirect callsites \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
nodes as a src of a generated new copy edge\par
}{
Reimplemented from {\b SVF::BVDataPTAImpl} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAERP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::AndersenSCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHQF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updateNodeRepAndSubs\:SVF::Andersen}
{\xe \v SVF::Andersen\:updateNodeRepAndSubs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Andersen::updateNodeRepAndSubs (NodeID  {\i nodeId}, NodeID  {\i newRepId}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHQG}
{\bkmkend AAAAAAAHQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Updates subnodes of its rep, and rep node of its subs. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
update nodeToRepMap, for each subs of current node updates its rep to newRepId\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/Andersen.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/Andersen.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::AndersenBase Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::AndersenBase}
{\xe \v SVF::AndersenBase}
{\bkmkstart AAAAAAAHMN}
{\bkmkend AAAAAAAHMN}
Inheritance diagram for SVF::AndersenBase:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_andersen_base.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b AndersenBase} ({\b PAG} *_pag, {\b PTATY} type={\b Andersen_BASE}, bool alias_check=true){\bkmkstart AAAAAAAHMO}
{\bkmkend AAAAAAAHMO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~AndersenBase} (){\bkmkstart AAAAAAAHMP}
{\bkmkend AAAAAAAHMP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b analyze} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Andersen} analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b finalize} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ConstraintGraph} * {\b getConstraintGraph} (){\bkmkstart AAAAAAAHMQ}
{\bkmkend AAAAAAAHMQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get constraint graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b printStat} (){\bkmkstart AAAAAAAHMR}
{\bkmkend AAAAAAAHMR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dump statistics }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b AndersenBase} *){\bkmkstart AAAAAAAHMS}
{\bkmkend AAAAAAAHMS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PointerAnalysis} *pta){\bkmkstart AAAAAAAHMT}
{\bkmkend AAAAAAAHMT}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static Size_t {\b numOfProcessedAddr} = 0{\bkmkstart AAAAAAAHMU}
{\bkmkend AAAAAAAHMU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static Size_t {\b numOfProcessedCopy} = 0{\bkmkstart AAAAAAAHMV}
{\bkmkend AAAAAAAHMV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of processed Addr edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static Size_t {\b numOfProcessedGep} = 0{\bkmkstart AAAAAAAHMW}
{\bkmkend AAAAAAAHMW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of processed Copy edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static Size_t {\b numOfProcessedLoad} = 0{\bkmkstart AAAAAAAHMX}
{\bkmkend AAAAAAAHMX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of processed Gep edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static Size_t {\b numOfProcessedStore} = 0{\bkmkstart AAAAAAAHMY}
{\bkmkend AAAAAAAHMY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of processed Load edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static Size_t {\b numOfSfrs} = 0{\bkmkstart AAAAAAAHMZ}
{\bkmkend AAAAAAAHMZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of processed Store edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static Size_t {\b numOfFieldExpand} = 0{\bkmkstart AAAAAAAHNA}
{\bkmkend AAAAAAAHNA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static Size_t {\b numOfSCCDetection} = 0{\bkmkstart AAAAAAAHNB}
{\bkmkend AAAAAAAHNB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static double {\b timeOfSCCDetection} = 0{\bkmkstart AAAAAAAHNC}
{\bkmkend AAAAAAAHNC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static double {\b timeOfSCCMerges} = 0{\bkmkstart AAAAAAAHND}
{\bkmkend AAAAAAAHND}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static double {\b timeOfCollapse} = 0{\bkmkstart AAAAAAAHNE}
{\bkmkend AAAAAAAHNE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static Size_t {\b AveragePointsToSetSize} = 0{\bkmkstart AAAAAAAHNF}
{\bkmkend AAAAAAAHNF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static Size_t {\b MaxPointsToSetSize} = 0{\bkmkstart AAAAAAAHNG}
{\bkmkend AAAAAAAHNG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static double {\b timeOfProcessCopyGep} = 0{\bkmkstart AAAAAAAHNH}
{\bkmkend AAAAAAAHNH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static double {\b timeOfProcessLoadStore} = 0{\bkmkstart AAAAAAAHNI}
{\bkmkend AAAAAAAHNI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static double {\b timeOfUpdateCallGraph} = 0{\bkmkstart AAAAAAAHNJ}
{\bkmkend AAAAAAAHNJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ConstraintGraph} * {\b consCG}{\bkmkstart AAAAAAAHNK}
{\bkmkend AAAAAAAHNK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraint Graph. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v analyze\:SVF::AndersenBase}
{\xe \v SVF::AndersenBase\:analyze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenBase::analyze (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHNL}
{\bkmkend AAAAAAAHNL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Andersen} analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Andersen} analysis \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialization for the Solver\par
}{
Implements {\b SVF::PointerAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAENH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::TypeAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHNM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v finalize\:SVF::AndersenBase}
{\xe \v SVF::AndersenBase\:finalize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenBase::finalize (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEPW}
{\bkmkend AAAAAAAEPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalize analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalize analysis \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dump constraint graph if PAGDotGraph flag is enabled\par
}{
Reimplemented from {\b SVF::PointerAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEPQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::TypeAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEPT \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEPV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v initialize\:SVF::AndersenBase}
{\xe \v SVF::AndersenBase\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenBase::initialize (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEQK}
{\bkmkend AAAAAAAEQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initilize analysis \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build {\b PAG}\par
Build Constraint Graph\par
Create statistic class\par
}{
Reimplemented from {\b SVF::PointerAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::TypeAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQE \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::AndersenSFR} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQG \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::AndersenHLCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::AndersenHCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQI \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/Andersen.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/Andersen.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::AndersenHCD Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::AndersenHCD}
{\xe \v SVF::AndersenHCD}
{\bkmkstart AAAAAAAHRM}
{\bkmkend AAAAAAAHRM}
\par
{
{\f2 #include <Andersen.h>}}\par
Inheritance diagram for SVF::AndersenHCD:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_andersen_h_c_d.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SCCDetection}< {\b OfflineConsG} * > {\b OSCC}{\bkmkstart AAAAAAAHRN}
{\bkmkend AAAAAAAHRN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b AndersenHCD} ({\b PAG} *_pag, {\b PTATY} type={\b AndersenHCD_WPA}){\bkmkstart AAAAAAAHRO}
{\bkmkend AAAAAAAHRO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b AndersenHCD} * {\b createAndersenHCD} ({\b PAG} *_pag){\bkmkstart AAAAAAAHRP}
{\bkmkend AAAAAAAHRP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an singleton instance directly instead of invoking llvm pass manager. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b releaseAndersenHCD} (){\bkmkstart AAAAAAAHRQ}
{\bkmkend AAAAAAAHRQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasOfflineRep} (NodeID nodeId) const{\bkmkstart AAAAAAAHRR}
{\bkmkend AAAAAAAHRR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getOfflineRep} (NodeID nodeId){\bkmkstart AAAAAAAHRS}
{\bkmkend AAAAAAAHRS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isaMergedNode} (NodeID node) const{\bkmkstart AAAAAAAHRT}
{\bkmkend AAAAAAAHRT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setMergedNode} (NodeID node){\bkmkstart AAAAAAAHRU}
{\bkmkend AAAAAAAHRU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b solveWorklist} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mergeSCC} (NodeID nodeId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mergeNodeAndPts} (NodeID node, NodeID tgt)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hybrid Cycle Detection Based {\b Andersen} Analysis \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:SVF::AndersenHCD}
{\xe \v SVF::AndersenHCD\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenHCD::initialize (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEQI}
{\bkmkend AAAAAAAEQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AndersenHCD} initilizer, including initilization of {\b PAG}, constraint graph and offline constraint graph \par
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::AndersenHLCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v mergeNodeAndPts\:SVF::AndersenHCD}
{\xe \v SVF::AndersenHCD\:mergeNodeAndPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenHCD::mergeNodeAndPts (NodeID  {\i node}, NodeID  {\i rep}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHRV}
{\bkmkend AAAAAAAHRV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Merge node and its pts to the rep node \par
}}
{\xe \v mergeSCC\:SVF::AndersenHCD}
{\xe \v SVF::AndersenHCD\:mergeSCC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenHCD::mergeSCC (NodeID  {\i nodeId}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHRW}
{\bkmkend AAAAAAAHRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collapse a node to its ref, if the ref exists \par
}{
Reimplemented in {\b SVF::AndersenHLCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHRX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v solveWorklist\:SVF::AndersenHCD}
{\xe \v SVF::AndersenHCD\:solveWorklist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenHCD::solveWorklist (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHRY}
{\bkmkend AAAAAAAHRY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AndersenHCD} worklist solver \par
}{
Reimplemented from {\b SVF::WPASolver< GraphType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHQQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/Andersen.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/AndersenHCD.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::AndersenHLCD Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::AndersenHLCD}
{\xe \v SVF::AndersenHLCD}
{\bkmkstart AAAAAAAHRZ}
{\bkmkend AAAAAAAHRZ}
\par
{
{\f2 #include <Andersen.h>}}\par
Inheritance diagram for SVF::AndersenHLCD:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_andersen_h_l_c_d.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b AndersenHLCD} ({\b PAG} *_pag, {\b PTATY} type={\b AndersenHLCD_WPA}){\bkmkstart AAAAAAAHSA}
{\bkmkend AAAAAAAHSA}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b AndersenHLCD} * {\b createAndersenHLCD} ({\b PAG} *_pag){\bkmkstart AAAAAAAHSB}
{\bkmkend AAAAAAAHSB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an singleton instance directly instead of invoking llvm pass manager. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b releaseAndersenHLCD} (){\bkmkstart AAAAAAAHSC}
{\bkmkend AAAAAAAHSC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b solveWorklist} (){\bkmkstart AAAAAAAHSD}
{\bkmkend AAAAAAAHSD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleCopyGep} ({\b ConstraintNode} *node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mergeSCC} (NodeID nodeId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mergeSrcToTgt} (NodeID nodeId, NodeID newRepId)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hybrid Lazy Cycle Detection Based {\b Andersen} Analysis \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v handleCopyGep\:SVF::AndersenHLCD}
{\xe \v SVF::AndersenHLCD\:handleCopyGep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVF::AndersenHLCD::handleCopyGep ({\b ConstraintNode} *  {\i node}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPB}
{\bkmkend AAAAAAAHPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process copy and gep edges \par
}{
Reimplemented from {\b SVF::AndersenLCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v initialize\:SVF::AndersenHLCD}
{\xe \v SVF::AndersenHLCD\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVF::AndersenHLCD::initialize (){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEQH}
{\bkmkend AAAAAAAEQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AndersenHCD} initilizer, including initilization of {\b PAG}, constraint graph and offline constraint graph \par
}{
Reimplemented from {\b SVF::AndersenHCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v mergeSCC\:SVF::AndersenHLCD}
{\xe \v SVF::AndersenHLCD\:mergeSCC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenHLCD::mergeSCC (NodeID  {\i nodeId}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHRX}
{\bkmkend AAAAAAAHRX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collapse nodes and fields based on the result of both offline and online SCC detection \par
}{
Reimplemented from {\b SVF::AndersenHCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHRW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v mergeSrcToTgt\:SVF::AndersenHLCD}
{\xe \v SVF::AndersenHLCD\:mergeSrcToTgt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::AndersenHLCD::mergeSrcToTgt (NodeID  {\i nodeId}, NodeID  {\i newRepId}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPL}
{\bkmkend AAAAAAAHPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
merge nodeId to newRepId. Return true if the newRepId is a PWC node \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
union pts of node to rep\par
move the edges from node to rep, and remove the node\par
set rep and sub relations\par
}{
Reimplemented from {\b SVF::AndersenLCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/Andersen.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/AndersenHLCD.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::AndersenLCD Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::AndersenLCD}
{\xe \v SVF::AndersenLCD}
{\bkmkstart AAAAAAAHRB}
{\bkmkend AAAAAAAHRB}
Inheritance diagram for SVF::AndersenLCD:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_andersen_l_c_d.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b AndersenLCD} ({\b PAG} *_pag, {\b PTATY} type={\b AndersenLCD_WPA}){\bkmkstart AAAAAAAHRC}
{\bkmkend AAAAAAAHRC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b AndersenLCD} * {\b createAndersenLCD} ({\b PAG} *_pag){\bkmkstart AAAAAAAHRD}
{\bkmkend AAAAAAAHRD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an singleton instance directly instead of invoking llvm pass manager. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b releaseAndersenLCD} (){\bkmkstart AAAAAAAHRE}
{\bkmkend AAAAAAAHRE}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasLCDCandidate} () const{\bkmkstart AAAAAAAHRF}
{\bkmkend AAAAAAAHRF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b cleanLCDCandidate} (){\bkmkstart AAAAAAAHRG}
{\bkmkend AAAAAAAHRG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addLCDCandidate} (NodeID nodeId){\bkmkstart AAAAAAAHRH}
{\bkmkend AAAAAAAHRH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isMetEdge} ({\b ConstraintEdge} *edge) const{\bkmkstart AAAAAAAHRI}
{\bkmkend AAAAAAAHRI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addMetEdge} ({\b ConstraintEdge} *edge){\bkmkstart AAAAAAAHRJ}
{\bkmkend AAAAAAAHRJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b solveWorklist} (){\bkmkstart AAAAAAAHRK}
{\bkmkend AAAAAAAHRK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleCopyGep} ({\b ConstraintNode} *node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mergeSCC} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeStack & {\b SCCDetect} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mergeSrcToTgt} (NodeID nodeId, NodeID newRepId)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v handleCopyGep\:SVF::AndersenLCD}
{\xe \v SVF::AndersenLCD\:handleCopyGep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenLCD::handleCopyGep ({\b ConstraintNode} *  {\i node}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPC}
{\bkmkend AAAAAAAHPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process copy and gep edges \par
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::AndersenHLCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v mergeSCC\:SVF::AndersenLCD}
{\xe \v SVF::AndersenLCD\:mergeSCC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenLCD::mergeSCC (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHRL}
{\bkmkend AAAAAAAHRL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collapse nodes and fields based on 'lcdCandidates' \par
}}
{\xe \v mergeSrcToTgt\:SVF::AndersenLCD}
{\xe \v SVF::AndersenLCD\:mergeSrcToTgt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool AndersenLCD::mergeSrcToTgt (NodeID  {\i nodeId}, NodeID  {\i newRepId}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPM}
{\bkmkend AAAAAAAHPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
merge nodeId to newRepId. Return true if the newRepId is a PWC node \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
union pts of node to rep\par
move the edges from node to rep, and remove the node\par
set rep and sub relations\par
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::AndersenHLCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v SCCDetect\:SVF::AndersenLCD}
{\xe \v SVF::AndersenLCD\:SCCDetect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeStack & AndersenLCD::SCCDetect (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHQC}
{\bkmkend AAAAAAAHQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b AndersenLCD} specified SCC detector, need to input a nodeStack 'lcdCandidate' \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detect SCC cycles\par
Merge SCC cycles\par
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/Andersen.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/AndersenLCD.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::AndersenSCD Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::AndersenSCD}
{\xe \v SVF::AndersenSCD}
{\bkmkstart AAAAAAAHSE}
{\bkmkend AAAAAAAHSE}
\par
{
{\f2 #include <AndersenSFR.h>}}\par
Inheritance diagram for SVF::AndersenSCD:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_andersen_s_c_d.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, NodeID > {\b NodeToNodeMap}{\bkmkstart AAAAAAAHSF}
{\bkmkend AAAAAAAHSF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b AndersenSCD} ({\b PAG} *_pag, {\b PTATY} type={\b AndersenSCD_WPA}){\bkmkstart AAAAAAAHSG}
{\bkmkend AAAAAAAHSG}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b AndersenSCD} * {\b createAndersenSCD} ({\b PAG} *_pag){\bkmkstart AAAAAAAHSH}
{\bkmkend AAAAAAAHSH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an singleton instance directly instead of invoking llvm pass manager. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b releaseAndersenSCD} (){\bkmkstart AAAAAAAHSI}
{\bkmkend AAAAAAAHSI}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addSccCandidate} (NodeID nodeId){\bkmkstart AAAAAAAHSJ}
{\bkmkend AAAAAAAHSJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual NodeStack & {\b SCCDetect} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b PWCDetect} (){\bkmkstart AAAAAAAHSK}
{\bkmkend AAAAAAAHSK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b solveWorklist} (){\bkmkstart AAAAAAAHSL}
{\bkmkend AAAAAAAHSL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleLoadStore} ({\b ConstraintNode} *node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b processAddr} (const {\b AddrCGEdge} *addr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b addCopyEdge} (NodeID src, NodeID dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b updateCallGraph} (const CallSiteToFunPtrMap &callsites)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b processPWC} ({\b ConstraintNode} *rep){\bkmkstart AAAAAAAHSM}
{\bkmkend AAAAAAAHSM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleCopyGep} ({\b ConstraintNode} *node)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeSet {\b sccCandidates}{\bkmkstart AAAAAAAHSN}
{\bkmkend AAAAAAAHSN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeToNodeMap {\b pwcReps}{\bkmkstart AAAAAAAHSO}
{\bkmkend AAAAAAAHSO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b AndersenSCD} * {\b scdAndersen} = NULL{\bkmkstart AAAAAAAHSP}
{\bkmkend AAAAAAAHSP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Selective Cycle Detection Based {\b Andersen} Analysis \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addCopyEdge\:SVF::AndersenSCD}
{\xe \v SVF::AndersenSCD\:addCopyEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool AndersenSCD::addCopyEdge (NodeID  {\i src}, NodeID  {\i dst}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHSQ}
{\bkmkend AAAAAAAHSQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If one copy edge is successful added, the src node should be added into SCC detection \par
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHOJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v handleCopyGep\:SVF::AndersenSCD}
{\xe \v SVF::AndersenSCD\:handleCopyGep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenSCD::handleCopyGep ({\b ConstraintNode} *  {\i node}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPA}
{\bkmkend AAAAAAAHPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute diff points-to set before propagation \par
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v handleLoadStore\:SVF::AndersenSCD}
{\xe \v SVF::AndersenSCD\:handleLoadStore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenSCD::handleLoadStore ({\b ConstraintNode} *  {\i node}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPF}
{\bkmkend AAAAAAAHPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source nodes of new added edges are pushed into sccCandidates. Source nodes of new added edges whose pts differ from those of dst nodes are pushed into worklist. \par
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processAddr\:SVF::AndersenSCD}
{\xe \v SVF::AndersenSCD\:processAddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenSCD::processAddr (const {\b AddrCGEdge} *  {\i addr}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPO}
{\bkmkend AAAAAAAHPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize worklist via processing addrs \par
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v SCCDetect\:SVF::AndersenSCD}
{\xe \v SVF::AndersenSCD\:SCCDetect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeStack & AndersenSCD::SCCDetect (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHQB}
{\bkmkend AAAAAAAHQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC detection for SCD \par
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updateCallGraph\:SVF::AndersenSCD}
{\xe \v SVF::AndersenSCD\:updateCallGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool AndersenSCD::updateCallGraph (const CallSiteToFunPtrMap &  {\i callsites}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHQF}
{\bkmkend AAAAAAAHQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update call graph for the input indirect callsites \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
nodes as a src of a generated new copy edge\par
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHQE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/AndersenSFR.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/AndersenSCD.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::AndersenSFR Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::AndersenSFR}
{\xe \v SVF::AndersenSFR}
{\bkmkstart AAAAAAAHSR}
{\bkmkend AAAAAAAHSR}
\par
{
{\f2 #include <AndersenSFR.h>}}\par
Inheritance diagram for SVF::AndersenSFR:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_andersen_s_f_r.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, NodeBS > {\b NodeStrides}{\bkmkstart AAAAAAAHSS}
{\bkmkend AAAAAAAHSS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, NodeSet > {\b FieldReps}{\bkmkstart AAAAAAAHST}
{\bkmkend AAAAAAAHST}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, pair< NodeID, NodeSet > > {\b SFRTrait}{\bkmkstart AAAAAAAHSU}
{\bkmkend AAAAAAAHSU}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b AndersenSFR} ({\b PAG} *_pag, {\b PTATY} type={\b AndersenSFR_WPA}){\bkmkstart AAAAAAAHSV}
{\bkmkend AAAAAAAHSV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b AndersenSFR} * {\b createAndersenSFR} ({\b PAG} *_pag){\bkmkstart AAAAAAAHSW}
{\bkmkend AAAAAAAHSW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an singleton instance directly instead of invoking llvm pass manager. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b releaseAndersenSFR} (){\bkmkstart AAAAAAAHSX}
{\bkmkend AAAAAAAHSX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PWCDetect} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b fieldExpand} (NodeSet &initials, Size_t offset, NodeBS &strides, PointsTo &expandPts){\bkmkstart AAAAAAAHSY}
{\bkmkend AAAAAAAHSY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b processGepPts} (PointsTo &pts, const {\b GepCGEdge} *edge)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b mergeSrcToTgt} (NodeID nodeId, NodeID newRepId)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Selective Cycle Detection with Stride-based Field Representation \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:SVF::AndersenSFR}
{\xe \v SVF::AndersenSFR\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenSFR::initialize (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEQG}
{\bkmkend AAAAAAAEQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initilize analysis \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize worklist\par
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v mergeSrcToTgt\:SVF::AndersenSFR}
{\xe \v SVF::AndersenSFR\:mergeSrcToTgt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool AndersenSFR::mergeSrcToTgt (NodeID  {\i nodeId}, NodeID  {\i newRepId}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPK}
{\bkmkend AAAAAAAHPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
merge nodeId to newRepId. Return true if the newRepId is a PWC node \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
union pts of node to rep\par
move the edges from node to rep, and remove the node\par
set rep and sub relations\par
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processGepPts\:SVF::AndersenSFR}
{\xe \v SVF::AndersenSFR\:processGepPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool AndersenSFR::processGepPts (PointsTo &  {\i pts}, const {\b GepCGEdge} *  {\i edge}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHSZ}
{\bkmkend AAAAAAAHSZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate point-to set via a gep edge, using SFR \par
}}
{\xe \v PWCDetect\:SVF::AndersenSFR}
{\xe \v SVF::AndersenSFR\:PWCDetect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenSFR::PWCDetect (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHTA}
{\bkmkend AAAAAAAHTA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call the PWC stride calculation method of class {\b CSC}. \par
}{
Reimplemented from {\b SVF::AndersenSCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHSE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/AndersenSFR.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/AndersenSFR.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::AndersenStat Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::AndersenStat}
{\xe \v SVF::AndersenStat}
{\bkmkstart AAAAAAAICG}
{\bkmkend AAAAAAAICG}
\par
{
{\f2 #include <WPAStat.h>}}\par
Inheritance diagram for SVF::AndersenStat:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_andersen_stat.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AndersenStat} ({\b AndersenBase} *p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b performStat} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b collectCycleInfo} ({\b ConstraintGraph} *consCG)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b statNullPtr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b constraintGraphStat} (){\bkmkstart AAAAAAAICH}
{\bkmkend AAAAAAAICH}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b _NumOfNullPtr}{\bkmkstart AAAAAAAICI}
{\bkmkend AAAAAAAICI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b _NumOfConstantPtr}{\bkmkstart AAAAAAAICJ}
{\bkmkend AAAAAAAICJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b _NumOfBlackholePtr}{\bkmkstart AAAAAAAICK}
{\bkmkend AAAAAAAICK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b CollapseTime} = "CollapseTime"{\bkmkstart AAAAAAAICL}
{\bkmkend AAAAAAAICL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u32_t {\b _MaxPtsSize} = 0{\bkmkstart AAAAAAAICM}
{\bkmkend AAAAAAAICM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u32_t {\b _NumOfCycles} = 0{\bkmkstart AAAAAAAICN}
{\bkmkend AAAAAAAICN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u32_t {\b _NumOfPWCCycles} = 0{\bkmkstart AAAAAAAICO}
{\bkmkend AAAAAAAICO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u32_t {\b _NumOfNodesInCycles} = 0{\bkmkstart AAAAAAAICP}
{\bkmkend AAAAAAAICP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u32_t {\b _MaxNumOfNodesInSCC} = 0{\bkmkstart AAAAAAAICQ}
{\bkmkend AAAAAAAICQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics of {\b Andersen}'s analysis \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AndersenStat\:SVF::AndersenStat}
{\xe \v SVF::AndersenStat\:AndersenStat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AndersenStat::AndersenStat ({\b AndersenBase} *  {\i p})}}
\par
{\bkmkstart AAAAAAAICR}
{\bkmkend AAAAAAAICR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v collectCycleInfo\:SVF::AndersenStat}
{\xe \v SVF::AndersenStat\:collectCycleInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenStat::collectCycleInfo ({\b ConstraintGraph} *  {\i consCG})}}
\par
{\bkmkstart AAAAAAAICS}
{\bkmkend AAAAAAAICS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect cycle information \par
}}
{\xe \v performStat\:SVF::AndersenStat}
{\xe \v SVF::AndersenStat\:performStat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenStat::performStat (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAICT}
{\bkmkend AAAAAAAICT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start here \par
}{
Reimplemented from {\b SVF::PTAStat} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABEG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v statNullPtr\:SVF::AndersenStat}
{\xe \v SVF::AndersenStat\:statNullPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenStat::statNullPtr ()}}
\par
{\bkmkstart AAAAAAAICU}
{\bkmkend AAAAAAAICU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stat null pointers \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO: change the condition here to fetch the points-to set\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/WPAStat.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/AndersenStat.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::AndersenWaveDiff Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::AndersenWaveDiff}
{\xe \v SVF::AndersenWaveDiff}
{\bkmkstart AAAAAAAHQH}
{\bkmkend AAAAAAAHQH}
\par
{
{\f2 #include <Andersen.h>}}\par
Inheritance diagram for SVF::AndersenWaveDiff:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_andersen_wave_diff.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b AndersenWaveDiff} ({\b PAG} *_pag, {\b PTATY} type={\b AndersenWaveDiff_WPA}, bool alias_check=true){\bkmkstart AAAAAAAHQI}
{\bkmkend AAAAAAAHQI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b solveWorklist} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b processNode} (NodeID nodeId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b postProcessNode} (NodeID nodeId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleCopyGep} ({\b ConstraintNode} *node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b handleLoad} (NodeID id, const {\b ConstraintEdge} *load)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b handleStore} (NodeID id, const {\b ConstraintEdge} *store)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processCopy} (NodeID node, const {\b ConstraintEdge} *edge)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b AndersenWaveDiff} * {\b createAndersenWaveDiff} ({\b PAG} *_pag){\bkmkstart AAAAAAAHQJ}
{\bkmkend AAAAAAAHQJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an singleton instance directly instead of invoking llvm pass manager. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b releaseAndersenWaveDiff} (){\bkmkstart AAAAAAAHQK}
{\bkmkend AAAAAAAHQK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mergeNodeToRep} (NodeID nodeId, NodeID newRepId)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Merge sub node to its rep. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b processCast} (const {\b ConstraintEdge} *){\bkmkstart AAAAAAAHQL}
{\bkmkend AAAAAAAHQL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
process "bitcast" {\b CopyCGEdge} }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wave propagation with diff points-to set. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v handleCopyGep\:SVF::AndersenWaveDiff}
{\xe \v SVF::AndersenWaveDiff\:handleCopyGep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenWaveDiff::handleCopyGep ({\b ConstraintNode} *  {\i node}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPD}
{\bkmkend AAAAAAAHPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle copy gep \par
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHOZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v handleLoad\:SVF::AndersenWaveDiff}
{\xe \v SVF::AndersenWaveDiff\:handleLoad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool AndersenWaveDiff::handleLoad (NodeID  {\i nodeId}, const {\b ConstraintEdge} *  {\i edge}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHQM}
{\bkmkend AAAAAAAHQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle load \par
}}
{\xe \v handleStore\:SVF::AndersenWaveDiff}
{\xe \v SVF::AndersenWaveDiff\:handleStore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool AndersenWaveDiff::handleStore (NodeID  {\i nodeId}, const {\b ConstraintEdge} *  {\i edge}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHQN}
{\bkmkend AAAAAAAHQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle store \par
}}
{\xe \v mergeNodeToRep\:SVF::AndersenWaveDiff}
{\xe \v SVF::AndersenWaveDiff\:mergeNodeToRep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenWaveDiff::mergeNodeToRep (NodeID  {\i nodeId}, NodeID  {\i newRepId}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPH}
{\bkmkend AAAAAAAHPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Merge sub node to its rep. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
update rep's propagated points-to set\par
{
\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab if find gep edges inside SCC cycle, the rep node will become a PWC node and its pts should be collapsed later.\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab if the node to be merged is already a PWC node, the rep node will also become a PWC node as it will have a self-cycle gep edge.\par}
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v postProcessNode\:SVF::AndersenWaveDiff}
{\xe \v SVF::AndersenWaveDiff\:postProcessNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenWaveDiff::postProcessNode (NodeID  {\i nodeId}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHQO}
{\bkmkend AAAAAAAHQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Post process node \par
}}
{\xe \v processCopy\:SVF::AndersenWaveDiff}
{\xe \v SVF::AndersenWaveDiff\:processCopy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool AndersenWaveDiff::processCopy (NodeID  {\i node}, const {\b ConstraintEdge} *  {\i edge}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPR}
{\bkmkend AAAAAAAHPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate diff points-to set from src to dst \par
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processNode\:SVF::AndersenWaveDiff}
{\xe \v SVF::AndersenWaveDiff\:processNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenWaveDiff::processNode (NodeID  {\i nodeId}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPX}
{\bkmkend AAAAAAAHPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process edge {\b PAGNode} \par
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v solveWorklist\:SVF::AndersenWaveDiff}
{\xe \v SVF::AndersenWaveDiff\:solveWorklist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenWaveDiff::solveWorklist (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHQP}
{\bkmkend AAAAAAAHQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
solve worklist \par
}{
Reimplemented from {\b SVF::WPASolver< GraphType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHQQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/Andersen.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/AndersenWaveDiff.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::AndersenWaveDiffWithType Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::AndersenWaveDiffWithType}
{\xe \v SVF::AndersenWaveDiffWithType}
{\bkmkstart AAAAAAAHQR}
{\bkmkend AAAAAAAHQR}
\par
{
{\f2 #include <Andersen.h>}}\par
Inheritance diagram for SVF::AndersenWaveDiffWithType:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_andersen_wave_diff_with_type.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b AndersenWaveDiffWithType} ({\b PAG} *_pag, {\b PTATY} type={\b AndersenWaveDiffWithType_WPA}){\bkmkstart AAAAAAAHQS}
{\bkmkend AAAAAAAHQS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b AndersenWaveDiffWithType} * {\b createAndersenWaveDiffWithType} ({\b PAG} *p){\bkmkstart AAAAAAAHQT}
{\bkmkend AAAAAAAHQT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an singleton instance directly instead of invoking llvm pass manager. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b releaseAndersenWaveDiffWithType} (){\bkmkstart AAAAAAAHQU}
{\bkmkend AAAAAAAHQU}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual NodeStack & {\b SCCDetect} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC detection. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mergeTypeOfNodes} (const NodeBS &nodes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
merge types of nodes in a cycle }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b processCast} (const {\b ConstraintEdge} *edge){\bkmkstart AAAAAAAHQV}
{\bkmkend AAAAAAAHQV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
process "bitcast" {\b CopyCGEdge} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b updateObjType} (const Type *type, const PointsTo &objs){\bkmkstart AAAAAAAHQW}
{\bkmkend AAAAAAAHQW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
update type of objects when process "bitcast" {\b CopyCGEdge} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b processTypeMismatchedGep} (NodeID obj, const Type *type){\bkmkstart AAAAAAAHQX}
{\bkmkend AAAAAAAHQX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
process mismatched gep edges }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b matchType} (NodeID ptrid, NodeID objid, const {\b NormalGepCGEdge} *normalGepEdge){\bkmkstart AAAAAAAHQY}
{\bkmkend AAAAAAAHQY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
match types for Gep Edges }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b addTypeForGepObjNode} (NodeID id, const {\b NormalGepCGEdge} *normalGepEdge){\bkmkstart AAAAAAAHQZ}
{\bkmkend AAAAAAAHQZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add type for newly created GepObjNode }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wave propagation with diff points-to set with type filter. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v mergeTypeOfNodes\:SVF::AndersenWaveDiffWithType}
{\xe \v SVF::AndersenWaveDiffWithType\:mergeTypeOfNodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AndersenWaveDiffWithType::mergeTypeOfNodes (const NodeBS &  {\i nodes}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHRA}
{\bkmkend AAAAAAAHRA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
merge types of nodes in a cycle }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
collect types in a cycle\par
merge types of nodes in a cycle\par
}}
{\xe \v SCCDetect\:SVF::AndersenWaveDiffWithType}
{\xe \v SVF::AndersenWaveDiffWithType\:SCCDetect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeStack & AndersenWaveDiffWithType::SCCDetect (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHQD}
{\bkmkend AAAAAAAHQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC detection. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
merge types of nodes in SCC\par
}{
Reimplemented from {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/Andersen.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/AndersenWaveDiffWithType.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::Annotator Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::Annotator}
{\xe \v SVF::Annotator}
{\bkmkstart AAAAAAAGSG}
{\bkmkend AAAAAAAGSG}
\par
{
{\f2 #include <Annotator.h>}}\par
Inheritance diagram for SVF::Annotator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_annotator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Annotator} (){\bkmkstart AAAAAAAGSH}
{\bkmkend AAAAAAAGSH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~Annotator} (){\bkmkstart AAAAAAAGSI}
{\bkmkend AAAAAAAGSI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasSBSourceFlag} (Instruction *inst) const{\bkmkstart AAAAAAAGSJ}
{\bkmkend AAAAAAAGSJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SB Has flag methods. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasSBSinkFlag} (Instruction *inst) const{\bkmkstart AAAAAAAGSK}
{\bkmkend AAAAAAAGSK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasDRNotCheckFlag} (Instruction *inst) const{\bkmkstart AAAAAAAGSL}
{\bkmkend AAAAAAAGSL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Race Detection Has flag methods. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasDRNotCheckFlag} (const Instruction *inst) const{\bkmkstart AAAAAAAGSM}
{\bkmkend AAAAAAAGSM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasDRCheckFlag} (Instruction *inst) const{\bkmkstart AAAAAAAGSN}
{\bkmkend AAAAAAAGSN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasDRCheckFlag} (const Instruction *inst) const{\bkmkstart AAAAAAAGSO}
{\bkmkend AAAAAAAGSO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addMDTag} (Instruction *inst, std::string str){\bkmkstart AAAAAAAGSP}
{\bkmkend AAAAAAAGSP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simple add/remove meta data information. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeMDTag} (Instruction *inst, std::string str){\bkmkstart AAAAAAAGSQ}
{\bkmkend AAAAAAAGSQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addMDTag} (Instruction *inst, Value *val, std::string str)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
manipulate llvm meta data on instructions for a specific value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeMDTag} (Instruction *inst, Value *val, std::string str){\bkmkstart AAAAAAAGSR}
{\bkmkend AAAAAAAGSR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
remove flag from llvm metadata }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const char * {\b SB_SLICESOURCE}{\bkmkstart AAAAAAAGSS}
{\bkmkend AAAAAAAGSS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Saber annotations. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const char * {\b SB_SLICESINK}{\bkmkstart AAAAAAAGST}
{\bkmkend AAAAAAAGST}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const char * {\b SB_FESIBLE}{\bkmkstart AAAAAAAGSU}
{\bkmkend AAAAAAAGSU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const char * {\b SB_INFESIBLE}{\bkmkstart AAAAAAAGSV}
{\bkmkend AAAAAAAGSV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const char * {\b DR_NOT_CHECK}{\bkmkstart AAAAAAAGSW}
{\bkmkend AAAAAAAGSW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Race Detection annotations. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const char * {\b DR_CHECK}{\bkmkstart AAAAAAAGSX}
{\bkmkend AAAAAAAGSX}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Program annotator to write meta data information on LLVM IR \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addMDTag\:SVF::Annotator}
{\xe \v SVF::Annotator\:addMDTag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVF::Annotator::addMDTag (Instruction *  {\i inst}, Value *  {\i val}, std::string  {\i str}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAGSY}
{\bkmkend AAAAAAAGSY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
manipulate llvm meta data on instructions for a specific value }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add flag to llvm metadata \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Annotator.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ArgumentVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ArgumentVFGNode}
{\xe \v SVF::ArgumentVFGNode}
{\bkmkstart AAAAAAADSX}
{\bkmkend AAAAAAADSX}
Inheritance diagram for SVF::ArgumentVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_argument_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ArgumentVFGNode} (NodeID id, const {\b PAGNode} *p, {\b VFGNodeK} k){\bkmkstart AAAAAAADSY}
{\bkmkend AAAAAAADSY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isPTANode} () const{\bkmkstart AAAAAAADSZ}
{\bkmkend AAAAAAADSZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this argument node is of pointer type (used for pointer analysis). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADTA}
{\bkmkend AAAAAAADTA}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ArgumentVFGNode} *){\bkmkstart AAAAAAADTB}
{\bkmkend AAAAAAADTB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADTC}
{\bkmkend AAAAAAADTC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADTD}
{\bkmkend AAAAAAADTD}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b param}{\bkmkstart AAAAAAADTE}
{\bkmkend AAAAAAADTE}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::BddCondManager Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::BddCondManager}
{\xe \v SVF::BddCondManager}
{\bkmkstart AAAAAAAGUM}
{\bkmkend AAAAAAAGUM}
\par
{
{\f2 #include <Conditions.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b BddCondManager} (){\bkmkstart AAAAAAAGUN}
{\bkmkend AAAAAAAGUN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ~BddCondManager} (){\bkmkstart AAAAAAAGUO}
{\bkmkend AAAAAAAGUO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b Cudd_bdd} (u32_t i){\bkmkstart AAAAAAAGUP}
{\bkmkend AAAAAAAGUP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned {\b BddVarNum} (){\bkmkstart AAAAAAAGUQ}
{\bkmkend AAAAAAAGUQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b getTrueCond} () const{\bkmkstart AAAAAAAGUR}
{\bkmkend AAAAAAAGUR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b getFalseCond} () const{\bkmkstart AAAAAAAGUS}
{\bkmkend AAAAAAAGUS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getBDDMemUsage} (){\bkmkstart AAAAAAAGUT}
{\bkmkend AAAAAAAGUT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getCondNumber} (){\bkmkstart AAAAAAAGUU}
{\bkmkend AAAAAAAGUU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getMaxLiveCondNumber} (){\bkmkstart AAAAAAAGUV}
{\bkmkend AAAAAAAGUV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b markForRelease} ({\b DdNode} *cond){\bkmkstart AAAAAAAGUW}
{\bkmkend AAAAAAAGUW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DdNode} * {\b AND} ({\b DdNode} *lhs, {\b DdNode} *rhs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operations on conditions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DdNode} * {\b OR} ({\b DdNode} *lhs, {\b DdNode} *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b NEG} ({\b DdNode} *lhs){\bkmkstart AAAAAAAGUX}
{\bkmkend AAAAAAAGUX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ddClearFlag} ({\b DdNode} *f) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b BddSupportStep} ({\b DdNode} *f, NodeBS &support) const{\bkmkstart AAAAAAAGUY}
{\bkmkend AAAAAAAGUY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b BddSupport} ({\b DdNode} *f, NodeBS &support) const{\bkmkstart AAAAAAAGUZ}
{\bkmkend AAAAAAAGUZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump} ({\b DdNode} *lhs, {\b raw_ostream} &O)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b dumpStr} ({\b DdNode} *lhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b printMinterms} ({\b DdNode} *d){\bkmkstart AAAAAAAGVA}
{\bkmkend AAAAAAAGVA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
print minterms and debug information for the Ddnode }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b printDbg} ({\b DdNode} *d){\bkmkstart AAAAAAAGVB}
{\bkmkend AAAAAAAGVB}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Using Cudd as conditions. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AND\:SVF::BddCondManager}
{\xe \v SVF::BddCondManager\:AND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DdNode} * BddCondManager::AND ({\b DdNode} *  {\i lhs}, {\b DdNode} *  {\i rhs})}}
\par
{\bkmkstart AAAAAAAGVC}
{\bkmkend AAAAAAAGVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operations on conditions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
use Cudd_bddAndLimit interface to avoid bdds blow up \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
drop the rhs condition\par
}}
{\xe \v ddClearFlag\:SVF::BddCondManager}
{\xe \v SVF::BddCondManager\:ddClearFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BddCondManager::ddClearFlag ({\b DdNode} *  {\i f}) const}}
\par
{\bkmkstart AAAAAAAGVD}
{\bkmkend AAAAAAAGVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Utilities for dumping conditions. These methods use global functions from CUDD package and they can be removed outside this class scope to be used by others. \par
}}
{\xe \v dump\:SVF::BddCondManager}
{\xe \v SVF::BddCondManager\:dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BddCondManager::dump ({\b DdNode} *  {\i lhs}, {\b raw_ostream} &  {\i O})}}
\par
{\bkmkstart AAAAAAAGVE}
{\bkmkend AAAAAAAGVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump BDD \par
}}
{\xe \v dumpStr\:SVF::BddCondManager}
{\xe \v SVF::BddCondManager\:dumpStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string BddCondManager::dumpStr ({\b DdNode} *  {\i lhs}) const}}
\par
{\bkmkstart AAAAAAAGVF}
{\bkmkend AAAAAAAGVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump BDD \par
}}
{\xe \v OR\:SVF::BddCondManager}
{\xe \v SVF::BddCondManager\:OR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DdNode} * BddCondManager::OR ({\b DdNode} *  {\i lhs}, {\b DdNode} *  {\i rhs})}}
\par
{\bkmkstart AAAAAAAGVG}
{\bkmkend AAAAAAAGVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Use Cudd_bddOrLimit interface to avoid bdds blow up \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
drop the two conditions here\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Conditions.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Util/Conditions.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::BinaryOPPE Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::BinaryOPPE}
{\xe \v SVF::BinaryOPPE}
{\bkmkstart AAAAAAACIZ}
{\bkmkend AAAAAAACIZ}
\par
{
{\f2 #include <PAGEdge.h>}}\par
Inheritance diagram for SVF::BinaryOPPE:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_binary_o_p_p_e.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b BinaryOPPE} ({\b PAGNode} *s, {\b PAGNode} *d){\bkmkstart AAAAAAACJA}
{\bkmkend AAAAAAACJA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACJB}
{\bkmkend AAAAAAACJB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b BinaryOPPE} *){\bkmkstart AAAAAAACJC}
{\bkmkend AAAAAAACJC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGEdge} *edge){\bkmkstart AAAAAAACJD}
{\bkmkend AAAAAAACJD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGEdgeTy} *edge){\bkmkstart AAAAAAACJE}
{\bkmkend AAAAAAACJE}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Binary instruction edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::BinaryOPVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::BinaryOPVFGNode}
{\xe \v SVF::BinaryOPVFGNode}
{\bkmkstart AAAAAAADQF}
{\bkmkend AAAAAAADQF}
\par
{
{\f2 #include <VFGNode.h>}}\par
Inheritance diagram for SVF::BinaryOPVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_binary_o_p_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< u32_t, const {\b PAGNode} * > {\b OPVers}{\bkmkstart AAAAAAADQG}
{\bkmkend AAAAAAADQG}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b BinaryOPVFGNode} (NodeID id, const {\b PAGNode} *r){\bkmkstart AAAAAAADQH}
{\bkmkend AAAAAAADQH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getOpVer} (u32_t pos) const{\bkmkstart AAAAAAADQI}
{\bkmkend AAAAAAADQI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operands at a BinaryNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setOpVer} (u32_t pos, const {\b PAGNode} *node){\bkmkstart AAAAAAADQJ}
{\bkmkend AAAAAAADQJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getRes} () const{\bkmkstart AAAAAAADQK}
{\bkmkend AAAAAAADQK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getOpVerNum} () const{\bkmkstart AAAAAAADQL}
{\bkmkend AAAAAAADQL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers::const_iterator {\b opVerBegin} () const{\bkmkstart AAAAAAADQM}
{\bkmkend AAAAAAADQM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers::const_iterator {\b opVerEnd} () const{\bkmkstart AAAAAAADQN}
{\bkmkend AAAAAAADQN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADQO}
{\bkmkend AAAAAAADQO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b BinaryOPVFGNode} *){\bkmkstart AAAAAAADQP}
{\bkmkend AAAAAAADQP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADQQ}
{\bkmkend AAAAAAADQQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADQR}
{\bkmkend AAAAAAADQR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b res}{\bkmkstart AAAAAAADQS}
{\bkmkend AAAAAAADQS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers {\b opVers}{\bkmkstart AAAAAAADQT}
{\bkmkend AAAAAAADQT}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b VFGNode} for binary operator instructions, e.g., a = b + c; \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::BreakConstantGEPs Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::BreakConstantGEPs}
{\xe \v SVF::BreakConstantGEPs}
{\bkmkstart AAAAAAAGDM}
{\bkmkend AAAAAAAGDM}
Inheritance diagram for SVF::BreakConstantGEPs:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_break_constant_g_e_ps.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

StringRef {\b getPassName} () const{\bkmkstart AAAAAAAGDN}
{\bkmkend AAAAAAAGDN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b runOnModule} (Module &M){\bkmkstart AAAAAAAGDO}
{\bkmkend AAAAAAAGDO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b getAnalysisUsage} (AnalysisUsage &AU) const{\bkmkstart AAAAAAAGDP}
{\bkmkend AAAAAAAGDP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static char {\b ID} = 0{\bkmkstart AAAAAAAGDQ}
{\bkmkend AAAAAAAGDQ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/BreakConstantExpr.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/BreakConstantExpr.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::BVDataPTAImpl Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::BVDataPTAImpl}
{\xe \v SVF::BVDataPTAImpl}
{\bkmkstart AAAAAAAEQW}
{\bkmkend AAAAAAAEQW}
\par
{
{\f2 #include <PointerAnalysisImpl.h>}}\par
Inheritance diagram for SVF::BVDataPTAImpl:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_b_v_data_p_t_a_impl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b PTData}< NodeID, NodeID, PointsTo > {\b PTDataTy}{\bkmkstart AAAAAAAEQX}
{\bkmkend AAAAAAAEQX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MutablePTData}< NodeID, NodeID, PointsTo > {\b MutPTDataTy}{\bkmkstart AAAAAAAEQY}
{\bkmkend AAAAAAAEQY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b DiffPTData}< NodeID, NodeID, PointsTo > {\b DiffPTDataTy}{\bkmkstart AAAAAAAEQZ}
{\bkmkend AAAAAAAEQZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MutableDiffPTData}< NodeID, NodeID, PointsTo > {\b MutDiffPTDataTy}{\bkmkstart AAAAAAAERA}
{\bkmkend AAAAAAAERA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b DFPTData}< NodeID, NodeID, PointsTo > {\b DFPTDataTy}{\bkmkstart AAAAAAAERB}
{\bkmkend AAAAAAAERB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MutableDFPTData}< NodeID, NodeID, PointsTo > {\b MutDFPTDataTy}{\bkmkstart AAAAAAAERC}
{\bkmkend AAAAAAAERC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b IncMutableDFPTData}< NodeID, NodeID, PointsTo > {\b IncMutDFPTDataTy}{\bkmkstart AAAAAAAERD}
{\bkmkend AAAAAAAERD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b VersionedPTData}< NodeID, NodeID, PointsTo, VersionedVar > {\b VersionedPTDataTy}{\bkmkstart AAAAAAAERE}
{\bkmkend AAAAAAAERE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MutableVersionedPTData}< NodeID, NodeID, PointsTo, VersionedVar > {\b MutVersionedPTDataTy}{\bkmkstart AAAAAAAERF}
{\bkmkend AAAAAAAERF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BVDataPTAImpl} ({\b PAG} *{\b pag}, {\b PointerAnalysis::PTATY} type, bool alias_check=true)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~BVDataPTAImpl} (){\bkmkstart AAAAAAAERG}
{\bkmkend AAAAAAAERG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b destroy} (){\bkmkstart AAAAAAAERH}
{\bkmkend AAAAAAAERH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Release memory. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PointerAnalysis} *pta){\bkmkstart AAAAAAAERI}
{\bkmkend AAAAAAAERI}
\par
}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const PointsTo & {\b getPts} (NodeID id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const NodeSet & {\b getRevPts} (NodeID nodeId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearPts} (NodeID id, NodeID element){\bkmkstart AAAAAAAERJ}
{\bkmkend AAAAAAAERJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove element from the points-to set of id. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearFullPts} (NodeID id){\bkmkstart AAAAAAAERK}
{\bkmkend AAAAAAAERK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear points-to set of id. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b unionPts} (NodeID id, const PointsTo &target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (NodeID id, NodeID ptd){\bkmkstart AAAAAAAERL}
{\bkmkend AAAAAAAERL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b addPts} (NodeID id, NodeID ptd){\bkmkstart AAAAAAAERM}
{\bkmkend AAAAAAAERM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearAllPts} (){\bkmkstart AAAAAAAERN}
{\bkmkend AAAAAAAERN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear all data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b expandFIObjs} (const PointsTo &pts, PointsTo &expandedPts)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Expand FI objects. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b writeToFile} (const std::string &filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface for analysis result storage on filesystem. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b readFromFile} (const std::string &filename)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual AliasResult {\b alias} (const MemoryLocation &LocA, const MemoryLocation &LocB)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given Location infos. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual AliasResult {\b alias} (const Value *V1, const Value *V2)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given Value infos. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual AliasResult {\b alias} (NodeID node1, NodeID node2)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given PAGNodeID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual AliasResult {\b alias} (const PointsTo &pts1, const PointsTo &pts2)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given two pts. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dumpCPts} (){\bkmkstart AAAAAAAERO}
{\bkmkend AAAAAAAERO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dump and debug, print out conditional pts }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b dumpTopLevelPtsTo} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b dumpAllPts} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateCallGraph} (const CallSiteToFunPtrMap &){\bkmkstart AAAAAAAERP}
{\bkmkend AAAAAAAERP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update callgraph. This should be implemented by its subclass. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTDataTy} * {\b getPTDataTy} () const{\bkmkstart AAAAAAAERQ}
{\bkmkend AAAAAAAERQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get points-to data structure. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DiffPTDataTy} * {\b getDiffPTDataTy} () const{\bkmkstart AAAAAAAERR}
{\bkmkend AAAAAAAERR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DFPTDataTy} * {\b getDFPTDataTy} () const{\bkmkstart AAAAAAAERS}
{\bkmkend AAAAAAAERS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MutDFPTDataTy} * {\b getMutDFPTDataTy} () const{\bkmkstart AAAAAAAERT}
{\bkmkend AAAAAAAERT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VersionedPTDataTy} * {\b getVersionedPTDataTy} () const{\bkmkstart AAAAAAAERU}
{\bkmkend AAAAAAAERU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasPtsMap} (void) const{\bkmkstart AAAAAAAERV}
{\bkmkend AAAAAAAERV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const MutPTDataTy::PtsMap & {\b getPtsMap} () const{\bkmkstart AAAAAAAERW}
{\bkmkend AAAAAAAERW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b onTheFlyCallGraphSolve} (const CallSiteToFunPtrMap &callsites, CallEdgeMap &newEdges)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On the fly call graph construction. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer analysis implementation which uses bit vector based points-to data structure \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v BVDataPTAImpl\:SVF::BVDataPTAImpl}
{\xe \v SVF::BVDataPTAImpl\:BVDataPTAImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
BVDataPTAImpl::BVDataPTAImpl ({\b PAG} *  {\i p}, {\b PointerAnalysis::PTATY}  {\i type}, bool  {\i alias_check} = {\f2 true})}}
\par
{\bkmkstart AAAAAAAERX}
{\bkmkend AAAAAAAERX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v alias\:SVF::BVDataPTAImpl}
{\xe \v SVF::BVDataPTAImpl\:alias}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AliasResult BVDataPTAImpl::alias (const MemoryLocation &  {\i LocA}, const MemoryLocation &  {\i LocB}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAERY}
{\bkmkend AAAAAAAERY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given Location infos. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return alias results based on our points-to/alias analysis \par
}{
Implements {\b SVF::PointerAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAENI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v alias\:SVF::BVDataPTAImpl}
{\xe \v SVF::BVDataPTAImpl\:alias}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AliasResult BVDataPTAImpl::alias (const PointsTo &  {\i p1}, const PointsTo &  {\i p2}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAERZ}
{\bkmkend AAAAAAAERZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given two pts. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return alias results based on our points-to/alias analysis \par
}}
{\xe \v alias\:SVF::BVDataPTAImpl}
{\xe \v SVF::BVDataPTAImpl\:alias}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AliasResult BVDataPTAImpl::alias (const Value *  {\i V1}, const Value *  {\i V2}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAESA}
{\bkmkend AAAAAAAESA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given Value infos. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return alias results based on our points-to/alias analysis \par
}{
Implements {\b SVF::PointerAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAENJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v alias\:SVF::BVDataPTAImpl}
{\xe \v SVF::BVDataPTAImpl\:alias}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AliasResult BVDataPTAImpl::alias (NodeID  {\i node1}, NodeID  {\i node2}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAESB}
{\bkmkend AAAAAAAESB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given PAGNodeID. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return alias results based on our points-to/alias analysis \par
}{
Implements {\b SVF::PointerAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAENK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v dumpAllPts\:SVF::BVDataPTAImpl}
{\xe \v SVF::BVDataPTAImpl\:dumpAllPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BVDataPTAImpl::dumpAllPts (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAESC}
{\bkmkend AAAAAAAESC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump all points-to including top-level ({\b ValPN}) and address-taken ({\b ObjPN}) variables \par
}{
Reimplemented from {\b SVF::PointerAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAELD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v dumpTopLevelPtsTo\:SVF::BVDataPTAImpl}
{\xe \v SVF::BVDataPTAImpl\:dumpTopLevelPtsTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BVDataPTAImpl::dumpTopLevelPtsTo (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAESD}
{\bkmkend AAAAAAAESD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump points-to of each pag node \par
}{
Reimplemented from {\b SVF::PointerAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAELD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAESE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v expandFIObjs\:SVF::BVDataPTAImpl}
{\xe \v SVF::BVDataPTAImpl\:expandFIObjs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BVDataPTAImpl::expandFIObjs (const PointsTo &  {\i pts}, PointsTo &  {\i expandedPts}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAESF}
{\bkmkend AAAAAAAESF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Expand FI objects. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Expand all fields of an aggregate in all points-to sets \par
}{
Reimplemented in {\b SVF::FlowSensitiveTBHC} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAESG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getPts\:SVF::BVDataPTAImpl}
{\xe \v SVF::BVDataPTAImpl\:getPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual const PointsTo& SVF::BVDataPTAImpl::getPts (NodeID  {\i id}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAESH}
{\bkmkend AAAAAAAESH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get points-to and reverse points-to \par
}{
Implements {\b SVF::PointerAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAENL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::Steensgaard} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAESI \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAESJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getRevPts\:SVF::BVDataPTAImpl}
{\xe \v SVF::BVDataPTAImpl\:getRevPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual const NodeSet& SVF::BVDataPTAImpl::getRevPts (NodeID  {\i nodeId}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEQB}
{\bkmkend AAAAAAAEQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an object, get all the nodes having whose pointsto contains the object. Similar to getPts, this also needs to be implemented in child classes. \par
}{
Implements {\b SVF::PointerAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEPZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v onTheFlyCallGraphSolve\:SVF::BVDataPTAImpl}
{\xe \v SVF::BVDataPTAImpl\:onTheFlyCallGraphSolve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BVDataPTAImpl::onTheFlyCallGraphSolve (const CallSiteToFunPtrMap &  {\i callsites}, CallEdgeMap &  {\i newEdges}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAESK}
{\bkmkend AAAAAAAESK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On the fly call graph construction. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On the fly call graph construction callsites is candidate indirect callsites need to be analyzed based on points-to results newEdges is the new indirect call edges discovered \par
}}
{\xe \v readFromFile\:SVF::BVDataPTAImpl}
{\xe \v SVF::BVDataPTAImpl\:readFromFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool BVDataPTAImpl::readFromFile (const std::string &  {\i filename}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAESL}
{\bkmkend AAAAAAAESL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Load pointer analysis result form a file. It populates {\b BVDataPTAImpl} with the points-to data, and updates {\b PAG} with the {\b PAG} offset nodes created during {\b Andersen}'s solving stage. \par
}}
{\xe \v unionPts\:SVF::BVDataPTAImpl}
{\xe \v SVF::BVDataPTAImpl\:unionPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool SVF::BVDataPTAImpl::unionPts (NodeID  {\i id}, const PointsTo &  {\i target}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAESM}
{\bkmkend AAAAAAAESM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union/add points-to. Add the reverse points-to for node collapse purpose To be noted that adding reverse pts might incur 10% total overhead during solving \par
}{
Reimplemented in {\b SVF::Steensgaard} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAESN \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAESO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v writeToFile\:SVF::BVDataPTAImpl}
{\xe \v SVF::BVDataPTAImpl\:writeToFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void BVDataPTAImpl::writeToFile (const std::string &  {\i filename}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAESP}
{\bkmkend AAAAAAAESP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface for analysis result storage on filesystem. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Store pointer analysis result into a file. It includes the points-to relations, and all {\b PAG} nodes including those created when solving {\b Andersen}'s constraints. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/PointerAnalysisImpl.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MemoryModel/PointerAnalysisImpl.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CallBlockNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CallBlockNode}
{\xe \v SVF::CallBlockNode}
{\bkmkstart AAAAAAABYO}
{\bkmkend AAAAAAABYO}
\par
{
{\f2 #include <ICFGNode.h>}}\par
Inheritance diagram for SVF::CallBlockNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_call_block_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const {\b PAGNode} * > {\b ActualParmVFGNodeVec}{\bkmkstart AAAAAAABYP}
{\bkmkend AAAAAAABYP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CallBlockNode} (NodeID id, const Instruction *c){\bkmkstart AAAAAAABYQ}
{\bkmkend AAAAAAABYQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Instruction * {\b getCallSite} () const{\bkmkstart AAAAAAABYR}
{\bkmkend AAAAAAABYR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b RetBlockNode} * {\b getRetBlockNode} () const{\bkmkstart AAAAAAABYS}
{\bkmkend AAAAAAABYS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setRetBlockNode} (const {\b RetBlockNode} *r){\bkmkstart AAAAAAABYT}
{\bkmkend AAAAAAABYT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getCaller} () const{\bkmkstart AAAAAAABYU}
{\bkmkend AAAAAAABYU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const BasicBlock * {\b getParent} () const{\bkmkstart AAAAAAABYV}
{\bkmkend AAAAAAABYV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return Basic Block. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isIndirectCall} () const{\bkmkstart AAAAAAABYW}
{\bkmkend AAAAAAABYW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if this is an indirect call. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const ActualParmVFGNodeVec & {\b getActualParms} () const{\bkmkstart AAAAAAABYX}
{\bkmkend AAAAAAABYX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the set of actual parameters. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addActualParms} (const {\b PAGNode} *ap){\bkmkstart AAAAAAABYY}
{\bkmkend AAAAAAABYY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add actual parameters. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAABYZ}
{\bkmkend AAAAAAABYZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CallBlockNode} *){\bkmkstart AAAAAAABZA}
{\bkmkend AAAAAAABZA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ICFGNode} *node){\bkmkstart AAAAAAABZB}
{\bkmkend AAAAAAABZB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b InterBlockNode} *node){\bkmkstart AAAAAAABZC}
{\bkmkend AAAAAAABZC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericICFGNodeTy} *node){\bkmkstart AAAAAAABZD}
{\bkmkend AAAAAAABZD}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call {\b ICFGNode} containing a set of ActualParmVFGNodes at a callsite \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ICFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CallCFGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CallCFGEdge}
{\xe \v SVF::CallCFGEdge}
{\bkmkstart AAAAAAABVS}
{\bkmkend AAAAAAABVS}
\par
{
{\f2 #include <ICFGEdge.h>}}\par
Inheritance diagram for SVF::CallCFGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_call_c_f_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CallCFGEdge} ({\b ICFGNode} *s, {\b ICFGNode} *d, const Instruction *c){\bkmkstart AAAAAAABVT}
{\bkmkend AAAAAAABVT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Instruction * {\b getCallSite} () const{\bkmkstart AAAAAAABVU}
{\bkmkend AAAAAAABVU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return callsite ID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAABVV}
{\bkmkend AAAAAAABVV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CallCFGEdge} *){\bkmkstart AAAAAAABVW}
{\bkmkend AAAAAAABVW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ICFGEdge} *edge){\bkmkstart AAAAAAABVX}
{\bkmkend AAAAAAABVX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericICFGEdgeTy} *edge){\bkmkstart AAAAAAABVY}
{\bkmkend AAAAAAABVY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call {\b ICFG} edge representing parameter passing/return from a caller to a callee \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ICFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CallCHI< Cond > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CallCHI< Cond >}
{\xe \v SVF::CallCHI< Cond >}
{\bkmkstart AAAAAAAFIL}
{\bkmkend AAAAAAAFIL}
\par
{
{\f2 #include <MSSAMuChi.h>}}\par
Inheritance diagram for SVF::CallCHI< Cond >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_call_c_h_i.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CallCHI} (const {\b CallBlockNode} *cs, const {\b MemRegion} *m, Cond c=PathCondAllocator::trueCond()){\bkmkstart AAAAAAAFIM}
{\bkmkend AAAAAAAFIM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructors for {\b StoreCHI}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const BasicBlock * {\b getBasicBlock} () const{\bkmkstart AAAAAAAFIN}
{\bkmkend AAAAAAAFIN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return basic block. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getCallSite} () const{\bkmkstart AAAAAAAFIO}
{\bkmkend AAAAAAAFIO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dump} (){\bkmkstart AAAAAAAFIP}
{\bkmkend AAAAAAAFIP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print CHI. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CallCHI} *chi){\bkmkstart AAAAAAAFIQ}
{\bkmkend AAAAAAAFIQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MSSACHI}< Cond > *chi){\bkmkstart AAAAAAAFIR}
{\bkmkend AAAAAAAFIR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MSSADEF} *chi){\bkmkstart AAAAAAAFIS}
{\bkmkend AAAAAAAFIS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Cond>\par
class SVF::CallCHI< Cond >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b StoreCHI} is annotated at each store instruction, representing a memory object is modified here \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MSSAMuChi.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CallDirSVFGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CallDirSVFGEdge}
{\xe \v SVF::CallDirSVFGEdge}
{\bkmkstart AAAAAAADNF}
{\bkmkend AAAAAAADNF}
\par
{
{\f2 #include <VFGEdge.h>}}\par
Inheritance diagram for SVF::CallDirSVFGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_call_dir_s_v_f_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CallDirSVFGEdge} ({\b VFGNode} *s, {\b VFGNode} *d, CallSiteID id){\bkmkstart AAAAAAADNG}
{\bkmkend AAAAAAADNG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteID {\b getCallSiteId} () const{\bkmkstart AAAAAAADNH}
{\bkmkend AAAAAAADNH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return callsite ID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADNI}
{\bkmkend AAAAAAADNI}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CallDirSVFGEdge} *){\bkmkstart AAAAAAADNJ}
{\bkmkend AAAAAAADNJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b DirectSVFGEdge} *edge){\bkmkstart AAAAAAADNK}
{\bkmkend AAAAAAADNK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGEdge} *edge){\bkmkstart AAAAAAADNL}
{\bkmkend AAAAAAADNL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGEdgeTy} *edge){\bkmkstart AAAAAAADNM}
{\bkmkend AAAAAAADNM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SVFG} call edge representing direct value-flows from a caller to its callee at a callsite \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CallGraphBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CallGraphBuilder}
{\xe \v SVF::CallGraphBuilder}
{\bkmkstart AAAAAAAGDY}
{\bkmkend AAAAAAAGDY}
Inheritance diagram for SVF::CallGraphBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_call_graph_builder.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CallGraphBuilder} ({\b PTACallGraph} *cg, {\b ICFG} *i){\bkmkstart AAAAAAAGDZ}
{\bkmkend AAAAAAAGDZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PTACallGraph} * {\b buildCallGraph} ({\b SVFModule} *svfModule)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build normal callgraph. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTACallGraph} * {\b callgraph}{\bkmkstart AAAAAAAGEA}
{\bkmkend AAAAAAAGEA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ICFG} * {\b icfg}{\bkmkstart AAAAAAAGEB}
{\bkmkend AAAAAAAGEB}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v buildCallGraph\:SVF::CallGraphBuilder}
{\xe \v SVF::CallGraphBuilder\:buildCallGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PTACallGraph} * CallGraphBuilder::buildCallGraph ({\b SVFModule} *  {\i svfModule})}}
\par
{\bkmkstart AAAAAAAGEC}
{\bkmkend AAAAAAAGEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build normal callgraph. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create nodes\par
create edges\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/CallGraphBuilder.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/CallGraphBuilder.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CallIndSVFGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CallIndSVFGEdge}
{\xe \v SVF::CallIndSVFGEdge}
{\bkmkstart AAAAAAACYN}
{\bkmkend AAAAAAACYN}
\par
{
{\f2 #include <SVFGEdge.h>}}\par
Inheritance diagram for SVF::CallIndSVFGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_call_ind_s_v_f_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CallIndSVFGEdge} ({\b VFGNode} *s, {\b VFGNode} *d, CallSiteID id){\bkmkstart AAAAAAACYO}
{\bkmkend AAAAAAACYO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteID {\b getCallSiteId} () const{\bkmkstart AAAAAAACYP}
{\bkmkend AAAAAAACYP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACYQ}
{\bkmkend AAAAAAACYQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CallIndSVFGEdge} *){\bkmkstart AAAAAAACYR}
{\bkmkend AAAAAAACYR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b IndirectSVFGEdge} *edge){\bkmkstart AAAAAAACYS}
{\bkmkend AAAAAAACYS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGEdge} *edge){\bkmkstart AAAAAAACYT}
{\bkmkend AAAAAAACYT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGEdgeTy} *edge){\bkmkstart AAAAAAACYU}
{\bkmkend AAAAAAACYU}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SVFG} call edge representing indirect value-flows from a caller to its callee at a callsite \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CallMU< Cond > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CallMU< Cond >}
{\xe \v SVF::CallMU< Cond >}
{\bkmkstart AAAAAAAFGV}
{\bkmkend AAAAAAAFGV}
\par
{
{\f2 #include <MSSAMuChi.h>}}\par
Inheritance diagram for SVF::CallMU< Cond >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_call_m_u.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CallMU} (const {\b CallBlockNode} *cs, const {\b MemRegion} *m, Cond c=PathCondAllocator::trueCond()){\bkmkstart AAAAAAAFGW}
{\bkmkend AAAAAAAFGW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor/Destructor for MU. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getCallSite} () const{\bkmkstart AAAAAAAFGX}
{\bkmkend AAAAAAAFGX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const BasicBlock * {\b getBasicBlock} () const{\bkmkstart AAAAAAAFGY}
{\bkmkend AAAAAAAFGY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return basic block. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dump} (){\bkmkstart AAAAAAAFGZ}
{\bkmkend AAAAAAAFGZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print MU. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CallMU} *){\bkmkstart AAAAAAAFHA}
{\bkmkend AAAAAAAFHA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MSSAMU}< Cond > *mu){\bkmkstart AAAAAAAFHB}
{\bkmkend AAAAAAAFHB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Cond>\par
class SVF::CallMU< Cond >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CallMU} is annotated at callsite, representing a memory object is indirect read by callee \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MSSAMuChi.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CallPE Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CallPE}
{\xe \v SVF::CallPE}
{\bkmkstart AAAAAAACKT}
{\bkmkend AAAAAAACKT}
\par
{
{\f2 #include <PAGEdge.h>}}\par
Inheritance diagram for SVF::CallPE:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_call_p_e.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CallPE} ({\b PAGNode} *s, {\b PAGNode} *d, const {\b CallBlockNode} *i, GEdgeKind k=PAGEdge::Call){\bkmkstart AAAAAAACKU}
{\bkmkend AAAAAAACKU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getCallInst} () const{\bkmkstart AAAAAAACKV}
{\bkmkend AAAAAAACKV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get method for the call instruction. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getCallSite} () const{\bkmkstart AAAAAAACKW}
{\bkmkend AAAAAAACKW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACKX}
{\bkmkend AAAAAAACKX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CallPE} *){\bkmkstart AAAAAAACKY}
{\bkmkend AAAAAAACKY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGEdge} *edge){\bkmkstart AAAAAAACKZ}
{\bkmkend AAAAAAACKZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGEdgeTy} *edge){\bkmkstart AAAAAAACLA}
{\bkmkend AAAAAAACLA}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::cast_convert_val< To, From, SimpleFrom > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::cast_convert_val< To, From, SimpleFrom >}
{\xe \v SVF::SVFUtil::cast_convert_val< To, From, SimpleFrom >}
{\bkmkstart AAAAAAAIFP}
{\bkmkend AAAAAAAIFP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b cast_retty}< To, From >::ret_type {\b doit} (From &Val){\bkmkstart AAAAAAAIFQ}
{\bkmkend AAAAAAAIFQ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::cast_convert_val< To, FromTy, FromTy > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::cast_convert_val< To, FromTy, FromTy >}
{\xe \v SVF::SVFUtil::cast_convert_val< To, FromTy, FromTy >}
{\bkmkstart AAAAAAAIFR}
{\bkmkend AAAAAAAIFR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b cast_retty}< To, FromTy >::ret_type {\b doit} (const FromTy &Val){\bkmkstart AAAAAAAIFS}
{\bkmkend AAAAAAAIFS}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::cast_retty< To, From > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::cast_retty< To, From >}
{\xe \v SVF::SVFUtil::cast_retty< To, From >}
{\bkmkstart AAAAAAAIEX}
{\bkmkend AAAAAAAIEX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

using {\b ret_type} = typename {\b cast_retty_wrap}< To, From, typename {\b simplify_type}< From >::SimpleType >::ret_type{\bkmkstart AAAAAAAIEY}
{\bkmkend AAAAAAAIEY}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::cast_retty_impl< To, From > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::cast_retty_impl< To, From >}
{\xe \v SVF::SVFUtil::cast_retty_impl< To, From >}
{\bkmkstart AAAAAAAIEZ}
{\bkmkend AAAAAAAIEZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

using {\b ret_type} = To &{\bkmkstart AAAAAAAIFA}
{\bkmkend AAAAAAAIFA}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::cast_retty_impl< To, const From * > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::cast_retty_impl< To, const From * >}
{\xe \v SVF::SVFUtil::cast_retty_impl< To, const From * >}
{\bkmkstart AAAAAAAIFF}
{\bkmkend AAAAAAAIFF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

using {\b ret_type} = const To *{\bkmkstart AAAAAAAIFG}
{\bkmkend AAAAAAAIFG}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::cast_retty_impl< To, const From *const > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::cast_retty_impl< To, const From *const >}
{\xe \v SVF::SVFUtil::cast_retty_impl< To, const From *const >}
{\bkmkstart AAAAAAAIFH}
{\bkmkend AAAAAAAIFH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

using {\b ret_type} = const To *{\bkmkstart AAAAAAAIFI}
{\bkmkend AAAAAAAIFI}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::cast_retty_impl< To, const From > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::cast_retty_impl< To, const From >}
{\xe \v SVF::SVFUtil::cast_retty_impl< To, const From >}
{\bkmkstart AAAAAAAIFB}
{\bkmkend AAAAAAAIFB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

using {\b ret_type} = const To &{\bkmkstart AAAAAAAIFC}
{\bkmkend AAAAAAAIFC}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::cast_retty_impl< To, From * > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::cast_retty_impl< To, From * >}
{\xe \v SVF::SVFUtil::cast_retty_impl< To, From * >}
{\bkmkstart AAAAAAAIFD}
{\bkmkend AAAAAAAIFD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

using {\b ret_type} = To *{\bkmkstart AAAAAAAIFE}
{\bkmkend AAAAAAAIFE}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::cast_retty_impl< To, std::unique_ptr< From > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::cast_retty_impl< To, std::unique_ptr< From > >}
{\xe \v SVF::SVFUtil::cast_retty_impl< To, std::unique_ptr< From > >}
{\bkmkstart AAAAAAAIFJ}
{\bkmkend AAAAAAAIFJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

using {\b ret_type} = std::unique_ptr< ResultType >{\bkmkstart AAAAAAAIFK}
{\bkmkend AAAAAAAIFK}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::cast_retty_wrap< To, From, SimpleFrom > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::cast_retty_wrap< To, From, SimpleFrom >}
{\xe \v SVF::SVFUtil::cast_retty_wrap< To, From, SimpleFrom >}
{\bkmkstart AAAAAAAIFL}
{\bkmkend AAAAAAAIFL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

using {\b ret_type} = typename {\b cast_retty}< To, SimpleFrom >::ret_type{\bkmkstart AAAAAAAIFM}
{\bkmkend AAAAAAAIFM}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::cast_retty_wrap< To, FromTy, FromTy > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::cast_retty_wrap< To, FromTy, FromTy >}
{\xe \v SVF::SVFUtil::cast_retty_wrap< To, FromTy, FromTy >}
{\bkmkstart AAAAAAAIFN}
{\bkmkend AAAAAAAIFN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

using {\b ret_type} = typename {\b cast_retty_impl}< To, FromTy >::ret_type{\bkmkstart AAAAAAAIFO}
{\bkmkend AAAAAAAIFO}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CFLSolver< GraphType, DPIm > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CFLSolver< GraphType, DPIm >}
{\xe \v SVF::CFLSolver< GraphType, DPIm >}
{\bkmkstart AAAAAAAGTN}
{\bkmkend AAAAAAAGTN}
Inheritance diagram for SVF::CFLSolver< GraphType, DPIm >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_c_f_l_solver.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::GraphTraits< GraphType > {\b GTraits}{\bkmkstart AAAAAAAGTO}
{\bkmkend AAAAAAAGTO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define the GTraits and node iterator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef GTraits::NodeType {\b GNODE}{\bkmkstart AAAAAAAGTP}
{\bkmkend AAAAAAAGTP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef GTraits::EdgeType {\b GEDGE}{\bkmkstart AAAAAAAGTQ}
{\bkmkend AAAAAAAGTQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef GTraits::nodes_iterator {\b node_iterator}{\bkmkstart AAAAAAAGTR}
{\bkmkend AAAAAAAGTR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef GTraits::ChildIteratorType {\b child_iterator}{\bkmkstart AAAAAAAGTS}
{\bkmkend AAAAAAAGTS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::GraphTraits< llvm::Inverse< GNODE * > > {\b InvGTraits}{\bkmkstart AAAAAAAGTT}
{\bkmkend AAAAAAAGTT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define inverse GTraits and note iterator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef InvGTraits::ChildIteratorType {\b inv_child_iterator}{\bkmkstart AAAAAAAGTU}
{\bkmkend AAAAAAAGTU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< DPIm > {\b WorkList}{\bkmkstart AAAAAAAGTV}
{\bkmkend AAAAAAAGTV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define worklist. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CFLSolver} (){\bkmkstart AAAAAAAGTW}
{\bkmkend AAAAAAAGTW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~CFLSolver} (){\bkmkstart AAAAAAAGTX}
{\bkmkend AAAAAAAGTX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const GraphType {\b graph} () const{\bkmkstart AAAAAAAGTY}
{\bkmkend AAAAAAAGTY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get/Set graph methods. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setGraph} (GraphType g){\bkmkstart AAAAAAAGTZ}
{\bkmkend AAAAAAAGTZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

GNODE * {\b getNode} (NodeID id) const{\bkmkstart AAAAAAAGUA}
{\bkmkend AAAAAAAGUA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual NodeID {\b getNodeIDFromItem} (const DPIm &item) const{\bkmkstart AAAAAAAGUB}
{\bkmkend AAAAAAAGUB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b forwardTraverse} (DPIm &it){\bkmkstart AAAAAAAGUC}
{\bkmkend AAAAAAAGUC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CFL forward traverse solve. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b backwardTraverse} (DPIm &it){\bkmkstart AAAAAAAGUD}
{\bkmkend AAAAAAAGUD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CFL forward traverse solve. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b FWProcessCurNode} (const DPIm &){\bkmkstart AAAAAAAGUE}
{\bkmkend AAAAAAAGUE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process the DP item. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b BWProcessCurNode} (const DPIm &){\bkmkstart AAAAAAAGUF}
{\bkmkend AAAAAAAGUF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b FWProcessOutgoingEdge} (const DPIm &item, GEDGE *edge){\bkmkstart AAAAAAAGUG}
{\bkmkend AAAAAAAGUG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagation for the solving, to be implemented in the child class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b BWProcessIncomingEdge} (const DPIm &item, GEDGE *edge){\bkmkstart AAAAAAAGUH}
{\bkmkend AAAAAAAGUH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DPIm {\b popFromWorklist} (){\bkmkstart AAAAAAAGUI}
{\bkmkend AAAAAAAGUI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Worklist operations. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b pushIntoWorklist} (DPIm &item){\bkmkstart AAAAAAAGUJ}
{\bkmkend AAAAAAAGUJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isWorklistEmpty} (){\bkmkstart AAAAAAAGUK}
{\bkmkend AAAAAAAGUK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isInWorklist} (DPIm &item){\bkmkstart AAAAAAAGUL}
{\bkmkend AAAAAAAGUL}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/CFLSolver.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CHEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CHEdge}
{\xe \v SVF::CHEdge}
{\bkmkstart AAAAAAAGEG}
{\bkmkend AAAAAAAGEG}
Inheritance diagram for SVF::CHEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_c_h_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b CHEDGETYPE} \{ {\b INHERITANCE} = 0x1
, {\b INSTANTCE} = 0x2
 \}{\bkmkstart AAAAAAAGEH}
{\bkmkend AAAAAAAGEH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericNode}< {\b CHNode}, {\b CHEdge} >::GEdgeSetTy {\b CHEdgeSetTy}{\bkmkstart AAAAAAAGEI}
{\bkmkend AAAAAAAGEI}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CHEdge} ({\b CHNode} *s, {\b CHNode} *d, CHEDGETYPE et, {\b GEdgeFlag} k=0){\bkmkstart AAAAAAAGEJ}
{\bkmkend AAAAAAAGEJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CHEDGETYPE {\b getEdgeType} () const{\bkmkstart AAAAAAAGEK}
{\bkmkend AAAAAAAGEK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/CHG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CHGraph Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CHGraph}
{\xe \v SVF::CHGraph}
{\bkmkstart AAAAAAAGFD}
{\bkmkend AAAAAAAGFD}
Inheritance diagram for SVF::CHGraph:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_c_h_graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b RELATIONTYPE} \{ {\b CONSTRUCTOR} = 0x1
, {\b DESTRUCTOR} = 0x2
 \}{\bkmkstart AAAAAAAGFE}
{\bkmkend AAAAAAAGFE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b CHNode} * > {\b CHNodeSetTy}{\bkmkstart AAAAAAAGFF}
{\bkmkend AAAAAAAGFF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< const {\b CHNode} * > {\b WorkList}{\bkmkstart AAAAAAAGFG}
{\bkmkend AAAAAAAGFG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< std::string, CHNodeSetTy > {\b NameToCHNodesMap}{\bkmkstart AAAAAAAGFH}
{\bkmkend AAAAAAAGFH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< CallSite, CHNodeSetTy > {\b CallSiteToCHNodesMap}{\bkmkstart AAAAAAAGFI}
{\bkmkend AAAAAAAGFI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< CallSite, VTableSet > {\b CallSiteToVTableSetMap}{\bkmkstart AAAAAAAGFJ}
{\bkmkend AAAAAAAGFJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< CallSite, VFunSet > {\b CallSiteToVFunSetMap}{\bkmkstart AAAAAAAGFK}
{\bkmkend AAAAAAAGFK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CHGraph} ({\b SVFModule} *svfModule){\bkmkstart AAAAAAAGFL}
{\bkmkend AAAAAAAGFL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b buildCHG} (){\bkmkstart AAAAAAAGFM}
{\bkmkend AAAAAAAGFM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b buildInternalMaps} (){\bkmkstart AAAAAAAGFN}
{\bkmkend AAAAAAAGFN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b buildCHGNodes} (const GlobalValue *V){\bkmkstart AAAAAAAGFO}
{\bkmkend AAAAAAAGFO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b buildCHGNodes} (const {\b SVFFunction} *F){\bkmkstart AAAAAAAGFP}
{\bkmkend AAAAAAAGFP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b buildCHGEdges} (const {\b SVFFunction} *F){\bkmkstart AAAAAAAGFQ}
{\bkmkend AAAAAAAGFQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b connectInheritEdgeViaCall} (const {\b SVFFunction} *caller, CallSite cs){\bkmkstart AAAAAAAGFR}
{\bkmkend AAAAAAAGFR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b connectInheritEdgeViaStore} (const {\b SVFFunction} *caller, const StoreInst *store){\bkmkstart AAAAAAAGFS}
{\bkmkend AAAAAAAGFS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addEdge} (const std::string className, const std::string baseClassName, CHEdge::CHEDGETYPE edgeType){\bkmkstart AAAAAAAGFT}
{\bkmkend AAAAAAAGFT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CHNode} * {\b getNode} (const std::string name) const{\bkmkstart AAAAAAAGFU}
{\bkmkend AAAAAAAGFU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CHNode} * {\b createNode} (const std::string name){\bkmkstart AAAAAAAGFV}
{\bkmkend AAAAAAAGFV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b buildClassNameToAncestorsDescendantsMap} (){\bkmkstart AAAAAAAGFW}
{\bkmkend AAAAAAAGFW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b buildVirtualFunctionToIDMap} (){\bkmkstart AAAAAAAGFX}
{\bkmkend AAAAAAAGFX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b buildCSToCHAVtblsAndVfnsMap} (){\bkmkstart AAAAAAAGFY}
{\bkmkend AAAAAAAGFY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b readInheritanceMetadataFromModule} (const Module &M){\bkmkstart AAAAAAAGFZ}
{\bkmkend AAAAAAAGFZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b analyzeVTables} (const Module &M){\bkmkstart AAAAAAAGGA}
{\bkmkend AAAAAAAGGA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CHGraph::CHNodeSetTy & {\b getInstancesAndDescendants} (const std::string className){\bkmkstart AAAAAAAGGB}
{\bkmkend AAAAAAAGGB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CHNodeSetTy & {\b getCSClasses} (CallSite cs){\bkmkstart AAAAAAAGGC}
{\bkmkend AAAAAAAGGC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getVFnsFromVtbls} (CallSite cs, const VTableSet &vtbls, VFunSet &virtualFunctions) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump} (const std::string &filename)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b printCH} (){\bkmkstart AAAAAAAGGD}
{\bkmkend AAAAAAAGGD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

s32_t {\b getVirtualFunctionID} (const {\b SVFFunction} *vfn) const{\bkmkstart AAAAAAAGGE}
{\bkmkend AAAAAAAGGE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getVirtualFunctionBasedonID} (s32_t id) const{\bkmkstart AAAAAAAGGF}
{\bkmkend AAAAAAAGGF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addInstances} (const std::string templateName, {\b CHNode} *node){\bkmkstart AAAAAAAGGG}
{\bkmkend AAAAAAAGGG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CHNodeSetTy & {\b getDescendants} (const std::string className){\bkmkstart AAAAAAAGGH}
{\bkmkend AAAAAAAGGH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CHNodeSetTy & {\b getInstances} (const std::string className){\bkmkstart AAAAAAAGGI}
{\bkmkend AAAAAAAGGI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b csHasVtblsBasedonCHA} (CallSite cs) override{\bkmkstart AAAAAAAGGJ}
{\bkmkend AAAAAAAGGJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b csHasVFnsBasedonCHA} (CallSite cs) override{\bkmkstart AAAAAAAGGK}
{\bkmkend AAAAAAAGGK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const VTableSet & {\b getCSVtblsBasedonCHA} (CallSite cs) override{\bkmkstart AAAAAAAGGL}
{\bkmkend AAAAAAAGGL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const VFunSet & {\b getCSVFsBasedonCHA} (CallSite cs) override{\bkmkstart AAAAAAAGGM}
{\bkmkend AAAAAAAGGM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CommonCHGraph} *chg){\bkmkstart AAAAAAAGGN}
{\bkmkend AAAAAAAGGN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v dump\:SVF::CHGraph}
{\xe \v SVF::CHGraph\:dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CHGraph::dump (const std::string &  {\i filename})}}
\par
{\bkmkstart AAAAAAAGGO}
{\bkmkend AAAAAAAGGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump call graph into dot file \par
}}
{\xe \v getVFnsFromVtbls\:SVF::CHGraph}
{\xe \v SVF::CHGraph\:getVFnsFromVtbls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CHGraph::getVFnsFromVtbls (CallSite  {\i cs}, const VTableSet &  {\i vtbls}, VFunSet &  {\i virtualFunctions}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGGP}
{\bkmkend AAAAAAAGGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get target virtual functions\par
get the function name of the virtual callsite\par
}{
Implements {\b SVF::CommonCHGraph} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAGGQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/CHG.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/CHG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CHNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CHNode}
{\xe \v SVF::CHNode}
{\bkmkstart AAAAAAAGEL}
{\bkmkend AAAAAAAGEL}
Inheritance diagram for SVF::CHNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_c_h_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b CLASSATTR} \{ {\b PURE_ABSTRACT} = 0x1
, {\b MULTI_INHERITANCE} = 0x2
, {\b TEMPLATE} = 0x04
 \}{\bkmkstart AAAAAAAGEM}
{\bkmkend AAAAAAAGEM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const {\b SVFFunction} * > {\b FuncVector}{\bkmkstart AAAAAAAGEN}
{\bkmkend AAAAAAAGEN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CHNode} (const std::string name, NodeID i=0, {\b GNodeK} k=0){\bkmkstart AAAAAAAGEO}
{\bkmkend AAAAAAAGEO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b getName} () const{\bkmkstart AAAAAAAGEP}
{\bkmkend AAAAAAAGEP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setFlag} (CLASSATTR mask){\bkmkstart AAAAAAAGEQ}
{\bkmkend AAAAAAAGEQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flags. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasFlag} (CLASSATTR mask) const{\bkmkstart AAAAAAAGER}
{\bkmkend AAAAAAAGER}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setPureAbstract} (){\bkmkstart AAAAAAAGES}
{\bkmkend AAAAAAAGES}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attribute. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setMultiInheritance} (){\bkmkstart AAAAAAAGET}
{\bkmkend AAAAAAAGET}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setTemplate} (){\bkmkstart AAAAAAAGEU}
{\bkmkend AAAAAAAGEU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isPureAbstract} () const{\bkmkstart AAAAAAAGEV}
{\bkmkend AAAAAAAGEV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isMultiInheritance} () const{\bkmkstart AAAAAAAGEW}
{\bkmkend AAAAAAAGEW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTemplate} () const{\bkmkstart AAAAAAAGEX}
{\bkmkend AAAAAAAGEX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addVirtualFunctionVector} (FuncVector vfuncvec){\bkmkstart AAAAAAAGEY}
{\bkmkend AAAAAAAGEY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::vector< FuncVector > & {\b getVirtualFunctionVectors} () const{\bkmkstart AAAAAAAGEZ}
{\bkmkend AAAAAAAGEZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b getVirtualFunctions} (u32_t idx, FuncVector &virtualFunctions) const{\bkmkstart AAAAAAAGFA}
{\bkmkend AAAAAAAGFA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const GlobalValue * {\b getVTable} () const{\bkmkstart AAAAAAAGFB}
{\bkmkend AAAAAAAGFB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setVTable} (const GlobalValue *vtbl){\bkmkstart AAAAAAAGFC}
{\bkmkend AAAAAAAGFC}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/CHG.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/CHG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CloneDummyObjPN Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CloneDummyObjPN}
{\xe \v SVF::CloneDummyObjPN}
{\bkmkstart AAAAAAACPY}
{\bkmkend AAAAAAACPY}
Inheritance diagram for SVF::CloneDummyObjPN:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_clone_dummy_obj_p_n.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CloneDummyObjPN} (NodeID i, const {\b MemObj} *m, {\b PNODEK} ty=CloneDummyObjNode){\bkmkstart AAAAAAACPZ}
{\bkmkend AAAAAAACPZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::string {\b getValueName} () const{\bkmkstart AAAAAAACQA}
{\bkmkend AAAAAAACQA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of this node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACQB}
{\bkmkend AAAAAAACQB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CloneDummyObjPN} *){\bkmkstart AAAAAAACQC}
{\bkmkend AAAAAAACQC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGNode} *node){\bkmkstart AAAAAAACQD}
{\bkmkend AAAAAAACQD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGNodeTy} *node){\bkmkstart AAAAAAACQE}
{\bkmkend AAAAAAACQE}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CloneFIObjPN Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CloneFIObjPN}
{\xe \v SVF::CloneFIObjPN}
{\bkmkstart AAAAAAACQM}
{\bkmkend AAAAAAACQM}
Inheritance diagram for SVF::CloneFIObjPN:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_clone_f_i_obj_p_n.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CloneFIObjPN} (const Value *val, NodeID i, const {\b MemObj} *{\b mem}, {\b PNODEK} ty=CloneFIObjNode){\bkmkstart AAAAAAACQN}
{\bkmkend AAAAAAACQN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::string {\b getValueName} () const{\bkmkstart AAAAAAACQO}
{\bkmkend AAAAAAACQO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of this node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACQP}
{\bkmkend AAAAAAACQP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CloneFIObjPN} *){\bkmkstart AAAAAAACQQ}
{\bkmkend AAAAAAACQQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGNode} *node){\bkmkstart AAAAAAACQR}
{\bkmkend AAAAAAACQR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGNodeTy} *node){\bkmkstart AAAAAAACQS}
{\bkmkend AAAAAAACQS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CloneGepObjPN Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CloneGepObjPN}
{\xe \v SVF::CloneGepObjPN}
{\bkmkstart AAAAAAACQF}
{\bkmkend AAAAAAACQF}
Inheritance diagram for SVF::CloneGepObjPN:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_clone_gep_obj_p_n.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CloneGepObjPN} (const {\b MemObj} *{\b mem}, NodeID i, const {\b LocationSet} &l, {\b PNODEK} ty=CloneGepObjNode){\bkmkstart AAAAAAACQG}
{\bkmkend AAAAAAACQG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::string {\b getValueName} () const{\bkmkstart AAAAAAACQH}
{\bkmkend AAAAAAACQH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of this node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACQI}
{\bkmkend AAAAAAACQI}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CloneGepObjPN} *){\bkmkstart AAAAAAACQJ}
{\bkmkend AAAAAAACQJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGNode} *node){\bkmkstart AAAAAAACQK}
{\bkmkend AAAAAAACQK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGNodeTy} *node){\bkmkstart AAAAAAACQL}
{\bkmkend AAAAAAACQL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CmpPE Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CmpPE}
{\xe \v SVF::CmpPE}
{\bkmkstart AAAAAAACIT}
{\bkmkend AAAAAAACIT}
\par
{
{\f2 #include <PAGEdge.h>}}\par
Inheritance diagram for SVF::CmpPE:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_cmp_p_e.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CmpPE} ({\b PAGNode} *s, {\b PAGNode} *d){\bkmkstart AAAAAAACIU}
{\bkmkend AAAAAAACIU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACIV}
{\bkmkend AAAAAAACIV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CmpPE} *){\bkmkstart AAAAAAACIW}
{\bkmkend AAAAAAACIW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGEdge} *edge){\bkmkstart AAAAAAACIX}
{\bkmkend AAAAAAACIX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGEdgeTy} *edge){\bkmkstart AAAAAAACIY}
{\bkmkend AAAAAAACIY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compare instruction edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CmpVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CmpVFGNode}
{\xe \v SVF::CmpVFGNode}
{\bkmkstart AAAAAAADPQ}
{\bkmkend AAAAAAADPQ}
\par
{
{\f2 #include <VFGNode.h>}}\par
Inheritance diagram for SVF::CmpVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_cmp_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< u32_t, const {\b PAGNode} * > {\b OPVers}{\bkmkstart AAAAAAADPR}
{\bkmkend AAAAAAADPR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CmpVFGNode} (NodeID id, const {\b PAGNode} *r){\bkmkstart AAAAAAADPS}
{\bkmkend AAAAAAADPS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getOpVer} (u32_t pos) const{\bkmkstart AAAAAAADPT}
{\bkmkend AAAAAAADPT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operands at a BinaryNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setOpVer} (u32_t pos, const {\b PAGNode} *node){\bkmkstart AAAAAAADPU}
{\bkmkend AAAAAAADPU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getRes} () const{\bkmkstart AAAAAAADPV}
{\bkmkend AAAAAAADPV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getOpVerNum} () const{\bkmkstart AAAAAAADPW}
{\bkmkend AAAAAAADPW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers::const_iterator {\b opVerBegin} () const{\bkmkstart AAAAAAADPX}
{\bkmkend AAAAAAADPX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers::const_iterator {\b opVerEnd} () const{\bkmkstart AAAAAAADPY}
{\bkmkend AAAAAAADPY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADPZ}
{\bkmkend AAAAAAADPZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CmpVFGNode} *){\bkmkstart AAAAAAADQA}
{\bkmkend AAAAAAADQA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADQB}
{\bkmkend AAAAAAADQB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADQC}
{\bkmkend AAAAAAADQC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b res}{\bkmkstart AAAAAAADQD}
{\bkmkend AAAAAAADQD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers {\b opVers}{\bkmkstart AAAAAAADQE}
{\bkmkend AAAAAAADQE}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b VFGNode} for compare instruction, e.g., bool b = (a!=c); \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CommonCHGraph Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CommonCHGraph}
{\xe \v SVF::CommonCHGraph}
{\bkmkstart AAAAAAAGGQ}
{\bkmkend AAAAAAAGGQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Common base for class hierarchy graph. Only implements what {\b PointerAnalysis} needs. }}\par
{
{\f2 #include <CommonCHG.h>}}\par
Inheritance diagram for SVF::CommonCHGraph:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_common_c_h_graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b CHGKind} \{ {\b Standard}
, {\b DI}
 \}{\bkmkstart AAAAAAAGGR}
{\bkmkend AAAAAAAGGR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b csHasVFnsBasedonCHA} (CallSite cs)=0{\bkmkstart AAAAAAAGGS}
{\bkmkend AAAAAAAGGS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const VFunSet & {\b getCSVFsBasedonCHA} (CallSite cs)=0{\bkmkstart AAAAAAAGGT}
{\bkmkend AAAAAAAGGT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b csHasVtblsBasedonCHA} (CallSite cs)=0{\bkmkstart AAAAAAAGGU}
{\bkmkend AAAAAAAGGU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const VTableSet & {\b getCSVtblsBasedonCHA} (CallSite cs)=0{\bkmkstart AAAAAAAGGV}
{\bkmkend AAAAAAAGGV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b getVFnsFromVtbls} (CallSite cs, const VTableSet &vtbls, VFunSet &virtualFunctions)=0{\bkmkstart AAAAAAAGGW}
{\bkmkend AAAAAAAGGW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CHGKind {\b getKind} (void) const{\bkmkstart AAAAAAAGGX}
{\bkmkend AAAAAAAGGX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CHGKind {\b kind}{\bkmkstart AAAAAAAGGY}
{\bkmkend AAAAAAAGGY}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Common base for class hierarchy graph. Only implements what {\b PointerAnalysis} needs. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/CommonCHG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CondPointsToSet< Cond > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CondPointsToSet< Cond >}
{\xe \v SVF::CondPointsToSet< Cond >}
{\bkmkstart AAAAAAADZU}
{\bkmkend AAAAAAADZU}
\par
{
{\f2 #include <ConditionalPT.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< Cond, PointsTo > {\b CondPts}{\bkmkstart AAAAAAADZV}
{\bkmkend AAAAAAADZV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef CondPts::iterator {\b CondPtsIter}{\bkmkstart AAAAAAADZW}
{\bkmkend AAAAAAADZW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef CondPts::const_iterator {\b CondPtsConstIter}{\bkmkstart AAAAAAADZX}
{\bkmkend AAAAAAADZX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b CondVar}< Cond > {\b SingleCondVar}{\bkmkstart AAAAAAADZY}
{\bkmkend AAAAAAADZY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef CondPtsSetIterator {\b iterator}{\bkmkstart AAAAAAADZZ}
{\bkmkend AAAAAAADZZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CondPointsToSet} (){\bkmkstart AAAAAAAEAA}
{\bkmkend AAAAAAAEAA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CondPointsToSet} (const Cond &cond, const PointsTo &pts){\bkmkstart AAAAAAAEAB}
{\bkmkend AAAAAAAEAB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CondPointsToSet} (const {\b CondPointsToSet}< Cond > &cptsSet){\bkmkstart AAAAAAAEAC}
{\bkmkend AAAAAAAEAC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CondPts & {\b pointsTo} (void){\bkmkstart AAAAAAAEAD}
{\bkmkend AAAAAAAEAD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Conditional PointsTo and starndard points-to. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CondPts & {\b pointsTo} (void) const{\bkmkstart AAAAAAAEAE}
{\bkmkend AAAAAAAEAE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const PointsTo & {\b pointsTo} (Cond cond) const{\bkmkstart AAAAAAAEAF}
{\bkmkend AAAAAAAEAF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasPointsTo} (Cond cond) const{\bkmkstart AAAAAAAEAG}
{\bkmkend AAAAAAAEAG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PointsTo & {\b pointsTo} (Cond cond){\bkmkstart AAAAAAAEAH}
{\bkmkend AAAAAAAEAH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CondPtsIter {\b cptsBegin} (){\bkmkstart AAAAAAAEAI}
{\bkmkend AAAAAAAEAI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
iterators }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CondPtsIter {\b cptsEnd} (){\bkmkstart AAAAAAAEAJ}
{\bkmkend AAAAAAAEAJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CondPtsConstIter {\b cptsBegin} () const{\bkmkstart AAAAAAAEAK}
{\bkmkend AAAAAAAEAK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CondPtsConstIter {\b cptsEnd} () const{\bkmkstart AAAAAAAEAL}
{\bkmkend AAAAAAAEAL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b clear} (){\bkmkstart AAAAAAAEAM}
{\bkmkend AAAAAAAEAM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned {\b numElement} () const{\bkmkstart AAAAAAAEAN}
{\bkmkend AAAAAAAEAN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get number of points-to targets. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b empty} () const{\bkmkstart AAAAAAAEAO}
{\bkmkend AAAAAAAEAO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if no element in the set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CondPointsToSet}< Cond > & {\b operator=} (const {\b CondPointsToSet}< Cond > &other){\bkmkstart AAAAAAAEAP}
{\bkmkend AAAAAAAEAP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b CondPointsToSet}< Cond > &rhs) const{\bkmkstart AAAAAAAEAQ}
{\bkmkend AAAAAAAEAQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator ==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b aliased} (const {\b CondPointsToSet}< Cond > &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isSubset} (const {\b CondPointsToSet}< Cond > &rhs) const{\bkmkstart AAAAAAAEAR}
{\bkmkend AAAAAAAEAR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check whether this {\b CondPointsToSet} is a subset of RHS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b intersects} (const {\b CondPointsToSet}< Cond > *rhs) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return TRUE if this and RHS share any common element. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b intersectWithComplement} (const {\b CondPointsToSet}< Cond > &cpts1, const {\b CondPointsToSet}< Cond > &cpts2){\bkmkstart AAAAAAAEAS}
{\bkmkend AAAAAAAEAS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Result of cpts1 & ~cpts2 is stored into this bitmap. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b intersectWithComplement} (const {\b CondPointsToSet}< Cond > &cpts1)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Result of cur & ~cpts1 is stored into this bitmap. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator&=} (const {\b CondPointsToSet}< Cond > &rhs){\bkmkstart AAAAAAAEAT}
{\bkmkend AAAAAAAEAT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator &=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b CondPointsToSet}< Cond > &rhs){\bkmkstart AAAAAAAEAU}
{\bkmkend AAAAAAAEAU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator !=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator|=} (const {\b CondPointsToSet}< Cond > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b CondPointsToSet}< Cond > &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b test_and_set} (const {\b SingleCondVar} &var){\bkmkstart AAAAAAAEAV}
{\bkmkend AAAAAAAEAV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test and set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b test} (const {\b SingleCondVar} &var) const{\bkmkstart AAAAAAAEAW}
{\bkmkend AAAAAAAEAW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set} (const {\b SingleCondVar} &var){\bkmkstart AAAAAAAEAX}
{\bkmkend AAAAAAAEAX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset} (const {\b SingleCondVar} &var){\bkmkstart AAAAAAAEAY}
{\bkmkend AAAAAAAEAY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dump} ({\b raw_ostream} &O) const{\bkmkstart AAAAAAAEAZ}
{\bkmkend AAAAAAAEAZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b dumpStr} () const{\bkmkstart AAAAAAAEBA}
{\bkmkend AAAAAAAEBA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b begin} (){\bkmkstart AAAAAAAEBB}
{\bkmkend AAAAAAAEBB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
iterators }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b end} (){\bkmkstart AAAAAAAEBC}
{\bkmkend AAAAAAAEBC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b begin} () const{\bkmkstart AAAAAAAEBD}
{\bkmkend AAAAAAAEBD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b end} () const{\bkmkstart AAAAAAAEBE}
{\bkmkend AAAAAAAEBE}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Cond>\par
class SVF::CondPointsToSet< Cond >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Conditional Points-to set \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v aliased\:SVF::CondPointsToSet< Cond >}
{\xe \v SVF::CondPointsToSet< Cond >\:aliased}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Cond > bool {\b SVF::CondPointsToSet}< Cond >::aliased (const {\b CondPointsToSet}< Cond > &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEBF}
{\bkmkend AAAAAAAEBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Two conditional points-to set are aliased when they access the same memory location under the same condition \par
}}
{\xe \v intersects\:SVF::CondPointsToSet< Cond >}
{\xe \v SVF::CondPointsToSet< Cond >\:intersects}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Cond > bool {\b SVF::CondPointsToSet}< Cond >::intersects (const {\b CondPointsToSet}< Cond > *  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEBG}
{\bkmkend AAAAAAAEBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return TRUE if this and RHS share any common element. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if either cpts is empty, just return.\par
}}
{\xe \v intersectWithComplement\:SVF::CondPointsToSet< Cond >}
{\xe \v SVF::CondPointsToSet< Cond >\:intersectWithComplement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Cond > void {\b SVF::CondPointsToSet}< Cond >::intersectWithComplement (const {\b CondPointsToSet}< Cond > &  {\i cpts1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEBH}
{\bkmkend AAAAAAAEBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Result of cur & ~cpts1 is stored into this bitmap. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if either cpts is empty, just return.\par
}}
{\xe \v operator<\:SVF::CondPointsToSet< Cond >}
{\xe \v SVF::CondPointsToSet< Cond >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Cond > bool {\b SVF::CondPointsToSet}< Cond >::operator< (const {\b CondPointsToSet}< Cond > &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEBI}
{\bkmkend AAAAAAAEBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compare two {\b CondPointsToSet} according to their points-to set size and points-to elements.{
\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab {\b CondPointsToSet} with smaller points-to set size is smaller than the other;\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab If the sizes are equal, comparing the conditions and real points-to targets in their points-to elements. \par}
}}
{\xe \v operator|=\:SVF::CondPointsToSet< Cond >}
{\xe \v SVF::CondPointsToSet< Cond >\:operator|=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Cond > bool {\b SVF::CondPointsToSet}< Cond >::operator|= (const {\b CondPointsToSet}< Cond > &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEBJ}
{\bkmkend AAAAAAAEBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator |= Merge {\b CondPointsToSet} of RHS into this one. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/ConditionalPT.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CondPTAImpl< Cond > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CondPTAImpl< Cond >}
{\xe \v SVF::CondPTAImpl< Cond >}
{\bkmkstart AAAAAAAESQ}
{\bkmkend AAAAAAAESQ}
\par
{
{\f2 #include <PointerAnalysisImpl.h>}}\par
Inheritance diagram for SVF::CondPTAImpl< Cond >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_cond_p_t_a_impl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b CondVar}< Cond > {\b CVar}{\bkmkstart AAAAAAAESR}
{\bkmkend AAAAAAAESR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b CondStdSet}< {\b CVar} > {\b CPtSet}{\bkmkstart AAAAAAAESS}
{\bkmkend AAAAAAAESS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b PTData}< {\b CVar}, {\b CVar}, {\b CPtSet} > {\b PTDataTy}{\bkmkstart AAAAAAAEST}
{\bkmkend AAAAAAAEST}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MutablePTData}< {\b CVar}, {\b CVar}, {\b CPtSet} > {\b MutPTDataTy}{\bkmkstart AAAAAAAESU}
{\bkmkend AAAAAAAESU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, PointsTo > {\b PtrToBVPtsMap}{\bkmkstart AAAAAAAESV}
{\bkmkend AAAAAAAESV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, NodeSet > {\b PtrToNSMap}{\bkmkstart AAAAAAAESW}
{\bkmkend AAAAAAAESW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a pointer to its BitVector points-to representation }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, {\b CPtSet} > {\b PtrToCPtsMap}{\bkmkstart AAAAAAAESX}
{\bkmkend AAAAAAAESX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CondPTAImpl} ({\b PAG} *{\b pag}, {\b PointerAnalysis::PTATY} type)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a pointer to its conditional points-to set }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~CondPTAImpl} (){\bkmkstart AAAAAAAESY}
{\bkmkend AAAAAAAESY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b destroy} (){\bkmkstart AAAAAAAESZ}
{\bkmkend AAAAAAAESZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Release memory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTDataTy} * {\b getPTDataTy} () const{\bkmkstart AAAAAAAETA}
{\bkmkend AAAAAAAETA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get points-to data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MutPTDataTy} * {\b getMutPTDataTy} () const{\bkmkstart AAAAAAAETB}
{\bkmkend AAAAAAAETB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasPtsMap} (void) const{\bkmkstart AAAAAAAETC}
{\bkmkend AAAAAAAETC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const MutPTDataTy::PtsMap & {\b getPtsMap} () const{\bkmkstart AAAAAAAETD}
{\bkmkend AAAAAAAETD}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PointerAnalysis} *pta){\bkmkstart AAAAAAAETE}
{\bkmkend AAAAAAAETE}
\par
}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTDataTy} * {\b ptD}{\bkmkstart AAAAAAAETF}
{\bkmkend AAAAAAAETF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Points-to data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b normalized}{\bkmkstart AAAAAAAETG}
{\bkmkend AAAAAAAETG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normalized flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PtrToBVPtsMap {\b ptrToBVPtsMap}{\bkmkstart AAAAAAAETH}
{\bkmkend AAAAAAAETH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normal points-to representation (without conditions) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PtrToNSMap} {\b objToNSRevPtsMap}{\bkmkstart AAAAAAAETI}
{\bkmkend AAAAAAAETI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normal points-to representation (without conditions) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PtrToCPtsMap {\b ptrToCPtsMap}{\bkmkstart AAAAAAAETJ}
{\bkmkend AAAAAAAETJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Conditional points-to representation (with conditions) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const {\b CPtSet} & {\b getPts} ({\b CVar} id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const Set< {\b CVar} > & {\b getRevPts} ({\b CVar} nodeId){\bkmkstart AAAAAAAETK}
{\bkmkend AAAAAAAETK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearPts} (){\bkmkstart AAAAAAAETL}
{\bkmkend AAAAAAAETL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear all data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b overlap} (const {\b CPtSet} &cpts1, const {\b CPtSet} &cpts2) const{\bkmkstart AAAAAAAETM}
{\bkmkend AAAAAAAETM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether cpts1 and cpts2 have overlap points-to targets. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b expandFIObjs} (const {\b CPtSet} &cpts, {\b CPtSet} &expandedCpts){\bkmkstart AAAAAAAETN}
{\bkmkend AAAAAAAETN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Expand all fields of an aggregate in all points-to sets. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dumpCPts} (){\bkmkstart AAAAAAAETO}
{\bkmkend AAAAAAAETO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print out conditional pts. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual PointsTo {\b getBVPointsTo} (const {\b CPtSet} &cpts) const{\bkmkstart AAAAAAAETP}
{\bkmkend AAAAAAAETP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a conditional pts return its bit vector points-to. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual PointsTo & {\b getPts} (NodeID ptr){\bkmkstart AAAAAAAETQ}
{\bkmkend AAAAAAAETQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a pointer return its bit vector points-to. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const {\b CPtSet} & {\b getCondPointsTo} (NodeID ptr){\bkmkstart AAAAAAAETR}
{\bkmkend AAAAAAAETR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a pointer return its conditional points-to. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual NodeSet & {\b getRevPts} (NodeID obj){\bkmkstart AAAAAAAEQA}
{\bkmkend AAAAAAAEQA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an object return all pointers points to this object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual AliasResult {\b alias} (const MemoryLocation &LocA, const MemoryLocation &LocB){\bkmkstart AAAAAAAETS}
{\bkmkend AAAAAAAETS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given Location infos. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual AliasResult {\b alias} (const Value *V1, const Value *V2){\bkmkstart AAAAAAAETT}
{\bkmkend AAAAAAAETT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given Value infos. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual AliasResult {\b alias} (NodeID node1, NodeID node2){\bkmkstart AAAAAAAETU}
{\bkmkend AAAAAAAETU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given two pointers. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual AliasResult {\b alias} (const {\b CVar} &var1, const {\b CVar} &var2){\bkmkstart AAAAAAAETV}
{\bkmkend AAAAAAAETV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given conditional variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual AliasResult {\b alias} (const {\b CPtSet} &pts1, const {\b CPtSet} &pts2){\bkmkstart AAAAAAAETW}
{\bkmkend AAAAAAAETW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given two conditional points-to sets. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b containBlackHoleNode} (const {\b CPtSet} &cpts){\bkmkstart AAAAAAAETX}
{\bkmkend AAAAAAAETX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test blk node for cpts. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b containConstantNode} (const {\b CPtSet} &cpts){\bkmkstart AAAAAAAETY}
{\bkmkend AAAAAAAETY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test constant node for cpts. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isCondCompatible} (const Cond &cxt1, const Cond &cxt2, bool singleton) const =0{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether two conditions are compatible (to be implemented by child class) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dumpTopLevelPtsTo} (){\bkmkstart AAAAAAAETZ}
{\bkmkend AAAAAAAETZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump points-to information of top-level pointers. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b finalize} (){\bkmkstart AAAAAAAEPX}
{\bkmkend AAAAAAAEPX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalization of pointer analysis, and normalize points-to information to Bit Vector representation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b unionPts} ({\b CVar} id, const {\b CPtSet} &target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} ({\b CVar} id, {\b CVar} ptd){\bkmkstart AAAAAAAEUA}
{\bkmkend AAAAAAAEUA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b addPts} ({\b CVar} id, {\b CVar} ptd){\bkmkstart AAAAAAAEUB}
{\bkmkend AAAAAAAEUB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b mustAlias} (const {\b CVar} &var1, const {\b CVar} &var2){\bkmkstart AAAAAAAEUC}
{\bkmkend AAAAAAAEUC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal interface to be used for conditional points-to set queries. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b contains} (const {\b CPtSet} &cpts1, const {\b CPtSet} &cpts2){\bkmkstart AAAAAAAEUD}
{\bkmkend AAAAAAAEUD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isSameVar} (const {\b CVar} &var1, const {\b CVar} &var2) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether two pointers/objects are the same one by considering their conditions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b NormalizePointsTo} (){\bkmkstart AAAAAAAEUE}
{\bkmkend AAAAAAAEUE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normalize points-to information to BitVector/conditional representation. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Cond>\par
class SVF::CondPTAImpl< Cond >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer analysis implementation which uses conditional points-to map data structure (context/path sensitive analysis) \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CondPTAImpl\:SVF::CondPTAImpl< Cond >}
{\xe \v SVF::CondPTAImpl< Cond >\:CondPTAImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Cond > {\b SVF::CondPTAImpl}< Cond >::{\b CondPTAImpl} ({\b PAG} *  {\i pag}, {\b PointerAnalysis::PTATY}  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEUF}
{\bkmkend AAAAAAAEUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a pointer to its conditional points-to set }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getPts\:SVF::CondPTAImpl< Cond >}
{\xe \v SVF::CondPTAImpl< Cond >\:getPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Cond > virtual const {\b CPtSet}& {\b SVF::CondPTAImpl}< Cond >::getPts ({\b CVar}  {\i id}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEUG}
{\bkmkend AAAAAAAEUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get points-to and reverse points-to \par
}}
{\xe \v isSameVar\:SVF::CondPTAImpl< Cond >}
{\xe \v SVF::CondPTAImpl< Cond >\:isSameVar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Cond > bool {\b SVF::CondPTAImpl}< Cond >::isSameVar (const {\b CVar} &  {\i var1}, const {\b CVar} &  {\i var2}) const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAEUH}
{\bkmkend AAAAAAAEUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether two pointers/objects are the same one by considering their conditions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
we distinguish context sensitive memory allocation here\par
}}
{\xe \v unionPts\:SVF::CondPTAImpl< Cond >}
{\xe \v SVF::CondPTAImpl< Cond >\:unionPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Cond > virtual bool {\b SVF::CondPTAImpl}< Cond >::unionPts ({\b CVar}  {\i id}, const {\b CPtSet} &  {\i target}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEUI}
{\bkmkend AAAAAAAEUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union/add points-to, and add the reverse points-to for node collapse purpose To be noted that adding reverse pts might incur 10% total overhead during solving \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/PointerAnalysisImpl.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CondStdSet< Element > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CondStdSet< Element >}
{\xe \v SVF::CondStdSet< Element >}
{\bkmkstart AAAAAAADYV}
{\bkmkend AAAAAAADYV}
\par
{
{\f2 #include <ConditionalPT.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedSet< Element >::iterator {\b iterator}{\bkmkstart AAAAAAADYW}
{\bkmkend AAAAAAADYW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedSet< Element >::const_iterator {\b const_iterator}{\bkmkstart AAAAAAADYX}
{\bkmkend AAAAAAADYX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CondStdSet} (const {\b CondStdSet}< Element > &cptsSet){\bkmkstart AAAAAAADYY}
{\bkmkend AAAAAAADYY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b test_and_set} (const Element &var){\bkmkstart AAAAAAADYZ}
{\bkmkend AAAAAAADYZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if the element is added. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b test} (const Element &var) const{\bkmkstart AAAAAAADZA}
{\bkmkend AAAAAAADZA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if the element is in the set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b set} (const Element &var){\bkmkstart AAAAAAADZB}
{\bkmkend AAAAAAADZB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add the element into set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reset} (const Element &var){\bkmkstart AAAAAAADZC}
{\bkmkend AAAAAAADZC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove var from the set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b empty} () const{\bkmkstart AAAAAAADZD}
{\bkmkend AAAAAAADZD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set size. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned {\b size} () const{\bkmkstart AAAAAAADZE}
{\bkmkend AAAAAAADZE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned {\b count} () const{\bkmkstart AAAAAAADZF}
{\bkmkend AAAAAAADZF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b clear} (){\bkmkstart AAAAAAADZG}
{\bkmkend AAAAAAADZG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b begin} (){\bkmkstart AAAAAAADZH}
{\bkmkend AAAAAAADZH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b end} (){\bkmkstart AAAAAAADZI}
{\bkmkend AAAAAAADZI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b begin} () const{\bkmkstart AAAAAAADZJ}
{\bkmkend AAAAAAADZJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b end} () const{\bkmkstart AAAAAAADZK}
{\bkmkend AAAAAAADZK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator|=} (const {\b CondStdSet}< Element > &rhs){\bkmkstart AAAAAAADZL}
{\bkmkend AAAAAAADZL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overload operators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator&=} (const {\b CondStdSet}< Element > &rhs){\bkmkstart AAAAAAADZM}
{\bkmkend AAAAAAADZM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b CondStdSet}< Element > &rhs) const{\bkmkstart AAAAAAADZN}
{\bkmkend AAAAAAADZN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b CondStdSet}< Element > &rhs) const{\bkmkstart AAAAAAADZO}
{\bkmkend AAAAAAADZO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CondStdSet}< Element > & {\b operator=} (const {\b CondStdSet}< Element > &rhs){\bkmkstart AAAAAAADZP}
{\bkmkend AAAAAAADZP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator<} (const {\b CondStdSet}< Element > &rhs) const{\bkmkstart AAAAAAADZQ}
{\bkmkend AAAAAAADZQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b intersects} (const {\b CondStdSet}< Element > &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b toString} () const{\bkmkstart AAAAAAADZR}
{\bkmkend AAAAAAADZR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const ElementSet & {\b getElementSet} () const{\bkmkstart AAAAAAADZS}
{\bkmkend AAAAAAADZS}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Element>\par
class SVF::CondStdSet< Element >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Conditional variable set \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v intersects\:SVF::CondStdSet< Element >}
{\xe \v SVF::CondStdSet< Element >\:intersects}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Element > bool {\b SVF::CondStdSet}< Element >::intersects (const {\b CondStdSet}< Element > &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADZT}
{\bkmkend AAAAAAADZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return TRUE if this and RHS share common elements. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/ConditionalPT.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CondVar< Cond > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CondVar< Cond >}
{\xe \v SVF::CondVar< Cond >}
{\bkmkstart AAAAAAADYJ}
{\bkmkend AAAAAAADYJ}
\par
{
{\f2 #include <ConditionalPT.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CondVar} (const Cond &cond, NodeID id){\bkmkstart AAAAAAADYK}
{\bkmkend AAAAAAADYK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CondVar} (const {\b CondVar} &conVar){\bkmkstart AAAAAAADYL}
{\bkmkend AAAAAAADYL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CondVar} (){\bkmkstart AAAAAAADYM}
{\bkmkend AAAAAAADYM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CondVar} & {\b operator=} (const {\b CondVar} &rhs){\bkmkstart AAAAAAADYN}
{\bkmkend AAAAAAADYN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b CondVar} &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Cond & {\b get_cond} () const{\bkmkstart AAAAAAADYO}
{\bkmkend AAAAAAADYO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b get_id} () const{\bkmkstart AAAAAAADYP}
{\bkmkend AAAAAAADYP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b toString} () const{\bkmkstart AAAAAAADYQ}
{\bkmkend AAAAAAADYQ}
\par
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \par
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b CondVar} &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b CondVar} &rhs) const{\bkmkstart AAAAAAADYR}
{\bkmkend AAAAAAADYR}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b raw_ostream} & {\b operator<<} ({\b raw_ostream} &o, const {\b CondVar}< Cond > &cvar){\bkmkstart AAAAAAADYS}
{\bkmkend AAAAAAADYS}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Cond>\par
class SVF::CondVar< Cond >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Conditional Variable (c,v) A context/path condition A variable NodeID \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator<\:SVF::CondVar< Cond >}
{\xe \v SVF::CondVar< Cond >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Cond > bool {\b SVF::CondVar}< Cond >::operator< (const {\b CondVar}< Cond > &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADYT}
{\bkmkend AAAAAAADYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Less than implementation. \par
}}
{\xe \v operator==\:SVF::CondVar< Cond >}
{\xe \v SVF::CondVar< Cond >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Cond > bool {\b SVF::CondVar}< Cond >::operator== (const {\b CondVar}< Cond > &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADYU}
{\bkmkend AAAAAAADYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Comparison between two elements. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/ConditionalPT.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ConstraintEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ConstraintEdge}
{\xe \v SVF::ConstraintEdge}
{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
Inheritance diagram for SVF::ConstraintEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_constraint_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ConstraintEdgeK} \{ {\b Addr}
, {\b Copy}
, {\b Store}
, {\b Load}
, {\b NormalGep}
, {\b VariantGep}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericNode}< {\b ConstraintNode}, {\b ConstraintEdge} >::GEdgeSetTy {\b ConstraintEdgeSetTy}{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraint edge type. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ConstraintEdge} ({\b ConstraintNode} *s, {\b ConstraintNode} *d, {\b ConstraintEdgeK} k, EdgeID id=0){\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ~ConstraintEdge} (){\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

EdgeID {\b getEdgeID} () const{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return edge ID. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericConsEdgeTy} *edge){\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ClassOf. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v ConstraintEdgeK\:SVF::ConstraintEdge}
{\xe \v SVF::ConstraintEdge\:ConstraintEdgeK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SVF::ConstraintEdge::ConstraintEdgeK}}}
\par
{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
five kinds of constraint graph edges Gep edge is used for field sensitivity \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ConsGEdge.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ConstraintGraph Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph}
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
\par
{
{\f2 #include <ConsG.h>}}\par
Inheritance diagram for SVF::ConstraintGraph:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_constraint_graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, {\b ConstraintNode} * > {\b ConstraintNodeIDToNodeMapTy}{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef ConstraintEdge::ConstraintEdgeSetTy::iterator {\b ConstraintNodeIter}{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, NodeID > {\b NodeToRepMap}{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, NodeBS > {\b NodeToSubsMap}{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< NodeID > {\b WorkList}{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ConstraintGraph} ({\b PAG} *p){\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~ConstraintGraph} (){\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ConstraintNode} * {\b getConstraintNode} (NodeID id) const{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get/add/remove constraint node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addConstraintNode} ({\b ConstraintNode} *node, NodeID id){\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasConstraintNode} (NodeID id) const{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeConstraintNode} ({\b ConstraintNode} *node){\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasEdge} ({\b ConstraintNode} *src, {\b ConstraintNode} *dst, {\b ConstraintEdge::ConstraintEdgeK} kind){\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ConstraintEdge} * {\b getEdge} ({\b ConstraintNode} *src, {\b ConstraintNode} *dst, {\b ConstraintEdge::ConstraintEdgeK} kind){\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get an edge via its src and dst nodes and kind. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AddrCGEdge} * {\b addAddrCGEdge} (NodeID src, NodeID dst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a {\b PAG} edge into Edge map. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CopyCGEdge} * {\b addCopyCGEdge} (NodeID src, NodeID dst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Copy edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NormalGepCGEdge} * {\b addNormalGepCGEdge} (NodeID src, NodeID dst, const {\b LocationSet} &ls)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Gep edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VariantGepCGEdge} * {\b addVariantGepCGEdge} (NodeID src, NodeID dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LoadCGEdge} * {\b addLoadCGEdge} (NodeID src, NodeID dst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Load edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StoreCGEdge} * {\b addStoreCGEdge} (NodeID src, NodeID dst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Store edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ConstraintEdge::ConstraintEdgeSetTy} & {\b getAddrCGEdges} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b PAG} edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ConstraintEdge::ConstraintEdgeSetTy} & {\b getDirectCGEdges} (){\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Copy/call/ret/gep edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ConstraintEdge::ConstraintEdgeSetTy} & {\b getLoadCGEdges} (){\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Load edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ConstraintEdge::ConstraintEdgeSetTy} & {\b getStoreCGEdges} (){\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Store edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reTargetDstOfEdge} ({\b ConstraintEdge} *edge, {\b ConstraintNode} *newDstNode)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used for cycle elimination. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reTargetSrcOfEdge} ({\b ConstraintEdge} *edge, {\b ConstraintNode} *newSrcNode)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove edge from old src target, change edge dst id and add modifed edge into new src. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeAddrEdge} ({\b AddrCGEdge} *edge)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove addr edge from their src and dst edge sets. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeDirectEdge} ({\b ConstraintEdge} *edge)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove direct edge from their src and dst edge sets. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeLoadEdge} ({\b LoadCGEdge} *edge)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove load edge from their src and dst edge sets. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeStoreEdge} ({\b StoreCGEdge} *edge)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove store edge from their src and dst edge sets. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b sccRepNode} (NodeID id) const{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC rep/sub nodes methods. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeBS & {\b sccSubNodes} (NodeID id){\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setRep} (NodeID node, NodeID rep){\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setSubs} (NodeID node, NodeBS &subs){\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b resetSubs} (NodeID node){\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b moveInEdgesToRepNode} ({\b ConstraintNode} *node, {\b ConstraintNode} *rep)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b moveOutEdgesToRepNode} ({\b ConstraintNode} *node, {\b ConstraintNode} *rep)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b moveEdgesToRepNode} ({\b ConstraintNode} *node, {\b ConstraintNode} *rep)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isZeroOffsettedGepCGEdge} ({\b ConstraintEdge} *edge) const{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if a given edge is a {\b NormalGepCGEdge} with 0 offset. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const PAG::CallSiteToFunPtrMap & {\b getIndirectCallsites} () const{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wrappers for invoking {\b PAG} methods. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getBlackHoleNode} (){\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isBlkObjOrConstantObj} (NodeID id){\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeBS & {\b getAllFieldsObjNode} (NodeID id){\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getBaseObjNode} (NodeID id){\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isSingleFieldObj} (NodeID id) const{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b getGepObjNode} (NodeID id, const {\b LocationSet} &ls)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a field of a memory object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b getFIObjNode} (NodeID id)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a field-insensitive node of a memory object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isPWCNode} (NodeID nodeId){\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check/Set PWC (positive weight cycle) flag. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setPWCNode} (NodeID nodeId){\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasNodesToBeCollapsed} () const{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add/get nodes to be collapsed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addNodeToBeCollapsed} (NodeID id){\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getNextCollapseNode} (){\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump} (std::string name)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump graph into dot file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print CG into terminal. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b buildCG} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGEdge::PAGEdgeSetTy & {\b getPAGEdgeSet} ({\b PAGEdge::PEDGEK} kind){\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getValueNode} (const Value *value) const{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wappers used internally, not expose to Andernsen Pass. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getReturnNode} (const {\b SVFFunction} *value) const{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getVarargNode} (const {\b SVFFunction} *value) const{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAG} * {\b pag}{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeToRepMap {\b nodeToRepMap}{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeToSubsMap {\b nodeToSubsMap}{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b WorkList} {\b nodesToBeCollapsed}{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

EdgeID {\b edgeIndex}{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ConstraintEdge::ConstraintEdgeSetTy} {\b AddrCGEdgeSet}{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ConstraintEdge::ConstraintEdgeSetTy} {\b directEdgeSet}{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ConstraintEdge::ConstraintEdgeSetTy} {\b LoadCGEdgeSet}{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ConstraintEdge::ConstraintEdgeSetTy} {\b StoreCGEdgeSet}{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraint graph for {\b Andersen}'s analysis ConstraintNodes are same as PAGNodes ConstraintEdges are self-defined edges (initialized with ConstraintEdges) \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addAddrCGEdge\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:addAddrCGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AddrCGEdge} * ConstraintGraph::addAddrCGEdge (NodeID  {\i src}, NodeID  {\i dst})}}
\par
{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a {\b PAG} edge into Edge map. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Address edge\par
Add an address edge \par
}}
{\xe \v addCopyCGEdge\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:addCopyCGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CopyCGEdge} * ConstraintGraph::addCopyCGEdge (NodeID  {\i src}, NodeID  {\i dst})}}
\par
{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Copy edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Copy edge \par
}}
{\xe \v addLoadCGEdge\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:addLoadCGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LoadCGEdge} * ConstraintGraph::addLoadCGEdge (NodeID  {\i src}, NodeID  {\i dst})}}
\par
{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Load edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Load edge \par
}}
{\xe \v addNormalGepCGEdge\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:addNormalGepCGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NormalGepCGEdge} * ConstraintGraph::addNormalGepCGEdge (NodeID  {\i src}, NodeID  {\i dst}, const {\b LocationSet} &  {\i ls})}}
\par
{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Gep edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Gep edge \par
}}
{\xe \v addStoreCGEdge\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:addStoreCGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StoreCGEdge} * ConstraintGraph::addStoreCGEdge (NodeID  {\i src}, NodeID  {\i dst})}}
\par
{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Store edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Store edge \par
}}
{\xe \v addVariantGepCGEdge\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:addVariantGepCGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b VariantGepCGEdge} * ConstraintGraph::addVariantGepCGEdge (NodeID  {\i src}, NodeID  {\i dst})}}
\par
{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add variant gep edge \par
}}
{\xe \v buildCG\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:buildCG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ConstraintGraph::buildCG (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start building constraint graph \par
}}
{\xe \v destroy\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ConstraintGraph::destroy (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory has been cleaned up at {\b GenericGraph} \par
}}
{\xe \v dump\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ConstraintGraph::dump (std::string  {\i name})}}
\par
{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump graph into dot file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump constraint graph \par
}}
{\xe \v getAddrCGEdges\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:getAddrCGEdges}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ConstraintEdge::ConstraintEdgeSetTy}& SVF::ConstraintGraph::getAddrCGEdges (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b PAG} edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Address edges \par
}}
{\xe \v getFIObjNode\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:getFIObjNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID SVF::ConstraintGraph::getFIObjNode (NodeID  {\i id}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a field-insensitive node of a memory object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a node when it is (1) not exist on graph and (2) not merged\par
}}
{\xe \v getGepObjNode\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:getGepObjNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID SVF::ConstraintGraph::getGepObjNode (NodeID  {\i id}, const {\b LocationSet} &  {\i ls}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a field of a memory object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a node when it is (1) not exist on graph and (2) not merged\par
}}
{\xe \v moveEdgesToRepNode\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:moveEdgesToRepNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::ConstraintGraph::moveEdgesToRepNode ({\b ConstraintNode} *  {\i node}, {\b ConstraintNode} *  {\i rep}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Move} incoming/outgoing direct edges of a sub node to its rep node Return TRUE if there's a gep edge inside this SCC (PWC). \par
}}
{\xe \v moveInEdgesToRepNode\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:moveInEdgesToRepNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ConstraintGraph::moveInEdgesToRepNode ({\b ConstraintNode} *  {\i node}, {\b ConstraintNode} *  {\i rep})}}
\par
{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Move} incoming direct edges of a sub node which is outside the SCC to its rep node Remove incoming direct edges of a sub node which is inside the SCC from its rep node Return TRUE if there's a gep edge inside this SCC (PWC).\par
{\b Move} incoming direct edges of a sub node which is outside SCC to its rep node Remove incoming direct edges of a sub node which is inside SCC from its rep node \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
only copy and gep edge can be removed\par
}}
{\xe \v moveOutEdgesToRepNode\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:moveOutEdgesToRepNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ConstraintGraph::moveOutEdgesToRepNode ({\b ConstraintNode} *  {\i node}, {\b ConstraintNode} *  {\i rep})}}
\par
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Move} outgoing direct edges of a sub node which is outside the SCC to its rep node Remove outgoing direct edges of sub node which is inside the SCC from its rep node Return TRUE if there's a gep edge inside this SCC (PWC).\par
{\b Move} outgoing direct edges of a sub node which is outside SCC to its rep node Remove outgoing direct edges of a sub node which is inside SCC from its rep node \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
only copy and gep edge can be removed\par
}}
{\xe \v print\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ConstraintGraph::print ()}}
\par
{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print CG into terminal. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print this constraint graph including its nodes and edges \par
}}
{\xe \v removeAddrEdge\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:removeAddrEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ConstraintGraph::removeAddrEdge ({\b AddrCGEdge} *  {\i edge})}}
\par
{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove addr edge from their src and dst edge sets. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove addr edge from their src and dst edge sets \par
}}
{\xe \v removeDirectEdge\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:removeDirectEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ConstraintGraph::removeDirectEdge ({\b ConstraintEdge} *  {\i edge})}}
\par
{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove direct edge from their src and dst edge sets. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove edges from their src and dst edge sets \par
}}
{\xe \v removeLoadEdge\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:removeLoadEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ConstraintGraph::removeLoadEdge ({\b LoadCGEdge} *  {\i edge})}}
\par
{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove load edge from their src and dst edge sets. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove load edge from their src and dst edge sets \par
}}
{\xe \v removeStoreEdge\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:removeStoreEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ConstraintGraph::removeStoreEdge ({\b StoreCGEdge} *  {\i edge})}}
\par
{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove store edge from their src and dst edge sets. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove store edge from their src and dst edge sets \par
}}
{\xe \v reTargetDstOfEdge\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:reTargetDstOfEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ConstraintGraph::reTargetDstOfEdge ({\b ConstraintEdge} *  {\i edge}, {\b ConstraintNode} *  {\i newDstNode})}}
\par
{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used for cycle elimination. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove edge from old dst target, change edge dst id and add modifed edge into new dst\par
Re-target dst node of an edge\par
(1) Remove edge from old dst target, (2) Change edge dst id and (3) Add modifed edge into new dst \par
}}
{\xe \v reTargetSrcOfEdge\:SVF::ConstraintGraph}
{\xe \v SVF::ConstraintGraph\:reTargetSrcOfEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ConstraintGraph::reTargetSrcOfEdge ({\b ConstraintEdge} *  {\i edge}, {\b ConstraintNode} *  {\i newSrcNode})}}
\par
{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove edge from old src target, change edge dst id and add modifed edge into new src. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Re-target src node of an edge (1) Remove edge from old src target, (2) Change edge src id and (3) Add modified edge into new src \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ConsG.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ConsG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ConstraintNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ConstraintNode}
{\xe \v SVF::ConstraintNode}
{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
Inheritance diagram for SVF::ConstraintNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_constraint_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SCCEdgeFlag} \{ {\b Copy}
, {\b Direct}
 \}{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef ConstraintEdge::ConstraintEdgeSetTy::iterator {\b iterator}{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef ConstraintEdge::ConstraintEdgeSetTy::const_iterator {\b const_iterator}{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ConstraintNode} (NodeID i){\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isPWCNode} () const{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a node involves in PWC, if so, all its points-to elements should become field-insensitive. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setPWCNode} (){\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isdirectEdge} ({\b ConstraintEdge::ConstraintEdgeK} kind){\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Direct and Indirect {\b PAG} edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isIndirectEdge} ({\b ConstraintEdge::ConstraintEdgeK} kind){\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b ConstraintEdge::ConstraintEdgeSetTy} & {\b getDirectInEdges} () const{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return constraint edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b ConstraintEdge::ConstraintEdgeSetTy} & {\b getDirectOutEdges} () const{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b ConstraintEdge::ConstraintEdgeSetTy} & {\b getCopyInEdges} () const{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b ConstraintEdge::ConstraintEdgeSetTy} & {\b getCopyOutEdges} () const{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b ConstraintEdge::ConstraintEdgeSetTy} & {\b getGepInEdges} () const{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b ConstraintEdge::ConstraintEdgeSetTy} & {\b getGepOutEdges} () const{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b ConstraintEdge::ConstraintEdgeSetTy} & {\b getLoadInEdges} () const{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b ConstraintEdge::ConstraintEdgeSetTy} & {\b getLoadOutEdges} () const{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b ConstraintEdge::ConstraintEdgeSetTy} & {\b getStoreInEdges} () const{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b ConstraintEdge::ConstraintEdgeSetTy} & {\b getStoreOutEdges} () const{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b ConstraintEdge::ConstraintEdgeSetTy} & {\b getAddrInEdges} () const{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b ConstraintEdge::ConstraintEdgeSetTy} & {\b getAddrOutEdges} () const{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b directOutEdgeBegin} (){\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b directOutEdgeEnd} (){\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b directInEdgeBegin} (){\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b directInEdgeEnd} (){\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b directOutEdgeBegin} () const{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b directOutEdgeEnd} () const{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b directInEdgeBegin} () const{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b directInEdgeEnd} () const{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ConstraintEdge::ConstraintEdgeSetTy} & {\b incomingAddrEdges} (){\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ConstraintEdge::ConstraintEdgeSetTy} & {\b outgoingAddrEdges} (){\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b outgoingAddrsBegin} () const{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b outgoingAddrsEnd} () const{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b incomingAddrsBegin} () const{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b incomingAddrsEnd} () const{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b outgoingLoadsBegin} () const{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b outgoingLoadsEnd} () const{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b incomingLoadsBegin} () const{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b incomingLoadsEnd} () const{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b outgoingStoresBegin} () const{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b outgoingStoresEnd} () const{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b incomingStoresBegin} () const{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b incomingStoresEnd} () const{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addIncomingCopyEdge} ({\b CopyCGEdge} *inEdge){\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add constraint graph edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addIncomingGepEdge} ({\b GepCGEdge} *inEdge){\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addOutgoingCopyEdge} ({\b CopyCGEdge} *outEdge){\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addOutgoingGepEdge} ({\b GepCGEdge} *outEdge){\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addIncomingAddrEdge} ({\b AddrCGEdge} *inEdge){\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addIncomingLoadEdge} ({\b LoadCGEdge} *inEdge){\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addIncomingStoreEdge} ({\b StoreCGEdge} *inEdge){\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addIncomingDirectEdge} ({\b ConstraintEdge} *inEdge){\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addOutgoingAddrEdge} ({\b AddrCGEdge} *outEdge){\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addOutgoingLoadEdge} ({\b LoadCGEdge} *outEdge){\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addOutgoingStoreEdge} ({\b StoreCGEdge} *outEdge){\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addOutgoingDirectEdge} ({\b ConstraintEdge} *outEdge){\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeOutgoingAddrEdge} ({\b AddrCGEdge} *outEdge){\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove constraint graph edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeIncomingAddrEdge} ({\b AddrCGEdge} *inEdge){\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeOutgoingDirectEdge} ({\b ConstraintEdge} *outEdge){\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeIncomingDirectEdge} ({\b ConstraintEdge} *inEdge){\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeOutgoingLoadEdge} ({\b LoadCGEdge} *outEdge){\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeIncomingLoadEdge} ({\b LoadCGEdge} *inEdge){\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeOutgoingStoreEdge} ({\b StoreCGEdge} *outEdge){\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeIncomingStoreEdge} ({\b StoreCGEdge} *inEdge){\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b setSCCEdgeFlag} (SCCEdgeFlag f){\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b _isPWCNode}{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeBS {\b strides}{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b newExpand}{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeBS {\b baseIds}{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static SCCEdgeFlag {\b sccEdgeFlag} = ConstraintNode::Direct{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ConsGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ConsG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ContextCond Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ContextCond}
{\xe \v SVF::ContextCond}
{\bkmkstart AAAAAAAGYZ}
{\bkmkend AAAAAAAGYZ}
\par
{
{\f2 #include <DPItem.h>}}\par
Inheritance diagram for SVF::ContextCond:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_context_cond.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef CallStrCxt::const_iterator {\b const_iterator}{\bkmkstart AAAAAAAGZA}
{\bkmkend AAAAAAAGZA}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ContextCond} (){\bkmkstart AAAAAAAGZB}
{\bkmkend AAAAAAAGZB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ContextCond} (const {\b ContextCond} &cond){\bkmkstart AAAAAAAGZC}
{\bkmkend AAAAAAAGZC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~ContextCond} (){\bkmkstart AAAAAAAGZD}
{\bkmkend AAAAAAAGZD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallStrCxt & {\b getContexts} () const{\bkmkstart AAAAAAAGZE}
{\bkmkend AAAAAAAGZE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallStrCxt & {\b getContexts} (){\bkmkstart AAAAAAAGZF}
{\bkmkend AAAAAAAGZF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isConcreteCxt} () const{\bkmkstart AAAAAAAGZG}
{\bkmkend AAAAAAAGZG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether it is an concrete context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setNonConcreteCxt} (){\bkmkstart AAAAAAAGZH}
{\bkmkend AAAAAAAGZH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether it is an concrete context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b containCallStr} (NodeID cxt) const{\bkmkstart AAAAAAAGZI}
{\bkmkend AAAAAAAGZI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether contains callstring cxt. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b cxtSize} () const{\bkmkstart AAAAAAAGZJ}
{\bkmkend AAAAAAAGZJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get context size. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b pushContext} (NodeID ctx)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b matchContext} (NodeID ctx)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Match context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b ContextCond} &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b operator[]} (const u32_t index) const{\bkmkstart AAAAAAAGZK}
{\bkmkend AAAAAAAGZK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator[]. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ContextCond} & {\b operator=} (const {\b ContextCond} &rhs){\bkmkstart AAAAAAAGZL}
{\bkmkend AAAAAAAGZL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b ContextCond} &rhs) const{\bkmkstart AAAAAAAGZM}
{\bkmkend AAAAAAAGZM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b ContextCond} &rhs) const{\bkmkstart AAAAAAAGZN}
{\bkmkend AAAAAAAGZN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator!=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b begin} () const{\bkmkstart AAAAAAAGZO}
{\bkmkend AAAAAAAGZO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Begin iterators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b end} () const{\bkmkstart AAAAAAAGZP}
{\bkmkend AAAAAAAGZP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
End iterators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b toString} () const{\bkmkstart AAAAAAAGZQ}
{\bkmkend AAAAAAAGZQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump context condition. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b setMaxCxtLen} (u32_t max){\bkmkstart AAAAAAAGZR}
{\bkmkend AAAAAAAGZR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set max context limit }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u32_t {\b maximumCxt} = 0{\bkmkstart AAAAAAAGZS}
{\bkmkend AAAAAAAGZS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallStrCxt {\b context}{\bkmkstart AAAAAAAGZT}
{\bkmkend AAAAAAAGZT}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Context Condition \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v matchContext\:SVF::ContextCond}
{\xe \v SVF::ContextCond\:matchContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool SVF::ContextCond::matchContext (NodeID  {\i ctx}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGZU}
{\bkmkend AAAAAAAGZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Match context. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if context is empty, then it is the unbalanced parentheses match\par
otherwise, we perform balanced parentheses matching\par
}}
{\xe \v operator<\:SVF::ContextCond}
{\xe \v SVF::ContextCond\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::ContextCond::operator< (const {\b ContextCond} &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAGZV}
{\bkmkend AAAAAAAGZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable compare operator to avoid duplicated item insertion in map or set to be noted that two vectors can also overload operator() \par
}}
{\xe \v pushContext\:SVF::ContextCond}
{\xe \v SVF::ContextCond\:pushContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool SVF::ContextCond::pushContext (NodeID  {\i ctx}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGZW}
{\bkmkend AAAAAAAGZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push context. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
handle out of context limit case\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/DPItem.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Util/PathCondAllocator.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ContextDDA Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ContextDDA}
{\xe \v SVF::ContextDDA}
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
\par
{
{\f2 #include <ContextDDA.h>}}\par
Inheritance diagram for SVF::ContextDDA:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_context_d_d_a.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ContextDDA} ({\b PAG} *{\b _pag}, {\b DDAClient} *client)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ContextDDA} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} () override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialization of the analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b finalize} () override{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b analyze} () override{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dummy analyze method }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b computeDDAPts} (NodeID id) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute points-to set for an unconditional pointer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const {\b CxtPtSet} & {\b computeDDAPts} (const {\b CxtVar} &cxtVar)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute points-to set for a context-sensitive pointer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleOutOfBudgetDpm} (const {\b CxtLocDPItem} &dpm)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle out-of-budget dpm. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b CxtPtSet} {\b getConservativeCPts} (const {\b CxtLocDPItem} &dpm) override{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Override parent method. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual NodeID {\b getPtrNodeID} (const {\b CxtVar} &var) const override{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Override parent method. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b handleBKCondition} ({\b CxtLocDPItem} &dpm, const {\b SVFGEdge} *edge) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle condition for context or path analysis (backward analysis) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isHeapCondMemObj} (const {\b CxtVar} &var, const {\b StoreSVFGNode} *store) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b testIndCallReachability} ({\b CxtLocDPItem} &dpm, const {\b SVFFunction} *callee, const {\b CallBlockNode} *cs){\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
refine indirect call edge }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CallSiteID {\b getCSIDAtCall} ({\b CxtLocDPItem} &dpm, const {\b SVFGEdge} *edge)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get callsite id from call, return 0 if it is a spurious call edge }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CallSiteID {\b getCSIDAtRet} ({\b CxtLocDPItem} &dpm, const {\b SVFGEdge} *edge)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get callsite id from return, return 0 if it is a spurious return edge }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b popRecursiveCallSites} ({\b CxtLocDPItem} &dpm){\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pop recursive callsites. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isEdgeInRecursion} (CallSiteID csId){\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether call/return inside recursion. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b updateCallGraphAndSVFG} (const {\b CxtLocDPItem} &dpm, const {\b CallBlockNode} *cs, SVFGEdgeSet &svfgEdges) override{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update call graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b edgeInCallGraphSCC} (const {\b SVFGEdge} *edge){\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return TRUE if this edge is inside a {\b SVFG} SCC, i.e., src node and dst node are in the same SCC on the {\b SVFG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b CxtPtSet} {\b processGepPts} (const {\b GepSVFGNode} *gep, const {\b CxtPtSet} &srcPts) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
processGep node }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleAddr} ({\b CxtPtSet} &pts, const {\b CxtLocDPItem} &dpm, const {\b AddrSVFGNode} *addr) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle Address SVFGNode to add proper conditional points-to. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b propagateViaObj} (const {\b CxtVar} &storeObj, const {\b CxtVar} &loadObj) override{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate along indirect value-flow if two objects of load and store are same. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isCondCompatible} (const {\b ContextCond} &cxt1, const {\b ContextCond} &cxt2, bool singleton) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isInsensitiveCallRet} (const {\b SVFGEdge} *edge){\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this edge is treated context-insensitively. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

ConstSVFGEdgeSet & {\b getInsensitiveEdgeSet} (){\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return insensitive edge set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dumpContexts} (const {\b ContextCond} &cxts){\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dump context call strings }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b PTAName} () const override{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return PTA name. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Context-, Flow- Sensitive Demand-driven Analysis \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ContextDDA\:SVF::ContextDDA}
{\xe \v SVF::ContextDDA\:ContextDDA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ContextDDA::ContextDDA ({\b PAG} *  {\i _pag}, {\b DDAClient} *  {\i client})}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor \par
}}
{\xe \v ~ContextDDA\:SVF::ContextDDA}
{\xe \v SVF::ContextDDA\:~ContextDDA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ContextDDA::~ContextDDA (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v computeDDAPts\:SVF::ContextDDA}
{\xe \v SVF::ContextDDA\:computeDDAPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CxtPtSet} & ContextDDA::computeDDAPts (const {\b CxtVar} &  {\i var}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute points-to set for a context-sensitive pointer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute points-to set for a context-sensitive pointer \par
}}
{\xe \v computeDDAPts\:SVF::ContextDDA}
{\xe \v SVF::ContextDDA\:computeDDAPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ContextDDA::computeDDAPts (NodeID  {\i id}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute points-to set for an unconditional pointer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute points-to set for an unconditional pointer \par
}{
Reimplemented from {\b SVF::PointerAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getCSIDAtCall\:SVF::ContextDDA}
{\xe \v SVF::ContextDDA\:getCSIDAtCall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CallSiteID ContextDDA::getCSIDAtCall ({\b CxtLocDPItem} &  {\i dpm}, const {\b SVFGEdge} *  {\i edge})}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get callsite id from call, return 0 if it is a spurious call edge }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get callsite id from call, return 0 if it is a spurious call edge translate the callsite id from pre-computed callgraph on {\b SVFG} to the one on current callgraph \par
}}
{\xe \v getCSIDAtRet\:SVF::ContextDDA}
{\xe \v SVF::ContextDDA\:getCSIDAtRet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CallSiteID ContextDDA::getCSIDAtRet ({\b CxtLocDPItem} &  {\i dpm}, const {\b SVFGEdge} *  {\i edge})}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get callsite id from return, return 0 if it is a spurious return edge }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get callsite id from return, return 0 if it is a spurious return edge translate the callsite id from pre-computed callgraph on {\b SVFG} to the one on current callgraph \par
}}
{\xe \v handleAddr\:SVF::ContextDDA}
{\xe \v SVF::ContextDDA\:handleAddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void SVF::ContextDDA::handleAddr ({\b CxtPtSet} &  {\i pts}, const {\b CxtLocDPItem} &  {\i dpm}, const {\b AddrSVFGNode} *  {\i addr}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle Address SVFGNode to add proper conditional points-to. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
whether this object is set field-insensitive during pre-analysis\par
}{
Implements {\b SVF::DDAVFSolver< CxtVar, CxtPtSet, CxtLocDPItem >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v handleBKCondition\:SVF::ContextDDA}
{\xe \v SVF::ContextDDA\:handleBKCondition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ContextDDA::handleBKCondition ({\b CxtLocDPItem} &  {\i dpm}, const {\b SVFGEdge} *  {\i edge}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle condition for context or path analysis (backward analysis) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle conditions during backward traversing. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
we don't handle context in recursions, they treated as assignments\par
we don't handle context in recursions, they treated as assignments\par
TODO: When this call site id is contained in current call string, we may find a recursion. Try to solve this later.\par
}{
Reimplemented from {\b SVF::DDAVFSolver< CxtVar, CxtPtSet, CxtLocDPItem >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v handleOutOfBudgetDpm\:SVF::ContextDDA}
{\xe \v SVF::ContextDDA\:handleOutOfBudgetDpm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ContextDDA::handleOutOfBudgetDpm (const {\b CxtLocDPItem} &  {\i dpm})}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle out-of-budget dpm. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle out-of-budget dpm \par
}}
{\xe \v initialize\:SVF::ContextDDA}
{\xe \v SVF::ContextDDA\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ContextDDA::initialize (){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialization of the analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Analysis initialization \par
}{
Reimplemented from {\b SVF::PointerAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isCondCompatible\:SVF::ContextDDA}
{\xe \v SVF::ContextDDA\:isCondCompatible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ContextDDA::isCondCompatible (const {\b ContextCond} &  {\i cxt1}, const {\b ContextCond} &  {\i cxt2}, bool  {\i singleton}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether two call string contexts are compatible which may represent the same memory object compare with call strings from last few callsite ids (most recent ids to objects): compatible : (e.g., 123 == 123, 123 == 23). not compatible (e.g., 123 != 423)\par
context conditions of local(not in recursion) and global variables are compatible \par
}{
Implements {\b SVF::CondPTAImpl< ContextCond >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isHeapCondMemObj\:SVF::ContextDDA}
{\xe \v SVF::ContextDDA\:isHeapCondMemObj}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ContextDDA::isHeapCondMemObj (const {\b CxtVar} &  {\i var}, const {\b StoreSVFGNode} *  {\i store}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
we exclude concrete heap given the following conditions: (1) concrete calling context (not involved in recursion and not exceed the maximum context limit) (2) not inside loop \par
}{
Reimplemented from {\b SVF::DDAVFSolver< CxtVar, CxtPtSet, CxtLocDPItem >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processGepPts\:SVF::ContextDDA}
{\xe \v SVF::ContextDDA\:processGepPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CxtPtSet} ContextDDA::processGepPts (const {\b GepSVFGNode} *  {\i gep}, const {\b CxtPtSet} &  {\i srcPts}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
processGep node }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate field objects for structs \par
}{
Implements {\b SVF::DDAVFSolver< CxtVar, CxtPtSet, CxtLocDPItem >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/DDA/ContextDDA.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/DDA/ContextDDA.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CopyCGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CopyCGEdge}
{\xe \v SVF::CopyCGEdge}
{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
\par
{
{\f2 #include <ConsGEdge.h>}}\par
Inheritance diagram for SVF::CopyCGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_copy_c_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CopyCGEdge} ({\b ConstraintNode} *s, {\b ConstraintNode} *d, EdgeID id){\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CopyCGEdge} *){\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ConstraintEdge} *edge){\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericConsEdgeTy} *edge){\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ConsGEdge.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CopyPE Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CopyPE}
{\xe \v SVF::CopyPE}
{\bkmkstart AAAAAAACIN}
{\bkmkend AAAAAAACIN}
\par
{
{\f2 #include <PAGEdge.h>}}\par
Inheritance diagram for SVF::CopyPE:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_copy_p_e.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CopyPE} ({\b PAGNode} *s, {\b PAGNode} *d){\bkmkstart AAAAAAACIO}
{\bkmkend AAAAAAACIO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACIP}
{\bkmkend AAAAAAACIP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CopyPE} *){\bkmkstart AAAAAAACIQ}
{\bkmkend AAAAAAACIQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGEdge} *edge){\bkmkstart AAAAAAACIR}
{\bkmkend AAAAAAACIR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGEdgeTy} *edge){\bkmkstart AAAAAAACIS}
{\bkmkend AAAAAAACIS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CopyVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CopyVFGNode}
{\xe \v SVF::CopyVFGNode}
{\bkmkstart AAAAAAADPJ}
{\bkmkend AAAAAAADPJ}
\par
{
{\f2 #include <VFGNode.h>}}\par
Inheritance diagram for SVF::CopyVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_copy_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CopyVFGNode} (NodeID id, const {\b CopyPE} *copy){\bkmkstart AAAAAAADPK}
{\bkmkend AAAAAAADPK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADPL}
{\bkmkend AAAAAAADPL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CopyVFGNode} *){\bkmkstart AAAAAAADPM}
{\bkmkend AAAAAAADPM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b StmtVFGNode} *node){\bkmkstart AAAAAAADPN}
{\bkmkend AAAAAAADPN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADPO}
{\bkmkend AAAAAAADPO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADPP}
{\bkmkend AAAAAAADPP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b VFGNode} for copies \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CSC Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CSC}
{\xe \v SVF::CSC}
{\bkmkstart AAAAAAAHTB}
{\bkmkend AAAAAAAHTB}
\par
{
{\f2 #include <CSC.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, NodeID > {\b IdToIdMap}{\bkmkstart AAAAAAAHTC}
{\bkmkend AAAAAAAHTC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FILOWorkList}< NodeID > {\b WorkStack}{\bkmkstart AAAAAAAHTD}
{\bkmkend AAAAAAAHTD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef IdToIdMap::iterator {\b iterator}{\bkmkstart AAAAAAAHTE}
{\bkmkend AAAAAAAHTE}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CSC} ({\b ConstraintGraph} *g, {\b CGSCC} *c){\bkmkstart AAAAAAAHTF}
{\bkmkend AAAAAAAHTF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b find} (NodeStack &candidates){\bkmkstart AAAAAAAHTG}
{\bkmkend AAAAAAAHTG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visit} (NodeID nodeId, Size_t _w){\bkmkstart AAAAAAAHTH}
{\bkmkend AAAAAAAHTH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b clear} (){\bkmkstart AAAAAAAHTI}
{\bkmkend AAAAAAAHTI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isVisited} (NodeID nId){\bkmkstart AAAAAAAHTJ}
{\bkmkend AAAAAAAHTJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setVisited} (NodeID nId){\bkmkstart AAAAAAAHTK}
{\bkmkend AAAAAAAHTK}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
class {\b CSC}: cycle stride calculation \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/CSC.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/CSC.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
cuddPathPair Struct Reference\par \pard\plain 
{\tc\tcl2 \v cuddPathPair}
{\xe \v cuddPathPair}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b pos}{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b neg}{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/CUDD/cuddSat.c\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CxtDPItem Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CxtDPItem}
{\xe \v SVF::CxtDPItem}
{\bkmkstart AAAAAAAHCB}
{\bkmkend AAAAAAAHCB}
Inheritance diagram for SVF::CxtDPItem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_cxt_d_p_item.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtDPItem} (NodeID c, const {\b ContextCond} &cxt){\bkmkstart AAAAAAAHCC}
{\bkmkend AAAAAAAHCC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtDPItem} (const {\b CxtVar} &var){\bkmkstart AAAAAAAHCD}
{\bkmkend AAAAAAAHCD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtDPItem} (const {\b CxtDPItem} &dps){\bkmkstart AAAAAAAHCE}
{\bkmkend AAAAAAAHCE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~CxtDPItem} (){\bkmkstart AAAAAAAHCF}
{\bkmkend AAAAAAAHCF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b ContextCond} & {\b getContexts} () const{\bkmkstart AAAAAAAHCG}
{\bkmkend AAAAAAAHCG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b pushContext} (NodeID cxt){\bkmkstart AAAAAAAHCH}
{\bkmkend AAAAAAAHCH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b matchContext} (NodeID cxt){\bkmkstart AAAAAAAHCI}
{\bkmkend AAAAAAAHCI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Match context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b CxtDPItem} &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtDPItem} & {\b operator=} (const {\b CxtDPItem} &rhs){\bkmkstart AAAAAAAHCJ}
{\bkmkend AAAAAAAHCJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading Operator=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b CxtDPItem} &rhs) const{\bkmkstart AAAAAAAHCK}
{\bkmkend AAAAAAAHCK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading Operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b CxtDPItem} &rhs) const{\bkmkstart AAAAAAAHCL}
{\bkmkend AAAAAAAHCL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading Operator!=. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator<\:SVF::CxtDPItem}
{\xe \v SVF::CxtDPItem\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::CxtDPItem::operator< (const {\b CxtDPItem} &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHCM}
{\bkmkend AAAAAAAHCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable compare operator to avoid duplicated item insertion in map or set to be noted that two vectors can also overload operator() \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/DPItem.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CxtProc Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CxtProc}
{\xe \v SVF::CxtProc}
{\bkmkstart AAAAAAAGWZ}
{\bkmkend AAAAAAAGWZ}
\par
{
{\f2 #include <CxtStmt.h>}}\par
Inheritance diagram for SVF::CxtProc:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_cxt_proc.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtProc} (const CallStrCxt &c, const {\b SVFFunction} *f){\bkmkstart AAAAAAAGXA}
{\bkmkend AAAAAAAGXA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtProc} (const {\b CxtProc} &ctm){\bkmkstart AAAAAAAGXB}
{\bkmkend AAAAAAAGXB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~CxtProc} (){\bkmkstart AAAAAAAGXC}
{\bkmkend AAAAAAAGXC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getProc} () const{\bkmkstart AAAAAAAGXD}
{\bkmkend AAAAAAAGXD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return current procedure. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallStrCxt & {\b getContext} () const{\bkmkstart AAAAAAAGXE}
{\bkmkend AAAAAAAGXE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return current context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b CxtProc} &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtProc} & {\b operator=} (const {\b CxtProc} &rhs){\bkmkstart AAAAAAAGXF}
{\bkmkend AAAAAAAGXF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b CxtProc} &rhs) const{\bkmkstart AAAAAAAGXG}
{\bkmkend AAAAAAAGXG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b CxtProc} &rhs) const{\bkmkstart AAAAAAAGXH}
{\bkmkend AAAAAAAGXH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b cxtToStr} () const{\bkmkstart AAAAAAAGXI}
{\bkmkend AAAAAAAGXI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return context in string format. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dump} () const{\bkmkstart AAAAAAAGXJ}
{\bkmkend AAAAAAAGXJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump {\b CxtProc}. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallStrCxt {\b cxt}{\bkmkstart AAAAAAAGXK}
{\bkmkend AAAAAAAGXK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b fun}{\bkmkstart AAAAAAAGXL}
{\bkmkend AAAAAAAGXL}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Context-sensitive procedure <c,m> c represent current context m represent current procedure \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator<\:SVF::CxtProc}
{\xe \v SVF::CxtProc\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::CxtProc::operator< (const {\b CxtProc} &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAGXM}
{\bkmkend AAAAAAAGXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable compare operator to avoid duplicated item insertion in map or set to be noted that two vectors can also overload operator() \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/CxtStmt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CxtStmt Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CxtStmt}
{\xe \v SVF::CxtStmt}
{\bkmkstart AAAAAAAGVH}
{\bkmkend AAAAAAAGVH}
\par
{
{\f2 #include <CxtStmt.h>}}\par
Inheritance diagram for SVF::CxtStmt:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_cxt_stmt.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtStmt} (const CallStrCxt &c, const Instruction *f){\bkmkstart AAAAAAAGVI}
{\bkmkend AAAAAAAGVI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtStmt} (const {\b CxtStmt} &ctm){\bkmkstart AAAAAAAGVJ}
{\bkmkend AAAAAAAGVJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~CxtStmt} (){\bkmkstart AAAAAAAGVK}
{\bkmkend AAAAAAAGVK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallStrCxt & {\b getContext} () const{\bkmkstart AAAAAAAGVL}
{\bkmkend AAAAAAAGVL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return current context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Instruction * {\b getStmt} () const{\bkmkstart AAAAAAAGVM}
{\bkmkend AAAAAAAGVM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return current statement. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b CxtStmt} &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtStmt} & {\b operator=} (const {\b CxtStmt} &rhs){\bkmkstart AAAAAAAGVN}
{\bkmkend AAAAAAAGVN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b CxtStmt} &rhs) const{\bkmkstart AAAAAAAGVO}
{\bkmkend AAAAAAAGVO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b CxtStmt} &rhs) const{\bkmkstart AAAAAAAGVP}
{\bkmkend AAAAAAAGVP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b cxtToStr} () const{\bkmkstart AAAAAAAGVQ}
{\bkmkend AAAAAAAGVQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return context in string format. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dump} () const{\bkmkstart AAAAAAAGVR}
{\bkmkend AAAAAAAGVR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump {\b CxtStmt}. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallStrCxt {\b cxt}{\bkmkstart AAAAAAAGVS}
{\bkmkend AAAAAAAGVS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Instruction * {\b inst}{\bkmkstart AAAAAAAGVT}
{\bkmkend AAAAAAAGVT}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Context-sensitive thread statement <c,s> \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator<\:SVF::CxtStmt}
{\xe \v SVF::CxtStmt\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::CxtStmt::operator< (const {\b CxtStmt} &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAGVU}
{\bkmkend AAAAAAAGVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable compare operator to avoid duplicated item insertion in map or set to be noted that two vectors can also overload operator() \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/CxtStmt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CxtStmtDPItem< LocCond > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CxtStmtDPItem< LocCond >}
{\xe \v SVF::CxtStmtDPItem< LocCond >}
{\bkmkstart AAAAAAAGZX}
{\bkmkend AAAAAAAGZX}
Inheritance diagram for SVF::CxtStmtDPItem< LocCond >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_cxt_stmt_d_p_item.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtStmtDPItem} (const {\b CxtVar} &var, const LocCond *locCond){\bkmkstart AAAAAAAGZY}
{\bkmkend AAAAAAAGZY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtStmtDPItem} (const {\b CxtStmtDPItem}< LocCond > &dps){\bkmkstart AAAAAAAGZZ}
{\bkmkend AAAAAAAGZZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~CxtStmtDPItem} (){\bkmkstart AAAAAAAHAA}
{\bkmkend AAAAAAAHAA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtVar} {\b getCondVar} () const{\bkmkstart AAAAAAAHAB}
{\bkmkend AAAAAAAHAB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get context var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b ContextCond} & {\b getCond} () const{\bkmkstart AAAAAAAHAC}
{\bkmkend AAAAAAAHAC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ContextCond} & {\b getCond} (){\bkmkstart AAAAAAAHAD}
{\bkmkend AAAAAAAHAD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b pushContext} (NodeID cxt){\bkmkstart AAAAAAAHAE}
{\bkmkend AAAAAAAHAE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b matchContext} (NodeID cxt){\bkmkstart AAAAAAAHAF}
{\bkmkend AAAAAAAHAF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Match context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b CxtStmtDPItem}< LocCond > &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtStmtDPItem}< LocCond > & {\b operator=} (const {\b CxtStmtDPItem}< LocCond > &rhs){\bkmkstart AAAAAAAHAG}
{\bkmkend AAAAAAAHAG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b CxtStmtDPItem}< LocCond > &rhs) const{\bkmkstart AAAAAAAHAH}
{\bkmkend AAAAAAAHAH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b CxtStmtDPItem}< LocCond > &rhs) const{\bkmkstart AAAAAAAHAI}
{\bkmkend AAAAAAAHAI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dump} () const{\bkmkstart AAAAAAAHAJ}
{\bkmkend AAAAAAAHAJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator<\:SVF::CxtStmtDPItem< LocCond >}
{\xe \v SVF::CxtStmtDPItem< LocCond >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class LocCond > bool {\b SVF::CxtStmtDPItem}< LocCond >::operator< (const {\b CxtStmtDPItem}< LocCond > &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHAK}
{\bkmkend AAAAAAAHAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable compare operator to avoid duplicated item insertion in map or set to be noted that two vectors can also overload operator() \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/DPItem.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CxtThread Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CxtThread}
{\xe \v SVF::CxtThread}
{\bkmkstart AAAAAAAGWF}
{\bkmkend AAAAAAAGWF}
\par
{
{\f2 #include <CxtStmt.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtThread} (const CallStrCxt &c, const CallInst *fork){\bkmkstart AAAAAAAGWG}
{\bkmkend AAAAAAAGWG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtThread} (const {\b CxtThread} &ct){\bkmkstart AAAAAAAGWH}
{\bkmkend AAAAAAAGWH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~CxtThread} (){\bkmkstart AAAAAAAGWI}
{\bkmkend AAAAAAAGWI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallStrCxt & {\b getContext} () const{\bkmkstart AAAAAAAGWJ}
{\bkmkend AAAAAAAGWJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return context of the thread. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallInst * {\b getThread} () const{\bkmkstart AAAAAAAGWK}
{\bkmkend AAAAAAAGWK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return forksite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b CxtThread} &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtThread} & {\b operator=} (const {\b CxtThread} &rhs){\bkmkstart AAAAAAAGWL}
{\bkmkend AAAAAAAGWL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b CxtThread} &rhs) const{\bkmkstart AAAAAAAGWM}
{\bkmkend AAAAAAAGWM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b CxtThread} &rhs) const{\bkmkstart AAAAAAAGWN}
{\bkmkend AAAAAAAGWN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b cxtToStr} () const{\bkmkstart AAAAAAAGWO}
{\bkmkend AAAAAAAGWO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return context in string format. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setInloop} (bool in){\bkmkstart AAAAAAAGWP}
{\bkmkend AAAAAAAGWP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inloop, incycle attributes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isInloop} () const{\bkmkstart AAAAAAAGWQ}
{\bkmkend AAAAAAAGWQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setIncycle} (bool in){\bkmkstart AAAAAAAGWR}
{\bkmkend AAAAAAAGWR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isIncycle} () const{\bkmkstart AAAAAAAGWS}
{\bkmkend AAAAAAAGWS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dump} () const{\bkmkstart AAAAAAAGWT}
{\bkmkend AAAAAAAGWT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump {\b CxtThread}. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallStrCxt {\b cxt}{\bkmkstart AAAAAAAGWU}
{\bkmkend AAAAAAAGWU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallInst * {\b forksite}{\bkmkstart AAAAAAAGWV}
{\bkmkend AAAAAAAGWV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b inloop}{\bkmkstart AAAAAAAGWW}
{\bkmkend AAAAAAAGWW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b incycle}{\bkmkstart AAAAAAAGWX}
{\bkmkend AAAAAAAGWX}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Context-sensitive thread <c,t> \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator<\:SVF::CxtThread}
{\xe \v SVF::CxtThread\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::CxtThread::operator< (const {\b CxtThread} &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAGWY}
{\bkmkend AAAAAAAGWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable compare operator to avoid duplicated item insertion in map or set to be noted that two vectors can also overload operator() \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/CxtStmt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CxtThreadProc Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CxtThreadProc}
{\xe \v SVF::CxtThreadProc}
{\bkmkstart AAAAAAAGXN}
{\bkmkend AAAAAAAGXN}
\par
{
{\f2 #include <CxtStmt.h>}}\par
Inheritance diagram for SVF::CxtThreadProc:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_cxt_thread_proc.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtThreadProc} (NodeID t, const CallStrCxt &c, const {\b SVFFunction} *f){\bkmkstart AAAAAAAGXO}
{\bkmkend AAAAAAAGXO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtThreadProc} (const {\b CxtThreadProc} &ctm){\bkmkstart AAAAAAAGXP}
{\bkmkend AAAAAAAGXP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~CxtThreadProc} (){\bkmkstart AAAAAAAGXQ}
{\bkmkend AAAAAAAGXQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getTid} () const{\bkmkstart AAAAAAAGXR}
{\bkmkend AAAAAAAGXR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return current thread id. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b CxtThreadProc} &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtThreadProc} & {\b operator=} (const {\b CxtThreadProc} &rhs){\bkmkstart AAAAAAAGXS}
{\bkmkend AAAAAAAGXS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b CxtThreadProc} &rhs) const{\bkmkstart AAAAAAAGXT}
{\bkmkend AAAAAAAGXT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b CxtThreadProc} &rhs) const{\bkmkstart AAAAAAAGXU}
{\bkmkend AAAAAAAGXU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dump} () const{\bkmkstart AAAAAAAGXV}
{\bkmkend AAAAAAAGXV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump {\b CxtThreadProc}. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Context-sensitive procedure <t,c,m> t represent current thread during traversing c represent current context m represent current procedure \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator<\:SVF::CxtThreadProc}
{\xe \v SVF::CxtThreadProc\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::CxtThreadProc::operator< (const {\b CxtThreadProc} &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAGXW}
{\bkmkend AAAAAAAGXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable compare operator to avoid duplicated item insertion in map or set to be noted that two vectors can also overload operator() \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/CxtStmt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::CxtThreadStmt Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::CxtThreadStmt}
{\xe \v SVF::CxtThreadStmt}
{\bkmkstart AAAAAAAGVV}
{\bkmkend AAAAAAAGVV}
\par
{
{\f2 #include <CxtStmt.h>}}\par
Inheritance diagram for SVF::CxtThreadStmt:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_cxt_thread_stmt.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtThreadStmt} (NodeID t, const CallStrCxt &c, const Instruction *f){\bkmkstart AAAAAAAGVW}
{\bkmkend AAAAAAAGVW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtThreadStmt} (const {\b CxtThreadStmt} &ctm){\bkmkstart AAAAAAAGVX}
{\bkmkend AAAAAAAGVX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~CxtThreadStmt} (){\bkmkstart AAAAAAAGVY}
{\bkmkend AAAAAAAGVY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getTid} () const{\bkmkstart AAAAAAAGVZ}
{\bkmkend AAAAAAAGVZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return current context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b CxtThreadStmt} &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CxtThreadStmt} & {\b operator=} (const {\b CxtThreadStmt} &rhs){\bkmkstart AAAAAAAGWA}
{\bkmkend AAAAAAAGWA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b CxtThreadStmt} &rhs) const{\bkmkstart AAAAAAAGWB}
{\bkmkend AAAAAAAGWB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b CxtThreadStmt} &rhs) const{\bkmkstart AAAAAAAGWC}
{\bkmkend AAAAAAAGWC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dump} () const{\bkmkstart AAAAAAAGWD}
{\bkmkend AAAAAAAGWD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump {\b CxtThreadStmt}. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Context-sensitive thread statement <t,c,s> \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator<\:SVF::CxtThreadStmt}
{\xe \v SVF::CxtThreadStmt\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::CxtThreadStmt::operator< (const {\b CxtThreadStmt} &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAGWE}
{\bkmkend AAAAAAAGWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable compare operator to avoid duplicated item insertion in map or set to be noted that two vectors can also overload operator() \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/CxtStmt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::DCHEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::DCHEdge}
{\xe \v SVF::DCHEdge}
{\bkmkstart AAAAAAAGHZ}
{\bkmkend AAAAAAAGHZ}
Inheritance diagram for SVF::DCHEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_d_c_h_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b INHERITANCE}
, {\b INSTANCE}
, {\b FIRST_FIELD}
, {\b STD_DEF}
 \}{\bkmkstart AAAAAAAGIA}
{\bkmkend AAAAAAAGIA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericNode}< {\b DCHNode}, {\b DCHEdge} >::GEdgeSetTy {\b DCHEdgeSetTy}{\bkmkstart AAAAAAAGIB}
{\bkmkend AAAAAAAGIB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DCHEdge} ({\b DCHNode} *src, {\b DCHNode} *dst, {\b GEdgeFlag} k=0){\bkmkstart AAAAAAAGIC}
{\bkmkend AAAAAAAGIC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b getOffset} (void) const{\bkmkstart AAAAAAAGID}
{\bkmkend AAAAAAAGID}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setOffset} (unsigned int offset){\bkmkstart AAAAAAAGIE}
{\bkmkend AAAAAAAGIE}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/DCHG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::DCHGraph Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::DCHGraph}
{\xe \v SVF::DCHGraph}
{\bkmkstart AAAAAAAGJB}
{\bkmkend AAAAAAAGJB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dwarf based CHG. }}\par
{
{\f2 #include <DCHG.h>}}\par
Inheritance diagram for SVF::DCHGraph:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_d_c_h_graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DCHGraph} (const {\b SVFModule} *svfMod){\bkmkstart AAAAAAAGJC}
{\bkmkend AAAAAAAGJC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b buildCHG} (bool extend)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dump} (const std::string &filename){\bkmkstart AAAAAAAGJD}
{\bkmkend AAAAAAAGJD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b print} (void){\bkmkstart AAAAAAAGJE}
{\bkmkend AAAAAAAGJE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b csHasVFnsBasedonCHA} (CallSite cs) override{\bkmkstart AAAAAAAGJF}
{\bkmkend AAAAAAAGJF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const VFunSet & {\b getCSVFsBasedonCHA} (CallSite cs) override{\bkmkstart AAAAAAAGJG}
{\bkmkend AAAAAAAGJG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b csHasVtblsBasedonCHA} (CallSite cs) override{\bkmkstart AAAAAAAGJH}
{\bkmkend AAAAAAAGJH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const VTableSet & {\b getCSVtblsBasedonCHA} (CallSite cs) override{\bkmkstart AAAAAAAGJI}
{\bkmkend AAAAAAAGJI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b getVFnsFromVtbls} (CallSite cs, const VTableSet &vtbls, VFunSet &virtualFunctions) override{\bkmkstart AAAAAAAGJJ}
{\bkmkend AAAAAAAGJJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isBase} (const DIType *a, const DIType *b, bool firstField)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isFieldOf} (const DIType *f, const DIType *b){\bkmkstart AAAAAAAGJK}
{\bkmkend AAAAAAAGJK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if f is a field of b (fields from getFieldTypes). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const DIType * {\b getCanonicalType} (const DIType *t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const DIType * {\b getFieldType} (const DIType *base, unsigned idx){\bkmkstart AAAAAAAGJL}
{\bkmkend AAAAAAAGJL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the type of field number idx (flattened) in base. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::vector< const DIType * > & {\b getFieldTypes} (const DIType *base){\bkmkstart AAAAAAAGJM}
{\bkmkend AAAAAAAGJM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector of the types of all fields in base. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned {\b getNumFields} (const DIType *base){\bkmkstart AAAAAAAGJN}
{\bkmkend AAAAAAAGJN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Set< const DIType * > & {\b getAggs} (const DIType *base){\bkmkstart AAAAAAAGJO}
{\bkmkend AAAAAAAGJO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all the aggregates contained (transitively) in base. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFirstField} (const DIType *f, const DIType *b){\bkmkstart AAAAAAAGJP}
{\bkmkend AAAAAAAGJP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const DIType * {\b stripQualifiers} (const DIType *){\bkmkstart AAAAAAAGJQ}
{\bkmkend AAAAAAAGJQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the DIType beneath the qualifiers. Does not strip away "DW_TAG_members". }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const DIType * {\b stripArray} (const DIType *){\bkmkstart AAAAAAAGJR}
{\bkmkend AAAAAAAGJR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the DIType beneath all qualifiers and arrays. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b teq} (const DIType *t1, const DIType *t2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b diTypeToStr} (const DIType *){\bkmkstart AAAAAAAGJS}
{\bkmkend AAAAAAAGJS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a human-readable version of the DIType. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b isAgg} (const DIType *t){\bkmkstart AAAAAAAGJT}
{\bkmkend AAAAAAAGJT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b CommonCHGraph} *chg){\bkmkstart AAAAAAAGJU}
{\bkmkend AAAAAAAGJU}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFModule} * {\b svfModule}{\bkmkstart AAAAAAAGJV}
{\bkmkend AAAAAAAGJV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SVF} Module this CHG is built from. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b extended} = false{\bkmkstart AAAAAAAGJW}
{\bkmkend AAAAAAAGJW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this CHG is an extended CHG (first-field). Set by buildCHG. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Map< const DIType *, {\b DCHNode} * > {\b diTypeToNodeMap}{\bkmkstart AAAAAAAGJX}
{\bkmkend AAAAAAAGJX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maps DITypes to their nodes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Map< const GlobalValue *, const DIType * > {\b vtblToTypeMap}{\bkmkstart AAAAAAAGJY}
{\bkmkend AAAAAAAGJY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maps VTables to the DIType associated with them. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Map< const DIType *, NodeBS > {\b chaMap}{\bkmkstart AAAAAAAGJZ}
{\bkmkend AAAAAAAGJZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maps types to all children (i.e. CHA). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Map< const DIType *, NodeBS > {\b chaFFMap}{\bkmkstart AAAAAAAGKA}
{\bkmkend AAAAAAAGKA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maps types to all children but also considering first field. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Map< const DIType *, VTableSet > {\b vtblCHAMap}{\bkmkstart AAAAAAAGKB}
{\bkmkend AAAAAAAGKB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maps types to a set with their vtable and all their children's. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Map< CallSite, VFunSet > {\b csCHAMap}{\bkmkstart AAAAAAAGKC}
{\bkmkend AAAAAAAGKC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maps callsites to a set of potential virtual functions based on CHA. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Map< const DIType *, const DIType * > {\b canonicalTypeMap}{\bkmkstart AAAAAAAGKD}
{\bkmkend AAAAAAAGKD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maps types to their canonical type (many-to-one). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Set< const DIType * > {\b canonicalTypes}{\bkmkstart AAAAAAAGKE}
{\bkmkend AAAAAAAGKE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set of all possible canonical types (i.e. values of canonicalTypeMap). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Map< const DIType *, std::vector< const DIType * > > {\b fieldTypes}{\bkmkstart AAAAAAAGKF}
{\bkmkend AAAAAAAGKF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maps types to their flattened fields' types. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Map< const DIType *, Set< const DIType * > > {\b containingAggs}{\bkmkstart AAAAAAAGKG}
{\bkmkend AAAAAAAGKG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maps aggregate types to all the aggregate types it transitively contains. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dwarf based CHG. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v buildCHG\:SVF::DCHGraph}
{\xe \v SVF::DCHGraph\:buildCHG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DCHGraph::buildCHG (bool  {\i extend}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGKH}
{\bkmkend AAAAAAAGKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Builds the CHG from DWARF debug information. extend determines whether to extend the CHG with first field edges. \par
}}
{\xe \v getCanonicalType\:SVF::DCHGraph}
{\xe \v SVF::DCHGraph\:getCanonicalType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const DIType * DCHGraph::getCanonicalType (const DIType *  {\i t})}}
\par
{\bkmkstart AAAAAAAGKI}
{\bkmkend AAAAAAAGKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the type representing all qualifier-variations of t. This should only matter in the case of DerivedTypes where qualifiers and have qualified base types cause a mess. \par
}}
{\xe \v isBase\:SVF::DCHGraph}
{\xe \v SVF::DCHGraph\:isBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCHGraph::isBase (const DIType *  {\i a}, const DIType *  {\i b}, bool  {\i firstField}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGKJ}
{\bkmkend AAAAAAAGKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if a is a transitive base of b. firstField determines whether to consider first-field edges. \par
}}
{\xe \v teq\:SVF::DCHGraph}
{\xe \v SVF::DCHGraph\:teq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool DCHGraph::teq (const DIType *  {\i t1}, const DIType *  {\i t2}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAGKK}
{\bkmkend AAAAAAAGKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if t1 and t2 are equivalent, ignoring qualifiers. For equality... Tags always need to be equal. DIBasicType: shallow pointer equality. DIDerivedType: base types (teq). DICompositeType: shallow pointer equality. DISubroutineType: shallow pointer equality. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/DCHG.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/DCHG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::DCHNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::DCHNode}
{\xe \v SVF::DCHNode}
{\bkmkstart AAAAAAAGIF}
{\bkmkend AAAAAAAGIF}
Inheritance diagram for SVF::DCHNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_d_c_h_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b CLASSATTR} \{ {\b PURE_ABSTRACT} = 0x1
, {\b MULTI_INHERITANCE} = 0x2
, {\b TEMPLATE} = 0x04
, {\b SCALAR} = 0x08
 \}{\bkmkstart AAAAAAAGIG}
{\bkmkend AAAAAAAGIG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const Function * > {\b FuncVector}{\bkmkstart AAAAAAAGIH}
{\bkmkend AAAAAAAGIH}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DCHNode} (const DIType *diType, NodeID i=0, {\b GNodeK} k=0){\bkmkstart AAAAAAAGII}
{\bkmkend AAAAAAAGII}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const DIType * {\b getType} (void) const{\bkmkstart AAAAAAAGIJ}
{\bkmkend AAAAAAAGIJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b getName} () const{\bkmkstart AAAAAAAGIK}
{\bkmkend AAAAAAAGIK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setFlag} (CLASSATTR mask){\bkmkstart AAAAAAAGIL}
{\bkmkend AAAAAAAGIL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flags. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasFlag} (CLASSATTR mask) const{\bkmkstart AAAAAAAGIM}
{\bkmkend AAAAAAAGIM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setPureAbstract} (){\bkmkstart AAAAAAAGIN}
{\bkmkend AAAAAAAGIN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attribute. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setMultiInheritance} (){\bkmkstart AAAAAAAGIO}
{\bkmkend AAAAAAAGIO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setTemplate} (){\bkmkstart AAAAAAAGIP}
{\bkmkend AAAAAAAGIP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setScalar} (){\bkmkstart AAAAAAAGIQ}
{\bkmkend AAAAAAAGIQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isPureAbstract} () const{\bkmkstart AAAAAAAGIR}
{\bkmkend AAAAAAAGIR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isMultiInheritance} () const{\bkmkstart AAAAAAAGIS}
{\bkmkend AAAAAAAGIS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTemplate} () const{\bkmkstart AAAAAAAGIT}
{\bkmkend AAAAAAAGIT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isScalar} () const{\bkmkstart AAAAAAAGIU}
{\bkmkend AAAAAAAGIU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addTypedef} (const DIDerivedType *diTypedef){\bkmkstart AAAAAAAGIV}
{\bkmkend AAAAAAAGIV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Set< const DIDerivedType * > & {\b getTypedefs} (void) const{\bkmkstart AAAAAAAGIW}
{\bkmkend AAAAAAAGIW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setVTable} (const GlobalValue *vtbl){\bkmkstart AAAAAAAGIX}
{\bkmkend AAAAAAAGIX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const GlobalValue * {\b getVTable} () const{\bkmkstart AAAAAAAGIY}
{\bkmkend AAAAAAAGIY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::vector< std::vector< const Function * > > & {\b getVfnVectors} (void) const{\bkmkstart AAAAAAAGIZ}
{\bkmkend AAAAAAAGIZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the vector of virtual function vectors. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::vector< const Function * > & {\b getVfnVector} (unsigned n){\bkmkstart AAAAAAAGJA}
{\bkmkend AAAAAAAGJA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the nth virtual function vector in the vtable. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/DCHG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::DDAClient Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::DDAClient}
{\xe \v SVF::DDAClient}
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
\par
{
{\f2 #include <DDAClient.h>}}\par
Inheritance diagram for SVF::DDAClient:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_d_d_a_client.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DDAClient} ({\b SVFModule} *mod){\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b initialise} ({\b SVFModule} *){\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual OrderedNodeSet & {\b collectCandidateQueries} ({\b PAG} *p){\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect candidate pointers for query. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const OrderedNodeSet & {\b getCandidateQueries} () const{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get candidate queries. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b handleStatement} (const {\b SVFGNode} *, NodeID){\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call back used by {\b DDAVFSolver}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setPAG} ({\b PAG} *g){\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set {\b PAG} graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setCurrentQueryPtr} (NodeID ptr){\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the pointer being queried. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setQuery} (NodeID ptr){\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set pointer to be queried by DDA analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFModule} * {\b getModule} () const{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get LLVM module. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b answerQueries} ({\b PointerAnalysis} *pta){\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b performStat} ({\b PointerAnalysis} *){\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b collectWPANum} ({\b SVFModule} *){\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addCandidate} (NodeID id){\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAG} * {\b pag}{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} graph used by current DDA analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFModule} * {\b module}{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LLVM module. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b curPtr}{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
current pointer being queried }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OrderedNodeSet {\b candidateQueries}{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
store all candidate pointers to be queried }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
General {\b DDAClient} which queries all top level pointers by default. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/DDA/DDAClient.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/DDA/DDAClient.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::DDAPass Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::DDAPass}
{\xe \v SVF::DDAPass}
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
\par
{
{\f2 #include <DDAPass.h>}}\par
Inheritance diagram for SVF::DDAPass:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_d_d_a_pass.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SCCDetection}< {\b SVFG} * > {\b SVFGSCC}{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedSet< const {\b SVFGEdge} * > {\b SVFGEdgeSet}{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< {\b PointerAnalysis} * > {\b PTAVector}{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b getAnalysisUsage} (AnalysisUsage &au) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void * {\b getAdjustedAnalysisPointer} (AnalysisID){\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual AliasResult {\b alias} (const MemoryLocation &LocA, const MemoryLocation &LocB){\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given Location infos. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual AliasResult {\b alias} (const Value *V1, const Value *V2)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given Value infos. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual AliasResult {\b alias} (NodeID V1, NodeID V2){\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given PAGNodes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b runOnModule} ({\b SVFModule} *module)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start from here. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b runOnModule} (Module &module){\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start from here. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b selectClient} ({\b SVFModule} *module)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Select a client. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual StringRef {\b getPassName} () const{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pass name. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static char {\b ID} = 0{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pass ID. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Demand-Driven Pointer Analysis. This class performs various pointer analysis on the given module. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v alias\:SVF::DDAPass}
{\xe \v SVF::DDAPass\:alias}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AliasResult DDAPass::alias (const Value *  {\i V1}, const Value *  {\i V2}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given Value infos. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return alias results based on our points-to/alias analysis TODO: Need to handle PartialAlias and MustAlias here. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO: When this method is invoked during compiler optimizations, the IR used for pointer analysis may been changed, so some Values may not find corresponding {\b PAG} node. In this case, we only check alias between two Values if they both have {\b PAG} nodes. Otherwise, MayAlias will be returned.\par
}}
{\xe \v getAnalysisUsage\:SVF::DDAPass}
{\xe \v SVF::DDAPass\:getAnalysisUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void SVF::DDAPass::getAnalysisUsage (AnalysisUsage &  {\i au}) const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
do not intend to change the IR in this pass,\par
}}
{\xe \v runOnModule\:SVF::DDAPass}
{\xe \v SVF::DDAPass\:runOnModule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DDAPass::runOnModule ({\b SVFModule} *  {\i module}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start from here. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
initialization for llvm alias analyzer\par
}}
{\xe \v selectClient\:SVF::DDAPass}
{\xe \v SVF::DDAPass\:selectClient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DDAPass::selectClient ({\b SVFModule} *  {\i module}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Select a client. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
select a client to initialize queries \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
solve function pointer\par
allow user specify queries\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/DDA/DDAPass.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/DDA/DDAPass.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::DDAStat Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::DDAStat}
{\xe \v SVF::DDAStat}
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
\par
{
{\f2 #include <DDAStat.h>}}\par
Inheritance diagram for SVF::DDAStat:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_d_d_a_stat.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DDAStat} ({\b FlowDDA} *pta){\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DDAStat} ({\b ContextDDA} *pta){\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b performStatPerQuery} (NodeID ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b performStat} (){\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b printStat} (){\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b printStatPerQuery} (NodeID ptr, const PointsTo &pts){\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b getNumOfOOBQuery} (){\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setMemUsageBefore} (u32_t vmrss, u32_t vmsize){\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setMemUsageAfter} (u32_t vmrss, u32_t vmsize){\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFG} * {\b getSVFG} () const{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PointerAnalysis} * {\b getPTA} () const{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeBS & {\b getStrongUpdateStores} (){\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b _NumOfDPM}{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b _NumOfStrongUpdates}{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b _NumOfMustAliases}{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b _NumOfInfeasiblePath}{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u64_t {\b _NumOfStep}{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u64_t {\b _NumOfStepInCycle}{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b _AnaTimePerQuery}{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b _AnaTimeCyclePerQuery}{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b _TotalTimeOfQueries}{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b _TotalTimeOfBKCondition}{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeBS {\b _StrongUpdateStores}{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics of demand-driven analysis \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v performStatPerQuery\:SVF::DDAStat}
{\xe \v SVF::DDAStat\:performStatPerQuery}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DDAStat::performStatPerQuery (NodeID  {\i ptr}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
reset numbers for next query\par
}{
Reimplemented from {\b SVF::PTAStat} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABEG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/DDA/DDAStat.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/DDA/DDAStat.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::DDAVFSolver< CVar, CPtSet, DPIm > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::DDAVFSolver< CVar, CPtSet, DPIm >}
{\xe \v SVF::DDAVFSolver< CVar, CPtSet, DPIm >}
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
\par
{
{\f2 #include <DDAVFSolver.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SCCDetection}< {\b SVFG} * > {\b SVFGSCC}{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SCCDetection}< {\b PTACallGraph} * > {\b CallGraphSCC}{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PTACallGraphEdge::CallInstSet {\b CallInstSet}{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PAG::CallSiteSet {\b CallSiteSet}{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedSet< DPIm > {\b DPTItemSet}{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< DPIm, CPtSet > {\b DPImToCPtSetMap}{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< DPIm, CVar > {\b DPMToCVarMap}{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< DPIm, DPIm > {\b DPMToDPMMap}{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< NodeID, DPTItemSet > {\b LocToDPMVecMap}{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedSet< const {\b SVFGEdge} * > {\b ConstSVFGEdgeSet}{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef SVFGEdge::SVFGEdgeSetTy {\b SVFGEdgeSet}{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< const {\b SVFGNode} *, DPTItemSet > {\b StoreToPMSetMap}{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DDAVFSolver} (){\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~DDAVFSolver} (){\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeBS & {\b getCandidateQueries} (){\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return candidate pointers for DDA. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual DPIm {\b getDPIm} (const CVar &var, const {\b SVFGNode} *loc) const{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given CVar and location (SVFGNode) return a new {\b DPItem}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionDDAPts} (CPtSet &pts, const CPtSet &targetPts){\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union pts. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionDDAPts} (DPIm dpm, const CPtSet &targetPts){\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union pts. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b addDDAPts} (CPtSet &pts, const CVar &var){\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add pts. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFG} * {\b getSVFG} () const{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return {\b SVFG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFGSCC} * {\b getSVFGSCC} () const{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return SVFGSCC. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dumpCPtSet} (const CPtSet &cpts) const{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const CPtSet & {\b findPT} (const DPIm &dpm)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute points-to. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleSingleStatement} (const DPIm &dpm, CPtSet &pts)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle single statement. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reCompute} (const DPIm &dpm)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
recompute points-to for value-flow cycles and indirect calls }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reComputeForEdges} (const DPIm &dpm, const SVFGEdgeSet &edgeSet, bool indirectCall=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Traverse along out edges to find all nodes which may be affected by locDPM. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b buildSVFG} ({\b PAG} *pag){\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build {\b SVFG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b resetQuery} (){\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset visited map for next points-to query. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b OOBResetVisited} (){\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset visited map if the current query is out-of-budget. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFGNode} * {\b getDefSVFGNode} (const {\b PAGNode} *pagNode) const{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
GetDefinition {\b SVFG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b backtraceAlongIndirectVF} (CPtSet &pts, const DPIm &oldDpm){\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Backward traverse along indirect value flows. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b backtraceAlongDirectVF} (CPtSet &pts, const DPIm &oldDpm){\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Backward traverse along direct value flows. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b DDAStat}{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
\par
}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b outOfBudgetQuery}{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether the current query is out of step limits. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAG} * {\b _pag}{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFG} * {\b _svfg}{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SVFG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b AndersenWaveDiff} * {\b _ander}{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Andersen}'s analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeBS {\b candidateQueries}{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
candidate pointers; }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTACallGraph} * {\b _callGraph}{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CallGraph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CallGraphSCC} * {\b _callGraphSCC}{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC for CallGraph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFGSCC} * {\b _svfgSCC}{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC for {\b SVFG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DPTItemSet {\b backwardVisited}{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
visited map during backward traversing }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DPImToCPtSetMap {\b dpmToTLCPtSetMap}{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
points-to caching map for top-level vars }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DPImToCPtSetMap {\b dpmToADCPtSetMap}{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
points-to caching map for address-taken vars }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

LocToDPMVecMap {\b locToDpmSetMap}{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map location to its dpms }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DPMToDPMMap {\b dpmToloadDpmMap}{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dpms at loads for may/must-alias analysis with stores }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DPMToCVarMap {\b loadToPTCVarMap}{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a load dpm to its cvar pointed by its pointer operand }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DPTItemSet {\b outOfBudgetDpms}{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
out of budget dpm set }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

StoreToPMSetMap {\b storeToDPMs}{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map store to set of DPM which have been stong updated there }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DDAStat} * {\b ddaStat}{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DDA stat. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFGBuilder} {\b svfgBuilder}{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SVFG} Builder. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b startNewPTCompFromLoadSrc} (CPtSet &pts, const DPIm &oldDpm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b startNewPTCompFromStoreDst} (CPtSet &pts, const DPIm &oldDpm){\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b backtraceToStoreSrc} (CPtSet &pts, const DPIm &oldDpm){\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b backwardPropDpm} (CPtSet &pts, NodeID ptr, const DPIm &oldDpm, const {\b SVFGEdge} *edge)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dpm transit during backward tracing }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isMustAlias} (const DPIm &, const DPIm &){\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
whether load and store are aliased }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isStrongUpdate} (const CPtSet &dstCPSet, const {\b StoreSVFGNode} *store)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return TRUE if this is a strong update STORE statement. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isLocalCVarInRecursion} (const CVar &var) const{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a local variable is in function recursions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b propagateViaObj} (const CVar &storeObj, const CVar &loadObj){\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the points-to contain the object obj, we could move forward along indirect value-flow edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resolveFunPtr} (const DPIm &dpm)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
resolve function pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual NodeID {\b getPtrNodeID} (const CVar &var) const =0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods to be implemented in child class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual CPtSet {\b processGepPts} (const {\b GepSVFGNode} *gep, const CPtSet &srcPts)=0{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ProcessGep node to generate field object nodes of a struct. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b handleAddr} (CPtSet &pts, const DPIm &dpm, const {\b AddrSVFGNode} *addr)=0{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle AddrSVFGNode to add proper points-to. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual CPtSet {\b getConservativeCPts} (const DPIm &dpm)=0{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get conservative points-to results when the query is out of budget. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b handleBKCondition} (DPIm &, const {\b SVFGEdge} *){\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle condition for context or path analysis (backward analysis) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b updateCallGraphAndSVFG} (const DPIm &, const {\b CallBlockNode} *, SVFGEdgeSet &){\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update call graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b markbkVisited} (const DPIm &dpm){\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visited flags to avoid cycles. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isbkVisited} (const DPIm &dpm){\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b clearbkVisited} (const DPIm &dpm){\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const CPtSet & {\b getCachedPointsTo} (const DPIm &dpm){\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Points-to Caching for top-level pointers and address-taken objects. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b updateCachedPointsTo} (const DPIm &dpm, const CPtSet &pts){\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const CPtSet & {\b getCachedTLPointsTo} (const DPIm &dpm){\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const CPtSet & {\b getCachedADPointsTo} (const DPIm &dpm){\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTopLevelPtrStmt} (const {\b SVFGNode} *stmt){\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this is a top-level pointer statement. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual DPIm {\b getDPImWithOldCond} (const DPIm &oldDpm, const CVar &var, const {\b SVFGNode} *loc){\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return dpm with old context and path conditions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SVFGSCCDetection} (){\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SVFG} SCC detection. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getSVFGSCCRepNode} (NodeID id){\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get SCC rep node of a {\b SVFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isSVFGNodeInCycle} (const {\b SVFGNode} *node){\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return whether this SVFGNode is in cycle. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b edgeInSVFGSCC} (const {\b SVFGEdge} *edge){\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return TRUE if this edge is inside a {\b SVFG} SCC, i.e., src node and dst node are in the same SCC on the {\b SVFG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setCallGraph} ({\b PTACallGraph} *cg){\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set callgraph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setCallGraphSCC} ({\b CallGraphSCC} *scc){\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set callgraphSCC. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isHeapCondMemObj} (const CVar &var, const {\b StoreSVFGNode} *){\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check heap and array object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isArrayCondMemObj} (const CVar &var) const{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFieldInsenCondMemObj} (const CVar &var) const{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addLoadDpmAndCVar} (const DPIm &dpm, const DPIm &loadDpm, const CVar &loadVar){\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LoadDpm for must-alias analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addLoadDpm} (const DPIm &dpm, const DPIm &loadDpm){\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Note that simply use "dpmToloadDpmMap[dpm]=loadDpm", requires DPIm have a default constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const DPIm & {\b getLoadDpm} (const DPIm &dpm) const{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addLoadCVar} (const DPIm &dpm, const CVar &loadVar){\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CVar & {\b getLoadCVar} (const DPIm &dpm) const{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b AndersenWaveDiff} * {\b getAndersenAnalysis} () const{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return {\b Andersen}'s analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleOutOfBudgetDpm} (const DPIm &dpm)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
handle out-of-budget queries }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b testOutOfBudget} (const DPIm &dpm){\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isOutOfBudgetQuery} () const{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addOutOfBudgetDpm} (const DPIm &dpm){\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isOutOfBudgetDpm} (const DPIm &dpm) const{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DDAStat} * {\b setDDAStat} ({\b DDAStat} *s){\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set {\b DDAStat}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addSUStat} (const DPIm &dpm, const {\b SVFGNode} *node){\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
stat strong updates num }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b rmSUStat} (const DPIm &dpm, const {\b SVFGNode} *node){\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
remove strong updates num if the dpm goes to weak updates branch }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class CVar, class CPtSet, class DPIm>\par
class SVF::DDAVFSolver< CVar, CPtSet, DPIm >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Value-Flow Based Demand-Driven Points-to Analysis \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v backwardPropDpm\:SVF::DDAVFSolver< CVar, CPtSet, DPIm >}
{\xe \v SVF::DDAVFSolver< CVar, CPtSet, DPIm >\:backwardPropDpm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class CVar , class CPtSet , class DPIm > virtual void {\b SVF::DDAVFSolver}< CVar, CPtSet, DPIm >::backwardPropDpm (CPtSet &  {\i pts}, NodeID  {\i ptr}, const DPIm &  {\i oldDpm}, const {\b SVFGEdge} *  {\i edge}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dpm transit during backward tracing }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
handle context-/path- sensitivity\par
record the source of load dpm\par
handle out of budget case\par
}}
{\xe \v findPT\:SVF::DDAVFSolver< CVar, CPtSet, DPIm >}
{\xe \v SVF::DDAVFSolver< CVar, CPtSet, DPIm >\:findPT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class CVar , class CPtSet , class DPIm > virtual const CPtSet& {\b SVF::DDAVFSolver}< CVar, CPtSet, DPIm >::findPT (const DPIm &  {\i dpm}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute points-to. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add successors of current stmt if its pts has been changed.\par
}}
{\xe \v getPtrNodeID\:SVF::DDAVFSolver< CVar, CPtSet, DPIm >}
{\xe \v SVF::DDAVFSolver< CVar, CPtSet, DPIm >\:getPtrNodeID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class CVar , class CPtSet , class DPIm > virtual NodeID {\b SVF::DDAVFSolver}< CVar, CPtSet, DPIm >::getPtrNodeID (const CVar &  {\i var}) const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods to be implemented in child class. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get variable ID (PAGNodeID) according to CVar \par
}{
Implemented in {\b SVF::FlowDDA} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABHR \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::ContextDDA} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v handleOutOfBudgetDpm\:SVF::DDAVFSolver< CVar, CPtSet, DPIm >}
{\xe \v SVF::DDAVFSolver< CVar, CPtSet, DPIm >\:handleOutOfBudgetDpm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class CVar , class CPtSet , class DPIm > void {\b SVF::DDAVFSolver}< CVar, CPtSet, DPIm >::handleOutOfBudgetDpm (const DPIm &  {\i dpm}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
handle out-of-budget queries }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle out-of-budget dpm \par
}}
{\xe \v handleSingleStatement\:SVF::DDAVFSolver< CVar, CPtSet, DPIm >}
{\xe \v SVF::DDAVFSolver< CVar, CPtSet, DPIm >\:handleSingleStatement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class CVar , class CPtSet , class DPIm > virtual void {\b SVF::DDAVFSolver}< CVar, CPtSet, DPIm >::handleSingleStatement (const DPIm &  {\i dpm}, CPtSet &  {\i pts}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle single statement. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
resolve function pointer first at indirect callsite\par
}}
{\xe \v isStrongUpdate\:SVF::DDAVFSolver< CVar, CPtSet, DPIm >}
{\xe \v SVF::DDAVFSolver< CVar, CPtSet, DPIm >\:isStrongUpdate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class CVar , class CPtSet , class DPIm > virtual bool {\b SVF::DDAVFSolver}< CVar, CPtSet, DPIm >::isStrongUpdate (const CPtSet &  {\i dstCPSet}, const {\b StoreSVFGNode} *  {\i store}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return TRUE if this is a strong update STORE statement. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find the unique element in cpts\par
}}
{\xe \v reCompute\:SVF::DDAVFSolver< CVar, CPtSet, DPIm >}
{\xe \v SVF::DDAVFSolver< CVar, CPtSet, DPIm >\:reCompute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class CVar , class CPtSet , class DPIm > void {\b SVF::DDAVFSolver}< CVar, CPtSet, DPIm >::reCompute (const DPIm &  {\i dpm}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
recompute points-to for value-flow cycles and indirect calls }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
re-compute due to indirect calls\par
callgraph scc detection for local variable in recursion\par
re-compute for transitive closures\par
}}
{\xe \v reComputeForEdges\:SVF::DDAVFSolver< CVar, CPtSet, DPIm >}
{\xe \v SVF::DDAVFSolver< CVar, CPtSet, DPIm >\:reComputeForEdges}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class CVar , class CPtSet , class DPIm > void {\b SVF::DDAVFSolver}< CVar, CPtSet, DPIm >::reComputeForEdges (const DPIm &  {\i dpm}, const SVFGEdgeSet &  {\i edgeSet}, bool  {\i indirectCall} = {\f2 false}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Traverse along out edges to find all nodes which may be affected by locDPM. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only collect nodes we have traversed\par
}}
{\xe \v resolveFunPtr\:SVF::DDAVFSolver< CVar, CPtSet, DPIm >}
{\xe \v SVF::DDAVFSolver< CVar, CPtSet, DPIm >\:resolveFunPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class CVar , class CPtSet , class DPIm > void {\b SVF::DDAVFSolver}< CVar, CPtSet, DPIm >::resolveFunPtr (const DPIm &  {\i dpm}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
resolve function pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
use pre-analysis call graph to approximate all potential callsites\par
}}
{\xe \v startNewPTCompFromLoadSrc\:SVF::DDAVFSolver< CVar, CPtSet, DPIm >}
{\xe \v SVF::DDAVFSolver< CVar, CPtSet, DPIm >\:startNewPTCompFromLoadSrc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class CVar , class CPtSet , class DPIm > void {\b SVF::DDAVFSolver}< CVar, CPtSet, DPIm >::startNewPTCompFromLoadSrc (CPtSet &  {\i pts}, const DPIm &  {\i oldDpm}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Backward traverse for top-level pointers of load/store statements \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/DDA/DDAVFSolver.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DdCache Struct Reference\par \pard\plain 
{\tc\tcl2 \v DdCache}
{\xe \v DdCache}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b f}{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b g}{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

ptruint {\b h}{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b data}{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/cuddInt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DdChildren Struct Reference\par \pard\plain 
{\tc\tcl2 \v DdChildren}
{\xe \v DdChildren}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b DdNode} * {\b T}{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b DdNode} * {\b E}{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/cudd.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DdGen Struct Reference\par \pard\plain 
{\tc\tcl2 \v DdGen}
{\xe \v DdGen}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdManager} * {\b manager}{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b type}{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b status}{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

union \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

\~ struct \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

\~ \~ int * {\b cube}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

\~ \~ CUDD_VALUE_TYPE {\b value}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b cubes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

\~ struct \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

\~ \~ int * {\b cube}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

\~ \~ {\b DdNode} * {\b ub}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b primes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

\~ struct \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

\~ \~ int {\b size}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b nodes}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b gen}{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

\~ int {\b sp}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

\~ {\b DdNode} ** {\b stack}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b stack}{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b node}{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/cuddInt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DdHashItem Struct Reference\par \pard\plain 
{\tc\tcl2 \v DdHashItem}
{\xe \v DdHashItem}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b DdHashItem} * {\b next}{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

ptrint {\b count}{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b value}{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b key} [1]{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/cuddInt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DdHashTable Struct Reference\par \pard\plain 
{\tc\tcl2 \v DdHashTable}
{\xe \v DdHashTable}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b keysize}{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b itemsize}{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdHashItem} ** {\b bucket}{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdHashItem} * {\b nextFree}{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdHashItem} ** {\b memoryList}{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b numBuckets}{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b shift}{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b size}{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b maxsize}{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdManager} * {\b manager}{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/cuddInt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DdHook Struct Reference\par \pard\plain 
{\tc\tcl2 \v DdHook}
{\xe \v DdHook}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DD_HFP {\b f}{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b DdHook} * {\b next}{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/cuddInt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DdLevelQueue Struct Reference\par \pard\plain 
{\tc\tcl2 \v DdLevelQueue}
{\xe \v DdLevelQueue}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void * {\b first}{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdQueueItem} ** {\b last}{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdQueueItem} * {\b freelist}{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdQueueItem} ** {\b buckets}{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b levels}{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b itemsize}{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b size}{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b maxsize}{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b numBuckets}{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b shift}{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/cuddInt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DdLocalCache Struct Reference\par \pard\plain 
{\tc\tcl2 \v DdLocalCache}
{\xe \v DdLocalCache}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdLocalCacheItem} * {\b item}{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b itemsize}{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b keysize}{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b slots}{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b shift}{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b lookUps}{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b minHit}{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b hits}{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b maxslots}{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdManager} * {\b manager}{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b DdLocalCache} * {\b next}{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/cuddInt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DdLocalCacheItem Struct Reference\par \pard\plain 
{\tc\tcl2 \v DdLocalCacheItem}
{\xe \v DdLocalCacheItem}
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b value}{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b key} [1]{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/cuddInt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DdManager Struct Reference\par \pard\plain 
{\tc\tcl2 \v DdManager}
{\xe \v DdManager}
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} {\b sentinel}{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b one}{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b zero}{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b plusinfinity}{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b minusinfinity}{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b background}{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdCache} * {\b acache}{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdCache} * {\b cache}{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b cacheSlots}{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b cacheShift}{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b cacheMisses}{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b cacheHits}{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b minHit}{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b cacheSlack}{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b maxCacheHard}{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b size}{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b sizeZ}{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b maxSize}{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b maxSizeZ}{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdSubtable} * {\b subtables}{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdSubtable} * {\b subtableZ}{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdSubtable} {\b constants}{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b slots}{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b keys}{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b keysZ}{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b dead}{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b deadZ}{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b maxLive}{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b minDead}{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b gcFrac}{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b gcEnabled}{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b looseUpTo}{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b initSlots}{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} ** {\b stack}{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b allocated}{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b reclaimed}{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b isolated}{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int * {\b perm}{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int * {\b permZ}{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int * {\b invperm}{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int * {\b invpermZ}{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} ** {\b vars}{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int * {\b map}{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} ** {\b univ}{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b linearSize}{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

long * {\b interact}{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

long * {\b linear}{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} ** {\b memoryList}{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b nextFree}{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

char * {\b stash}{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} ** {\b deathRow}{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b deathRowDepth}{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b nextDead}{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned {\b deadMask}{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CUDD_VALUE_TYPE {\b epsilon}{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b reordered}{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b reorderings}{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b maxReorderings}{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b siftMaxVar}{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b siftMaxSwap}{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b maxGrowth}{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b maxGrowthAlt}{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b reordCycle}{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b autoDyn}{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b autoDynZ}{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Cudd_ReorderingType {\b autoMethod}{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Cudd_ReorderingType {\b autoMethodZ}{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b realign}{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b realignZ}{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b nextDyn}{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b countDead}{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MtrNode} * {\b tree}{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MtrNode} * {\b treeZ}{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Cudd_AggregationType {\b groupcheck}{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b recomb}{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b symmviolation}{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b arcviolation}{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b populationSize}{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b numberXovers}{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b randomizeOrder}{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdLocalCache} * {\b localCaches}{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

char * {\b hooks}{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdHook} * {\b preGCHook}{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdHook} * {\b postGCHook}{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdHook} * {\b preReorderingHook}{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdHook} * {\b postReorderingHook}{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FILE * {\b out}{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FILE * {\b err}{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Cudd_ErrorType {\b errorCode}{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned long {\b startTime}{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned long {\b timeLimit}{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned long {\b memused}{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned long {\b maxmem}{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned long {\b maxmemhard}{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b garbageCollections}{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned long {\b GCTime}{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned long {\b reordTime}{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b totCachehits}{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b totCacheMisses}{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b cachecollisions}{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b cacheinserts}{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b cacheLastInserts}{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b cachedeletions}{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b peakLiveNodes}{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/cuddInt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DdNode Struct Reference\par \pard\plain 
{\tc\tcl2 \v DdNode}
{\xe \v DdNode}
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DdHalfWord {\b index}{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DdHalfWord {\b ref}{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} * {\b next}{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

union \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

\~ CUDD_VALUE_TYPE {\b value}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

\~ {\b DdChildren} {\b kids}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b type}{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/cudd.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DdQueueItem Struct Reference\par \pard\plain 
{\tc\tcl2 \v DdQueueItem}
{\xe \v DdQueueItem}
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b DdQueueItem} * {\b next}{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b DdQueueItem} * {\b cnext}{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void * {\b key}{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/cuddInt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DdSubtable Struct Reference\par \pard\plain 
{\tc\tcl2 \v DdSubtable}
{\xe \v DdSubtable}
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DdNode} ** {\b nodelist}{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b shift}{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b slots}{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b keys}{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b maxKeys}{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b dead}{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b next}{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b bindVar}{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Cudd_VariableType {\b varType}{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b pairIndex}{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b varHandled}{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Cudd_LazyGroupType {\b varToBeGrouped}{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/cuddInt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::cppUtil::DemangledName Struct Reference\par \pard\plain 
{\tc\tcl2 \v SVF::cppUtil::DemangledName}
{\xe \v SVF::cppUtil::DemangledName}
{\bkmkstart AAAAAAAIDL}
{\bkmkend AAAAAAAIDL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b className}{\bkmkstart AAAAAAAIDM}
{\bkmkend AAAAAAAIDM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b funcName}{\bkmkstart AAAAAAAIDN}
{\bkmkend AAAAAAAIDN}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/CPPUtil.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::DFPTData< Key, Datum, Data > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::DFPTData< Key, Datum, Data >}
{\xe \v SVF::DFPTData< Key, Datum, Data >}
{\bkmkstart AAAAAAADWS}
{\bkmkend AAAAAAADWS}
\par
{
{\f2 #include <AbstractPointsToDS.h>}}\par
Inheritance diagram for SVF::DFPTData< Key, Datum, Data >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_d_f_p_t_data.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b PTData}< Key, Datum, Data > {\b BasePTData}{\bkmkstart AAAAAAADWT}
{\bkmkend AAAAAAADWT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b BasePTData::PTDataTy} {\b PTDataTy}{\bkmkstart AAAAAAADWU}
{\bkmkend AAAAAAADWU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeID {\b LocID}{\bkmkstart AAAAAAADWV}
{\bkmkend AAAAAAADWV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DFPTData} (bool reversePT=true, {\b PTDataTy} ty=BasePTData::DataFlow){\bkmkstart AAAAAAADWW}
{\bkmkend AAAAAAADWW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b hasDFInSet} (LocID loc) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b hasDFOutSet} (LocID loc) const =0{\bkmkstart AAAAAAADWX}
{\bkmkend AAAAAAADWX}
\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \par
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b hasDFOutSet} (LocID loc, const Key &var) const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b hasDFInSet} (LocID loc, const Key &var) const =0{\bkmkstart AAAAAAADWY}
{\bkmkend AAAAAAADWY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const Data & {\b getDFInPtsSet} (LocID loc, const Key &var)=0{\bkmkstart AAAAAAADWZ}
{\bkmkend AAAAAAADWZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const Data & {\b getDFOutPtsSet} (LocID loc, const Key &var)=0{\bkmkstart AAAAAAADXA}
{\bkmkend AAAAAAADXA}
\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \par
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b updateDFInFromIn} (LocID srcLoc, const Key &srcVar, LocID dstLoc, const Key &dstVar)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateAllDFInFromIn} (LocID srcLoc, const Key &srcVar, LocID dstLoc, const Key &dstVar)=0{\bkmkstart AAAAAAADXB}
{\bkmkend AAAAAAADXB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union (IN[dstLoc::dstVar], IN[srcLoc:srcVar]. There is no flag check, unlike the above. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateDFInFromOut} (LocID srcLoc, const Key &srcVar, LocID dstLoc, const Key &dstVar)=0{\bkmkstart AAAAAAADXC}
{\bkmkend AAAAAAADXC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union (IN[dstLoc:dstVar], OUT[srcLoc:srcVar]). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateAllDFInFromOut} (LocID srcLoc, const Key &srcVar, LocID dstLoc, const Key &dstVar)=0{\bkmkstart AAAAAAADXD}
{\bkmkend AAAAAAADXD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union (IN[dstLoc::dstVar], OUT[srcLoc:srcVar]. There is no flag check, unlike the above. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateDFOutFromIn} (LocID srcLoc, const Key &srcVar, LocID dstLoc, const Key &dstVar)=0{\bkmkstart AAAAAAADXE}
{\bkmkend AAAAAAADXE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union (OUT[dstLoc:dstVar], IN[srcLoc:srcVar]). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateAllDFOutFromIn} (LocID loc, const Key &singleton, bool strongUpdates)=0{\bkmkstart AAAAAAADXF}
{\bkmkend AAAAAAADXF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For each variable var in IN at loc, do updateDFOutFromIn(loc, var, loc, var). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearAllDFOutUpdatedVar} (LocID)=0{\bkmkstart AAAAAAADXG}
{\bkmkend AAAAAAADXG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateTLVPts} (LocID srcLoc, const Key &srcVar, const Key &dstVar)=0{\bkmkstart AAAAAAADXH}
{\bkmkend AAAAAAADXH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update points-to set of top-level pointers with IN[srcLoc:srcVar]. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateATVPts} (const Key &srcVar, LocID dstLoc, const Key &dstVar)=0{\bkmkstart AAAAAAADXI}
{\bkmkend AAAAAAADXI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update address-taken variables OUT[dstLoc:dstVar] with points-to of top-level pointers. }{
}\par
}\par}
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b classof} (const {\b DFPTData}< Key, Datum, Data > *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PTData}< Key, Datum, Data > *ptd){\bkmkstart AAAAAAADXJ}
{\bkmkend AAAAAAADXJ}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Key, typename Datum, typename Data>\par
class SVF::DFPTData< Key, Datum, Data >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Data-flow points-to data structure for flow-sensitive analysis as defined by Hardekopf and Lin (CGO 11). Points-to information is maintained at each program point (statement). For address-taken variables, every program point has two sets: IN and OUT points-to sets. For top-level variables, points-to sets are maintained flow-insensitively via getPts(var). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v classof\:SVF::DFPTData< Key, Datum, Data >}
{\xe \v SVF::DFPTData< Key, Datum, Data >\:classof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > static bool {\b SVF::DFPTData}< Key, Datum, Data >::classof (const {\b DFPTData}< Key, Datum, Data > * ){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAADXK}
{\bkmkend AAAAAAADXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods to support type inquiry through isa, cast, and dyn_cast: \par
}}
{\xe \v hasDFInSet\:SVF::DFPTData< Key, Datum, Data >}
{\xe \v SVF::DFPTData< Key, Datum, Data >\:hasDFInSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > virtual bool {\b SVF::DFPTData}< Key, Datum, Data >::hasDFInSet (LocID  {\i loc}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAADXL}
{\bkmkend AAAAAAADXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether the DF IN/OUT sets have points-to sets. \par
}{
Implemented in {\b SVF::MutableDFPTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADXM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v hasDFOutSet\:SVF::DFPTData< Key, Datum, Data >}
{\xe \v SVF::DFPTData< Key, Datum, Data >\:hasDFOutSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > virtual bool {\b SVF::DFPTData}< Key, Datum, Data >::hasDFOutSet (LocID  {\i loc}, const Key &  {\i var}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAADXN}
{\bkmkend AAAAAAADXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Access points-to set from data-flow IN/OUT set. \par
}{
Implemented in {\b SVF::MutableDFPTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADXO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updateDFInFromIn\:SVF::DFPTData< Key, Datum, Data >}
{\xe \v SVF::DFPTData< Key, Datum, Data >\:updateDFInFromIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > virtual bool {\b SVF::DFPTData}< Key, Datum, Data >::updateDFInFromIn (LocID  {\i srcLoc}, const Key &  {\i srcVar}, LocID  {\i dstLoc}, const Key &  {\i dstVar}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAADXP}
{\bkmkend AAAAAAADXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update points-to for IN/OUT set IN[loc:var] represents the points-to of variable var in the IN set of location loc. union(ptsDst, ptsSrc) represents ptsDst = ptsDst U ptsSrc.\par
Union (IN[dstLoc:dstVar], IN[srcLoc:srcVar]). \par
}{
Implemented in {\b SVF::IncMutableDFPTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADXQ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::MutableDFPTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADXR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/AbstractPointsToDS.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::DiffPTData< Key, Datum, Data > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::DiffPTData< Key, Datum, Data >}
{\xe \v SVF::DiffPTData< Key, Datum, Data >}
{\bkmkstart AAAAAAADWG}
{\bkmkend AAAAAAADWG}
\par
{
{\f2 #include <AbstractPointsToDS.h>}}\par
Inheritance diagram for SVF::DiffPTData< Key, Datum, Data >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_diff_p_t_data.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b PTData}< Key, Datum, Data > {\b BasePTData}{\bkmkstart AAAAAAADWH}
{\bkmkend AAAAAAADWH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b BasePTData::PTDataTy} {\b PTDataTy}{\bkmkstart AAAAAAADWI}
{\bkmkend AAAAAAADWI}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DiffPTData} (bool reversePT=true, {\b PTDataTy} ty=PTDataTy::Diff){\bkmkstart AAAAAAADWJ}
{\bkmkend AAAAAAADWJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const Data & {\b getDiffPts} (Key &var)=0{\bkmkstart AAAAAAADWK}
{\bkmkend AAAAAAADWK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get diff points to. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b computeDiffPts} (Key &var, const Data &all)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updatePropaPtsMap} (Key &src, Key &dst)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearPropaPts} (Key &var)=0{\bkmkstart AAAAAAADWL}
{\bkmkend AAAAAAADWL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear propagated points-to set of var. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b classof} (const {\b DiffPTData}< Key, Datum, Data > *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PTData}< Key, Datum, Data > *ptd){\bkmkstart AAAAAAADWM}
{\bkmkend AAAAAAADWM}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Key, typename Datum, typename Data>\par
class SVF::DiffPTData< Key, Datum, Data >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract diff points-to data with cached information. This is an optimisation on top of the base points-to data structure. The points-to information is propagated incrementally only for the different parts. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v classof\:SVF::DiffPTData< Key, Datum, Data >}
{\xe \v SVF::DiffPTData< Key, Datum, Data >\:classof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > static bool {\b SVF::DiffPTData}< Key, Datum, Data >::classof (const {\b DiffPTData}< Key, Datum, Data > * ){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAADWN}
{\bkmkend AAAAAAADWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods to support type inquiry through isa, cast, and dyn_cast: \par
}}
{\xe \v computeDiffPts\:SVF::DiffPTData< Key, Datum, Data >}
{\xe \v SVF::DiffPTData< Key, Datum, Data >\:computeDiffPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > virtual bool {\b SVF::DiffPTData}< Key, Datum, Data >::computeDiffPts (Key &  {\i var}, const Data &  {\i all}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAADWO}
{\bkmkend AAAAAAADWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute diff points to. Return TRUE if diff is not empty.{
\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab calculate diff: diff = all - propa.\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab update propagated pts: propa = all. \par}
}{
Implemented in {\b SVF::MutableDiffPTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADWP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updatePropaPtsMap\:SVF::DiffPTData< Key, Datum, Data >}
{\xe \v SVF::DiffPTData< Key, Datum, Data >\:updatePropaPtsMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > virtual void {\b SVF::DiffPTData}< Key, Datum, Data >::updatePropaPtsMap (Key &  {\i src}, Key &  {\i dst}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAADWQ}
{\bkmkend AAAAAAADWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update dst's propagated points-to set with src's. The final result is the intersection of these two sets. \par
}{
Implemented in {\b SVF::MutableDiffPTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADWR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/AbstractPointsToDS.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::DirectSVFGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::DirectSVFGEdge}
{\xe \v SVF::DirectSVFGEdge}
{\bkmkstart AAAAAAADMS}
{\bkmkend AAAAAAADMS}
\par
{
{\f2 #include <VFGEdge.h>}}\par
Inheritance diagram for SVF::DirectSVFGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_direct_s_v_f_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DirectSVFGEdge} ({\b VFGNode} *s, {\b VFGNode} *d, {\b GEdgeFlag} k){\bkmkstart AAAAAAADMT}
{\bkmkend AAAAAAADMT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADMU}
{\bkmkend AAAAAAADMU}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b DirectSVFGEdge} *){\bkmkstart AAAAAAADMV}
{\bkmkend AAAAAAADMV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGEdge} *edge){\bkmkstart AAAAAAADMW}
{\bkmkend AAAAAAADMW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGEdgeTy} *edge){\bkmkstart AAAAAAADMX}
{\bkmkend AAAAAAADMX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SVFG} edge representing direct value-flows \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::DistinctMRG Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::DistinctMRG}
{\xe \v SVF::DistinctMRG}
{\bkmkstart AAAAAAAEYR}
{\bkmkend AAAAAAAEYR}
\par
{
{\f2 #include <MemPartition.h>}}\par
Inheritance diagram for SVF::DistinctMRG:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_distinct_m_r_g.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DistinctMRG} ({\b BVDataPTAImpl} *p, bool ptrOnly){\bkmkstart AAAAAAAEYS}
{\bkmkend AAAAAAAEYS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b partitionMRs} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Partition regions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b getMRsForLoad} ({\b MRSet} &aliasMRs, const PointsTo &cpts, const {\b SVFFunction} *fun)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory region at a load. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b getMRsForCallSiteRef} ({\b MRSet} &aliasMRs, const PointsTo &cpts, const {\b SVFFunction} *fun)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory regions to be inserted at a load statement. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Distinct memory region generator. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getMRsForCallSiteRef\:SVF::DistinctMRG}
{\xe \v SVF::DistinctMRG\:getMRsForCallSiteRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DistinctMRG::getMRsForCallSiteRef ({\b MRSet} &  {\i aliasMRs}, const PointsTo &  {\i cpts}, const {\b SVFFunction} *  {\i fun}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEYT}
{\bkmkend AAAAAAAEYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory regions to be inserted at a load statement. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory regions to be inserted at a load statement. Just process as {\b getMRsForLoad()}. \par
}{
Reimplemented from {\b SVF::MRGenerator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEYU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getMRsForLoad\:SVF::DistinctMRG}
{\xe \v SVF::DistinctMRG\:getMRsForLoad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DistinctMRG::getMRsForLoad ({\b MRSet} &  {\i mrs}, const PointsTo &  {\i pts}, const {\b SVFFunction} *  {\i fun}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEYV}
{\bkmkend AAAAAAAEYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory region at a load. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory regions to be inserted at a load statement. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cpts} \cell }{The conditional points-to set of load statement. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fun} \cell }{The function being analyzed. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mrs} \cell }{Memory region set contains all possible target memory regions. \cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory regions for each points-to element in cpts.\par
}{
Reimplemented from {\b SVF::MRGenerator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEYW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v partitionMRs\:SVF::DistinctMRG}
{\xe \v SVF::DistinctMRG\:partitionMRs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DistinctMRG::partitionMRs (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEYX}
{\bkmkend AAAAAAAEYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Partition regions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create distinct memory regions. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect all points-to target in a function scope.\par
}{
Reimplemented from {\b SVF::MRGenerator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEYY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MemPartition.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MSSA/MemPartition.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::DOTGraphTraits< CHGraph * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::DOTGraphTraits< CHGraph * >}
{\xe \v llvm::DOTGraphTraits< CHGraph * >}
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
Inheritance diagram for llvm::DOTGraphTraits< CHGraph * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_d_o_t_graph_traits_3_01_c_h_graph_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b CHNode} {\b NodeType}{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DOTGraphTraits} (bool isSimple=false){\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getGraphName} ({\b CHGraph} *){\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of the graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getNodeLabel} ({\b CHNode} *node, {\b CHGraph} *){\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return function name;. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getNodeAttributes} ({\b CHNode} *node, {\b CHGraph} *){\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<class EdgeIter > static std::string {\b getEdgeAttributes} ({\b CHNode} *, EdgeIter EI, {\b CHGraph} *){\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write value flow graph into dot file for debugging \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/CHG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::DOTGraphTraits< ConstraintGraph * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::DOTGraphTraits< ConstraintGraph * >}
{\xe \v llvm::DOTGraphTraits< ConstraintGraph * >}
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
Inheritance diagram for llvm::DOTGraphTraits< ConstraintGraph * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_d_o_t_graph_traits_3_01_constraint_graph_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b ConstraintNode} {\b NodeType}{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DOTGraphTraits} (bool isSimple=false){\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getGraphName} ({\b ConstraintGraph} *){\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of the graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b getNodeLabel} ({\b NodeType} *n, {\b ConstraintGraph} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getNodeAttributes} ({\b NodeType} *n, {\b ConstraintGraph} *){\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<class EdgeIter > static std::string {\b getEdgeAttributes} ({\b NodeType} *, EdgeIter EI, {\b ConstraintGraph} *){\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<class EdgeIter > static std::string {\b getEdgeSourceLabel} ({\b NodeType} *, EdgeIter){\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getNodeLabel\:llvm::DOTGraphTraits< ConstraintGraph * >}
{\xe \v llvm::DOTGraphTraits< ConstraintGraph * >\:getNodeLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string llvm::DOTGraphTraits< {\b ConstraintGraph} * >::getNodeLabel ({\b NodeType} *  {\i n}, {\b ConstraintGraph} * ){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return label of a VFG node with two display mode Either you can choose to display the name of the value or the whole instruction \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ConsG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::DOTGraphTraits< ICFG * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::DOTGraphTraits< ICFG * >}
{\xe \v llvm::DOTGraphTraits< ICFG * >}
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
Inheritance diagram for llvm::DOTGraphTraits< ICFG * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_d_o_t_graph_traits_3_01_i_c_f_g_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b ICFGNode} {\b NodeType}{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DOTGraphTraits} (bool isSimple=false){\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b getNodeLabel} ({\b NodeType} *node, {\b ICFG} *graph){\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getGraphName} ({\b ICFG} *){\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of the graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getSimpleNodeLabel} ({\b NodeType} *node, {\b ICFG} *){\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the label of an ICFG node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getNodeAttributes} ({\b NodeType} *node, {\b ICFG} *){\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<class EdgeIter > static std::string {\b getEdgeAttributes} ({\b NodeType} *, EdgeIter EI, {\b ICFG} *){\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<class EdgeIter > static std::string {\b getEdgeSourceLabel} ({\b NodeType} *, EdgeIter EI){\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ICFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::DOTGraphTraits< OfflineConsG * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::DOTGraphTraits< OfflineConsG * >}
{\xe \v llvm::DOTGraphTraits< OfflineConsG * >}
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
Inheritance diagram for llvm::DOTGraphTraits< OfflineConsG * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_d_o_t_graph_traits_3_01_offline_cons_g_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b ConstraintNode} {\b NodeType}{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DOTGraphTraits} (bool isSimple=false){\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getGraphName} ({\b OfflineConsG} *){\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of the graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b getNodeLabel} ({\b NodeType} *n, {\b OfflineConsG} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getNodeAttributes} ({\b NodeType} *n, {\b OfflineConsG} *){\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<class EdgeIter > static std::string {\b getEdgeAttributes} ({\b NodeType} *, EdgeIter EI, {\b OfflineConsG} *){\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<class EdgeIter > static std::string {\b getEdgeSourceLabel} ({\b NodeType} *, EdgeIter){\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getNodeLabel\:llvm::DOTGraphTraits< OfflineConsG * >}
{\xe \v llvm::DOTGraphTraits< OfflineConsG * >\:getNodeLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string llvm::DOTGraphTraits< {\b OfflineConsG} * >::getNodeLabel ({\b NodeType} *  {\i n}, {\b OfflineConsG} * ){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return label of a VFG node with two display mode Either you can choose to display the name of the value or the whole instruction \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/OfflineConsG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::DOTGraphTraits< PAG * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::DOTGraphTraits< PAG * >}
{\xe \v llvm::DOTGraphTraits< PAG * >}
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
Inheritance diagram for llvm::DOTGraphTraits< PAG * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_d_o_t_graph_traits_3_01_p_a_g_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b PAGNode} {\b NodeType}{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b NodeType::iterator} {\b ChildIteratorType}{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DOTGraphTraits} (bool isSimple=false){\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getGraphName} ({\b PAG} *graph){\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of the graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b getNodeLabel} ({\b PAGNode} *node, {\b PAG} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getNodeAttributes} ({\b PAGNode} *node, {\b PAG} *){\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<class EdgeIter > static std::string {\b getEdgeAttributes} ({\b PAGNode} *, EdgeIter EI, {\b PAG} *){\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<class EdgeIter > static std::string {\b getEdgeSourceLabel} ({\b PAGNode} *, EdgeIter EI){\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write value flow graph into dot file for debugging \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getNodeLabel\:llvm::DOTGraphTraits< PAG * >}
{\xe \v llvm::DOTGraphTraits< PAG * >\:getNodeLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string llvm::DOTGraphTraits< {\b PAG} * >::getNodeLabel ({\b PAGNode} *  {\i node}, {\b PAG} * ){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return label of a VFG node with two display mode Either you can choose to display the name of the value or the whole instruction \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::DOTGraphTraits< PTACallGraph * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::DOTGraphTraits< PTACallGraph * >}
{\xe \v llvm::DOTGraphTraits< PTACallGraph * >}
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
Inheritance diagram for llvm::DOTGraphTraits< PTACallGraph * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_d_o_t_graph_traits_3_01_p_t_a_call_graph_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b PTACallGraphNode} {\b NodeType}{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeType::iterator {\b ChildIteratorType}{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DOTGraphTraits} (bool isSimple=false){\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getGraphName} ({\b PTACallGraph} *){\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of the graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getNodeLabel} ({\b PTACallGraphNode} *node, {\b PTACallGraph} *){\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return function name;. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getNodeAttributes} ({\b PTACallGraphNode} *node, {\b PTACallGraph} *){\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<class EdgeIter > static std::string {\b getEdgeAttributes} ({\b PTACallGraphNode} *, EdgeIter EI, {\b PTACallGraph} *){\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<class EdgeIter > static std::string {\b getEdgeSourceLabel} ({\b NodeType} *, EdgeIter EI){\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write value flow graph into dot file for debugging \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PTACallGraph.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::DOTGraphTraits< SVFG * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::DOTGraphTraits< SVFG * >}
{\xe \v llvm::DOTGraphTraits< SVFG * >}
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
Inheritance diagram for llvm::DOTGraphTraits< SVFG * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_d_o_t_graph_traits_3_01_s_v_f_g_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SVFGNode} {\b NodeType}{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DOTGraphTraits} (bool isSimple=false){\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b getNodeLabel} ({\b NodeType} *node, {\b SVFG} *graph){\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getGraphName} ({\b SVFG} *){\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of the graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getSimpleNodeLabel} ({\b NodeType} *node, {\b SVFG} *){\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return label of a VFG node without MemSSA information. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getCompleteNodeLabel} ({\b NodeType} *node, {\b SVFG} *){\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return label of a VFG node with MemSSA information. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b getNodeAttributes} ({\b NodeType} *node, {\b SVFG} *graph)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<class EdgeIter > static std::string {\b getEdgeAttributes} ({\b NodeType} *, EdgeIter EI, {\b SVFG} *){\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<class EdgeIter > static std::string {\b getEdgeSourceLabel} ({\b NodeType} *, EdgeIter EI){\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getNodeAttributes\:llvm::DOTGraphTraits< SVFG * >}
{\xe \v llvm::DOTGraphTraits< SVFG * >\:getNodeAttributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string llvm::DOTGraphTraits< {\b SVFG} * >::getNodeAttributes ({\b NodeType} *  {\i node}, {\b SVFG} *  {\i graph}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dump slice information\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::DOTGraphTraits< TCT * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::DOTGraphTraits< TCT * >}
{\xe \v llvm::DOTGraphTraits< TCT * >}
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
Inheritance diagram for llvm::DOTGraphTraits< TCT * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_d_o_t_graph_traits_3_01_t_c_t_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b TCTNode} {\b NodeType}{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b NodeType::iterator} {\b ChildIteratorType}{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DOTGraphTraits} (bool isSimple=false){\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getGraphName} ({\b TCT} *graph){\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of the graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getNodeLabel} ({\b TCTNode} *node, {\b TCT} *graph){\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return function name;. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getNodeAttributes} ({\b TCTNode} *node, {\b TCT} *tct){\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class EdgeIter > static std::string {\b getEdgeAttributes} ({\b TCTNode} *node, EdgeIter EI, {\b TCT} *csThreadTree)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write value flow graph into dot file for debugging \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getEdgeAttributes\:llvm::DOTGraphTraits< TCT * >}
{\xe \v llvm::DOTGraphTraits< TCT * >\:getEdgeAttributes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class EdgeIter > static std::string llvm::DOTGraphTraits< {\b TCT} * >::getEdgeAttributes ({\b TCTNode} *  {\i node}, EdgeIter  {\i EI}, {\b TCT} *  {\i csThreadTree}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
black edge for direct call while two functions contain indirect calls will be label with red color\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MTA/TCT.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::DOTGraphTraits< VFG * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::DOTGraphTraits< VFG * >}
{\xe \v llvm::DOTGraphTraits< VFG * >}
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
Inheritance diagram for llvm::DOTGraphTraits< VFG * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_d_o_t_graph_traits_3_01_v_f_g_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b VFGNode} {\b NodeType}{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DOTGraphTraits} (bool isSimple=false){\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b getNodeLabel} ({\b NodeType} *node, {\b VFG} *graph){\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getGraphName} ({\b VFG} *){\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of the graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getSimpleNodeLabel} ({\b NodeType} *node, {\b VFG} *){\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return label of a VFG node without MemSSA information. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getCompleteNodeLabel} ({\b NodeType} *node, {\b VFG} *){\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return label of a VFG node with MemSSA information. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b getNodeAttributes} ({\b NodeType} *node, {\b VFG} *){\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<class EdgeIter > static std::string {\b getEdgeAttributes} ({\b NodeType} *, EdgeIter EI, {\b VFG} *){\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

template<class EdgeIter > static std::string {\b getEdgeSourceLabel} ({\b NodeType} *, EdgeIter EI){\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::DoubleFreeChecker Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::DoubleFreeChecker}
{\xe \v SVF::DoubleFreeChecker}
{\bkmkstart AAAAAAAFWF}
{\bkmkend AAAAAAAFWF}
\par
{
{\f2 #include <DoubleFreeChecker.h>}}\par
Inheritance diagram for SVF::DoubleFreeChecker:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_double_free_checker.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DoubleFreeChecker} (){\bkmkstart AAAAAAAFWG}
{\bkmkend AAAAAAAFWG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~DoubleFreeChecker} (){\bkmkstart AAAAAAAFWH}
{\bkmkend AAAAAAAFWH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b runOnModule} ({\b SVFModule} *module)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start from here. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reportBug} ({\b ProgSlice} *slice){\bkmkstart AAAAAAAFWI}
{\bkmkend AAAAAAAFWI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Report file/close bugs. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Double free checker to check deallocations of memory \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v runOnModule\:SVF::DoubleFreeChecker}
{\xe \v SVF::DoubleFreeChecker\:runOnModule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool SVF::DoubleFreeChecker::runOnModule ({\b SVFModule} *  {\i module}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFWJ}
{\bkmkend AAAAAAAFWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start from here. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
start analysis\par
}{
Reimplemented from {\b SVF::LeakChecker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFWK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SABER/DoubleFreeChecker.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SABER/DoubleFreeChecker.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::DPItem Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::DPItem}
{\xe \v SVF::DPItem}
{\bkmkstart AAAAAAAGXX}
{\bkmkend AAAAAAAGXX}
\par
{
{\f2 #include <DPItem.h>}}\par
Inheritance diagram for SVF::DPItem:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_d_p_item.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DPItem} (NodeID c){\bkmkstart AAAAAAAGXY}
{\bkmkend AAAAAAAGXY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DPItem} (const {\b DPItem} &dps){\bkmkstart AAAAAAAGXZ}
{\bkmkend AAAAAAAGXZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~DPItem} (){\bkmkstart AAAAAAAGYA}
{\bkmkend AAAAAAAGYA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getCurNodeID} () const{\bkmkstart AAAAAAAGYB}
{\bkmkend AAAAAAAGYB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setCurNodeID} (NodeID c){\bkmkstart AAAAAAAGYC}
{\bkmkend AAAAAAAGYC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b DPItem} &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DPItem} & {\b operator=} (const {\b DPItem} &rhs){\bkmkstart AAAAAAAGYD}
{\bkmkend AAAAAAAGYD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading Operator=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b DPItem} &rhs) const{\bkmkstart AAAAAAAGYE}
{\bkmkend AAAAAAAGYE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading Operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b DPItem} &rhs) const{\bkmkstart AAAAAAAGYF}
{\bkmkend AAAAAAAGYF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading Operator!=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dump} () const{\bkmkstart AAAAAAAGYG}
{\bkmkend AAAAAAAGYG}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b setMaxBudget} (u32_t max){\bkmkstart AAAAAAAGYH}
{\bkmkend AAAAAAAGYH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set max step budge per query }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u32_t {\b getMaxBudget} (){\bkmkstart AAAAAAAGYI}
{\bkmkend AAAAAAAGYI}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b cur}{\bkmkstart AAAAAAAGYJ}
{\bkmkend AAAAAAAGYJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u64_t {\b maximumBudget} = ULONG_MAX - 1{\bkmkstart AAAAAAAGYK}
{\bkmkend AAAAAAAGYK}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dynamic programming item for CFL researchability search This serves as a base class for CFL-reachability formulation by matching parentheses. Extend this class for further sophisticated CFL-reachability items (e.g. field, flow, path) \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator<\:SVF::DPItem}
{\xe \v SVF::DPItem\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::DPItem::operator< (const {\b DPItem} &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAGYL}
{\bkmkend AAAAAAAGYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable compare operator to avoid duplicated item insertion in map or set to be noted that two vectors can also overload operator() \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/DPItem.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Util/PathCondAllocator.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::DummyObjPN Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::DummyObjPN}
{\xe \v SVF::DummyObjPN}
{\bkmkstart AAAAAAACPR}
{\bkmkend AAAAAAACPR}
Inheritance diagram for SVF::DummyObjPN:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_dummy_obj_p_n.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DummyObjPN} (NodeID i, const {\b MemObj} *m, {\b PNODEK} ty=DummyObjNode){\bkmkstart AAAAAAACPS}
{\bkmkend AAAAAAACPS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::string {\b getValueName} () const{\bkmkstart AAAAAAACPT}
{\bkmkend AAAAAAACPT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of this node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACPU}
{\bkmkend AAAAAAACPU}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b DummyObjPN} *){\bkmkstart AAAAAAACPV}
{\bkmkend AAAAAAACPV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGNode} *node){\bkmkstart AAAAAAACPW}
{\bkmkend AAAAAAACPW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGNodeTy} *node){\bkmkstart AAAAAAACPX}
{\bkmkend AAAAAAACPX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::DummyValPN Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::DummyValPN}
{\xe \v SVF::DummyValPN}
{\bkmkstart AAAAAAACPK}
{\bkmkend AAAAAAACPK}
Inheritance diagram for SVF::DummyValPN:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_dummy_val_p_n.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DummyValPN} (NodeID i){\bkmkstart AAAAAAACPL}
{\bkmkend AAAAAAACPL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::string {\b getValueName} () const{\bkmkstart AAAAAAACPM}
{\bkmkend AAAAAAACPM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of this node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACPN}
{\bkmkend AAAAAAACPN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b DummyValPN} *){\bkmkstart AAAAAAACPO}
{\bkmkend AAAAAAACPO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGNode} *node){\bkmkstart AAAAAAACPP}
{\bkmkend AAAAAAACPP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGNodeTy} *node){\bkmkstart AAAAAAACPQ}
{\bkmkend AAAAAAACPQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::EntryCHI< Cond > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::EntryCHI< Cond >}
{\xe \v SVF::EntryCHI< Cond >}
{\bkmkstart AAAAAAAFIT}
{\bkmkend AAAAAAAFIT}
\par
{
{\f2 #include <MSSAMuChi.h>}}\par
Inheritance diagram for SVF::EntryCHI< Cond >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_entry_c_h_i.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b EntryCHI} (const {\b SVFFunction} *f, const {\b MemRegion} *m, Cond c=PathCondAllocator::trueCond()){\bkmkstart AAAAAAAFIU}
{\bkmkend AAAAAAAFIU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructors for {\b EntryCHI}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getFunction} () const{\bkmkstart AAAAAAAFIV}
{\bkmkend AAAAAAAFIV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dump} (){\bkmkstart AAAAAAAFIW}
{\bkmkend AAAAAAAFIW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print CHI. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b EntryCHI} *chi){\bkmkstart AAAAAAAFIX}
{\bkmkend AAAAAAAFIX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MSSACHI}< Cond > *chi){\bkmkstart AAAAAAAFIY}
{\bkmkend AAAAAAAFIY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MSSADEF} *chi){\bkmkstart AAAAAAAFIZ}
{\bkmkend AAAAAAAFIZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Cond>\par
class SVF::EntryCHI< Cond >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b EntryCHI} is annotated at function entry, representing receiving memory objects from callers \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MSSAMuChi.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EpDoubleStruct Struct Reference\par \pard\plain 
{\tc\tcl2 \v EpDoubleStruct}
{\xe \v EpDoubleStruct}
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

union {\b EpTypeUnion} {\b type}{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b exponent}{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/epd.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EpTypeUnion Union Reference\par \pard\plain 
{\tc\tcl2 \v EpTypeUnion}
{\xe \v EpTypeUnion}
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
\par
{
{\f2 #include <epd.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b value}{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b IeeeDoubleStruct} {\b bits}{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b IeeeNanStruct} {\b nan}{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct**********************************************************************\par
Synopsis [Extended precision double to keep very large value.]\par
Description [Extended precision double to keep very large value.]\par
SeeAlso [] \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this union was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/epd.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::GenericEdge< NodeTy >::equalGEdge Struct Reference\par \pard\plain 
{\tc\tcl2 \v SVF::GenericEdge< NodeTy >::equalGEdge}
{\xe \v SVF::GenericEdge< NodeTy >::equalGEdge}
{\bkmkstart AAAAAAABQZ}
{\bkmkend AAAAAAABQZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add the hash function for std::set (we also can overload operator< to implement this) }}\par
{
{\f2 #include <GenericGraph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator()} (const {\b GenericEdge}< {\b NodeType} > *lhs, const {\b GenericEdge}< {\b NodeType} > *rhs) const{\bkmkstart AAAAAAABRA}
{\bkmkend AAAAAAABRA}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class NodeTy>\par
struct SVF::GenericEdge< NodeTy >::equalGEdge\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add the hash function for std::set (we also can overload operator< to implement this) \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/GenericGraph.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MemRegion::equalMemRegion Struct Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MemRegion::equalMemRegion}
{\xe \v SVF::MemRegion::equalMemRegion}
{\bkmkstart AAAAAAAEZX}
{\bkmkend AAAAAAAEZX}
\par
{
{\f2 #include <MemRegion.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator()} (const {\b MemRegion} *lhs, const {\b MemRegion} *rhs) const{\bkmkstart AAAAAAAEZY}
{\bkmkend AAAAAAAEZY}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add the hash function here to sort elements and remove and remove duplicated element in the set (binary tree comparision) \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MemRegion.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MemRegion::equalPointsTo Struct Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MemRegion::equalPointsTo}
{\xe \v SVF::MemRegion::equalPointsTo}
{\bkmkstart AAAAAAAEZZ}
{\bkmkend AAAAAAAEZZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator()} (const PointsTo &lhs, const PointsTo &rhs) const{\bkmkstart AAAAAAAFAA}
{\bkmkend AAAAAAAFAA}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MemRegion.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ExtAPI Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ExtAPI}
{\xe \v SVF::ExtAPI}
{\bkmkstart AAAAAAAHCN}
{\bkmkend AAAAAAAHCN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b extf_t} \{ {\b EFT_NOOP} = 0
, {\b EFT_ALLOC}
, {\b EFT_REALLOC}
, {\b EFT_FREE}
, {\b EFT_NOSTRUCT_ALLOC}
, {\b EFT_STAT}
, {\b EFT_STAT2}
, {\b EFT_L_A0}
, {\b EFT_L_A1}
, {\b EFT_L_A2}
, {\b EFT_L_A8}
, {\b EFT_L_A0__A0R_A1}
, {\b EFT_L_A0__A0R_A1R}
, {\b EFT_A1R_A0R}
, {\b EFT_A3R_A1R_NS}
, {\b EFT_A1R_A0}
, {\b EFT_A2R_A1}
, {\b EFT_A4R_A1}
, {\b EFT_L_A0__A2R_A0}
, {\b EFT_L_A0__A1_A0}
, {\b EFT_A0R_NEW}
, {\b EFT_A1R_NEW}
, {\b EFT_A2R_NEW}
, {\b EFT_A4R_NEW}
, {\b EFT_A11R_NEW}
, {\b EFT_STD_RB_TREE_INSERT_AND_REBALANCE}
, {\b EFT_STD_RB_TREE_INCREMENT}
, {\b EFT_STD_LIST_HOOK}
, {\b CPP_EFT_A0R_A1}
, {\b CPP_EFT_A0R_A1R}
, {\b CPP_EFT_A1R}
, {\b EFT_CXA_BEGIN_CATCH}
, {\b CPP_EFT_DYNAMIC_CAST}
, {\b EFT_OTHER}
 \}{\bkmkstart AAAAAAAHCO}
{\bkmkend AAAAAAAHCO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

extf_t {\b get_type} (const {\b SVFFunction} *F) const{\bkmkstart AAAAAAAHCP}
{\bkmkend AAAAAAAHCP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b has_static} (const {\b SVFFunction} *F) const{\bkmkstart AAAAAAAHCQ}
{\bkmkend AAAAAAAHCQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b has_static2} (const {\b SVFFunction} *F) const{\bkmkstart AAAAAAAHCR}
{\bkmkend AAAAAAAHCR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b is_alloc} (const {\b SVFFunction} *F) const{\bkmkstart AAAAAAAHCS}
{\bkmkend AAAAAAAHCS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b is_arg_alloc} (const {\b SVFFunction} *F) const{\bkmkstart AAAAAAAHCT}
{\bkmkend AAAAAAAHCT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b get_alloc_arg_pos} (const {\b SVFFunction} *F) const{\bkmkstart AAAAAAAHCU}
{\bkmkend AAAAAAAHCU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b no_struct_alloc} (const {\b SVFFunction} *F) const{\bkmkstart AAAAAAAHCV}
{\bkmkend AAAAAAAHCV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b is_dealloc} (const {\b SVFFunction} *F) const{\bkmkstart AAAAAAAHCW}
{\bkmkend AAAAAAAHCW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b is_noop} (const {\b SVFFunction} *F) const{\bkmkstart AAAAAAAHCX}
{\bkmkend AAAAAAAHCX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b is_realloc} (const {\b SVFFunction} *F) const{\bkmkstart AAAAAAAHCY}
{\bkmkend AAAAAAAHCY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b is_ext} (const {\b SVFFunction} *F){\bkmkstart AAAAAAAHCZ}
{\bkmkend AAAAAAAHCZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b ExtAPI} * {\b getExtAPI} (){\bkmkstart AAAAAAAHDA}
{\bkmkend AAAAAAAHDA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Singleton design here to make sure we only have one instance during whole analysis. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/ExtAPI.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Util/ExtAPI.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ExternalPAG Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ExternalPAG}
{\xe \v SVF::ExternalPAG}
{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
\par
{
{\f2 #include <ExternalPAG.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ExternalPAG} (std::string functionName){\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b getFunctionName} () const{\bkmkstart AAAAAAABPY}
{\bkmkend AAAAAAABPY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeSet & {\b getValueNodes} (){\bkmkstart AAAAAAABPZ}
{\bkmkend AAAAAAABPZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeSet & {\b getObjectNodes} (){\bkmkstart AAAAAAABQA}
{\bkmkend AAAAAAABQA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OrderedSet< std::tuple< NodeID, NodeID, std::string, int > > & {\b getEdges} (){\bkmkstart AAAAAAABQB}
{\bkmkend AAAAAAABQB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Map< int, NodeID > & {\b getArgNodes} (){\bkmkstart AAAAAAABQC}
{\bkmkend AAAAAAABQC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getReturnNode} () const{\bkmkstart AAAAAAABQD}
{\bkmkend AAAAAAABQD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setReturnNode} (NodeID returnNode){\bkmkstart AAAAAAABQE}
{\bkmkend AAAAAAABQE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasReturnNode} () const{\bkmkstart AAAAAAABQF}
{\bkmkend AAAAAAABQF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Does this function have a return node? }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addExternalPAG} (const {\b SVFFunction} *function)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b initialise} ({\b SVFModule} *svfModule)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b connectCallsiteToExternalPAG} (CallSite *cs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b hasExternalPAG} (const {\b SVFFunction} *function){\bkmkstart AAAAAAABQG}
{\bkmkend AAAAAAABQG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether an external {\b PAG} implementing function exists. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b dumpFunctions} (std::vector< std::string > functions)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump individual PAGs of specified functions. Currently to outs(). }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents the {\b PAG} of a function loaded externally (i.e. from file). It's purpose is to be attached to the main {\b PAG} (almost) seamlessly. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addExternalPAG\:SVF::ExternalPAG}
{\xe \v SVF::ExternalPAG\:addExternalPAG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ExternalPAG::addExternalPAG (const {\b SVFFunction} *  {\i function})}}
\par
{\bkmkstart AAAAAAABQH}
{\bkmkend AAAAAAABQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds (creates new equivalents) all the nodes and edges of this extpag to the main {\b PAG}. function is used as a key for future lookups. Returns true on success, false otherwise (incl. if it already exists). \par
}}
{\xe \v connectCallsiteToExternalPAG\:SVF::ExternalPAG}
{\xe \v SVF::ExternalPAG\:connectCallsiteToExternalPAG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ExternalPAG::connectCallsiteToExternalPAG (CallSite *  {\i cs}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABQI}
{\bkmkend AAAAAAABQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connects callsite if a external {\b PAG} implementing the relevant function has been added. Returns true on success, false otherwise. \par
}}
{\xe \v dumpFunctions\:SVF::ExternalPAG}
{\xe \v SVF::ExternalPAG\:dumpFunctions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ExternalPAG::dumpFunctions (std::vector< std::string >  {\i functions}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABQJ}
{\bkmkend AAAAAAABQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump individual PAGs of specified functions. Currently to outs(). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump PAGs for the functions \par
}}
{\xe \v initialise\:SVF::ExternalPAG}
{\xe \v SVF::ExternalPAG\:initialise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ExternalPAG::initialise ({\b SVFModule} *  {\i svfModule}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABQK}
{\bkmkend AAAAAAABQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parses command line arguments and attaches external PAGs to main {\b PAG}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ExternalPAG.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ExternalPAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FieldInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FieldInfo}
{\xe \v SVF::FieldInfo}
{\bkmkstart AAAAAAAEBK}
{\bkmkend AAAAAAAEBK}
\par
{
{\f2 #include <LocationSet.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< NodePair > {\b ElemNumStridePairVec}{\bkmkstart AAAAAAAEBL}
{\bkmkend AAAAAAAEBL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FieldInfo} (u32_t idx, u32_t byteOff, const Type *ty, ElemNumStridePairVec pa){\bkmkstart AAAAAAAEBM}
{\bkmkend AAAAAAAEBM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getFlattenFldIdx} () const{\bkmkstart AAAAAAAEBN}
{\bkmkend AAAAAAAEBN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getFlattenByteOffset} () const{\bkmkstart AAAAAAAEBO}
{\bkmkend AAAAAAAEBO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Type * {\b getFlattenElemTy} () const{\bkmkstart AAAAAAAEBP}
{\bkmkend AAAAAAAEBP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const ElemNumStridePairVec & {\b getElemNumStridePairVect} () const{\bkmkstart AAAAAAAEBQ}
{\bkmkend AAAAAAAEBQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

ElemNumStridePairVec::const_iterator {\b elemStridePairBegin} () const{\bkmkstart AAAAAAAEBR}
{\bkmkend AAAAAAAEBR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

ElemNumStridePairVec::const_iterator {\b elemStridePairEnd} () const{\bkmkstart AAAAAAAEBS}
{\bkmkend AAAAAAAEBS}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Field information of an aggregate object \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/LocationSet.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FIFOWorkList< Data > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FIFOWorkList< Data >}
{\xe \v SVF::FIFOWorkList< Data >}
{\bkmkstart AAAAAAAHMB}
{\bkmkend AAAAAAAHMB}
\par
{
{\f2 #include <WorkList.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b empty} () const{\bkmkstart AAAAAAAHMC}
{\bkmkend AAAAAAAHMC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b find} (Data data) const{\bkmkstart AAAAAAAHMD}
{\bkmkend AAAAAAAHMD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b push} (Data data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Data {\b pop} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Data>\par
class SVF::FIFOWorkList< Data >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Worklist with "first in first out" order. New nodes will be pushed at back and popped from front. Elements in the list are unique as they're recorded by Set. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v clear\:SVF::FIFOWorkList< Data >}
{\xe \v SVF::FIFOWorkList< Data >\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Data > void {\b SVF::FIFOWorkList}< Data >::clear (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHME}
{\bkmkend AAAAAAAHME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear all the data \par
}}
{\xe \v pop\:SVF::FIFOWorkList< Data >}
{\xe \v SVF::FIFOWorkList< Data >\:pop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Data > Data {\b SVF::FIFOWorkList}< Data >::pop (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHMF}
{\bkmkend AAAAAAAHMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pop a data from the END of work list. \par
}}
{\xe \v push\:SVF::FIFOWorkList< Data >}
{\xe \v SVF::FIFOWorkList< Data >\:push}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Data > bool {\b SVF::FIFOWorkList}< Data >::push (Data  {\i data}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHMG}
{\bkmkend AAAAAAAHMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push a data into the work list. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/WorkList.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FileChecker Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FileChecker}
{\xe \v SVF::FileChecker}
{\bkmkstart AAAAAAAFWL}
{\bkmkend AAAAAAAFWL}
\par
{
{\f2 #include <FileChecker.h>}}\par
Inheritance diagram for SVF::FileChecker:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_file_checker.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FileChecker} (){\bkmkstart AAAAAAAFWM}
{\bkmkend AAAAAAAFWM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~FileChecker} (){\bkmkstart AAAAAAAFWN}
{\bkmkend AAAAAAAFWN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b runOnModule} ({\b SVFModule} *module)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start from here. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isSourceLikeFun} (const {\b SVFFunction} *fun){\bkmkstart AAAAAAAFWO}
{\bkmkend AAAAAAAFWO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether the function is a heap allocator/reallocator (allocate memory) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isSinkLikeFun} (const {\b SVFFunction} *fun){\bkmkstart AAAAAAAFWP}
{\bkmkend AAAAAAAFWP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether the function is a heap deallocator (free/release memory) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reportBug} ({\b ProgSlice} *slice){\bkmkstart AAAAAAAFWQ}
{\bkmkend AAAAAAAFWQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Report file/close bugs. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reportNeverClose} (const {\b SVFGNode} *src){\bkmkstart AAAAAAAFWR}
{\bkmkend AAAAAAAFWR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reportPartialClose} (const {\b SVFGNode} *src){\bkmkstart AAAAAAAFWS}
{\bkmkend AAAAAAAFWS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
File open/close checker to check consistency of file operations \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v runOnModule\:SVF::FileChecker}
{\xe \v SVF::FileChecker\:runOnModule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool SVF::FileChecker::runOnModule ({\b SVFModule} *  {\i module}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFWT}
{\bkmkend AAAAAAAFWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start from here. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
start analysis\par
}{
Reimplemented from {\b SVF::LeakChecker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFWK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SABER/FileChecker.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SABER/FileChecker.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FILOWorkList< Data > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FILOWorkList< Data >}
{\xe \v SVF::FILOWorkList< Data >}
{\bkmkstart AAAAAAAHMH}
{\bkmkend AAAAAAAHMH}
\par
{
{\f2 #include <WorkList.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b empty} () const{\bkmkstart AAAAAAAHMI}
{\bkmkend AAAAAAAHMI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b find} (Data data) const{\bkmkstart AAAAAAAHMJ}
{\bkmkend AAAAAAAHMJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b push} (Data data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Data {\b pop} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Data>\par
class SVF::FILOWorkList< Data >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Worlist with "first in last out" order. New nodes will be pushed at back and popped from back. Elements in the list are unique as they're recorded by Set. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v clear\:SVF::FILOWorkList< Data >}
{\xe \v SVF::FILOWorkList< Data >\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Data > void {\b SVF::FILOWorkList}< Data >::clear (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHMK}
{\bkmkend AAAAAAAHMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear all the data \par
}}
{\xe \v pop\:SVF::FILOWorkList< Data >}
{\xe \v SVF::FILOWorkList< Data >\:pop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Data > Data {\b SVF::FILOWorkList}< Data >::pop (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHML}
{\bkmkend AAAAAAAHML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pop a data from the END of work list. \par
}}
{\xe \v push\:SVF::FILOWorkList< Data >}
{\xe \v SVF::FILOWorkList< Data >\:push}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Data > bool {\b SVF::FILOWorkList}< Data >::push (Data  {\i data}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHMM}
{\bkmkend AAAAAAAHMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push a data into the work list. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/WorkList.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FIObjPN Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FIObjPN}
{\xe \v SVF::FIObjPN}
{\bkmkstart AAAAAAACOO}
{\bkmkend AAAAAAACOO}
Inheritance diagram for SVF::FIObjPN:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_f_i_obj_p_n.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FIObjPN} (const Value *val, NodeID i, const {\b MemObj} *{\b mem}, {\b PNODEK} ty=FIObjNode){\bkmkstart AAAAAAACOP}
{\bkmkend AAAAAAACOP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::string {\b getValueName} () const{\bkmkstart AAAAAAACOQ}
{\bkmkend AAAAAAACOQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of a LLVM value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACOR}
{\bkmkend AAAAAAACOR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b FIObjPN} *){\bkmkstart AAAAAAACOS}
{\bkmkend AAAAAAACOS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ObjPN} *node){\bkmkstart AAAAAAACOT}
{\bkmkend AAAAAAACOT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGNode} *node){\bkmkstart AAAAAAACOU}
{\bkmkend AAAAAAACOU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGNodeTy} *node){\bkmkstart AAAAAAACOV}
{\bkmkend AAAAAAACOV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FlowDDA Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FlowDDA}
{\xe \v SVF::FlowDDA}
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
\par
{
{\f2 #include <FlowDDA.h>}}\par
Inheritance diagram for SVF::FlowDDA:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_flow_d_d_a.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef BVDataPTAImpl::CallSiteSet {\b CallSiteSet}{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef BVDataPTAImpl::CallEdgeMap {\b CallEdgeMap}{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef BVDataPTAImpl::FunctionSet {\b FunctionSet}{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FlowDDA} ({\b PAG} *{\b _pag}, {\b DDAClient} *client){\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~FlowDDA} (){\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b analyze} () override{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dummy analyze method }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b computeDDAPts} (NodeID id) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute points-to set for all top variable. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleOutOfBudgetDpm} (const {\b LocDPItem} &dpm)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle out-of-budget dpm. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b handleBKCondition} ({\b LocDPItem} &dpm, const {\b SVFGEdge} *edge) override{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle condition for flow analysis (backward analysis) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b testIndCallReachability} ({\b LocDPItem} &dpm, const {\b SVFFunction} *callee, CallSiteID csId){\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
refine indirect call edge }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b initialize} () override{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialization of the analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b finalize} () override{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isHeapCondMemObj} (const NodeID &var, const {\b StoreSVFGNode} *store) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual PointsTo {\b getConservativeCPts} (const {\b LocDPItem} &dpm) override{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Override parent method. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual NodeID {\b getPtrNodeID} (const NodeID &var) const override{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Override parent method. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleAddr} (PointsTo &pts, const {\b LocDPItem} &dpm, const {\b AddrSVFGNode} *addr) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle Address SVFGNode to add proper points-to. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual PointsTo {\b processGepPts} (const {\b GepSVFGNode} *gep, const PointsTo &srcPts) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
processGep node }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b updateCallGraphAndSVFG} (const {\b LocDPItem} &dpm, const {\b CallBlockNode} *cs, SVFGEdgeSet &svfgEdges) override{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update call graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const PointsTo & {\b getCachedTLPointsTo} (const {\b LocDPItem} &dpm) override{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Override parent class functions to get/add cached points-to directly via {\b PAGNode} ID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionDDAPts} ({\b LocDPItem} dpm, const PointsTo &targetPts) override{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union pts. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b PTAName} () const override{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return PTA name. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flow sensitive demand-driven analysis on value-flow graph \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v computeDDAPts\:SVF::FlowDDA}
{\xe \v SVF::FlowDDA\:computeDDAPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FlowDDA::computeDDAPts (NodeID  {\i id}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute points-to set for all top variable. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute points-to set for queries \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
start DDA analysis\par
}{
Reimplemented from {\b SVF::PointerAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v handleAddr\:SVF::FlowDDA}
{\xe \v SVF::FlowDDA\:handleAddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void SVF::FlowDDA::handleAddr (PointsTo &  {\i pts}, const {\b LocDPItem} &  {\i dpm}, const {\b AddrSVFGNode} *  {\i addr}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle Address SVFGNode to add proper points-to. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
whether this object is set field-insensitive during pre-analysis\par
}{
Implements {\b SVF::DDAVFSolver< NodeID, PointsTo, LocDPItem >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v handleOutOfBudgetDpm\:SVF::FlowDDA}
{\xe \v SVF::FlowDDA\:handleOutOfBudgetDpm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FlowDDA::handleOutOfBudgetDpm (const {\b LocDPItem} &  {\i dpm})}}
\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle out-of-budget dpm. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle out-of-budget dpm \par
}}
{\xe \v isHeapCondMemObj\:SVF::FlowDDA}
{\xe \v SVF::FlowDDA\:isHeapCondMemObj}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowDDA::isHeapCondMemObj (const NodeID &  {\i var}, const {\b StoreSVFGNode} *  {\i store}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
we exclude concrete heap here following the conditions: (1) local allocated heap and (2) not escaped to the scope outside the current function (3) not inside loop (4) not involved in recursion \par
}{
Reimplemented from {\b SVF::DDAVFSolver< NodeID, PointsTo, LocDPItem >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processGepPts\:SVF::FlowDDA}
{\xe \v SVF::FlowDDA\:processGepPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PointsTo FlowDDA::processGepPts (const {\b GepSVFGNode} *  {\i gep}, const PointsTo &  {\i srcPts}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
processGep node }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate field objects for structs \par
}{
Implements {\b SVF::DDAVFSolver< NodeID, PointsTo, LocDPItem >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/DDA/FlowDDA.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/DDA/FlowDDA.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FlowSensitive Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive}
{\bkmkstart AAAAAAAHTL}
{\bkmkend AAAAAAAHTL}
Inheritance diagram for SVF::FlowSensitive:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_flow_sensitive.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b BVDataPTAImpl::MutDFPTDataTy} {\b MutDFPTDataTy}{\bkmkstart AAAAAAAHTM}
{\bkmkend AAAAAAAHTM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b BVDataPTAImpl::MutDFPTDataTy::DFPtsMap} {\b DFInOutMap}{\bkmkstart AAAAAAAHTN}
{\bkmkend AAAAAAAHTN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef BVDataPTAImpl::MutDFPTDataTy::PtsMap {\b PtsMap}{\bkmkstart AAAAAAAHTO}
{\bkmkend AAAAAAAHTO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FlowSensitive} ({\b PAG} *_pag, {\b PTATY} type={\b FSSPARSE_WPA}){\bkmkstart AAAAAAAHTP}
{\bkmkend AAAAAAAHTP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~FlowSensitive} (){\bkmkstart AAAAAAAHTQ}
{\bkmkend AAAAAAAHTQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b runOnModule} ({\b SVFModule} *){\bkmkstart AAAAAAAHTR}
{\bkmkend AAAAAAAHTR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start from here. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b analyze} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flow sensitive analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b finalize} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b PTAName} () const{\bkmkstart AAAAAAAHTS}
{\bkmkend AAAAAAAHTS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get PTA name. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFG} * {\b getSVFG} () const{\bkmkstart AAAAAAAHTT}
{\bkmkend AAAAAAAHTT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return {\b SVFG}. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b FlowSensitive} * {\b createFSWPA} ({\b PAG} *_pag){\bkmkstart AAAAAAAHTU}
{\bkmkend AAAAAAAHTU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create signle instance of flow-sensitive pointer analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b releaseFSWPA} (){\bkmkstart AAAAAAAHTV}
{\bkmkend AAAAAAAHTV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Release flow-sensitive pointer analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b FlowSensitive} *){\bkmkstart AAAAAAAHTW}
{\bkmkend AAAAAAAHTW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PointerAnalysis} *pta){\bkmkstart AAAAAAAHTX}
{\bkmkend AAAAAAAHTX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef SVFG::SVFGEdgeSetTy {\b SVFGEdgeSetTy}{\bkmkstart AAAAAAAHTY}
{\bkmkend AAAAAAAHTY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual NodeStack & {\b SCCDetect} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC detection. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b propFromSrcToDst} ({\b SVFGEdge} *edge)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b propAlongDirectEdge} (const {\b DirectSVFGEdge} *edge)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information along a DIRECT {\b SVFG} edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b propAlongIndirectEdge} (const {\b IndirectSVFGEdge} *edge)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information along an INDIRECT {\b SVFG} edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b propVarPtsFromSrcToDst} (NodeID var, const {\b SVFGNode} *src, const {\b SVFGNode} *dst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information of a certain variable from src to dst. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b propagateFromAPToFP} (const {\b ActualParmSVFGNode} *ap, const {\b SVFGNode} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b propagateFromFRToAR} (const {\b FormalRetSVFGNode} *fr, const {\b SVFGNode} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b weakUpdateOutFromIn} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAHTZ}
{\bkmkend AAAAAAAHTZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle weak updates. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b strongUpdateOutFromIn} (const {\b SVFGNode} *node, NodeID singleton){\bkmkstart AAAAAAAHUA}
{\bkmkend AAAAAAAHUA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle strong updates. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b propVarPtsAfterCGUpdated} (NodeID var, const {\b SVFGNode} *src, const {\b SVFGNode} *dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b propDFOutToIn} (const {\b SVFGNode} *srcStmt, NodeID srcVar, const {\b SVFGNode} *dstStmt, NodeID dstVar){\bkmkstart AAAAAAAHUB}
{\bkmkend AAAAAAAHUB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b propDFInToIn} (const {\b SVFGNode} *srcStmt, NodeID srcVar, const {\b SVFGNode} *dstStmt, NodeID dstVar){\bkmkstart AAAAAAAHUC}
{\bkmkend AAAAAAAHUC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b updateOutFromIn} (const {\b SVFGNode} *srcStmt, NodeID srcVar, const {\b SVFGNode} *dstStmt, NodeID dstVar){\bkmkstart AAAAAAAHUD}
{\bkmkend AAAAAAAHUD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update data-flow points-to data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateInFromIn} (const {\b SVFGNode} *srcStmt, NodeID srcVar, const {\b SVFGNode} *dstStmt, NodeID dstVar){\bkmkstart AAAAAAAHUE}
{\bkmkend AAAAAAAHUE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateInFromOut} (const {\b SVFGNode} *srcStmt, NodeID srcVar, const {\b SVFGNode} *dstStmt, NodeID dstVar){\bkmkstart AAAAAAAHUF}
{\bkmkend AAAAAAAHUF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPtsFromIn} (const {\b SVFGNode} *stmt, NodeID srcVar, NodeID dstVar){\bkmkstart AAAAAAAHUG}
{\bkmkend AAAAAAAHUG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPtsFromTop} (const {\b SVFGNode} *stmt, NodeID srcVar, NodeID dstVar){\bkmkstart AAAAAAAHUH}
{\bkmkend AAAAAAAHUH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b clearAllDFOutVarFlag} (const {\b SVFGNode} *stmt){\bkmkstart AAAAAAAHUI}
{\bkmkend AAAAAAAHUI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b processNode} (NodeID nodeId)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle various constraints. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b processSVFGNode} ({\b SVFGNode} *node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processAddr} (const {\b AddrSVFGNode} *addr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processCopy} (const {\b CopySVFGNode} *copy)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processPhi} (const {\b PHISVFGNode} *phi)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processGep} (const {\b GepSVFGNode} *edge)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processLoad} (const {\b LoadSVFGNode} *load)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processStore} (const {\b StoreSVFGNode} *store)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b updateCallGraph} (const CallSiteToFunPtrMap &callsites)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update call graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b connectCallerAndCallee} (const CallEdgeMap &newEdges, SVFGEdgeSetTy &edges)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect nodes in {\b SVFG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateConnectedNodes} (const SVFGEdgeSetTy &edges)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update nodes connected during updating call graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isStrongUpdate} (const {\b SVFGNode} *node, NodeID &singleton)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return TRUE if this is a strong update STORE statement. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b printCTirAliasStats} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b countAliases} (Set< std::pair< NodeID, NodeID >> cmp, unsigned *mayAliases, unsigned *noAliases){\bkmkstart AAAAAAAHUJ}
{\bkmkend AAAAAAAHUJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills may/noAliases for the location/pointer pairs in cmp. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const PointsTo & {\b getDFInPtsSet} (const {\b SVFGNode} *stmt, const NodeID node){\bkmkstart AAAAAAAHUK}
{\bkmkend AAAAAAAHUK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get points-to set for a node from data flow IN/OUT set at a statement. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const PointsTo & {\b getDFOutPtsSet} (const {\b SVFGNode} *stmt, const NodeID node){\bkmkstart AAAAAAAHUL}
{\bkmkend AAAAAAAHUL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b svfgStat} (){\bkmkstart AAAAAAAHUM}
{\bkmkend AAAAAAAHUM}
\par
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \par
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const DFInOutMap & {\b getDFInputMap} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const DFInOutMap & {\b getDFOutputMap} () const{\bkmkstart AAAAAAAHUN}
{\bkmkend AAAAAAAHUN}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFG} * {\b svfg}{\bkmkstart AAAAAAAHUO}
{\bkmkend AAAAAAAHUO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFGBuilder} {\b memSSA}{\bkmkstart AAAAAAAHUP}
{\bkmkend AAAAAAAHUP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b AndersenWaveDiff} * {\b ander}{\bkmkstart AAAAAAAHUQ}
{\bkmkend AAAAAAAHUQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b numOfProcessedAddr}{\bkmkstart AAAAAAAHUR}
{\bkmkend AAAAAAAHUR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b numOfProcessedCopy}{\bkmkstart AAAAAAAHUS}
{\bkmkend AAAAAAAHUS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of processed Addr node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b numOfProcessedGep}{\bkmkstart AAAAAAAHUT}
{\bkmkend AAAAAAAHUT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of processed Copy node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b numOfProcessedPhi}{\bkmkstart AAAAAAAHUU}
{\bkmkend AAAAAAAHUU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of processed Gep node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b numOfProcessedLoad}{\bkmkstart AAAAAAAHUV}
{\bkmkend AAAAAAAHUV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of processed Phi node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b numOfProcessedStore}{\bkmkstart AAAAAAAHUW}
{\bkmkend AAAAAAAHUW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of processed Load node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b numOfProcessedActualParam}{\bkmkstart AAAAAAAHUX}
{\bkmkend AAAAAAAHUX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of processed Store node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b numOfProcessedFormalRet}{\bkmkstart AAAAAAAHUY}
{\bkmkend AAAAAAAHUY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of processed actual param node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b numOfProcessedMSSANode}{\bkmkstart AAAAAAAHUZ}
{\bkmkend AAAAAAAHUZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of processed formal ret node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b maxSCCSize}{\bkmkstart AAAAAAAHVA}
{\bkmkend AAAAAAAHVA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of processed mssa node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b numOfSCC}{\bkmkstart AAAAAAAHVB}
{\bkmkend AAAAAAAHVB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b numOfNodesInSCC}{\bkmkstart AAAAAAAHVC}
{\bkmkend AAAAAAAHVC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b solveTime}{\bkmkstart AAAAAAAHVD}
{\bkmkend AAAAAAAHVD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of solve. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b sccTime}{\bkmkstart AAAAAAAHVE}
{\bkmkend AAAAAAAHVE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of SCC detection. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b processTime}{\bkmkstart AAAAAAAHVF}
{\bkmkend AAAAAAAHVF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of processNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b propagationTime}{\bkmkstart AAAAAAAHVG}
{\bkmkend AAAAAAAHVG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of points-to propagation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b directPropaTime}{\bkmkstart AAAAAAAHVH}
{\bkmkend AAAAAAAHVH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of points-to propagation of address-taken objects }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b indirectPropaTime}{\bkmkstart AAAAAAAHVI}
{\bkmkend AAAAAAAHVI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of points-to propagation of top-level pointers }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b updateTime}{\bkmkstart AAAAAAAHVJ}
{\bkmkend AAAAAAAHVJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of strong/weak updates. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b addrTime}{\bkmkstart AAAAAAAHVK}
{\bkmkend AAAAAAAHVK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of handling address edges }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b copyTime}{\bkmkstart AAAAAAAHVL}
{\bkmkend AAAAAAAHVL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of handling copy edges }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b gepTime}{\bkmkstart AAAAAAAHVM}
{\bkmkend AAAAAAAHVM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of handling gep edges }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b loadTime}{\bkmkstart AAAAAAAHVN}
{\bkmkend AAAAAAAHVN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of load edges }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b storeTime}{\bkmkstart AAAAAAAHVO}
{\bkmkend AAAAAAAHVO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of store edges }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b phiTime}{\bkmkstart AAAAAAAHVP}
{\bkmkend AAAAAAAHVP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of phi nodes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b updateCallGraphTime}{\bkmkstart AAAAAAAHVQ}
{\bkmkend AAAAAAAHVQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of updating call graph }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeBS {\b svfgHasSU}{\bkmkstart AAAAAAAHVR}
{\bkmkend AAAAAAAHVR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b FlowSensitive} * {\b fspta} = NULL{\bkmkstart AAAAAAAHVS}
{\bkmkend AAAAAAAHVS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b FlowSensitiveStat}{\bkmkstart AAAAAAAHVT}
{\bkmkend AAAAAAAHVT}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v analyze\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:analyze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FlowSensitive::analyze (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHVU}
{\bkmkend AAAAAAAHVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flow sensitive analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start analysis \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialization for the Solver\par
Start solving constraints\par
finalize the analysis\par
}{
Implements {\b SVF::PointerAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAENH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::FlowSensitiveTBHC} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHVV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v connectCallerAndCallee\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:connectCallerAndCallee}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FlowSensitive::connectCallerAndCallee (const CallEdgeMap &  {\i newEdges}, SVFGEdgeSetTy &  {\i edges}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHVW}
{\bkmkend AAAAAAAHVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect nodes in {\b SVFG}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle parameter passing in {\b SVFG} \par
}}
{\xe \v finalize\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:finalize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FlowSensitive::finalize (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEPU}
{\bkmkend AAAAAAAEPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalize analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalize analysis \par
}{
Reimplemented from {\b SVF::PointerAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEPQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::VersionedFlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEPR \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::FlowSensitiveTBHC} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEPS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getDFInputMap\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:getDFInputMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const DFInOutMap& SVF::FlowSensitive::getDFInputMap () const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHVX}
{\bkmkend AAAAAAAHVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get IN/OUT data flow map. May only be called when the backing is MUTABLE. \par
}}
{\xe \v initialize\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FlowSensitive::initialize (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEQF}
{\bkmkend AAAAAAAEQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis \par
}{
Reimplemented from {\b SVF::PointerAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::VersionedFlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQC \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::FlowSensitiveTBHC} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isStrongUpdate\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:isStrongUpdate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitive::isStrongUpdate (const {\b SVFGNode} *  {\i node}, NodeID &  {\i singleton}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHVY}
{\bkmkend AAAAAAAHVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return TRUE if this is a strong update STORE statement. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return TRUE if this is a strong update STORE statement. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find the unique element in cpts\par
}}
{\xe \v printCTirAliasStats\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:printCTirAliasStats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FlowSensitive::printCTirAliasStats (void ){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHVZ}
{\bkmkend AAAAAAAHVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints some easily parseable stats on aliasing of relevant CTir TL PTS. Format: eval-ctir-aliases #TOTAL_TESTS #MAY_ALIAS #NO_ALIAS \par
}}
{\xe \v processAddr\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:processAddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitive::processAddr (const {\b AddrSVFGNode} *  {\i addr}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWA}
{\bkmkend AAAAAAAHWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process address node \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO: If this object has been set as field-insensitive, just add the insensitive object node into dst pointer's pts.\par
}{
Reimplemented in {\b SVF::FlowSensitiveTBHC} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processCopy\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:processCopy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitive::processCopy (const {\b CopySVFGNode} *  {\i copy}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWC}
{\bkmkend AAAAAAAHWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process copy node \par
}{
Reimplemented in {\b SVF::FlowSensitiveTBHC} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processGep\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:processGep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitive::processGep (const {\b GepSVFGNode} *  {\i edge}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWE}
{\bkmkend AAAAAAAHWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process gep node \par
}{
Reimplemented in {\b SVF::FlowSensitiveTBHC} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processLoad\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:processLoad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitive::processLoad (const {\b LoadSVFGNode} *  {\i load}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWG}
{\bkmkend AAAAAAAHWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process load node\par
Foreach node \\in src pts(dst) = union pts(node) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the ptd is a field-insensitive node, we should also get all field nodes' points-to sets and pass them to pagDst.\par
}{
Reimplemented in {\b SVF::VersionedFlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWH \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::FlowSensitiveTBHC} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processNode\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:processNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FlowSensitive::processNode (NodeID  {\i nodeId}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWJ}
{\bkmkend AAAAAAAHWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle various constraints. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process each {\b SVFG} node \par
}{
Reimplemented from {\b SVF::WPASolver< GraphType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::VersionedFlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processPhi\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:processPhi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitive::processPhi (const {\b PHISVFGNode} *  {\i phi}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWL}
{\bkmkend AAAAAAAHWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process mssa phi node \par
}{
Reimplemented in {\b SVF::FlowSensitiveTBHC} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processStore\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:processStore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitive::processStore (const {\b StoreSVFGNode} *  {\i store}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWN}
{\bkmkend AAAAAAAHWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process store node\par
foreach node \\in dst pts(node) = union pts(src) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STORE statement can only be processed if the pointer on the LHS points to something. If we handle STORE with an empty points-to set, the OUT set will be updated from IN set. Then if LHS pointer points-to one target and it has been identified as a strong update, we can't remove those points-to information computed before this strong update from the OUT set.\par
check if this is a strong updates store\par
}{
Reimplemented in {\b SVF::VersionedFlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWO \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::FlowSensitiveTBHC} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processSVFGNode\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:processSVFGNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitive::processSVFGNode ({\b SVFGNode} *  {\i node}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHWQ}
{\bkmkend AAAAAAAHWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process each {\b SVFG} node \par
}}
{\xe \v propagateFromAPToFP\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:propagateFromAPToFP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitive::propagateFromAPToFP (const {\b ActualParmSVFGNode} *  {\i ap}, const {\b SVFGNode} *  {\i dst}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWR}
{\bkmkend AAAAAAAHWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information from an actual-param to a formal-param. Not necessary if {\b SVFGOPT} is used instead of original {\b SVFG}.\par
Propagate points-to information from actual-param to formal-param. Not necessary if {\b SVFGOPT} is used instead of original {\b SVFG}. \par
}}
{\xe \v propagateFromFRToAR\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:propagateFromFRToAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitive::propagateFromFRToAR (const {\b FormalRetSVFGNode} *  {\i fr}, const {\b SVFGNode} *  {\i dst}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWS}
{\bkmkend AAAAAAAHWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information from a formal-ret to an actual-ret. Not necessary if {\b SVFGOPT} is used instead of original {\b SVFG}.\par
Propagate points-to information from formal-ret to actual-ret. Not necessary if {\b SVFGOPT} is used instead of original {\b SVFG}. \par
}}
{\xe \v propAlongDirectEdge\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:propAlongDirectEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitive::propAlongDirectEdge (const {\b DirectSVFGEdge} *  {\i edge}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWT}
{\bkmkend AAAAAAAHWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information along a DIRECT {\b SVFG} edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information along DIRECT {\b SVFG} edge. \par
}{
Reimplemented in {\b SVF::FlowSensitiveTBHC} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v propAlongIndirectEdge\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:propAlongIndirectEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitive::propAlongIndirectEdge (const {\b IndirectSVFGEdge} *  {\i edge}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWV}
{\bkmkend AAAAAAAHWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information along an INDIRECT {\b SVFG} edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information along INDIRECT {\b SVFG} edge. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this is a field-insensitive obj, propagate all field node's pts\par
}{
Reimplemented in {\b SVF::VersionedFlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWW \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::FlowSensitiveTBHC} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v propFromSrcToDst\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:propFromSrcToDst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitive::propFromSrcToDst ({\b SVFGEdge} *  {\i edge}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWY}
{\bkmkend AAAAAAAHWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information from an edge's src node to its dst node.\par
Propagate points-to information from source to destination node Union dfOutput of src to dfInput of dst. Only propagate points-to set of node which exists on the {\b SVFG} edge.{
\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab propagation along direct edge will always return TRUE.\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab propagation along indirect edge will return TRUE if destination node's IN set has been updated. \par}
}}
{\xe \v propVarPtsAfterCGUpdated\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:propVarPtsAfterCGUpdated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitive::propVarPtsAfterCGUpdated (NodeID  {\i var}, const {\b SVFGNode} *  {\i src}, const {\b SVFGNode} *  {\i dst}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHWZ}
{\bkmkend AAAAAAAHWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagation between newly connected {\b SVFG} nodes during updateCallGraph. Can only be used during updateCallGraph.\par
Propagate points-to information of a certain variable from src to dst. \par
}}
{\xe \v propVarPtsFromSrcToDst\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:propVarPtsFromSrcToDst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitive::propVarPtsFromSrcToDst (NodeID  {\i var}, const {\b SVFGNode} *  {\i src}, const {\b SVFGNode} *  {\i dst}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHXA}
{\bkmkend AAAAAAAHXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information of a certain variable from src to dst. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information of a certain variable from src to dst. \par
}}
{\xe \v SCCDetect\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:SCCDetect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeStack & FlowSensitive::SCCDetect (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHXB}
{\bkmkend AAAAAAAHXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC detection. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC detection \par
}{
Reimplemented from {\b SVF::WPAFSSolver< GraphType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHXC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updateCallGraph\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:updateCallGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitive::updateCallGraph (const CallSiteToFunPtrMap &  {\i callsites}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHXD}
{\bkmkend AAAAAAAHXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update call graph. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update call graph.\par
Update call graph \par
}{
Reimplemented from {\b SVF::BVDataPTAImpl} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAERP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updateConnectedNodes\:SVF::FlowSensitive}
{\xe \v SVF::FlowSensitive\:updateConnectedNodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FlowSensitive::updateConnectedNodes (const SVFGEdgeSetTy &  {\i edges}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHXE}
{\bkmkend AAAAAAAHXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update nodes connected during updating call graph. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push nodes connected during update call graph into worklist so they will be solved during next iteration. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this is a formal-param or actual-ret node, we need to solve this phi node in next iteration\par
If this is a formal-in or actual-out node, we need to propagate points-to information from its predecessor node.\par
If this is a field-insensitive obj, propagate all field node's pts\par
}{
Reimplemented in {\b SVF::VersionedFlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHXF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/FlowSensitive.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/FlowSensitive.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FlowSensitiveStat Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FlowSensitiveStat}
{\xe \v SVF::FlowSensitiveStat}
{\bkmkstart AAAAAAAICV}
{\bkmkend AAAAAAAICV}
\par
{
{\f2 #include <WPAStat.h>}}\par
Inheritance diagram for SVF::FlowSensitiveStat:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_flow_sensitive_stat.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef FlowSensitive::DFInOutMap {\b DFInOutMap}{\bkmkstart AAAAAAAICW}
{\bkmkend AAAAAAAICW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef FlowSensitive::PtsMap {\b PtsMap}{\bkmkstart AAAAAAAICX}
{\bkmkend AAAAAAAICX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FlowSensitiveStat} ({\b FlowSensitive} *pta){\bkmkstart AAAAAAAICY}
{\bkmkend AAAAAAAICY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b performStat} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FlowSensitive} * {\b fspta}{\bkmkstart AAAAAAAICZ}
{\bkmkend AAAAAAAICZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics of flow-sensitive analysis \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v performStat\:SVF::FlowSensitiveStat}
{\xe \v SVF::FlowSensitiveStat\:performStat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FlowSensitiveStat::performStat (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAIDA}
{\bkmkend AAAAAAAIDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start statistics \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SVFG} nodes.\par
}{
Reimplemented from {\b SVF::PTAStat} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABEG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/WPAStat.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/FlowSensitiveStat.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FlowSensitiveTBHC Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FlowSensitiveTBHC}
{\xe \v SVF::FlowSensitiveTBHC}
{\bkmkstart AAAAAAAHXG}
{\bkmkend AAAAAAAHXG}
\par
{
{\f2 #include <FlowSensitiveTBHC.h>}}\par
Inheritance diagram for SVF::FlowSensitiveTBHC:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_flow_sensitive_t_b_h_c.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FlowSensitiveTBHC} ({\b PAG} *_pag, {\b PTATY} type={\b FSTBHC_WPA}){\bkmkstart AAAAAAAHXH}
{\bkmkend AAAAAAAHXH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~FlowSensitiveTBHC} (){\bkmkstart AAAAAAAHXI}
{\bkmkend AAAAAAAHXI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b analyze} () override{\bkmkstart AAAAAAAHVV}
{\bkmkend AAAAAAAHVV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flow sensitive analysis with FSTBHC. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b initialize} () override{\bkmkstart AAAAAAAEQD}
{\bkmkend AAAAAAAEQD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b finalize} () override{\bkmkstart AAAAAAAEPS}
{\bkmkend AAAAAAAEPS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b PTAName} () const override{\bkmkstart AAAAAAAHXJ}
{\bkmkend AAAAAAAHXJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get PTA name. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b propAlongIndirectEdge} (const {\b IndirectSVFGEdge} *edge) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information along an INDIRECT {\b SVFG} edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b propAlongDirectEdge} (const {\b DirectSVFGEdge} *edge) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information along a DIRECT {\b SVFG} edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processAddr} (const {\b AddrSVFGNode} *addr) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processGep} (const {\b GepSVFGNode} *gep) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processLoad} (const {\b LoadSVFGNode} *load) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processStore} (const {\b StoreSVFGNode} *store) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processPhi} (const {\b PHISVFGNode} *phi) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processCopy} (const {\b CopySVFGNode} *copy) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const NodeBS & {\b getAllFieldsObjNode} (NodeID id) override{\bkmkstart AAAAAAAHXK}
{\bkmkend AAAAAAAHXK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateInFromIn} (const {\b SVFGNode} *srcStmt, NodeID srcVar, const {\b SVFGNode} *dstStmt, NodeID dstVar) override{\bkmkstart AAAAAAAHXL}
{\bkmkend AAAAAAAHXL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateInFromOut} (const {\b SVFGNode} *srcStmt, NodeID srcVar, const {\b SVFGNode} *dstStmt, NodeID dstVar) override{\bkmkstart AAAAAAAHXM}
{\bkmkend AAAAAAAHXM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPtsFromIn} (const {\b SVFGNode} *stmt, NodeID srcVar, NodeID dstVar) override{\bkmkstart AAAAAAAHXN}
{\bkmkend AAAAAAAHXN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPtsFromTop} (const {\b SVFGNode} *stmt, NodeID srcVar, NodeID dstVar) override{\bkmkstart AAAAAAAHXO}
{\bkmkend AAAAAAAHXO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b propDFOutToIn} (const {\b SVFGNode} *srcStmt, NodeID srcVar, const {\b SVFGNode} *dstStmt, NodeID dstVar) override{\bkmkstart AAAAAAAHXP}
{\bkmkend AAAAAAAHXP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b propDFInToIn} (const {\b SVFGNode} *srcStmt, NodeID srcVar, const {\b SVFGNode} *dstStmt, NodeID dstVar) override{\bkmkstart AAAAAAAHXQ}
{\bkmkend AAAAAAAHXQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b expandFIObjs} (const PointsTo &pts, PointsTo &expandedPts) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Expand FI objects. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const DIType * {\b getTypeFromCTirMetadata} (const {\b SVFGNode} *)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const MDNode * {\b getRawCTirMetadata} (const {\b SVFGNode} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b FlowSensitiveTBHC} *){\bkmkstart AAAAAAAHXR}
{\bkmkend AAAAAAAHXR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For LLVM RTTI. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PointerAnalysis} *pta){\bkmkstart AAAAAAAHXS}
{\bkmkend AAAAAAAHXS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For LLVM RTTI. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b backPropagate} (NodeID clone) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b countAliases} (Set< std::pair< NodeID, NodeID >> cmp, unsigned *mayAliases, unsigned *noAliases) override{\bkmkstart AAAAAAAHXT}
{\bkmkend AAAAAAAHXT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills may/noAliases for the location/pointer pairs in cmp. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flow sensitive whole program pointer analysis with type-based heap cloning. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v backPropagate\:SVF::FlowSensitiveTBHC}
{\xe \v SVF::FlowSensitiveTBHC\:backPropagate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FlowSensitiveTBHC::backPropagate (NodeID  {\i clone}){\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHLL}
{\bkmkend AAAAAAAHLL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Required by user. Handles back-propagation of newly created clone after all metadata has been set. Used by cloneObject. \par
}{
Implements {\b SVF::TypeBasedHeapCloning} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHLK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v expandFIObjs\:SVF::FlowSensitiveTBHC}
{\xe \v SVF::FlowSensitiveTBHC\:expandFIObjs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FlowSensitiveTBHC::expandFIObjs (const PointsTo &  {\i pts}, PointsTo &  {\i expandedPts}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAESG}
{\bkmkend AAAAAAAESG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Expand FI objects. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Expand all fields of an aggregate in all points-to sets \par
}{
Reimplemented from {\b SVF::BVDataPTAImpl} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAESF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getRawCTirMetadata\:SVF::FlowSensitiveTBHC}
{\xe \v SVF::FlowSensitiveTBHC\:getRawCTirMetadata}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const MDNode * FlowSensitiveTBHC::getRawCTirMetadata (const {\b SVFGNode} *  {\i s}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAHXU}
{\bkmkend AAAAAAAHXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns raw ctir metadata of the instruction behind a {\b SVFG} node. Wraps {\b getRawCTirMetadata(const Value *)}. Returns null if it doesn't exist. \par
}}
{\xe \v getTypeFromCTirMetadata\:SVF::FlowSensitiveTBHC}
{\xe \v SVF::FlowSensitiveTBHC\:getTypeFromCTirMetadata}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const DIType * FlowSensitiveTBHC::getTypeFromCTirMetadata (const {\b SVFGNode} *  {\i s})}}
\par
{\bkmkstart AAAAAAAHXV}
{\bkmkend AAAAAAAHXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Extracts the value from SVFGNode (if it exists), and calls {\b getTypeFromCTirMetadata(const Value *)}. If no ctir type exists, returns null (void). \par
}}
{\xe \v processAddr\:SVF::FlowSensitiveTBHC}
{\xe \v SVF::FlowSensitiveTBHC\:processAddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitiveTBHC::processAddr (const {\b AddrSVFGNode} *  {\i addr}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWB}
{\bkmkend AAAAAAAHWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process address node \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO: If this object has been set as field-insensitive, just add the insensitive object node into dst pointer's pts.\par
}{
Reimplemented from {\b SVF::FlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processCopy\:SVF::FlowSensitiveTBHC}
{\xe \v SVF::FlowSensitiveTBHC\:processCopy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitiveTBHC::processCopy (const {\b CopySVFGNode} *  {\i copy}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWD}
{\bkmkend AAAAAAAHWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process copy node \par
}{
Reimplemented from {\b SVF::FlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processGep\:SVF::FlowSensitiveTBHC}
{\xe \v SVF::FlowSensitiveTBHC\:processGep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitiveTBHC::processGep (const {\b GepSVFGNode} *  {\i edge}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWF}
{\bkmkend AAAAAAAHWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process gep node \par
}{
Reimplemented from {\b SVF::FlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processLoad\:SVF::FlowSensitiveTBHC}
{\xe \v SVF::FlowSensitiveTBHC\:processLoad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitiveTBHC::processLoad (const {\b LoadSVFGNode} *  {\i load}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWI}
{\bkmkend AAAAAAAHWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process load node\par
Foreach node \\in src pts(dst) = union pts(node) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the ptd is a field-insensitive node, we should also get all field nodes' points-to sets and pass them to pagDst.\par
If the ptd is a field-insensitive node, we should also get all field nodes' points-to sets and pass them to pagDst.\par
}{
Reimplemented from {\b SVF::FlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processPhi\:SVF::FlowSensitiveTBHC}
{\xe \v SVF::FlowSensitiveTBHC\:processPhi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitiveTBHC::processPhi (const {\b PHISVFGNode} *  {\i phi}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWM}
{\bkmkend AAAAAAAHWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process mssa phi node \par
}{
Reimplemented from {\b SVF::FlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processStore\:SVF::FlowSensitiveTBHC}
{\xe \v SVF::FlowSensitiveTBHC\:processStore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitiveTBHC::processStore (const {\b StoreSVFGNode} *  {\i store}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWP}
{\bkmkend AAAAAAAHWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process store node\par
foreach node \\in dst pts(node) = union pts(src) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STORE statement can only be processed if the pointer on the LHS points to something. If we handle STORE with an empty points-to set, the OUT set will be updated from IN set. Then if LHS pointer points-to one target and it has been identified as a strong update, we can't remove those points-to information computed before this strong update from the OUT set.\par
check if this is a strong updates store\par
STORE statement can only be processed if the pointer on the LHS points to something. If we handle STORE with an empty points-to set, the OUT set will be updated from IN set. Then if LHS pointer points-to one target and it has been identified as a strong update, we can't remove those points-to information computed before this strong update from the OUT set.\par
check if this is a strong updates store\par
}{
Reimplemented from {\b SVF::FlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v propAlongDirectEdge\:SVF::FlowSensitiveTBHC}
{\xe \v SVF::FlowSensitiveTBHC\:propAlongDirectEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitiveTBHC::propAlongDirectEdge (const {\b DirectSVFGEdge} *  {\i edge}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWU}
{\bkmkend AAAAAAAHWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information along a DIRECT {\b SVFG} edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information along DIRECT {\b SVFG} edge. \par
}{
Reimplemented from {\b SVF::FlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v propAlongIndirectEdge\:SVF::FlowSensitiveTBHC}
{\xe \v SVF::FlowSensitiveTBHC\:propAlongIndirectEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FlowSensitiveTBHC::propAlongIndirectEdge (const {\b IndirectSVFGEdge} *  {\i edge}){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWX}
{\bkmkend AAAAAAAHWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information along an INDIRECT {\b SVFG} edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate points-to information along INDIRECT {\b SVFG} edge. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this is a field-insensitive obj, propagate all field node's pts\par
If this is a field-insensitive obj, propagate all field node's pts\par
}{
Reimplemented from {\b SVF::FlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/FlowSensitiveTBHC.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/FlowSensitiveTBHC.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ForkJoinAnalysis Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ForkJoinAnalysis}
{\xe \v SVF::ForkJoinAnalysis}
{\bkmkstart AAAAAAAFPK}
{\bkmkend AAAAAAAFPK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ValDomain} \{ {\b Empty}
, {\b TDAlive}
, {\b TDDead}
 \}{\bkmkstart AAAAAAAFPL}
{\bkmkend AAAAAAAFPL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
semilattice Empty==>TDDead==>TDAlive }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef TCT::InstVec {\b InstVec}{\bkmkstart AAAAAAAFPM}
{\bkmkend AAAAAAAFPM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CxtStmt}, {\b ValDomain} > {\b CxtStmtToAliveFlagMap}{\bkmkstart AAAAAAAFPN}
{\bkmkend AAAAAAAFPN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CxtStmt}, NodeBS > {\b CxtStmtToTIDMap}{\bkmkstart AAAAAAAFPO}
{\bkmkend AAAAAAAFPO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< NodePair > {\b ThreadPairSet}{\bkmkstart AAAAAAAFPP}
{\bkmkend AAAAAAAFPP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CxtStmt}, const Loop * > {\b CxtStmtToLoopMap}{\bkmkstart AAAAAAAFPQ}
{\bkmkend AAAAAAAFPQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< {\b CxtStmt} > {\b CxtStmtWorkList}{\bkmkstart AAAAAAAFPR}
{\bkmkend AAAAAAAFPR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Instruction *, {\b PTASCEV} > {\b forkjoinToPTASCEVMap}{\bkmkstart AAAAAAAFPS}
{\bkmkend AAAAAAAFPS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ForkJoinAnalysis} ({\b TCT} *t){\bkmkstart AAAAAAAFPT}
{\bkmkend AAAAAAAFPT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b collectSCEVInfo} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
functions }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b analyzeForkJoinPair} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeBS & {\b getDirectlyJoinedTid} (const {\b CxtStmt} &cs){\bkmkstart AAAAAAAFPU}
{\bkmkend AAAAAAAFPU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get directly joined threadIDs based on a context-sensitive join site. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeBS {\b getDirAndIndJoinedTid} (const {\b CxtStmt} &cs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get directly and indirectly joined threadIDs based on a context-sensitive join site. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Loop * {\b isJoinInSymmetricLoop} (const {\b CxtStmt} &cs) const{\bkmkstart AAAAAAAFPV}
{\bkmkend AAAAAAAFPV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a context-sensitive join satisfies symmetric loop pattern. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isHBPair} (NodeID tid1, NodeID tid2){\bkmkstart AAAAAAAFPW}
{\bkmkend AAAAAAAFPW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether thread t1 happens-before thread t2. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFullJoin} (NodeID tid1, NodeID tid2){\bkmkstart AAAAAAAFPX}
{\bkmkend AAAAAAAFPX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether t1 fully joins t2. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Instruction * {\b getExitInstOfParentRoutineFun} (NodeID tid) const{\bkmkstart AAAAAAAFPY}
{\bkmkend AAAAAAAFPY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get exit instruction of the start routine function of tid's parent thread. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Loop * {\b getJoinLoop} (const Instruction *inst){\bkmkstart AAAAAAAFPZ}
{\bkmkend AAAAAAAFPZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get loop for join site. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

ScalarEvolution * {\b getSE} (const Instruction *inst){\bkmkstart AAAAAAAFQA}
{\bkmkend AAAAAAAFQA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get SE for function. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v analyzeForkJoinPair\:SVF::ForkJoinAnalysis}
{\xe \v SVF::ForkJoinAnalysis\:analyzeForkJoinPair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ForkJoinAnalysis::analyzeForkJoinPair ()}}
\par
{\bkmkstart AAAAAAAFQB}
{\bkmkend AAAAAAAFQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
context-sensitive forward traversal from each fork site. Generate following results (1) fork join pair, maps a context-sensitive join site to its corresponding thread ids (2) never happen-in-parallel thread pairs\par
Context-sensitive forward traversal from each fork site \par
}}
{\xe \v collectSCEVInfo\:SVF::ForkJoinAnalysis}
{\xe \v SVF::ForkJoinAnalysis\:collectSCEVInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ForkJoinAnalysis::collectSCEVInfo ()}}
\par
{\bkmkstart AAAAAAAFQC}
{\bkmkend AAAAAAAFQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
functions }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect SCEV pass information for pointers at fork/join sites Because ScalarEvolution is a function pass, previous knowledge of a function may be overwritten when analyzing a new function. We use a internal wrapper class {\b PTASCEV} to record all the necessary information for determining symmetric fork/join inside loops \par
}}
{\xe \v getDirAndIndJoinedTid\:SVF::ForkJoinAnalysis}
{\xe \v SVF::ForkJoinAnalysis\:getDirAndIndJoinedTid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeBS ForkJoinAnalysis::getDirAndIndJoinedTid (const {\b CxtStmt} &  {\i cs})}}
\par
{\bkmkstart AAAAAAAFQD}
{\bkmkend AAAAAAAFQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get directly and indirectly joined threadIDs based on a context-sensitive join site. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return thread id(s) which are joined at this join site (1) thread t1 directly joins thread t2 (2) thread t1 indirectly joins thread t3 via directly joining t2 (t2 fully joins its child thread t3) \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/MHP.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MTA/MHP.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FormalINSVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FormalINSVFGNode}
{\xe \v SVF::FormalINSVFGNode}
{\bkmkstart AAAAAAACZS}
{\bkmkend AAAAAAACZS}
Inheritance diagram for SVF::FormalINSVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_formal_i_n_s_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FormalINSVFGNode} (NodeID id, const {\b MemSSA::ENTRYCHI} *entry){\bkmkstart AAAAAAACZT}
{\bkmkend AAAAAAACZT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemSSA::ENTRYCHI} * {\b getEntryChi} () const{\bkmkstart AAAAAAACZU}
{\bkmkend AAAAAAACZU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b EntryCHI}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACZV}
{\bkmkend AAAAAAACZV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b FormalINSVFGNode} *){\bkmkstart AAAAAAACZW}
{\bkmkend AAAAAAACZW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAACZX}
{\bkmkend AAAAAAACZX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAACZY}
{\bkmkend AAAAAAACZY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FormalOUTSVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FormalOUTSVFGNode}
{\xe \v SVF::FormalOUTSVFGNode}
{\bkmkstart AAAAAAACZZ}
{\bkmkend AAAAAAACZZ}
Inheritance diagram for SVF::FormalOUTSVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_formal_o_u_t_s_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FormalOUTSVFGNode} (NodeID id, const {\b MemSSA::RETMU} *exit){\bkmkstart AAAAAAADAA}
{\bkmkend AAAAAAADAA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemSSA::RETMU} * {\b getRetMU} () const{\bkmkstart AAAAAAADAB}
{\bkmkend AAAAAAADAB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b RetMU}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADAC}
{\bkmkend AAAAAAADAC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b FormalOUTSVFGNode} *){\bkmkstart AAAAAAADAD}
{\bkmkend AAAAAAADAD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADAE}
{\bkmkend AAAAAAADAE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADAF}
{\bkmkend AAAAAAADAF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FormalParmVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FormalParmVFGNode}
{\xe \v SVF::FormalParmVFGNode}
{\bkmkstart AAAAAAADTO}
{\bkmkend AAAAAAADTO}
Inheritance diagram for SVF::FormalParmVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_formal_parm_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FormalParmVFGNode} (NodeID id, const {\b PAGNode} *n, const {\b SVFFunction} *f){\bkmkstart AAAAAAADTP}
{\bkmkend AAAAAAADTP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getParam} () const{\bkmkstart AAAAAAADTQ}
{\bkmkend AAAAAAADTQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return parameter. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getFun} () const{\bkmkstart AAAAAAADTR}
{\bkmkend AAAAAAADTR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addCallPE} (const {\b CallPE} *call){\bkmkstart AAAAAAADTS}
{\bkmkend AAAAAAADTS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return call edge. }{
}\par
}\par}
}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CallPESet::const_iterator {\b callPEBegin} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallPESet::const_iterator {\b callPEEnd} () const{\bkmkstart AAAAAAADTT}
{\bkmkend AAAAAAADTT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADTU}
{\bkmkend AAAAAAADTU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b FormalParmVFGNode} *){\bkmkstart AAAAAAADTV}
{\bkmkend AAAAAAADTV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADTW}
{\bkmkend AAAAAAADTW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ArgumentVFGNode} *node){\bkmkstart AAAAAAADTX}
{\bkmkend AAAAAAADTX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADTY}
{\bkmkend AAAAAAADTY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v callPEBegin\:SVF::FormalParmVFGNode}
{\xe \v SVF::FormalParmVFGNode\:callPEBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CallPESet::const_iterator SVF::FormalParmVFGNode::callPEBegin () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADTZ}
{\bkmkend AAAAAAADTZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call edge iterator \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FormalRetVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FormalRetVFGNode}
{\xe \v SVF::FormalRetVFGNode}
{\bkmkstart AAAAAAADUK}
{\bkmkend AAAAAAADUK}
\par
{
{\f2 #include <VFGNode.h>}}\par
Inheritance diagram for SVF::FormalRetVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_formal_ret_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FormalRetVFGNode} (NodeID id, const {\b PAGNode} *n, const {\b SVFFunction} *f){\bkmkstart AAAAAAADUL}
{\bkmkend AAAAAAADUL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getRet} () const{\bkmkstart AAAAAAADUM}
{\bkmkend AAAAAAADUM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return value at callee. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getFun} () const{\bkmkstart AAAAAAADUN}
{\bkmkend AAAAAAADUN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addRetPE} (const {\b RetPE} *retPE){\bkmkstart AAAAAAADUO}
{\bkmkend AAAAAAADUO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b RetPE}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

RetPESet::const_iterator {\b retPEBegin} () const{\bkmkstart AAAAAAADUP}
{\bkmkend AAAAAAADUP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b RetPE} iterators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

RetPESet::const_iterator {\b retPEEnd} () const{\bkmkstart AAAAAAADUQ}
{\bkmkend AAAAAAADUQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADUR}
{\bkmkend AAAAAAADUR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b FormalRetVFGNode}){\bkmkstart AAAAAAADUS}
{\bkmkend AAAAAAADUS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADUT}
{\bkmkend AAAAAAADUT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ArgumentVFGNode} *node){\bkmkstart AAAAAAADUU}
{\bkmkend AAAAAAADUU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADUV}
{\bkmkend AAAAAAADUV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Callee return {\b ICFG} node \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FSMPTA Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FSMPTA}
{\xe \v SVF::FSMPTA}
{\bkmkstart AAAAAAAFLE}
{\bkmkend AAAAAAAFLE}
\par
{
{\f2 #include <FSMPTA.h>}}\par
Inheritance diagram for SVF::FSMPTA:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_f_s_m_p_t_a.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FSMPTA} ({\b MHP} *m, {\b LockAnalysis} *la){\bkmkstart AAAAAAAFLF}
{\bkmkend AAAAAAAFLF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ~FSMPTA} (){\bkmkstart AAAAAAAFLG}
{\bkmkend AAAAAAAFLG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} ({\b SVFModule} *module)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MHP} * {\b getMHP} () const{\bkmkstart AAAAAAAFLH}
{\bkmkend AAAAAAAFLH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b MHP}. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b FSMPTA} * {\b createFSMPTA} ({\b SVFModule} *module, {\b MHP} *m, {\b LockAnalysis} *la){\bkmkstart AAAAAAAFLI}
{\bkmkend AAAAAAAFLI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create signle instance of flow-sensitive pointer analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b releaseFSMPTA} (){\bkmkstart AAAAAAAFLJ}
{\bkmkend AAAAAAAFLJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Release flow-sensitive pointer analysis. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flow-sensitive pointer analysis for multithreaded programs \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initialize\:SVF::FSMPTA}
{\xe \v SVF::FSMPTA\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FSMPTA::initialize ({\b SVFModule} *  {\i module})}}
\par
{\bkmkstart AAAAAAAFLK}
{\bkmkend AAAAAAAFLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/FSMPTA.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MTA/FSMPTA.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FunEntryBlockNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FunEntryBlockNode}
{\xe \v SVF::FunEntryBlockNode}
{\bkmkstart AAAAAAABXT}
{\bkmkend AAAAAAABXT}
\par
{
{\f2 #include <ICFGNode.h>}}\par
Inheritance diagram for SVF::FunEntryBlockNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_fun_entry_block_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const {\b PAGNode} * > {\b FormalParmNodeVec}{\bkmkstart AAAAAAABXU}
{\bkmkend AAAAAAABXU}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FunEntryBlockNode} (NodeID id, const {\b SVFFunction} *f){\bkmkstart AAAAAAABXV}
{\bkmkend AAAAAAABXV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getFun} () const{\bkmkstart AAAAAAABXW}
{\bkmkend AAAAAAABXW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const FormalParmNodeVec & {\b getFormalParms} () const{\bkmkstart AAAAAAABXX}
{\bkmkend AAAAAAABXX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the set of formal parameters. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addFormalParms} (const {\b PAGNode} *fp){\bkmkstart AAAAAAABXY}
{\bkmkend AAAAAAABXY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add formal parameters. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAABXZ}
{\bkmkend AAAAAAABXZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b FunEntryBlockNode} *){\bkmkstart AAAAAAABYA}
{\bkmkend AAAAAAABYA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b InterBlockNode} *node){\bkmkstart AAAAAAABYB}
{\bkmkend AAAAAAABYB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ICFGNode} *node){\bkmkstart AAAAAAABYC}
{\bkmkend AAAAAAABYC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericICFGNodeTy} *node){\bkmkstart AAAAAAABYD}
{\bkmkend AAAAAAABYD}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function entry {\b ICFGNode} containing a set of FormalParmVFGNodes of a function \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ICFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FunExitBlockNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FunExitBlockNode}
{\xe \v SVF::FunExitBlockNode}
{\bkmkstart AAAAAAABYE}
{\bkmkend AAAAAAABYE}
\par
{
{\f2 #include <ICFGNode.h>}}\par
Inheritance diagram for SVF::FunExitBlockNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_fun_exit_block_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FunExitBlockNode} (NodeID id, const {\b SVFFunction} *f){\bkmkstart AAAAAAABYF}
{\bkmkend AAAAAAABYF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getFun} () const{\bkmkstart AAAAAAABYG}
{\bkmkend AAAAAAABYG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getFormalRet} () const{\bkmkstart AAAAAAABYH}
{\bkmkend AAAAAAABYH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return actual return parameter. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addFormalRet} (const {\b PAGNode} *fr){\bkmkstart AAAAAAABYI}
{\bkmkend AAAAAAABYI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add actual return parameter. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAABYJ}
{\bkmkend AAAAAAABYJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b FunEntryBlockNode} *){\bkmkstart AAAAAAABYK}
{\bkmkend AAAAAAABYK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ICFGNode} *node){\bkmkstart AAAAAAABYL}
{\bkmkend AAAAAAABYL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b InterBlockNode} *node){\bkmkstart AAAAAAABYM}
{\bkmkend AAAAAAABYM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericICFGNodeTy} *node){\bkmkstart AAAAAAABYN}
{\bkmkend AAAAAAABYN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function exit {\b ICFGNode} containing (at most one) FormalRetVFGNodes of a function \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ICFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::FunptrDDAClient Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::FunptrDDAClient}
{\xe \v SVF::FunptrDDAClient}
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
\par
{
{\f2 #include <DDAClient.h>}}\par
Inheritance diagram for SVF::FunptrDDAClient:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_funptr_d_d_a_client.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FunptrDDAClient} ({\b SVFModule} *{\b module}){\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual OrderedNodeSet & {\b collectCandidateQueries} ({\b PAG} *p){\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only collect function pointers as query candidates. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b performStat} ({\b PointerAnalysis} *pta){\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DDA client with function pointers as query candidates. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/DDA/DDAClient.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/DDA/DDAClient.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::generic_bridge_gep_type_iterator< ItTy > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v llvm::generic_bridge_gep_type_iterator< ItTy >}
{\xe \v llvm::generic_bridge_gep_type_iterator< ItTy >}
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
Inheritance diagram for llvm::generic_bridge_gep_type_iterator< ItTy >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classllvm_1_1generic__bridge__gep__type__iterator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b generic_bridge_gep_type_iterator} &x) const{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b generic_bridge_gep_type_iterator} &x) const{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Type * {\b operator*} () const{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Type * {\b getIndexedType} () const{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Type * {\b operator->} () const{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Value * {\b getOperand} () const{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b generic_bridge_gep_type_iterator} & {\b operator++} (){\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b generic_bridge_gep_type_iterator} {\b operator++} (int){\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b generic_bridge_gep_type_iterator} {\b begin} (Type *Ty, ItTy It){\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b generic_bridge_gep_type_iterator} {\b begin} (Type *Ty, unsigned AddrSpace, ItTy It){\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b generic_bridge_gep_type_iterator} {\b end} (ItTy It){\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/GEPTypeBridgeIterator.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::GenericEdge< NodeTy > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::GenericEdge< NodeTy >}
{\xe \v SVF::GenericEdge< NodeTy >}
{\bkmkstart AAAAAAABQL}
{\bkmkend AAAAAAABQL}
\par
{
{\f2 #include <GenericGraph.h>}}\par
Inheritance diagram for SVF::GenericEdge< NodeTy >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_generic_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b equalGEdge}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add the hash function for std::set (we also can overload operator< to implement this) }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeTy {\b NodeType}{\bkmkstart AAAAAAABQM}
{\bkmkend AAAAAAABQM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Node type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef u64_t {\b GEdgeFlag}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef s32_t {\b GEdgeKind}{\bkmkstart AAAAAAABQN}
{\bkmkend AAAAAAABQN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b GenericEdge} (NodeTy *s, NodeTy *d, {\b GEdgeFlag} k){\bkmkstart AAAAAAABQO}
{\bkmkend AAAAAAABQO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~GenericEdge} (){\bkmkstart AAAAAAABQP}
{\bkmkend AAAAAAABQP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getSrcID} () const{\bkmkstart AAAAAAABQQ}
{\bkmkend AAAAAAABQQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get methods of the components }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getDstID} () const{\bkmkstart AAAAAAABQR}
{\bkmkend AAAAAAABQR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

GEdgeKind {\b getEdgeKind} () const{\bkmkstart AAAAAAABQS}
{\bkmkend AAAAAAABQS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b NodeType} * {\b getSrcNode} () const{\bkmkstart AAAAAAABQT}
{\bkmkend AAAAAAABQT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b NodeType} * {\b getDstNode} () const{\bkmkstart AAAAAAABQU}
{\bkmkend AAAAAAABQU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b GenericEdge}< {\b NodeType} > *rhs) const{\bkmkstart AAAAAAABQV}
{\bkmkend AAAAAAABQV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static constexpr unsigned char {\b EdgeKindMaskBits} = 8{\bkmkstart AAAAAAABQW}
{\bkmkend AAAAAAABQW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We use the lower 8 bits to denote edge kind. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static constexpr u64_t {\b EdgeKindMask} = (~0ULL) >> (64 - {\b EdgeKindMaskBits}){\bkmkstart AAAAAAABQX}
{\bkmkend AAAAAAABQX}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class NodeTy>\par
class SVF::GenericEdge< NodeTy >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic edge on the graph as base class \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v GEdgeFlag\:SVF::GenericEdge< NodeTy >}
{\xe \v SVF::GenericEdge< NodeTy >\:GEdgeFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class NodeTy > typedef u64_t {\b SVF::GenericEdge}< NodeTy >::{\b GEdgeFlag}}}
\par
{\bkmkstart AAAAAAABQY}
{\bkmkend AAAAAAABQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Edge Flag Edge format as follows (from lowest bit): (1) 0-7 bits encode an edge kind (allow maximum 16 kinds) (2) 8-63 bits encode a callsite instruction \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/GenericGraph.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::GenericGraph< NodeTy, EdgeTy > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::GenericGraph< NodeTy, EdgeTy >}
{\xe \v SVF::GenericGraph< NodeTy, EdgeTy >}
{\bkmkstart AAAAAAABSM}
{\bkmkend AAAAAAABSM}
Inheritance diagram for SVF::GenericGraph< NodeTy, EdgeTy >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_generic_graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeTy {\b NodeType}{\bkmkstart AAAAAAABSN}
{\bkmkend AAAAAAABSN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef EdgeTy {\b EdgeType}{\bkmkstart AAAAAAABSO}
{\bkmkend AAAAAAABSO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, NodeType * > {\b IDToNodeMapTy}{\bkmkstart AAAAAAABSP}
{\bkmkend AAAAAAABSP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NodeID to {\b GenericNode} map. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef IDToNodeMapTy::iterator {\b iterator}{\bkmkstart AAAAAAABSQ}
{\bkmkend AAAAAAABSQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Node Iterators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef IDToNodeMapTy::const_iterator {\b const_iterator}{\bkmkstart AAAAAAABSR}
{\bkmkend AAAAAAABSR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b GenericGraph} (){\bkmkstart AAAAAAABSS}
{\bkmkend AAAAAAABSS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~GenericGraph} (){\bkmkstart AAAAAAABST}
{\bkmkend AAAAAAABST}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b destroy} (){\bkmkstart AAAAAAABSU}
{\bkmkend AAAAAAABSU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Release memory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b iterator} {\b begin} (){\bkmkstart AAAAAAABSV}
{\bkmkend AAAAAAABSV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b iterator} {\b end} (){\bkmkstart AAAAAAABSW}
{\bkmkend AAAAAAABSW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b begin} () const{\bkmkstart AAAAAAABSX}
{\bkmkend AAAAAAABSX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b end} () const{\bkmkstart AAAAAAABSY}
{\bkmkend AAAAAAABSY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addGNode} (NodeID id, NodeType *node){\bkmkstart AAAAAAABSZ}
{\bkmkend AAAAAAABSZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a Node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeType * {\b getGNode} (NodeID id) const{\bkmkstart AAAAAAABTA}
{\bkmkend AAAAAAABTA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasGNode} (NodeID id) const{\bkmkstart AAAAAAABTB}
{\bkmkend AAAAAAABTB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has a node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeGNode} (NodeType *node){\bkmkstart AAAAAAABTC}
{\bkmkend AAAAAAABTC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Delete a node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getTotalNodeNum} () const{\bkmkstart AAAAAAABTD}
{\bkmkend AAAAAAABTD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get total number of node/edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getTotalEdgeNum} () const{\bkmkstart AAAAAAABTE}
{\bkmkend AAAAAAABTE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b incNodeNum} (){\bkmkstart AAAAAAABTF}
{\bkmkend AAAAAAABTF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Increase number of node/edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b incEdgeNum} (){\bkmkstart AAAAAAABTG}
{\bkmkend AAAAAAABTG}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b edgeNum}{\bkmkstart AAAAAAABTH}
{\bkmkend AAAAAAABTH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
total num of node }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b nodeNum}{\bkmkstart AAAAAAABTI}
{\bkmkend AAAAAAABTI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
total num of edge }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b IDToNodeMapTy} {\b IDToNodeMap}{\bkmkstart AAAAAAABTJ}
{\bkmkend AAAAAAABTJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
node map }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/GenericGraph.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::GenericNode< NodeTy, EdgeTy > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::GenericNode< NodeTy, EdgeTy >}
{\xe \v SVF::GenericNode< NodeTy, EdgeTy >}
{\bkmkstart AAAAAAABRB}
{\bkmkend AAAAAAABRB}
\par
{
{\f2 #include <GenericGraph.h>}}\par
Inheritance diagram for SVF::GenericNode< NodeTy, EdgeTy >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_generic_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeTy {\b NodeType}{\bkmkstart AAAAAAABRC}
{\bkmkend AAAAAAABRC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef EdgeTy {\b EdgeType}{\bkmkstart AAAAAAABRD}
{\bkmkend AAAAAAABRD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef s32_t {\b GNodeK}{\bkmkstart AAAAAAABRE}
{\bkmkend AAAAAAABRE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Edge kind. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedSet< EdgeType *, typename EdgeType::equalGEdge > {\b GEdgeSetTy}{\bkmkstart AAAAAAABRF}
{\bkmkend AAAAAAABRF}
\par
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \par
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef GEdgeSetTy::iterator {\b iterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef GEdgeSetTy::const_iterator {\b const_iterator}{\bkmkstart AAAAAAABRG}
{\bkmkend AAAAAAABRG}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b GenericNode} (NodeID i, {\b GNodeK} k){\bkmkstart AAAAAAABRH}
{\bkmkend AAAAAAABRH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~GenericNode} (){\bkmkstart AAAAAAABRI}
{\bkmkend AAAAAAABRI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getId} () const{\bkmkstart AAAAAAABRJ}
{\bkmkend AAAAAAABRJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get ID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b GNodeK} {\b getNodeKind} () const{\bkmkstart AAAAAAABRK}
{\bkmkend AAAAAAABRK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get node kind. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasIncomingEdge} () const{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has incoming/outgoing edge set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasOutgoingEdge} () const{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b iterator} {\b OutEdgeBegin} (){\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
iterators }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b iterator} {\b OutEdgeEnd} (){\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b iterator} {\b InEdgeBegin} (){\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b iterator} {\b InEdgeEnd} (){\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b OutEdgeBegin} () const{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b OutEdgeEnd} () const{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b InEdgeBegin} () const{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b InEdgeEnd} () const{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b iterator} {\b directOutEdgeBegin} (){\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterators used for SCC detection, overwrite it in child class if necessory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b iterator} {\b directOutEdgeEnd} (){\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b iterator} {\b directInEdgeBegin} (){\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b iterator} {\b directInEdgeEnd} (){\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const_iterator {\b directOutEdgeBegin} () const{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const_iterator {\b directOutEdgeEnd} () const{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const_iterator {\b directInEdgeBegin} () const{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const_iterator {\b directInEdgeEnd} () const{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b addIncomingEdge} (EdgeType *inEdge){\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add incoming and outgoing edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b addOutgoingEdge} (EdgeType *outEdge){\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

EdgeType * {\b hasIncomingEdge} (EdgeType *edge) const{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find incoming and outgoing edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

EdgeType * {\b hasOutgoingEdge} (EdgeType *edge) const{\bkmkstart AAAAAAABSG}
{\bkmkend AAAAAAABSG}
\par
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \par
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const GEdgeSetTy & {\b getOutEdges} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const GEdgeSetTy & {\b getInEdges} () const{\bkmkstart AAAAAAABSH}
{\bkmkend AAAAAAABSH}
\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \par
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Size_t {\b removeIncomingEdge} (EdgeType *edge)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b removeOutgoingEdge} (EdgeType *edge){\bkmkstart AAAAAAABSI}
{\bkmkend AAAAAAABSI}
\par
}
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class NodeTy, class EdgeTy>\par
class SVF::GenericNode< NodeTy, EdgeTy >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generic node on the graph as base class \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v iterator\:SVF::GenericNode< NodeTy, EdgeTy >}
{\xe \v SVF::GenericNode< NodeTy, EdgeTy >\:iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class NodeTy , class EdgeTy > typedef GEdgeSetTy::iterator {\b SVF::GenericNode}< NodeTy, EdgeTy >::{\b iterator}}}
\par
{\bkmkstart AAAAAAABSJ}
{\bkmkend AAAAAAABSJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Edge iterator \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getOutEdges\:SVF::GenericNode< NodeTy, EdgeTy >}
{\xe \v SVF::GenericNode< NodeTy, EdgeTy >\:getOutEdges}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class NodeTy , class EdgeTy > const GEdgeSetTy& {\b SVF::GenericNode}< NodeTy, EdgeTy >::getOutEdges () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSK}
{\bkmkend AAAAAAABSK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get incoming/outgoing edge set \par
}}
{\xe \v removeIncomingEdge\:SVF::GenericNode< NodeTy, EdgeTy >}
{\xe \v SVF::GenericNode< NodeTy, EdgeTy >\:removeIncomingEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class NodeTy , class EdgeTy > Size_t {\b SVF::GenericNode}< NodeTy, EdgeTy >::removeIncomingEdge (EdgeType *  {\i edge}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSL}
{\bkmkend AAAAAAABSL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove incoming and outgoing edges \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/GenericGraph.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::GepCGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::GepCGEdge}
{\xe \v SVF::GepCGEdge}
{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
\par
{
{\f2 #include <ConsGEdge.h>}}\par
Inheritance diagram for SVF::GepCGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_gep_c_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GepCGEdge} *){\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ConstraintEdge} *edge){\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericConsEdgeTy} *edge){\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b GepCGEdge} ({\b ConstraintNode} *s, {\b ConstraintNode} *d, {\b ConstraintEdgeK} k, EdgeID id){\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gep edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ConsGEdge.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::GepObjPN Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::GepObjPN}
{\xe \v SVF::GepObjPN}
{\bkmkstart AAAAAAACOC}
{\bkmkend AAAAAAACOC}
Inheritance diagram for SVF::GepObjPN:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_gep_obj_p_n.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b GepObjPN} (const {\b MemObj} *{\b mem}, NodeID i, const {\b LocationSet} &l, {\b PNODEK} ty=GepObjNode){\bkmkstart AAAAAAACOD}
{\bkmkend AAAAAAACOD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b LocationSet} & {\b getLocationSet} () const{\bkmkstart AAAAAAACOE}
{\bkmkend AAAAAAACOE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
offset of the mem object }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setBaseNode} (NodeID base){\bkmkstart AAAAAAACOF}
{\bkmkend AAAAAAACOF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the base object from which this GEP node came from. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getBaseNode} (void) const{\bkmkstart AAAAAAACOG}
{\bkmkend AAAAAAACOG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the base object from which this GEP node came from. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const llvm::Type * {\b getType} () const{\bkmkstart AAAAAAACOH}
{\bkmkend AAAAAAACOH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the type of this gep object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::string {\b getValueName} () const{\bkmkstart AAAAAAACOI}
{\bkmkend AAAAAAACOI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of a LLVM value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACOJ}
{\bkmkend AAAAAAACOJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GepObjPN} *){\bkmkstart AAAAAAACOK}
{\bkmkend AAAAAAACOK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ObjPN} *node){\bkmkstart AAAAAAACOL}
{\bkmkend AAAAAAACOL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGNode} *node){\bkmkstart AAAAAAACOM}
{\bkmkend AAAAAAACOM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGNodeTy} *node){\bkmkstart AAAAAAACON}
{\bkmkend AAAAAAACON}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::GepPE Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::GepPE}
{\xe \v SVF::GepPE}
{\bkmkstart AAAAAAACJX}
{\bkmkend AAAAAAACJX}
\par
{
{\f2 #include <PAGEdge.h>}}\par
Inheritance diagram for SVF::GepPE:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_gep_p_e.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GepPE} *){\bkmkstart AAAAAAACJY}
{\bkmkend AAAAAAACJY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGEdge} *edge){\bkmkstart AAAAAAACJZ}
{\bkmkend AAAAAAACJZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGEdgeTy} *edge){\bkmkstart AAAAAAACKA}
{\bkmkend AAAAAAACKA}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b GepPE} ({\b PAGNode} *s, {\b PAGNode} *d, {\b PEDGEK} k){\bkmkstart AAAAAAACKB}
{\bkmkend AAAAAAACKB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACKC}
{\bkmkend AAAAAAACKC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gep edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::GepValPN Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::GepValPN}
{\xe \v SVF::GepValPN}
{\bkmkstart AAAAAAACNR}
{\bkmkend AAAAAAACNR}
Inheritance diagram for SVF::GepValPN:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_gep_val_p_n.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b GepValPN} (const Value *val, NodeID i, const {\b LocationSet} &l, const Type *ty, u32_t idx){\bkmkstart AAAAAAACNS}
{\bkmkend AAAAAAACNS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getOffset} () const{\bkmkstart AAAAAAACNT}
{\bkmkend AAAAAAACNT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
offset of the base value node }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::string {\b getValueName} () const{\bkmkstart AAAAAAACNU}
{\bkmkend AAAAAAACNU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of a LLVM value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Type * {\b getType} () const{\bkmkstart AAAAAAACNV}
{\bkmkend AAAAAAACNV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return type of the value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getFieldIdx} () const{\bkmkstart AAAAAAACNW}
{\bkmkend AAAAAAACNW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACNX}
{\bkmkend AAAAAAACNX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GepValPN} *){\bkmkstart AAAAAAACNY}
{\bkmkend AAAAAAACNY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ValPN} *node){\bkmkstart AAAAAAACNZ}
{\bkmkend AAAAAAACNZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGNode} *node){\bkmkstart AAAAAAACOA}
{\bkmkend AAAAAAACOA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGNodeTy} *node){\bkmkstart AAAAAAACOB}
{\bkmkend AAAAAAACOB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::GepVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::GepVFGNode}
{\xe \v SVF::GepVFGNode}
{\bkmkstart AAAAAAADRJ}
{\bkmkend AAAAAAADRJ}
\par
{
{\f2 #include <VFGNode.h>}}\par
Inheritance diagram for SVF::GepVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_gep_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b GepVFGNode} (NodeID id, const {\b GepPE} *edge){\bkmkstart AAAAAAADRK}
{\bkmkend AAAAAAADRK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADRL}
{\bkmkend AAAAAAADRL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GepVFGNode} *){\bkmkstart AAAAAAADRM}
{\bkmkend AAAAAAADRM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b StmtVFGNode} *node){\bkmkstart AAAAAAADRN}
{\bkmkend AAAAAAADRN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADRO}
{\bkmkend AAAAAAADRO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADRP}
{\bkmkend AAAAAAADRP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b VFGNode} for Gep \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::GlobalBlockNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::GlobalBlockNode}
{\xe \v SVF::GlobalBlockNode}
{\bkmkstart AAAAAAABXB}
{\bkmkend AAAAAAABXB}
\par
{
{\f2 #include <ICFGNode.h>}}\par
Inheritance diagram for SVF::GlobalBlockNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_global_block_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b GlobalBlockNode} (NodeID id){\bkmkstart AAAAAAABXC}
{\bkmkend AAAAAAABXC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAABXD}
{\bkmkend AAAAAAABXD}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GlobalBlockNode} *){\bkmkstart AAAAAAABXE}
{\bkmkend AAAAAAABXE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ICFGNode} *node){\bkmkstart AAAAAAABXF}
{\bkmkend AAAAAAABXF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericICFGNodeTy} *node){\bkmkstart AAAAAAABXG}
{\bkmkend AAAAAAABXG}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unique {\b ICFG} node stands for all global initializations \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ICFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SCCDetection< GraphType >::GNodeSCCInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SCCDetection< GraphType >::GNodeSCCInfo}
{\xe \v SVF::SCCDetection< GraphType >::GNodeSCCInfo}
{\bkmkstart AAAAAAAHFY}
{\bkmkend AAAAAAAHFY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b visited} (void) const{\bkmkstart AAAAAAAHFZ}
{\bkmkend AAAAAAAHFZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visited} (bool v){\bkmkstart AAAAAAAHGA}
{\bkmkend AAAAAAAHGA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b inSCC} (void) const{\bkmkstart AAAAAAAHGB}
{\bkmkend AAAAAAAHGB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b inSCC} (bool v){\bkmkstart AAAAAAAHGC}
{\bkmkend AAAAAAAHGC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b rep} (void) const{\bkmkstart AAAAAAAHGD}
{\bkmkend AAAAAAAHGD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b rep} (NodeID n){\bkmkstart AAAAAAAHGE}
{\bkmkend AAAAAAAHGE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addSubNodes} (NodeID n){\bkmkstart AAAAAAAHGF}
{\bkmkend AAAAAAAHGF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeBS & {\b subNodes} (){\bkmkstart AAAAAAAHGG}
{\bkmkend AAAAAAAHGG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const NodeBS & {\b subNodes} () const{\bkmkstart AAAAAAAHGH}
{\bkmkend AAAAAAAHGH}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/SCC.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphPrinter Class Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphPrinter}
{\xe \v llvm::GraphPrinter}
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class GraphType > static void {\b WriteGraphToFile} (llvm::raw_ostream &O, const std::string &GraphName, const GraphType &GT, bool simple=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class GraphType > static void {\b PrintGraph} (llvm::raw_ostream &O, const std::string &GraphName, const GraphType &GT)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v PrintGraph\:llvm::GraphPrinter}
{\xe \v llvm::GraphPrinter\:PrintGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class GraphType > static void llvm::GraphPrinter::PrintGraph (llvm::raw_ostream &  {\i O}, const std::string &  {\i GraphName}, const GraphType &  {\i GT}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print the graph to command line \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define the GTraits and node iterator for printing\par
}}
{\xe \v WriteGraphToFile\:llvm::GraphPrinter}
{\xe \v llvm::GraphPrinter\:WriteGraphToFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class GraphType > static void llvm::GraphPrinter::WriteGraphToFile (llvm::raw_ostream &  {\i O}, const std::string &  {\i GraphName}, const GraphType &  {\i GT}, bool  {\i simple} = {\f2 false}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write the graph into dot file for debugging purpose \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/GraphPrinter.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< Inverse< SVF::CHNode * > > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< Inverse< SVF::CHNode * > >}
{\xe \v llvm::GraphTraits< Inverse< SVF::CHNode * > >}
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal. }}\par
{
{\f2 #include <CHG.h>}}\par
Inheritance diagram for llvm::GraphTraits< Inverse< SVF::CHNode * > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_inverse_3_01_s_v_f_1_1_c_h_node_01_5_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/CHG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< Inverse< SVF::ConstraintNode * > > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< Inverse< SVF::ConstraintNode * > >}
{\xe \v llvm::GraphTraits< Inverse< SVF::ConstraintNode * > >}
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for Value flow node, it is used for inverse traversal. }}\par
{
{\f2 #include <ConsG.h>}}\par
Inheritance diagram for llvm::GraphTraits< Inverse< SVF::ConstraintNode * > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_inverse_3_01_s_v_f_1_1_constraint_node_01_5_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for Value flow node, it is used for inverse traversal. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ConsG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< Inverse< SVF::DCHNode * > > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< Inverse< SVF::DCHNode * > >}
{\xe \v llvm::GraphTraits< Inverse< SVF::DCHNode * > >}
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal. }}\par
{
{\f2 #include <DCHG.h>}}\par
Inheritance diagram for llvm::GraphTraits< Inverse< SVF::DCHNode * > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_inverse_3_01_s_v_f_1_1_d_c_h_node_01_5_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/DCHG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< Inverse< SVF::GenericNode< NodeTy, EdgeTy > * > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< Inverse< SVF::GenericNode< NodeTy, EdgeTy > * > >}
{\xe \v llvm::GraphTraits< Inverse< SVF::GenericNode< NodeTy, EdgeTy > * > >}
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
\par
{
{\f2 #include <GenericGraph.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeTy {\b NodeType}{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef EdgeTy {\b EdgeType}{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::pointer_to_unary_function< EdgeType *, NodeType * > {\b DerefEdge}{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef mapped_iterator< typename {\b SVF::GenericNode}< NodeTy, EdgeTy >::iterator, DerefEdge > {\b ChildIteratorType}{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static NodeType * {\b getEntryNode} (Inverse< NodeType * > G){\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static ChildIteratorType {\b child_begin} (const NodeType *N){\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static ChildIteratorType {\b child_end} (const NodeType *N){\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static NodeType * {\b edgeDereference} (EdgeType *edge){\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static unsigned {\b getNodeID} (const NodeType *N){\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class NodeTy, class EdgeTy>\par
struct llvm::GraphTraits< Inverse< SVF::GenericNode< NodeTy, EdgeTy > * > >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits for node which is used for inverse traversal. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/GenericGraph.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< Inverse< SVF::ICFGNode * > > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< Inverse< SVF::ICFGNode * > >}
{\xe \v llvm::GraphTraits< Inverse< SVF::ICFGNode * > >}
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal. }}\par
{
{\f2 #include <ICFG.h>}}\par
Inheritance diagram for llvm::GraphTraits< Inverse< SVF::ICFGNode * > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_inverse_3_01_s_v_f_1_1_i_c_f_g_node_01_5_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< Inverse< SVF::PAGNode * > > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< Inverse< SVF::PAGNode * > >}
{\xe \v llvm::GraphTraits< Inverse< SVF::PAGNode * > >}
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for PAG node, it is used for inverse traversal. }}\par
{
{\f2 #include <PAG.h>}}\par
Inheritance diagram for llvm::GraphTraits< Inverse< SVF::PAGNode * > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_inverse_3_01_s_v_f_1_1_p_a_g_node_01_5_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for PAG node, it is used for inverse traversal. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< Inverse< SVF::PTACallGraphNode * > > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< Inverse< SVF::PTACallGraphNode * > >}
{\xe \v llvm::GraphTraits< Inverse< SVF::PTACallGraphNode * > >}
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal. }}\par
{
{\f2 #include <PTACallGraph.h>}}\par
Inheritance diagram for llvm::GraphTraits< Inverse< SVF::PTACallGraphNode * > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_inverse_3_01_s_v_f_1_1_p_t_a_call_graph_node_01_5_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PTACallGraph.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< Inverse< SVF::TCTNode * > > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< Inverse< SVF::TCTNode * > >}
{\xe \v llvm::GraphTraits< Inverse< SVF::TCTNode * > >}
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for Value flow node, it is used for inverse traversal. }}\par
{
{\f2 #include <TCT.h>}}\par
Inheritance diagram for llvm::GraphTraits< Inverse< SVF::TCTNode * > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_inverse_3_01_s_v_f_1_1_t_c_t_node_01_5_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for Value flow node, it is used for inverse traversal. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/TCT.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< Inverse< SVF::VFGNode * > > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< Inverse< SVF::VFGNode * > >}
{\xe \v llvm::GraphTraits< Inverse< SVF::VFGNode * > >}
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal. }}\par
{
{\f2 #include <VFG.h>}}\par
Inheritance diagram for llvm::GraphTraits< Inverse< SVF::VFGNode * > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_inverse_3_01_s_v_f_1_1_v_f_g_node_01_5_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inverse GraphTraits specializations for call graph node, it is used for inverse traversal. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::CHGraph * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::CHGraph * >}
{\xe \v llvm::GraphTraits< SVF::CHGraph * >}
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
Inheritance diagram for llvm::GraphTraits< SVF::CHGraph * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_c_h_graph_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SVF::CHNode} * {\b NodeRef}{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/CHG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::CHNode * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::CHNode * >}
{\xe \v llvm::GraphTraits< SVF::CHNode * >}
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
Inheritance diagram for llvm::GraphTraits< SVF::CHNode * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_c_h_node_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/CHG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::ConstraintGraph * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::ConstraintGraph * >}
{\xe \v llvm::GraphTraits< SVF::ConstraintGraph * >}
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
Inheritance diagram for llvm::GraphTraits< SVF::ConstraintGraph * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_constraint_graph_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SVF::ConstraintNode} * {\b NodeRef}{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ConsG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::ConstraintNode * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::ConstraintNode * >}
{\xe \v llvm::GraphTraits< SVF::ConstraintNode * >}
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
Inheritance diagram for llvm::GraphTraits< SVF::ConstraintNode * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_constraint_node_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ConsG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::DCHGraph * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::DCHGraph * >}
{\xe \v llvm::GraphTraits< SVF::DCHGraph * >}
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
Inheritance diagram for llvm::GraphTraits< SVF::DCHGraph * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_d_c_h_graph_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SVF::DCHNode} * {\b NodeRef}{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/DCHG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::DCHNode * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::DCHNode * >}
{\xe \v llvm::GraphTraits< SVF::DCHNode * >}
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
Inheritance diagram for llvm::GraphTraits< SVF::DCHNode * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_d_c_h_node_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/DCHG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::GenericGraph< NodeTy, EdgeTy > * > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::GenericGraph< NodeTy, EdgeTy > * >}
{\xe \v llvm::GraphTraits< SVF::GenericGraph< NodeTy, EdgeTy > * >}
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
\par
{
{\f2 #include <GenericGraph.h>}}\par
Inheritance diagram for llvm::GraphTraits< SVF::GenericGraph< NodeTy, EdgeTy > * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_generic_graph_3_01_node_ty_00_01_edge_ty_01_4_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SVF::GenericGraph}< NodeTy, EdgeTy > {\b GenericGraphTy}{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeTy {\b NodeType}{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef EdgeTy {\b EdgeType}{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::pair< SVF::NodeID, NodeType * > {\b PairTy}{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::pointer_to_unary_function< PairTy, NodeType * > {\b DerefVal}{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef mapped_iterator< typename {\b GenericGraphTy::iterator}, DerefVal > {\b nodes_iterator}{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static NodeType * {\b getEntryNode} ({\b GenericGraphTy} *pag){\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static nodes_iterator {\b nodes_begin} ({\b GenericGraphTy} *G){\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static nodes_iterator {\b nodes_end} ({\b GenericGraphTy} *G){\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static NodeType * {\b Valdereference} (PairTy P){\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static unsigned {\b graphSize} ({\b GenericGraphTy} *G){\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static unsigned {\b getNodeID} (NodeType *N){\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static NodeType * {\b getNode} ({\b GenericGraphTy} *G, SVF::NodeID id){\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class NodeTy, class EdgeTy>\par
struct llvm::GraphTraits< SVF::GenericGraph< NodeTy, EdgeTy > * >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
GraphTraints \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/GenericGraph.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::GenericNode< NodeTy, EdgeTy > * > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::GenericNode< NodeTy, EdgeTy > * >}
{\xe \v llvm::GraphTraits< SVF::GenericNode< NodeTy, EdgeTy > * >}
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
\par
{
{\f2 #include <GenericGraph.h>}}\par
Inheritance diagram for llvm::GraphTraits< SVF::GenericNode< NodeTy, EdgeTy > * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_generic_node_3_01_node_ty_00_01_edge_ty_01_4_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeTy {\b NodeType}{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef EdgeTy {\b EdgeType}{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::pointer_to_unary_function< EdgeType *, NodeType * > {\b DerefEdge}{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef mapped_iterator< typename {\b SVF::GenericNode}< NodeTy, EdgeTy >::iterator, DerefEdge > {\b ChildIteratorType}{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static NodeType * {\b getEntryNode} (NodeType *pagN){\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static ChildIteratorType {\b child_begin} (const NodeType *N){\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static ChildIteratorType {\b child_end} (const NodeType *N){\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static ChildIteratorType {\b direct_child_begin} (const NodeType *N){\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static ChildIteratorType {\b direct_child_end} (const NodeType *N){\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static NodeType * {\b edgeDereference} (EdgeType *edge){\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class NodeTy, class EdgeTy>\par
struct llvm::GraphTraits< SVF::GenericNode< NodeTy, EdgeTy > * >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
GraphTraits for nodes \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/GenericGraph.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::ICFG * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::ICFG * >}
{\xe \v llvm::GraphTraits< SVF::ICFG * >}
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
Inheritance diagram for llvm::GraphTraits< SVF::ICFG * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_i_c_f_g_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SVF::ICFGNode} * {\b NodeRef}{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::ICFGNode * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::ICFGNode * >}
{\xe \v llvm::GraphTraits< SVF::ICFGNode * >}
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
Inheritance diagram for llvm::GraphTraits< SVF::ICFGNode * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_i_c_f_g_node_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::OfflineConsG * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::OfflineConsG * >}
{\xe \v llvm::GraphTraits< SVF::OfflineConsG * >}
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
Inheritance diagram for llvm::GraphTraits< SVF::OfflineConsG * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_offline_cons_g_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SVF::ConstraintNode} * {\b NodeRef}{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/OfflineConsG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::PAG * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::PAG * >}
{\xe \v llvm::GraphTraits< SVF::PAG * >}
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
Inheritance diagram for llvm::GraphTraits< SVF::PAG * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_p_a_g_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SVF::PAGNode} * {\b NodeRef}{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::PAGNode * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::PAGNode * >}
{\xe \v llvm::GraphTraits< SVF::PAGNode * >}
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
Inheritance diagram for llvm::GraphTraits< SVF::PAGNode * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_p_a_g_node_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::PTACallGraph * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::PTACallGraph * >}
{\xe \v llvm::GraphTraits< SVF::PTACallGraph * >}
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
Inheritance diagram for llvm::GraphTraits< SVF::PTACallGraph * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_p_t_a_call_graph_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SVF::PTACallGraphNode} * {\b NodeRef}{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PTACallGraph.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::PTACallGraphNode * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::PTACallGraphNode * >}
{\xe \v llvm::GraphTraits< SVF::PTACallGraphNode * >}
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
Inheritance diagram for llvm::GraphTraits< SVF::PTACallGraphNode * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_p_t_a_call_graph_node_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PTACallGraph.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::SVFG * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::SVFG * >}
{\xe \v llvm::GraphTraits< SVF::SVFG * >}
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
Inheritance diagram for llvm::GraphTraits< SVF::SVFG * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_s_v_f_g_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SVF::SVFGNode} * {\b NodeRef}{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::TCT * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::TCT * >}
{\xe \v llvm::GraphTraits< SVF::TCT * >}
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
Inheritance diagram for llvm::GraphTraits< SVF::TCT * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_t_c_t_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SVF::TCTNode} * {\b NodeRef}{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/TCT.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::TCTNode * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::TCTNode * >}
{\xe \v llvm::GraphTraits< SVF::TCTNode * >}
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
Inheritance diagram for llvm::GraphTraits< SVF::TCTNode * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_t_c_t_node_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/TCT.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::VFG * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::VFG * >}
{\xe \v llvm::GraphTraits< SVF::VFG * >}
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
Inheritance diagram for llvm::GraphTraits< SVF::VFG * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_v_f_g_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SVF::VFGNode} * {\b NodeRef}{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
llvm::GraphTraits< SVF::VFGNode * > Struct Reference\par \pard\plain 
{\tc\tcl2 \v llvm::GraphTraits< SVF::VFGNode * >}
{\xe \v llvm::GraphTraits< SVF::VFGNode * >}
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
Inheritance diagram for llvm::GraphTraits< SVF::VFGNode * >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structllvm_1_1_graph_traits_3_01_s_v_f_1_1_v_f_g_node_01_5_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFG.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
hack Union Reference\par \pard\plain 
{\tc\tcl2 \v hack}
{\xe \v hack}
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CUDD_VALUE_TYPE {\b value}{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b bits} [2]{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CFile***********************************************************************\par
FileName [cuddTable.c]\par
PackageName [cudd]\par
Synopsis [Unique table management functions.]\par
Description [External procedures included in this module: {
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Cudd_Prime() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Cudd_Reserve() \par}
Internal procedures included in this module: {
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddAllocNode() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddInitTable() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddFreeTable() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddGarbageCollect() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddZddGetNode() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddZddGetNodeIVO() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddUniqueInter() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddUniqueInterIVO() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddUniqueInterZdd() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddUniqueConst() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddRehash() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddShrinkSubtable() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddInsertSubtables() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddDestroySubtables() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddResizeTableZdd() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddSlowTableGrowth() \par}
Static procedures included in this module: {
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ddRehashZdd() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ddResizeTable() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddFindParent() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddOrderedInsert() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddOrderedThread() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddRotateLeft() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddRotateRight() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddDoRebalance() \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cuddCheckCollisionOrdering() \par}
]\par
SeeAlso []\par
Author [Fabio Somenzi]\par
Copyright [Copyright (c) 1995-2012, Regents of the University of Colorado\par
All rights reserved.\par
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\par
Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\par
Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\par
Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\par
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.] \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this union was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/CUDD/cuddTable.c\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::HareParForEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::HareParForEdge}
{\xe \v SVF::HareParForEdge}
{\bkmkstart AAAAAAADFG}
{\bkmkend AAAAAAADFG}
\par
{
{\f2 #include <ThreadCallGraph.h>}}\par
Inheritance diagram for SVF::HareParForEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_hare_par_for_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericNode}< {\b PTACallGraphNode}, {\b HareParForEdge} >::GEdgeSetTy {\b ParForEdgeSet}{\bkmkstart AAAAAAADFH}
{\bkmkend AAAAAAADFH}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b HareParForEdge} ({\b PTACallGraphNode} *s, {\b PTACallGraphNode} *d, CallSiteID csId){\bkmkstart AAAAAAADFI}
{\bkmkend AAAAAAADFI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~HareParForEdge} (){\bkmkstart AAAAAAADFJ}
{\bkmkend AAAAAAADFJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b HareParForEdge} *){\bkmkstart AAAAAAADFK}
{\bkmkend AAAAAAADFK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ClassOf. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PTACallGraphEdge} *edge){\bkmkstart AAAAAAADFL}
{\bkmkend AAAAAAADFL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
hare_parallel_for edge from fork site to the entry of a start routine function \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ThreadCallGraph.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std::hash< const SVF::CondVar< Cond > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v std::hash< const SVF::CondVar< Cond > >}
{\xe \v std::hash< const SVF::CondVar< Cond > >}
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for CondVar. }}\par
{
{\f2 #include <ConditionalPT.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

size_t {\b operator()} (const {\b SVF::CondVar}< Cond > &cv) const{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Cond>\par
struct std::hash< const SVF::CondVar< Cond > >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for CondVar. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/ConditionalPT.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std::hash< const SVF::ContextCond > Struct Reference\par \pard\plain 
{\tc\tcl2 \v std::hash< const SVF::ContextCond >}
{\xe \v std::hash< const SVF::ContextCond >}
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for ContextCond. }}\par
{
{\f2 #include <DPItem.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

size_t {\b operator()} (const {\b SVF::ContextCond} &cc) const{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for ContextCond. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/DPItem.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std::hash< llvm::SparseBitVector<> > Struct Reference\par \pard\plain 
{\tc\tcl2 \v std::hash< llvm::SparseBitVector<> >}
{\xe \v std::hash< llvm::SparseBitVector<> >}
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for SparseBitVectors. }}\par
{
{\f2 #include <BasicTypes.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

size_t {\b operator()} (const llvm::SparseBitVector<> &sbv) const{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for SparseBitVectors. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/BasicTypes.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std::hash< std::pair< T, U > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v std::hash< std::pair< T, U > >}
{\xe \v std::hash< std::pair< T, U > >}
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for pairs. }}\par
{
{\f2 #include <SVFBasicTypes.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

size_t {\b operator()} (const std::pair< T, U > &p) const{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static size_t {\b szudzik} (size_t a, size_t b){\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, typename U>\par
struct std::hash< std::pair< T, U > >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for pairs. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/SVFBasicTypes.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std::hash< SVF::CallSite > Struct Reference\par \pard\plain 
{\tc\tcl2 \v std::hash< SVF::CallSite >}
{\xe \v std::hash< SVF::CallSite >}
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for CallSites. }}\par
{
{\f2 #include <BasicTypes.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

size_t {\b operator()} (const SVF::CallSite &cs) const{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for CallSites. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/BasicTypes.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std::hash< SVF::CondVar< Cond > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v std::hash< SVF::CondVar< Cond > >}
{\xe \v std::hash< SVF::CondVar< Cond > >}
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

size_t {\b operator()} (const {\b SVF::CondVar}< Cond > &cv) const{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/ConditionalPT.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std::hash< SVF::ContextCond > Struct Reference\par \pard\plain 
{\tc\tcl2 \v std::hash< SVF::ContextCond >}
{\xe \v std::hash< SVF::ContextCond >}
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

size_t {\b operator()} (const {\b SVF::ContextCond} &cc) const{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/DPItem.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std::hash< SVF::CxtDPItem > Struct Reference\par \pard\plain 
{\tc\tcl2 \v std::hash< SVF::CxtDPItem >}
{\xe \v std::hash< SVF::CxtDPItem >}
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for CxtDPItem. }}\par
{
{\f2 #include <DPItem.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

size_t {\b operator()} (const {\b SVF::CxtDPItem} &cdpi) const{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for CxtDPItem. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/DPItem.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std::hash< SVF::CxtStmtDPItem< LocCond > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v std::hash< SVF::CxtStmtDPItem< LocCond > >}
{\xe \v std::hash< SVF::CxtStmtDPItem< LocCond > >}
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for CxtStmtDPItem. }}\par
{
{\f2 #include <DPItem.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

size_t {\b operator()} (const {\b SVF::CxtStmtDPItem}< LocCond > &csdpi) const{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class LocCond>\par
struct std::hash< SVF::CxtStmtDPItem< LocCond > >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for CxtStmtDPItem. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/DPItem.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std::hash< SVF::LocationSet > Struct Reference\par \pard\plain 
{\tc\tcl2 \v std::hash< SVF::LocationSet >}
{\xe \v std::hash< SVF::LocationSet >}
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

size_t {\b operator()} (const {\b SVF::LocationSet} &ls) const{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/LocationSet.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std::hash< SVF::SmallVector< T, N > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v std::hash< SVF::SmallVector< T, N > >}
{\xe \v std::hash< SVF::SmallVector< T, N > >}
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for SmallVectors. }}\par
{
{\f2 #include <SVFBasicTypes.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

size_t {\b operator()} (const SVF::SmallVector< T, N > &sv) const{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, unsigned N>\par
struct std::hash< SVF::SmallVector< T, N > >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for SmallVectors. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/SVFBasicTypes.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std::hash< SVF::StmtDPItem< LocCond > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v std::hash< SVF::StmtDPItem< LocCond > >}
{\xe \v std::hash< SVF::StmtDPItem< LocCond > >}
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for StmtDPItem. }}\par
{
{\f2 #include <DPItem.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

size_t {\b operator()} (const {\b SVF::StmtDPItem}< LocCond > &sdpi) const{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename LocCond>\par
struct std::hash< SVF::StmtDPItem< LocCond > >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Specialise hash for StmtDPItem. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/DPItem.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ICFG Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ICFG}
{\xe \v SVF::ICFG}
{\bkmkstart AAAAAAABTK}
{\bkmkend AAAAAAABTK}
Inheritance diagram for SVF::ICFG:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_i_c_f_g.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, {\b ICFGNode} * > {\b ICFGNodeIDToNodeMapTy}{\bkmkstart AAAAAAABTL}
{\bkmkend AAAAAAABTL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef ICFGEdge::ICFGEdgeSetTy {\b ICFGEdgeSetTy}{\bkmkstart AAAAAAABTM}
{\bkmkend AAAAAAABTM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef ICFGNodeIDToNodeMapTy::iterator {\b iterator}{\bkmkstart AAAAAAABTN}
{\bkmkend AAAAAAABTN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef ICFGNodeIDToNodeMapTy::const_iterator {\b const_iterator}{\bkmkstart AAAAAAABTO}
{\bkmkend AAAAAAABTO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, {\b FunEntryBlockNode} * > {\b FunToFunEntryNodeMapTy}{\bkmkstart AAAAAAABTP}
{\bkmkend AAAAAAABTP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, {\b FunExitBlockNode} * > {\b FunToFunExitNodeMapTy}{\bkmkstart AAAAAAABTQ}
{\bkmkend AAAAAAABTQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Instruction *, {\b CallBlockNode} * > {\b CSToCallNodeMapTy}{\bkmkstart AAAAAAABTR}
{\bkmkend AAAAAAABTR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Instruction *, {\b RetBlockNode} * > {\b CSToRetNodeMapTy}{\bkmkstart AAAAAAABTS}
{\bkmkend AAAAAAABTS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Instruction *, {\b IntraBlockNode} * > {\b InstToBlockNodeMapTy}{\bkmkstart AAAAAAABTT}
{\bkmkend AAAAAAABTT}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ICFG} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~ICFG} (){\bkmkstart AAAAAAABTU}
{\bkmkend AAAAAAABTU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ICFGNode} * {\b getICFGNode} (NodeID id) const{\bkmkstart AAAAAAABTV}
{\bkmkend AAAAAAABTV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a {\b ICFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasICFGNode} (NodeID id) const{\bkmkstart AAAAAAABTW}
{\bkmkend AAAAAAABTW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether has the {\b ICFGNode}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ICFGEdge} * {\b hasIntraICFGEdge} ({\b ICFGNode} *src, {\b ICFGNode} *dst, {\b ICFGEdge::ICFGEdgeK} kind)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we has a {\b SVFG} edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ICFGEdge} * {\b hasInterICFGEdge} ({\b ICFGNode} *src, {\b ICFGNode} *dst, {\b ICFGEdge::ICFGEdgeK} kind)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ICFGEdge} * {\b hasThreadICFGEdge} ({\b ICFGNode} *src, {\b ICFGNode} *dst, {\b ICFGEdge::ICFGEdgeK} kind)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ICFGEdge} * {\b getICFGEdge} (const {\b ICFGNode} *src, const {\b ICFGNode} *dst, {\b ICFGEdge::ICFGEdgeK} kind)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a {\b SVFG} edge according to src and dst. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump} (const std::string &file, bool simple=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump graph into dot file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateCallGraph} ({\b PTACallGraph} *callgraph)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
update {\b ICFG} for indirect calls }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeICFGEdge} ({\b ICFGEdge} *edge){\bkmkstart AAAAAAABTX}
{\bkmkend AAAAAAABTX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove a {\b SVFG} edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeICFGNode} ({\b ICFGNode} *node){\bkmkstart AAAAAAABTY}
{\bkmkend AAAAAAABTY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove a {\b ICFGNode}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ICFGEdge} * {\b addIntraEdge} ({\b ICFGNode} *srcNode, {\b ICFGNode} *dstNode)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add control-flow edges for top level pointers. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ICFGEdge} * {\b addConditionalIntraEdge} ({\b ICFGNode} *srcNode, {\b ICFGNode} *dstNode, const Value *condition, NodeID branchID)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ICFGEdge} * {\b addCallEdge} ({\b ICFGNode} *srcNode, {\b ICFGNode} *dstNode, const Instruction *cs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ICFGEdge} * {\b addRetEdge} ({\b ICFGNode} *srcNode, {\b ICFGNode} *dstNode, const Instruction *cs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b checkIntraEdgeParents} (const {\b ICFGNode} *srcNode, const {\b ICFGNode} *dstNode){\bkmkstart AAAAAAABTZ}
{\bkmkend AAAAAAABTZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sanitize Intra edges, verify that both nodes belong to the same function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b addICFGEdge} ({\b ICFGEdge} *edge){\bkmkstart AAAAAAABUA}
{\bkmkend AAAAAAABUA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add {\b ICFG} edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b addICFGNode} ({\b ICFGNode} *node){\bkmkstart AAAAAAABUB}
{\bkmkend AAAAAAABUB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a {\b ICFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ICFGNode} * {\b getBlockICFGNode} (const Instruction *inst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a basic block {\b ICFGNode}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CallBlockNode} * {\b getCallBlockNode} (const Instruction *inst){\bkmkstart AAAAAAABUC}
{\bkmkend AAAAAAABUC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b RetBlockNode} * {\b getRetBlockNode} (const Instruction *inst){\bkmkstart AAAAAAABUD}
{\bkmkend AAAAAAABUD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b IntraBlockNode} * {\b getIntraBlockNode} (const Instruction *inst){\bkmkstart AAAAAAABUE}
{\bkmkend AAAAAAABUE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FunEntryBlockNode} * {\b getFunEntryBlockNode} (const {\b SVFFunction} *fun){\bkmkstart AAAAAAABUF}
{\bkmkend AAAAAAABUF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a function entry node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FunExitBlockNode} * {\b getFunExitBlockNode} (const {\b SVFFunction} *fun){\bkmkstart AAAAAAABUG}
{\bkmkend AAAAAAABUG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a function exit node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b GlobalBlockNode} * {\b getGlobalBlockNode} () const{\bkmkstart AAAAAAABUH}
{\bkmkend AAAAAAABUH}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b totalICFGNode}{\bkmkstart AAAAAAABUI}
{\bkmkend AAAAAAABUI}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ICFG\:SVF::ICFG}
{\xe \v SVF::ICFG\:ICFG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ICFG::ICFG ()}}
\par
{\bkmkstart AAAAAAABUJ}
{\bkmkend AAAAAAABUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Build {\b ICFG} 1) build {\b ICFG} nodes statements for top level pointers (PAGEdges) 2) connect {\b ICFG} edges between two statements (PAGEdges) \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addCallEdge\:SVF::ICFG}
{\xe \v SVF::ICFG\:addCallEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ICFGEdge} * ICFG::addCallEdge ({\b ICFGNode} *  {\i srcNode}, {\b ICFGNode} *  {\i dstNode}, const Instruction *  {\i cs})}}
\par
{\bkmkstart AAAAAAABUK}
{\bkmkend AAAAAAABUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add interprocedural call edges between two nodes \par
}}
{\xe \v addConditionalIntraEdge\:SVF::ICFG}
{\xe \v SVF::ICFG\:addConditionalIntraEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ICFGEdge} * ICFG::addConditionalIntraEdge ({\b ICFGNode} *  {\i srcNode}, {\b ICFGNode} *  {\i dstNode}, const Value *  {\i condition}, NodeID  {\i branchID})}}
\par
{\bkmkstart AAAAAAABUL}
{\bkmkend AAAAAAABUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add conditional intraprocedural edges between two nodes \par
}}
{\xe \v addIntraEdge\:SVF::ICFG}
{\xe \v SVF::ICFG\:addIntraEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ICFGEdge} * ICFG::addIntraEdge ({\b ICFGNode} *  {\i srcNode}, {\b ICFGNode} *  {\i dstNode})}}
\par
{\bkmkstart AAAAAAABUM}
{\bkmkend AAAAAAABUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add control-flow edges for top level pointers. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add intraprocedural edges between two nodes \par
}}
{\xe \v addRetEdge\:SVF::ICFG}
{\xe \v SVF::ICFG\:addRetEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ICFGEdge} * ICFG::addRetEdge ({\b ICFGNode} *  {\i srcNode}, {\b ICFGNode} *  {\i dstNode}, const Instruction *  {\i cs})}}
\par
{\bkmkstart AAAAAAABUN}
{\bkmkend AAAAAAABUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add interprocedural return edges between two nodes \par
}}
{\xe \v dump\:SVF::ICFG}
{\xe \v SVF::ICFG\:dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ICFG::dump (const std::string &  {\i file}, bool  {\i simple} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABUO}
{\bkmkend AAAAAAABUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump graph into dot file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump {\b ICFG} \par
}}
{\xe \v getBlockICFGNode\:SVF::ICFG}
{\xe \v SVF::ICFG\:getBlockICFGNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ICFGNode} * ICFG::getBlockICFGNode (const Instruction *  {\i inst})}}
\par
{\bkmkstart AAAAAAABUP}
{\bkmkend AAAAAAABUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a basic block {\b ICFGNode}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a basic block {\b ICFGNode} TODO:: need to fix the assertions \par
}}
{\xe \v getICFGEdge\:SVF::ICFG}
{\xe \v SVF::ICFG\:getICFGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ICFGEdge} * ICFG::getICFGEdge (const {\b ICFGNode} *  {\i src}, const {\b ICFGNode} *  {\i dst}, {\b ICFGEdge::ICFGEdgeK}  {\i kind})}}
\par
{\bkmkstart AAAAAAABUQ}
{\bkmkend AAAAAAABUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a {\b SVFG} edge according to src and dst. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the corresponding {\b ICFGEdge} \par
}}
{\xe \v hasInterICFGEdge\:SVF::ICFG}
{\xe \v SVF::ICFG\:hasInterICFGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ICFGEdge} * ICFG::hasInterICFGEdge ({\b ICFGNode} *  {\i src}, {\b ICFGNode} *  {\i dst}, {\b ICFGEdge::ICFGEdgeK}  {\i kind})}}
\par
{\bkmkstart AAAAAAABUR}
{\bkmkend AAAAAAABUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we has an inter {\b ICFG} edge \par
}}
{\xe \v hasIntraICFGEdge\:SVF::ICFG}
{\xe \v SVF::ICFG\:hasIntraICFGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ICFGEdge} * ICFG::hasIntraICFGEdge ({\b ICFGNode} *  {\i src}, {\b ICFGNode} *  {\i dst}, {\b ICFGEdge::ICFGEdgeK}  {\i kind})}}
\par
{\bkmkstart AAAAAAABUS}
{\bkmkend AAAAAAABUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we has a {\b SVFG} edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we has an intra {\b ICFG} edge \par
}}
{\xe \v hasThreadICFGEdge\:SVF::ICFG}
{\xe \v SVF::ICFG\:hasThreadICFGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ICFGEdge} * ICFG::hasThreadICFGEdge ({\b ICFGNode} *  {\i src}, {\b ICFGNode} *  {\i dst}, {\b ICFGEdge::ICFGEdgeK}  {\i kind})}}
\par
{\bkmkstart AAAAAAABUT}
{\bkmkend AAAAAAABUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we has an thread {\b ICFG} edge \par
}}
{\xe \v updateCallGraph\:SVF::ICFG}
{\xe \v SVF::ICFG\:updateCallGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ICFG::updateCallGraph ({\b PTACallGraph} *  {\i callgraph})}}
\par
{\bkmkstart AAAAAAABUU}
{\bkmkend AAAAAAABUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
update {\b ICFG} for indirect calls }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update {\b ICFG} for indirect calls \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFG.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ICFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ICFGBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ICFGBuilder}
{\xe \v SVF::ICFGBuilder}
{\bkmkstart AAAAAAAGKQ}
{\bkmkend AAAAAAAGKQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const Instruction * > {\b InstVec}{\bkmkstart AAAAAAAGKR}
{\bkmkend AAAAAAAGKR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const Instruction * > {\b BBSet}{\bkmkstart AAAAAAAGKS}
{\bkmkend AAAAAAAGKS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< const Instruction * > {\b WorkList}{\bkmkstart AAAAAAAGKT}
{\bkmkend AAAAAAAGKT}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ICFGBuilder} ({\b ICFG} *i){\bkmkstart AAAAAAAGKU}
{\bkmkend AAAAAAAGKU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b build} ({\b SVFModule} *svfModule)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v build\:SVF::ICFGBuilder}
{\xe \v SVF::ICFGBuilder\:build}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ICFGBuilder::build ({\b SVFModule} *  {\i svfModule})}}
\par
{\bkmkstart AAAAAAAGKV}
{\bkmkend AAAAAAAGKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create {\b ICFG} nodes and edges \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/ICFGBuilder.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/ICFGBuilder.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ICFGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ICFGEdge}
{\xe \v SVF::ICFGEdge}
{\bkmkstart AAAAAAABUV}
{\bkmkend AAAAAAABUV}
Inheritance diagram for SVF::ICFGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_i_c_f_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ICFGEdgeK} \{ {\b IntraCF}
, {\b CallCF}
, {\b RetCF}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b ICFGEdgeK} {\b SVFGEdgeK}{\bkmkstart AAAAAAABUW}
{\bkmkend AAAAAAABUW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericNode}< {\b ICFGNode}, {\b ICFGEdge} >::GEdgeSetTy {\b ICFGEdgeSetTy}{\bkmkstart AAAAAAABUX}
{\bkmkend AAAAAAABUX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef ICFGEdgeSetTy {\b SVFGEdgeSetTy}{\bkmkstart AAAAAAABUY}
{\bkmkend AAAAAAABUY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ICFGEdge} ({\b ICFGNode} *s, {\b ICFGNode} *d, {\b GEdgeFlag} k){\bkmkstart AAAAAAABUZ}
{\bkmkend AAAAAAABUZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ~ICFGEdge} (){\bkmkstart AAAAAAABVA}
{\bkmkend AAAAAAABVA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isCFGEdge} () const{\bkmkstart AAAAAAABVB}
{\bkmkend AAAAAAABVB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get methods of the components. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isCallCFGEdge} () const{\bkmkstart AAAAAAABVC}
{\bkmkend AAAAAAABVC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isRetCFGEdge} () const{\bkmkstart AAAAAAABVD}
{\bkmkend AAAAAAABVD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isIntraCFGEdge} () const{\bkmkstart AAAAAAABVE}
{\bkmkend AAAAAAABVE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAABVF}
{\bkmkend AAAAAAABVF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b GEdgeFlag} {\b makeEdgeFlagWithInvokeID} (GEdgeKind k, CallSiteID cs){\bkmkstart AAAAAAABVG}
{\bkmkend AAAAAAABVG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute the unique edgeFlag value from edge kind and CallSiteID. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b raw_ostream} & {\b operator<<} ({\b raw_ostream} &o, const {\b ICFGEdge} &edge){\bkmkstart AAAAAAABVH}
{\bkmkend AAAAAAABVH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator << for dumping {\b ICFG} node ID. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v ICFGEdgeK\:SVF::ICFGEdge}
{\xe \v SVF::ICFGEdge\:ICFGEdgeK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SVF::ICFGEdge::ICFGEdgeK}}}
\par
{\bkmkstart AAAAAAABVI}
{\bkmkend AAAAAAABVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ten types of {\b ICFG} edge three types of control-flow edges seven types of value-flow edges \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ICFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ICFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ICFGNode}
{\xe \v SVF::ICFGNode}
{\bkmkstart AAAAAAABWG}
{\bkmkend AAAAAAABWG}
Inheritance diagram for SVF::ICFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_i_c_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ICFGNodeK} \{ {\b IntraBlock}
, {\b FunEntryBlock}
, {\b FunExitBlock}
, {\b FunCallBlock}
, {\b FunRetBlock}
, {\b GlobalBlock}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef ICFGEdge::ICFGEdgeSetTy::iterator {\b iterator}{\bkmkstart AAAAAAABWH}
{\bkmkend AAAAAAABWH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef ICFGEdge::ICFGEdgeSetTy::const_iterator {\b const_iterator}{\bkmkstart AAAAAAABWI}
{\bkmkend AAAAAAABWI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b CallPE} * > {\b CallPESet}{\bkmkstart AAAAAAABWJ}
{\bkmkend AAAAAAABWJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b RetPE} * > {\b RetPESet}{\bkmkstart AAAAAAABWK}
{\bkmkend AAAAAAABWK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::list< const {\b VFGNode} * > {\b VFGNodeList}{\bkmkstart AAAAAAABWL}
{\bkmkend AAAAAAABWL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::list< const {\b PAGEdge} * > {\b PAGEdgeList}{\bkmkstart AAAAAAABWM}
{\bkmkend AAAAAAABWM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ICFGNode} (NodeID i, {\b ICFGNodeK} k){\bkmkstart AAAAAAABWN}
{\bkmkend AAAAAAABWN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const {\b SVFFunction} * {\b getFun} () const{\bkmkstart AAAAAAABWO}
{\bkmkend AAAAAAABWO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the function of this {\b ICFGNode}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const BasicBlock * {\b getBB} () const{\bkmkstart AAAAAAABWP}
{\bkmkend AAAAAAABWP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the function of this {\b ICFGNode}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAABWQ}
{\bkmkend AAAAAAABWQ}
\par
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \par
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addVFGNode} (const {\b VFGNode} *vfgNode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const VFGNodeList & {\b getVFGNodes} () const{\bkmkstart AAAAAAABWR}
{\bkmkend AAAAAAABWR}
\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \par
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addPAGEdge} (const {\b PAGEdge} *edge)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const PAGEdgeList & {\b getPAGEdges} () const{\bkmkstart AAAAAAABWS}
{\bkmkend AAAAAAABWS}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b fun}{\bkmkstart AAAAAAABWT}
{\bkmkend AAAAAAABWT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const BasicBlock * {\b bb}{\bkmkstart AAAAAAABWU}
{\bkmkend AAAAAAABWU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

VFGNodeList {\b VFGNodes}{\bkmkstart AAAAAAABWV}
{\bkmkend AAAAAAABWV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGEdgeList {\b pagEdges}{\bkmkstart AAAAAAABWW}
{\bkmkend AAAAAAABWW}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b raw_ostream} & {\b operator<<} ({\b raw_ostream} &o, const {\b ICFGNode} &node){\bkmkstart AAAAAAABWX}
{\bkmkend AAAAAAABWX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator << for dumping {\b ICFG} node ID. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v ICFGNodeK\:SVF::ICFGNode}
{\xe \v SVF::ICFGNode\:ICFGNodeK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SVF::ICFGNode::ICFGNodeK}}}
\par
{\bkmkstart AAAAAAABWY}
{\bkmkend AAAAAAABWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
22 kinds of {\b ICFG} node Gep represents offset edge for field sensitivity \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addPAGEdge\:SVF::ICFGNode}
{\xe \v SVF::ICFGNode\:addPAGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVF::ICFGNode::addPAGEdge (const {\b PAGEdge} *  {\i edge}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWZ}
{\bkmkend AAAAAAABWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set/Get methods of VFGNodes \par
}}
{\xe \v addVFGNode\:SVF::ICFGNode}
{\xe \v SVF::ICFGNode\:addVFGNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVF::ICFGNode::addVFGNode (const {\b VFGNode} *  {\i vfgNode}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXA}
{\bkmkend AAAAAAABXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set/Get methods of VFGNodes \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ICFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ICFGPrinter Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ICFGPrinter}
{\xe \v SVF::ICFGPrinter}
{\bkmkstart AAAAAAAGKL}
{\bkmkend AAAAAAAGKL}
Inheritance diagram for SVF::ICFGPrinter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_i_c_f_g_printer.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b printICFGToJson} (const std::string &filename){\bkmkstart AAAAAAAGKM}
{\bkmkend AAAAAAAGKM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b getPAGNodeKindValue} (int kind){\bkmkstart AAAAAAAGKN}
{\bkmkend AAAAAAAGKN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b getPAGEdgeKindValue} (int kind){\bkmkstart AAAAAAAGKO}
{\bkmkend AAAAAAAGKO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b getICFGKind} (const int kind){\bkmkstart AAAAAAAGKP}
{\bkmkend AAAAAAAGKP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/Graph2Json.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/Graph2Json.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ICFGStat Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ICFGStat}
{\xe \v SVF::ICFGStat}
{\bkmkstart AAAAAAABZP}
{\bkmkend AAAAAAABZP}
Inheritance diagram for SVF::ICFGStat:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_i_c_f_g_stat.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b ICFGNode} * > {\b ICFGNodeSet}{\bkmkstart AAAAAAABZQ}
{\bkmkend AAAAAAABZQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ICFGStat} ({\b ICFG} *cfg){\bkmkstart AAAAAAABZR}
{\bkmkend AAAAAAABZR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b performStat} (){\bkmkstart AAAAAAABZS}
{\bkmkend AAAAAAABZS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b performStatforIFDS} (){\bkmkstart AAAAAAABZT}
{\bkmkend AAAAAAABZT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b countStat} (){\bkmkstart AAAAAAABZU}
{\bkmkend AAAAAAABZU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b printStat} (string statname){\bkmkstart AAAAAAABZV}
{\bkmkend AAAAAAABZV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFGStat.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IeeeDoubleStruct Struct Reference\par \pard\plain 
{\tc\tcl2 \v IeeeDoubleStruct}
{\xe \v IeeeDoubleStruct}
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
\par
{
{\f2 #include <epd.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b mantissa1}: 32{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b mantissa0}: 20{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b exponent}: 11{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b sign}: 1{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct**********************************************************************\par
Synopsis [IEEE double struct.]\par
Description [IEEE double struct.]\par
SeeAlso [] \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/epd.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IeeeNanStruct Struct Reference\par \pard\plain 
{\tc\tcl2 \v IeeeNanStruct}
{\xe \v IeeeNanStruct}
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
\par
{
{\f2 #include <epd.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b mantissa1}: 32{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b mantissa0}: 19{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b quiet_bit}: 1{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b exponent}: 11{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b sign}: 1{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct**********************************************************************\par
Synopsis [IEEE double NaN struct.]\par
Description [IEEE double NaN struct.]\par
SeeAlso [] \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/epd.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::IncMutableDFPTData< Key, Datum, Data > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::IncMutableDFPTData< Key, Datum, Data >}
{\xe \v SVF::IncMutableDFPTData< Key, Datum, Data >}
{\bkmkstart AAAAAAAEJA}
{\bkmkend AAAAAAAEJA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Incremental version of the mutable data-flow points-to data structure. }}\par
{
{\f2 #include <MutablePointsToDS.h>}}\par
Inheritance diagram for SVF::IncMutableDFPTData< Key, Datum, Data >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_inc_mutable_d_f_p_t_data.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b PTData}< Key, Datum, Data > {\b BasePTData}{\bkmkstart AAAAAAAEJB}
{\bkmkend AAAAAAAEJB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MutablePTData}< Key, Datum, Data > {\b BaseMutPTData}{\bkmkstart AAAAAAAEJC}
{\bkmkend AAAAAAAEJC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b DFPTData}< Key, Datum, Data > {\b BaseDFPTData}{\bkmkstart AAAAAAAEJD}
{\bkmkend AAAAAAAEJD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MutableDFPTData}< Key, Datum, Data > {\b BaseMutDFPTData}{\bkmkstart AAAAAAAEJE}
{\bkmkend AAAAAAAEJE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b BasePTData::PTDataTy} {\b PTDataTy}{\bkmkstart AAAAAAAEJF}
{\bkmkend AAAAAAAEJF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef BaseDFPTData::LocID {\b LocID}{\bkmkstart AAAAAAAEJG}
{\bkmkend AAAAAAAEJG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< LocID, Data > {\b UpdatedVarMap}{\bkmkstart AAAAAAAEJH}
{\bkmkend AAAAAAAEJH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
for propagating only newly added variable in IN/OUT set }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef UpdatedVarMap::iterator {\b UpdatedVarMapIter}{\bkmkstart AAAAAAAEJI}
{\bkmkend AAAAAAAEJI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef UpdatedVarMap::const_iterator {\b UpdatedVarconstIter}{\bkmkstart AAAAAAAEJJ}
{\bkmkend AAAAAAAEJJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Data::iterator {\b DataIter}{\bkmkstart AAAAAAAEJK}
{\bkmkend AAAAAAAEJK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b IncMutableDFPTData} (bool reversePT=true, {\b PTDataTy} ty=BasePTData::IncMutDataFlow){\bkmkstart AAAAAAAEJL}
{\bkmkend AAAAAAAEJL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b updateDFInFromIn} (LocID srcLoc, const Key &srcVar, LocID dstLoc, const Key &dstVar) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateDFInFromOut} (LocID srcLoc, const Key &srcVar, LocID dstLoc, const Key &dstVar) override{\bkmkstart AAAAAAAEJM}
{\bkmkend AAAAAAAEJM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union (IN[dstLoc:dstVar], OUT[srcLoc:srcVar]). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateDFOutFromIn} (LocID srcLoc, const Key &srcVar, LocID dstLoc, const Key &dstVar) override{\bkmkstart AAAAAAAEJN}
{\bkmkend AAAAAAAEJN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union (OUT[dstLoc:dstVar], IN[srcLoc:srcVar]). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateAllDFInFromOut} (LocID srcLoc, const Key &srcVar, LocID dstLoc, const Key &dstVar) override{\bkmkstart AAAAAAAEJO}
{\bkmkend AAAAAAAEJO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union (IN[dstLoc::dstVar], OUT[srcLoc:srcVar]. There is no flag check, unlike the above. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateAllDFInFromIn} (LocID srcLoc, const Key &srcVar, LocID dstLoc, const Key &dstVar) override{\bkmkstart AAAAAAAEJP}
{\bkmkend AAAAAAAEJP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union (IN[dstLoc::dstVar], IN[srcLoc:srcVar]. There is no flag check, unlike the above. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b updateAllDFOutFromIn} (LocID loc, const Key &singleton, bool strongUpdates) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For each variable var in IN at loc, do updateDFOutFromIn(loc, var, loc, var). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateTLVPts} (LocID srcLoc, const Key &srcVar, const Key &dstVar) override{\bkmkstart AAAAAAAEJQ}
{\bkmkend AAAAAAAEJQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update points-to set of top-level pointers with IN[srcLoc:srcVar]. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateATVPts} (const Key &srcVar, LocID dstLoc, const Key &dstVar) override{\bkmkstart AAAAAAAEJR}
{\bkmkend AAAAAAAEJR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update address-taken variables OUT[dstLoc:dstVar] with points-to of top-level pointers. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearAllDFOutUpdatedVar} (LocID loc) override{\bkmkstart AAAAAAAEJS}
{\bkmkend AAAAAAAEJS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b classof} (const {\b IncMutableDFPTData}< Key, Datum, Data > *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PTData}< Key, Datum, Data > *ptd){\bkmkstart AAAAAAAEJT}
{\bkmkend AAAAAAAEJT}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Key, typename Datum, typename Data>\par
class SVF::IncMutableDFPTData< Key, Datum, Data >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Incremental version of the mutable data-flow points-to data structure. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v classof\:SVF::IncMutableDFPTData< Key, Datum, Data >}
{\xe \v SVF::IncMutableDFPTData< Key, Datum, Data >\:classof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > static bool {\b SVF::IncMutableDFPTData}< Key, Datum, Data >::classof (const {\b IncMutableDFPTData}< Key, Datum, Data > * ){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEJU}
{\bkmkend AAAAAAAEJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods to support type inquiry through isa, cast, and dyn_cast: \par
}}
{\xe \v updateAllDFOutFromIn\:SVF::IncMutableDFPTData< Key, Datum, Data >}
{\xe \v SVF::IncMutableDFPTData< Key, Datum, Data >\:updateAllDFOutFromIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > virtual bool {\b SVF::IncMutableDFPTData}< Key, Datum, Data >::updateAllDFOutFromIn (LocID  {\i loc}, const Key &  {\i singleton}, bool  {\i strongUpdates}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEHB}
{\bkmkend AAAAAAAEHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For each variable var in IN at loc, do updateDFOutFromIn(loc, var, loc, var). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only variables has new pts from IN set need to be updated.\par
Enable strong updates if it is required to do so\par
Only variables has new pts from IN set need to be updated.\par
Enable strong updates if it is required to do so\par
}{
Reimplemented from {\b SVF::MutableDFPTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEHA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updateDFInFromIn\:SVF::IncMutableDFPTData< Key, Datum, Data >}
{\xe \v SVF::IncMutableDFPTData< Key, Datum, Data >\:updateDFInFromIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > virtual bool {\b SVF::IncMutableDFPTData}< Key, Datum, Data >::updateDFInFromIn (LocID  {\i srcLoc}, const Key &  {\i srcVar}, LocID  {\i dstLoc}, const Key &  {\i dstVar}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADXQ}
{\bkmkend AAAAAAADXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update points-to for IN/OUT set IN[loc:var] represents the points-to of variable var in the IN set of location loc. union(ptsDst, ptsSrc) represents ptsDst = ptsDst U ptsSrc.\par
Union (IN[dstLoc:dstVar], IN[srcLoc:srcVar]). \par
}{
Reimplemented from {\b SVF::MutableDFPTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADXR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/MutablePointsToDS.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::IndirectSVFGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::IndirectSVFGEdge}
{\xe \v SVF::IndirectSVFGEdge}
{\bkmkstart AAAAAAACXV}
{\bkmkend AAAAAAACXV}
\par
{
{\f2 #include <SVFGEdge.h>}}\par
Inheritance diagram for SVF::IndirectSVFGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_indirect_s_v_f_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b MRVer} * > {\b MRVerSet}{\bkmkstart AAAAAAACXW}
{\bkmkend AAAAAAACXW}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b IndirectSVFGEdge} ({\b VFGNode} *s, {\b VFGNode} *d, {\b GEdgeFlag} k){\bkmkstart AAAAAAACXX}
{\bkmkend AAAAAAACXX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b addPointsTo} (const PointsTo &c){\bkmkstart AAAAAAACXY}
{\bkmkend AAAAAAACXY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle memory region. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const PointsTo & {\b getPointsTo} () const{\bkmkstart AAAAAAACXZ}
{\bkmkend AAAAAAACXZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

MRVerSet & {\b getMRVer} (){\bkmkstart AAAAAAACYA}
{\bkmkend AAAAAAACYA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b addMrVer} (const {\b MRVer} *mr){\bkmkstart AAAAAAACYB}
{\bkmkend AAAAAAACYB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACYC}
{\bkmkend AAAAAAACYC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b IndirectSVFGEdge} *){\bkmkstart AAAAAAACYD}
{\bkmkend AAAAAAACYD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGEdge} *edge){\bkmkstart AAAAAAACYE}
{\bkmkend AAAAAAACYE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGEdgeTy} *edge){\bkmkstart AAAAAAACYF}
{\bkmkend AAAAAAACYF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SVFG} edge representing indirect value-flows from a caller to its callee at a callsite \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::InterBlockNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::InterBlockNode}
{\xe \v SVF::InterBlockNode}
{\bkmkstart AAAAAAABXO}
{\bkmkend AAAAAAABXO}
Inheritance diagram for SVF::InterBlockNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_inter_block_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b InterBlockNode} (NodeID id, {\b ICFGNodeK} k){\bkmkstart AAAAAAABXP}
{\bkmkend AAAAAAABXP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b InterBlockNode} *){\bkmkstart AAAAAAABXQ}
{\bkmkend AAAAAAABXQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ICFGNode} *node){\bkmkstart AAAAAAABXR}
{\bkmkend AAAAAAABXR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericICFGNodeTy} *node){\bkmkstart AAAAAAABXS}
{\bkmkend AAAAAAABXS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFGNode.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::InterDisjointMRG Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::InterDisjointMRG}
{\xe \v SVF::InterDisjointMRG}
{\bkmkstart AAAAAAAEZM}
{\bkmkend AAAAAAAEZM}
\par
{
{\f2 #include <MemPartition.h>}}\par
Inheritance diagram for SVF::InterDisjointMRG:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_inter_disjoint_m_r_g.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b InterDisjointMRG} ({\b BVDataPTAImpl} *p, bool ptrOnly){\bkmkstart AAAAAAAEZN}
{\bkmkend AAAAAAAEZN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b partitionMRs} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Partition regions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b getMRsForLoad} ({\b MRSet} &aliasMRs, const PointsTo &cpts, const {\b SVFFunction} *)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create memory regions which don't have intersections with each other in the whole program scope. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getMRsForLoad\:SVF::InterDisjointMRG}
{\xe \v SVF::InterDisjointMRG\:getMRsForLoad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void SVF::InterDisjointMRG::getMRsForLoad ({\b MRSet} &  {\i aliasMRs}, const PointsTo &  {\i cpts}, const {\b SVFFunction} * ){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEZJ}
{\bkmkend AAAAAAAEZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory regions to be inserted at a load statement. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cpts} \cell }{The conditional points-to set of load statement. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fun} \cell }{The function being analyzed. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mrs} \cell }{Memory region set contains all possible target memory regions. \cell }
{\row }
}
}{
Reimplemented from {\b SVF::IntraDisjointMRG} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEZI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v partitionMRs\:SVF::InterDisjointMRG}
{\xe \v SVF::InterDisjointMRG\:partitionMRs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InterDisjointMRG::partitionMRs (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEZL}
{\bkmkend AAAAAAAEZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Partition regions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate disjoint cpts.\par
Create memory regions.\par
}{
Reimplemented from {\b SVF::IntraDisjointMRG} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEZK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MemPartition.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MSSA/MemPartition.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::InterMSSAPHISVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::InterMSSAPHISVFGNode}
{\xe \v SVF::InterMSSAPHISVFGNode}
{\bkmkstart AAAAAAADBU}
{\bkmkend AAAAAAADBU}
Inheritance diagram for SVF::InterMSSAPHISVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_inter_m_s_s_a_p_h_i_s_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b InterMSSAPHISVFGNode} (NodeID id, const {\b FormalINSVFGNode} *fi){\bkmkstart AAAAAAADBV}
{\bkmkend AAAAAAADBV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor interPHI for formal parameter. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b InterMSSAPHISVFGNode} (NodeID id, const {\b ActualOUTSVFGNode} *ao){\bkmkstart AAAAAAADBW}
{\bkmkend AAAAAAADBW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor interPHI for actual return. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFormalINPHI} () const{\bkmkstart AAAAAAADBX}
{\bkmkend AAAAAAADBX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isActualOUTPHI} () const{\bkmkstart AAAAAAADBY}
{\bkmkend AAAAAAADBY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getFun} () const{\bkmkstart AAAAAAADBZ}
{\bkmkend AAAAAAADBZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the function of this SVFGNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getCallSite} () const{\bkmkstart AAAAAAADCA}
{\bkmkend AAAAAAADCA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADCB}
{\bkmkend AAAAAAADCB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b InterMSSAPHISVFGNode} *){\bkmkstart AAAAAAADCC}
{\bkmkend AAAAAAADCC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MSSAPHISVFGNode} *node){\bkmkstart AAAAAAADCD}
{\bkmkend AAAAAAADCD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MRSVFGNode} *node){\bkmkstart AAAAAAADCE}
{\bkmkend AAAAAAADCE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADCF}
{\bkmkend AAAAAAADCF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADCG}
{\bkmkend AAAAAAADCG}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::InterPHIVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::InterPHIVFGNode}
{\xe \v SVF::InterPHIVFGNode}
{\bkmkstart AAAAAAADUW}
{\bkmkend AAAAAAADUW}
Inheritance diagram for SVF::InterPHIVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_inter_p_h_i_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b InterPHIVFGNode} (NodeID id, const {\b FormalParmVFGNode} *fp){\bkmkstart AAAAAAADUX}
{\bkmkend AAAAAAADUX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor interPHI for formal parameter. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b InterPHIVFGNode} (NodeID id, const {\b ActualRetVFGNode} *ar){\bkmkstart AAAAAAADUY}
{\bkmkend AAAAAAADUY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor interPHI for actual return. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFormalParmPHI} () const{\bkmkstart AAAAAAADUZ}
{\bkmkend AAAAAAADUZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isActualRetPHI} () const{\bkmkstart AAAAAAADVA}
{\bkmkend AAAAAAADVA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getFun} () const{\bkmkstart AAAAAAADVB}
{\bkmkend AAAAAAADVB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the function of this SVFGNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getCallSite} () const{\bkmkstart AAAAAAADVC}
{\bkmkend AAAAAAADVC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADVD}
{\bkmkend AAAAAAADVD}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b InterPHIVFGNode} *){\bkmkstart AAAAAAADVE}
{\bkmkend AAAAAAADVE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PHIVFGNode} *node){\bkmkstart AAAAAAADVF}
{\bkmkend AAAAAAADVF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADVG}
{\bkmkend AAAAAAADVG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADVH}
{\bkmkend AAAAAAADVH}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::IntraBlockNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::IntraBlockNode}
{\xe \v SVF::IntraBlockNode}
{\bkmkstart AAAAAAABXH}
{\bkmkend AAAAAAABXH}
\par
{
{\f2 #include <ICFGNode.h>}}\par
Inheritance diagram for SVF::IntraBlockNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_intra_block_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b IntraBlockNode} (NodeID id, const Instruction *i){\bkmkstart AAAAAAABXI}
{\bkmkend AAAAAAABXI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Instruction * {\b getInst} () const{\bkmkstart AAAAAAABXJ}
{\bkmkend AAAAAAABXJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::string {\b toString} () const{\bkmkstart AAAAAAABXK}
{\bkmkend AAAAAAABXK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b IntraBlockNode} *){\bkmkstart AAAAAAABXL}
{\bkmkend AAAAAAABXL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ICFGNode} *node){\bkmkstart AAAAAAABXM}
{\bkmkend AAAAAAABXM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericICFGNodeTy} *node){\bkmkstart AAAAAAABXN}
{\bkmkend AAAAAAABXN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ICFG} node stands for a program statement \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ICFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::IntraCFGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::IntraCFGEdge}
{\xe \v SVF::IntraCFGEdge}
{\bkmkstart AAAAAAABVJ}
{\bkmkend AAAAAAABVJ}
\par
{
{\f2 #include <ICFGEdge.h>}}\par
Inheritance diagram for SVF::IntraCFGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_intra_c_f_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef std::pair< const Value *, NodeID > {\b BranchCondition}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b IntraCFGEdge} ({\b ICFGNode} *s, {\b ICFGNode} *d){\bkmkstart AAAAAAABVK}
{\bkmkend AAAAAAABVK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b BranchCondition} & {\b getBranchCondtion} (){\bkmkstart AAAAAAABVL}
{\bkmkend AAAAAAABVL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setBranchCondtion} (const Value *pNode, NodeID branchID){\bkmkstart AAAAAAABVM}
{\bkmkend AAAAAAABVM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAABVN}
{\bkmkend AAAAAAABVN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b IntraCFGEdge} *){\bkmkstart AAAAAAABVO}
{\bkmkend AAAAAAABVO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ICFGEdge} *edge){\bkmkstart AAAAAAABVP}
{\bkmkend AAAAAAABVP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericICFGEdgeTy} *edge){\bkmkstart AAAAAAABVQ}
{\bkmkend AAAAAAABVQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Intra {\b ICFG} edge representing control-flows between basic blocks within a function \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v BranchCondition\:SVF::IntraCFGEdge}
{\xe \v SVF::IntraCFGEdge\:BranchCondition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef std::pair<const Value*,NodeID> {\b SVF::IntraCFGEdge::BranchCondition}}}
\par
{\bkmkstart AAAAAAABVR}
{\bkmkend AAAAAAABVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the first element is a boolean (for if/else) or numeric condition value (for switch) the second element is the value when this condition should hold to execute this CFGEdge. e.g., Inst1: br cmp label 0, label 1, Inst2 is label 0 and Inst 3 is label 1; for edge between Inst1 and Inst 2, the first element is cmp and second element is 0 \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ICFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::IntraDirSVFGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::IntraDirSVFGEdge}
{\xe \v SVF::IntraDirSVFGEdge}
{\bkmkstart AAAAAAADMY}
{\bkmkend AAAAAAADMY}
\par
{
{\f2 #include <VFGEdge.h>}}\par
Inheritance diagram for SVF::IntraDirSVFGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_intra_dir_s_v_f_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b IntraDirSVFGEdge} ({\b VFGNode} *s, {\b VFGNode} *d){\bkmkstart AAAAAAADMZ}
{\bkmkend AAAAAAADMZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADNA}
{\bkmkend AAAAAAADNA}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b IntraDirSVFGEdge} *){\bkmkstart AAAAAAADNB}
{\bkmkend AAAAAAADNB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b DirectSVFGEdge} *edge){\bkmkstart AAAAAAADNC}
{\bkmkend AAAAAAADNC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGEdge} *edge){\bkmkstart AAAAAAADND}
{\bkmkend AAAAAAADND}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGEdgeTy} *edge){\bkmkstart AAAAAAADNE}
{\bkmkend AAAAAAADNE}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Intra {\b SVFG} edge representing direct intra-procedural value-flows \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::IntraDisjointMRG Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::IntraDisjointMRG}
{\xe \v SVF::IntraDisjointMRG}
{\bkmkstart AAAAAAAEYZ}
{\bkmkend AAAAAAAEYZ}
\par
{
{\f2 #include <MemPartition.h>}}\par
Inheritance diagram for SVF::IntraDisjointMRG:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_intra_disjoint_m_r_g.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< PointsTo, PointsToList > {\b PtsToSubPtsMap}{\bkmkstart AAAAAAAEZA}
{\bkmkend AAAAAAAEZA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, PtsToSubPtsMap > {\b FunToPtsMap}{\bkmkstart AAAAAAAEZB}
{\bkmkend AAAAAAAEZB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, PointsToList > {\b FunToInterMap}{\bkmkstart AAAAAAAEZC}
{\bkmkend AAAAAAAEZC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b IntraDisjointMRG} ({\b BVDataPTAImpl} *p, bool ptrOnly){\bkmkstart AAAAAAAEZD}
{\bkmkend AAAAAAAEZD}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b partitionMRs} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Partition regions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b getMRsForLoad} ({\b MRSet} &aliasMRs, const PointsTo &cpts, const {\b SVFFunction} *fun)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b getMRsForLoadFromInterList} ({\b MRSet} &mrs, const PointsTo &cpts, const PointsToList &inters){\bkmkstart AAAAAAAEZE}
{\bkmkend AAAAAAAEZE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b getMRsForCallSiteRef} ({\b MRSet} &aliasMRs, const PointsTo &cpts, const {\b SVFFunction} *fun)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory regions to be inserted at a load statement. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b createDisjointMR} (const {\b SVFFunction} *func, const PointsTo &cpts)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create disjoint memory region. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b computeIntersections} (const PointsTo &cpts, PointsToList &inters)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute intersections between cpts and computed cpts intersections before. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create memory regions which don't have intersections with each other in the same function scope. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v computeIntersections\:SVF::IntraDisjointMRG}
{\xe \v SVF::IntraDisjointMRG\:computeIntersections}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void IntraDisjointMRG::computeIntersections (const PointsTo &  {\i cpts}, PointsToList &  {\i inters}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAEZF}
{\bkmkend AAAAAAAEZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute intersections between cpts and computed cpts intersections before. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute intersections between cpts and computed cpts intersections before. \par
}}
{\xe \v createDisjointMR\:SVF::IntraDisjointMRG}
{\xe \v SVF::IntraDisjointMRG\:createDisjointMR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void IntraDisjointMRG::createDisjointMR (const {\b SVFFunction} *  {\i func}, const PointsTo &  {\i cpts}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAEZG}
{\bkmkend AAAAAAAEZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create disjoint memory region. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create memory regions for each points-to target. \par
}}
{\xe \v getMRsForCallSiteRef\:SVF::IntraDisjointMRG}
{\xe \v SVF::IntraDisjointMRG\:getMRsForCallSiteRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void IntraDisjointMRG::getMRsForCallSiteRef ({\b MRSet} &  {\i aliasMRs}, const PointsTo &  {\i cpts}, const {\b SVFFunction} *  {\i fun}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEZH}
{\bkmkend AAAAAAAEZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory regions to be inserted at a load statement. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory regions to be inserted at a load statement. Just process as {\b getMRsForLoad()}. \par
}{
Reimplemented from {\b SVF::MRGenerator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEYU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getMRsForLoad\:SVF::IntraDisjointMRG}
{\xe \v SVF::IntraDisjointMRG\:getMRsForLoad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void SVF::IntraDisjointMRG::getMRsForLoad ({\b MRSet} &  {\i aliasMRs}, const PointsTo &  {\i cpts}, const {\b SVFFunction} *  {\i fun}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEZI}
{\bkmkend AAAAAAAEZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory regions to be inserted at a load statement. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cpts} \cell }{The conditional points-to set of load statement. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fun} \cell }{The function being analyzed. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mrs} \cell }{Memory region set contains all possible target memory regions. \cell }
{\row }
}
}{
Reimplemented from {\b SVF::MRGenerator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEYW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::InterDisjointMRG} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEZJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v partitionMRs\:SVF::IntraDisjointMRG}
{\xe \v SVF::IntraDisjointMRG\:partitionMRs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void IntraDisjointMRG::partitionMRs (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEZK}
{\bkmkend AAAAAAAEZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Partition regions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create memory regions.\par
}{
Reimplemented from {\b SVF::MRGenerator} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEYY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::InterDisjointMRG} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEZL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MemPartition.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MSSA/MemPartition.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::IntraIndSVFGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::IntraIndSVFGEdge}
{\xe \v SVF::IntraIndSVFGEdge}
{\bkmkstart AAAAAAACYG}
{\bkmkend AAAAAAACYG}
\par
{
{\f2 #include <SVFGEdge.h>}}\par
Inheritance diagram for SVF::IntraIndSVFGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_intra_ind_s_v_f_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b IntraIndSVFGEdge} ({\b VFGNode} *s, {\b VFGNode} *d){\bkmkstart AAAAAAACYH}
{\bkmkend AAAAAAACYH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACYI}
{\bkmkend AAAAAAACYI}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b IntraIndSVFGEdge} *){\bkmkstart AAAAAAACYJ}
{\bkmkend AAAAAAACYJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b IndirectSVFGEdge} *edge){\bkmkstart AAAAAAACYK}
{\bkmkend AAAAAAACYK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGEdge} *edge){\bkmkstart AAAAAAACYL}
{\bkmkend AAAAAAACYL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGEdgeTy} *edge){\bkmkstart AAAAAAACYM}
{\bkmkend AAAAAAACYM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Intra {\b SVFG} edge representing indirect intra-procedural value-flows \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::IntraMSSAPHISVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::IntraMSSAPHISVFGNode}
{\xe \v SVF::IntraMSSAPHISVFGNode}
{\bkmkstart AAAAAAADBM}
{\bkmkend AAAAAAADBM}
Inheritance diagram for SVF::IntraMSSAPHISVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_intra_m_s_s_a_p_h_i_s_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b IntraMSSAPHISVFGNode} (NodeID id, const {\b MemSSA::PHI} *phi){\bkmkstart AAAAAAADBN}
{\bkmkend AAAAAAADBN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADBO}
{\bkmkend AAAAAAADBO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b IntraMSSAPHISVFGNode} *){\bkmkstart AAAAAAADBP}
{\bkmkend AAAAAAADBP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MSSAPHISVFGNode} *node){\bkmkstart AAAAAAADBQ}
{\bkmkend AAAAAAADBQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MRSVFGNode} *node){\bkmkstart AAAAAAADBR}
{\bkmkend AAAAAAADBR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADBS}
{\bkmkend AAAAAAADBS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADBT}
{\bkmkend AAAAAAADBT}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::IntraPHIVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::IntraPHIVFGNode}
{\xe \v SVF::IntraPHIVFGNode}
{\bkmkstart AAAAAAADSG}
{\bkmkend AAAAAAADSG}
Inheritance diagram for SVF::IntraPHIVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_intra_p_h_i_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< u32_t, const {\b ICFGNode} * > {\b OPIncomingBBs}{\bkmkstart AAAAAAADSH}
{\bkmkend AAAAAAADSH}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b IntraPHIVFGNode} (NodeID id, const {\b PAGNode} *r){\bkmkstart AAAAAAADSI}
{\bkmkend AAAAAAADSI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b ICFGNode} * {\b getOpIncomingBB} (u32_t pos) const{\bkmkstart AAAAAAADSJ}
{\bkmkend AAAAAAADSJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setOpVerAndBB} (u32_t pos, const {\b PAGNode} *node, const {\b ICFGNode} *bb){\bkmkstart AAAAAAADSK}
{\bkmkend AAAAAAADSK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADSL}
{\bkmkend AAAAAAADSL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b IntraPHIVFGNode} *){\bkmkstart AAAAAAADSM}
{\bkmkend AAAAAAADSM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PHIVFGNode} *node){\bkmkstart AAAAAAADSN}
{\bkmkend AAAAAAADSN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADSO}
{\bkmkend AAAAAAADSO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADSP}
{\bkmkend AAAAAAADSP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::is_simple_type< X > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::is_simple_type< X >}
{\xe \v SVF::SVFUtil::is_simple_type< X >}
{\bkmkstart AAAAAAAIFT}
{\bkmkend AAAAAAAIFT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const bool {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:SVF::SVFUtil::is_simple_type< X >}
{\xe \v SVF::SVFUtil::is_simple_type< X >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class X > const bool {\b SVF::SVFUtil::is_simple_type}< X >::value{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAIFU}
{\bkmkend AAAAAAAIFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
        std::is_same<X, typename simplify_type<X>::SimpleType>::value\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::isa_impl< To, From, Enabler > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::isa_impl< To, From, Enabler >}
{\xe \v SVF::SVFUtil::isa_impl< To, From, Enabler >}
{\bkmkstart AAAAAAAIEB}
{\bkmkend AAAAAAAIEB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b doit} (const From &Val){\bkmkstart AAAAAAAIEC}
{\bkmkend AAAAAAAIEC}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::isa_impl< To, From, typename std::enable_if< std::is_base_of< To, From >::value >::type > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::isa_impl< To, From, typename std::enable_if< std::is_base_of< To, From >::value >::type >}
{\xe \v SVF::SVFUtil::isa_impl< To, From, typename std::enable_if< std::is_base_of< To, From >::value >::type >}
{\bkmkstart AAAAAAAIED}
{\bkmkend AAAAAAAIED}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Always allow upcasts, and perform no dynamic check for them. }}\par
{
{\f2 #include <Casting.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b doit} (const From &){\bkmkstart AAAAAAAIEE}
{\bkmkend AAAAAAAIEE}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename To, typename From>\par
struct SVF::SVFUtil::isa_impl< To, From, typename std::enable_if< std::is_base_of< To, From >::value >::type >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Always allow upcasts, and perform no dynamic check for them. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::isa_impl_cl< To, From > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::isa_impl_cl< To, From >}
{\xe \v SVF::SVFUtil::isa_impl_cl< To, From >}
{\bkmkstart AAAAAAAIEF}
{\bkmkend AAAAAAAIEF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b doit} (const From &Val){\bkmkstart AAAAAAAIEG}
{\bkmkend AAAAAAAIEG}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::isa_impl_cl< To, const From * > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::isa_impl_cl< To, const From * >}
{\xe \v SVF::SVFUtil::isa_impl_cl< To, const From * >}
{\bkmkstart AAAAAAAIEP}
{\bkmkend AAAAAAAIEP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b doit} (const From *Val){\bkmkstart AAAAAAAIEQ}
{\bkmkend AAAAAAAIEQ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::isa_impl_cl< To, const From *const > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::isa_impl_cl< To, const From *const >}
{\xe \v SVF::SVFUtil::isa_impl_cl< To, const From *const >}
{\bkmkstart AAAAAAAIER}
{\bkmkend AAAAAAAIER}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b doit} (const From *Val){\bkmkstart AAAAAAAIES}
{\bkmkend AAAAAAAIES}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::isa_impl_cl< To, const From > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::isa_impl_cl< To, const From >}
{\xe \v SVF::SVFUtil::isa_impl_cl< To, const From >}
{\bkmkstart AAAAAAAIEH}
{\bkmkend AAAAAAAIEH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b doit} (const From &Val){\bkmkstart AAAAAAAIEI}
{\bkmkend AAAAAAAIEI}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::isa_impl_cl< To, const std::unique_ptr< From > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::isa_impl_cl< To, const std::unique_ptr< From > >}
{\xe \v SVF::SVFUtil::isa_impl_cl< To, const std::unique_ptr< From > >}
{\bkmkstart AAAAAAAIEJ}
{\bkmkend AAAAAAAIEJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b doit} (const std::unique_ptr< From > &Val){\bkmkstart AAAAAAAIEK}
{\bkmkend AAAAAAAIEK}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::isa_impl_cl< To, From * > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::isa_impl_cl< To, From * >}
{\xe \v SVF::SVFUtil::isa_impl_cl< To, From * >}
{\bkmkstart AAAAAAAIEL}
{\bkmkend AAAAAAAIEL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b doit} (const From *Val){\bkmkstart AAAAAAAIEM}
{\bkmkend AAAAAAAIEM}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::isa_impl_cl< To, From *const > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::isa_impl_cl< To, From *const >}
{\xe \v SVF::SVFUtil::isa_impl_cl< To, From *const >}
{\bkmkstart AAAAAAAIEN}
{\bkmkend AAAAAAAIEN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b doit} (const From *Val){\bkmkstart AAAAAAAIEO}
{\bkmkend AAAAAAAIEO}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::isa_impl_wrap< To, From, SimpleFrom > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::isa_impl_wrap< To, From, SimpleFrom >}
{\xe \v SVF::SVFUtil::isa_impl_wrap< To, From, SimpleFrom >}
{\bkmkstart AAAAAAAIET}
{\bkmkend AAAAAAAIET}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b doit} (const From &Val){\bkmkstart AAAAAAAIEU}
{\bkmkend AAAAAAAIEU}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::isa_impl_wrap< To, FromTy, FromTy > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::isa_impl_wrap< To, FromTy, FromTy >}
{\xe \v SVF::SVFUtil::isa_impl_wrap< To, FromTy, FromTy >}
{\bkmkstart AAAAAAAIEV}
{\bkmkend AAAAAAAIEV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b doit} (const FromTy &Val){\bkmkstart AAAAAAAIEW}
{\bkmkend AAAAAAAIEW}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::IteratedDominanceFrontier Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::IteratedDominanceFrontier}
{\xe \v SVF::IteratedDominanceFrontier}
{\bkmkstart AAAAAAAGHV}
{\bkmkend AAAAAAAGHV}
\par
{
{\f2 #include <DataFlowUtil.h>}}\par
Inheritance diagram for SVF::IteratedDominanceFrontier:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_iterated_dominance_frontier.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b getAnalysisUsage} (AnalysisUsage &AU) const{\bkmkstart AAAAAAAGHW}
{\bkmkend AAAAAAAGHW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b getIDFSet} (BasicBlock *B){\bkmkstart AAAAAAAGHX}
{\bkmkend AAAAAAAGHX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static char {\b ID} = 0{\bkmkstart AAAAAAAGHY}
{\bkmkend AAAAAAAGHY}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterated dominance frontier \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/DataFlowUtil.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/DataFlowUtil.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::LeakChecker Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::LeakChecker}
{\xe \v SVF::LeakChecker}
{\bkmkstart AAAAAAAFWU}
{\bkmkend AAAAAAAFWU}
\par
{
{\f2 #include <LeakChecker.h>}}\par
Inheritance diagram for SVF::LeakChecker:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_leak_checker.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b LEAK_TYPE} \{ {\b NEVER_FREE_LEAK}
, {\b CONTEXT_LEAK}
, {\b PATH_LEAK}
, {\b GLOBAL_LEAK}
 \}{\bkmkstart AAAAAAAFWV}
{\bkmkend AAAAAAAFWV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFGNode} *, const {\b CallBlockNode} * > {\b SVFGNodeToCSIDMap}{\bkmkstart AAAAAAAFWW}
{\bkmkend AAAAAAAFWW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< const {\b CallBlockNode} * > {\b CSWorkList}{\bkmkstart AAAAAAAFWX}
{\bkmkend AAAAAAAFWX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b ProgSlice::VFWorkList} {\b WorkList}{\bkmkstart AAAAAAAFWY}
{\bkmkend AAAAAAAFWY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeBS {\b SVFGNodeBS}{\bkmkstart AAAAAAAFWZ}
{\bkmkend AAAAAAAFWZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b LeakChecker} (){\bkmkstart AAAAAAAFXA}
{\bkmkend AAAAAAAFXA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~LeakChecker} (){\bkmkstart AAAAAAAFXB}
{\bkmkend AAAAAAAFXB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b runOnModule} ({\b SVFModule} *module)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start from here. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initSrcs} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize sources and sinks. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initSnks} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isSourceLikeFun} (const {\b SVFFunction} *fun){\bkmkstart AAAAAAAFXC}
{\bkmkend AAAAAAAFXC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether the function is a heap allocator/reallocator (allocate memory) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isSinkLikeFun} (const {\b SVFFunction} *fun){\bkmkstart AAAAAAAFXD}
{\bkmkend AAAAAAAFXD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether the function is a heap deallocator (free/release memory) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isSource} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAFXE}
{\bkmkend AAAAAAAFXE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A {\b SVFG} node is source if it is an actualRet at malloc site. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isSink} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAFXF}
{\bkmkend AAAAAAAFXF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A {\b SVFG} node is source if it is an actual parameter at dealloca site. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b reportBug} ({\b ProgSlice} *slice){\bkmkstart AAAAAAAFXG}
{\bkmkend AAAAAAAFXG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Report leaks. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reportNeverFree} (const {\b SVFGNode} *src){\bkmkstart AAAAAAAFXH}
{\bkmkend AAAAAAAFXH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b reportPartialLeak} (const {\b SVFGNode} *src){\bkmkstart AAAAAAAFXI}
{\bkmkend AAAAAAAFXI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b testsValidation} (const {\b ProgSlice} *slice)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Validate test cases for regression test purpose. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b validateSuccessTests} (const {\b SVFGNode} *source, const {\b SVFFunction} *fun){\bkmkstart AAAAAAAFXJ}
{\bkmkend AAAAAAAFXJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b validateExpectedFailureTests} (const {\b SVFGNode} *source, const {\b SVFFunction} *fun){\bkmkstart AAAAAAAFXK}
{\bkmkend AAAAAAAFXK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addSrcToCSID} (const {\b SVFGNode} *src, const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAFXL}
{\bkmkend AAAAAAAFXL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Record a source to its callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getSrcCSID} (const {\b SVFGNode} *src){\bkmkstart AAAAAAAFXM}
{\bkmkend AAAAAAAFXM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static Memory Leak Detector \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v initSnks\:SVF::LeakChecker}
{\xe \v SVF::LeakChecker\:initSnks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LeakChecker::initSnks (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFXN}
{\bkmkend AAAAAAAFXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize sinks \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
we only choose pointer parameters among all the actual parameters\par
}{
Implements {\b SVF::SrcSnkDDA} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFXO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v initSrcs\:SVF::LeakChecker}
{\xe \v SVF::LeakChecker\:initSrcs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LeakChecker::initSrcs (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFXP}
{\bkmkend AAAAAAAFXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize sources and sinks. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize sources and sinks\par
Initialize sources \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if this callsite return reside in a dead function then we do not care about its leaks for example instruction p = malloc is in a dead function, then program won't allocate this memory\par
}{
Implements {\b SVF::SrcSnkDDA} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFXQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v runOnModule\:SVF::LeakChecker}
{\xe \v SVF::LeakChecker\:runOnModule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool SVF::LeakChecker::runOnModule ({\b SVFModule} *  {\i module}){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFWK}
{\bkmkend AAAAAAAFWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start from here. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
start analysis\par
}{
Reimplemented in {\b SVF::FileChecker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFWT \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::DoubleFreeChecker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFWJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v testsValidation\:SVF::LeakChecker}
{\xe \v SVF::LeakChecker\:testsValidation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LeakChecker::testsValidation (const {\b ProgSlice} *  {\i slice}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFXR}
{\bkmkend AAAAAAAFXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Validate test cases for regression test purpose. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Validate test cases for regression test purpose \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SABER/LeakChecker.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SABER/LeakChecker.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::List< Data > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::List< Data >}
{\xe \v SVF::List< Data >}
{\bkmkstart AAAAAAAHLW}
{\bkmkend AAAAAAAHLW}
\par
{
{\f2 #include <WorkList.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b empty} () const{\bkmkstart AAAAAAAHLX}
{\bkmkend AAAAAAAHLX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b find} (Data data) const{\bkmkstart AAAAAAAHLY}
{\bkmkend AAAAAAAHLY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b push} (Data data){\bkmkstart AAAAAAAHLZ}
{\bkmkend AAAAAAAHLZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Data {\b pop} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Data>\par
class SVF::List< Data >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Worklist with "first come first go" order. New nodes pushed at back and popped from front. Elements in the list are unique as they're recorded by Set. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v pop\:SVF::List< Data >}
{\xe \v SVF::List< Data >\:pop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Data > Data {\b SVF::List}< Data >::pop (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHMA}
{\bkmkend AAAAAAAHMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get node from list head\par
change list head to the next node\par
the last node is popped.\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/WorkList.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::LLVMModuleSet Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::LLVMModuleSet}
{\xe \v SVF::LLVMModuleSet}
{\bkmkstart AAAAAAAGKW}
{\bkmkend AAAAAAAGKW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const {\b SVFFunction} * > {\b FunctionSetType}{\bkmkstart AAAAAAAGKX}
{\bkmkend AAAAAAAGKX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, const {\b SVFFunction} * > {\b FunDeclToDefMapTy}{\bkmkstart AAAAAAAGKY}
{\bkmkend AAAAAAAGKY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, FunctionSetType > {\b FunDefToDeclsMapTy}{\bkmkstart AAAAAAAGKZ}
{\bkmkend AAAAAAAGKZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const GlobalVariable *, GlobalVariable * > {\b GlobalDefToRepMapTy}{\bkmkstart AAAAAAAGLA}
{\bkmkend AAAAAAAGLA}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFModule} * {\b buildSVFModule} (Module &mod){\bkmkstart AAAAAAAGLB}
{\bkmkend AAAAAAAGLB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFModule} * {\b buildSVFModule} (const std::vector< std::string > &moduleNameVec){\bkmkstart AAAAAAAGLC}
{\bkmkend AAAAAAAGLC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFModule} * {\b getSVFModule} (){\bkmkstart AAAAAAAGLD}
{\bkmkend AAAAAAAGLD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getModuleNum} () const{\bkmkstart AAAAAAAGLE}
{\bkmkend AAAAAAAGLE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Module * {\b getModule} (u32_t idx) const{\bkmkstart AAAAAAAGLF}
{\bkmkend AAAAAAAGLF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Module & {\b getModuleRef} (u32_t idx) const{\bkmkstart AAAAAAAGLG}
{\bkmkend AAAAAAAGLG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dumpModulesToFile} (const std::string suffix){\bkmkstart AAAAAAAGLH}
{\bkmkend AAAAAAAGLH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getSVFFunction} (const Function *fun) const{\bkmkstart AAAAAAAGLI}
{\bkmkend AAAAAAAGLI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasDefinition} (const Function *fun) const{\bkmkstart AAAAAAAGLJ}
{\bkmkend AAAAAAAGLJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun decl --> def. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasDefinition} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAAGLK}
{\bkmkend AAAAAAAGLK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getDefinition} (const Function *fun) const{\bkmkstart AAAAAAAGLL}
{\bkmkend AAAAAAAGLL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getDefinition} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAAGLM}
{\bkmkend AAAAAAAGLM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasDeclaration} (const Function *fun) const{\bkmkstart AAAAAAAGLN}
{\bkmkend AAAAAAAGLN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun def --> decl. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasDeclaration} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAAGLO}
{\bkmkend AAAAAAAGLO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const FunctionSetType & {\b getDeclaration} (const Function *fun) const{\bkmkstart AAAAAAAGLP}
{\bkmkend AAAAAAAGLP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const FunctionSetType & {\b getDeclaration} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAAGLQ}
{\bkmkend AAAAAAAGLQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasGlobalRep} (const GlobalVariable *val) const{\bkmkstart AAAAAAAGLR}
{\bkmkend AAAAAAAGLR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global to rep. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

GlobalVariable * {\b getGlobalRep} (const GlobalVariable *val) const{\bkmkstart AAAAAAAGLS}
{\bkmkend AAAAAAAGLS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Module * {\b getMainLLVMModule} () const{\bkmkstart AAAAAAAGLT}
{\bkmkend AAAAAAAGLT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

LLVMContext & {\b getContext} () const{\bkmkstart AAAAAAAGLU}
{\bkmkend AAAAAAAGLU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b empty} () const{\bkmkstart AAAAAAAGLV}
{\bkmkend AAAAAAAGLV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b allCTir} (void) const{\bkmkstart AAAAAAAGLW}
{\bkmkend AAAAAAAGLW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if all LLVM modules are compiled with ctir. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b LLVMModuleSet} * {\b getLLVMModuleSet} (){\bkmkstart AAAAAAAGLX}
{\bkmkend AAAAAAAGLX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b releaseLLVMModuleSet} (){\bkmkstart AAAAAAAGLY}
{\bkmkend AAAAAAAGLY}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/LLVMModule.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/LLVMModule.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::LoadCGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::LoadCGEdge}
{\xe \v SVF::LoadCGEdge}
{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
\par
{
{\f2 #include <ConsGEdge.h>}}\par
Inheritance diagram for SVF::LoadCGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_load_c_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b LoadCGEdge} ({\b ConstraintNode} *s, {\b ConstraintNode} *d, EdgeID id){\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b LoadCGEdge} *){\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ConstraintEdge} *edge){\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericConsEdgeTy} *edge){\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Load edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ConsGEdge.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::LoadMU< Cond > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::LoadMU< Cond >}
{\xe \v SVF::LoadMU< Cond >}
{\bkmkstart AAAAAAAFGO}
{\bkmkend AAAAAAAFGO}
\par
{
{\f2 #include <MSSAMuChi.h>}}\par
Inheritance diagram for SVF::LoadMU< Cond >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_load_m_u.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b LoadMU} (const BasicBlock *b, const {\b LoadPE} *i, const {\b MemRegion} *m, Cond c=PathCondAllocator::trueCond()){\bkmkstart AAAAAAAFGP}
{\bkmkend AAAAAAAFGP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor/Destructor for MU. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b LoadPE} * {\b getLoadInst} () const{\bkmkstart AAAAAAAFGQ}
{\bkmkend AAAAAAAFGQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return load instruction. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const BasicBlock * {\b getBasicBlock} () const{\bkmkstart AAAAAAAFGR}
{\bkmkend AAAAAAAFGR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return basic block. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dump} (){\bkmkstart AAAAAAAFGS}
{\bkmkend AAAAAAAFGS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print MU. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b LoadMU} *){\bkmkstart AAAAAAAFGT}
{\bkmkend AAAAAAAFGT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MSSAMU}< Cond > *mu){\bkmkstart AAAAAAAFGU}
{\bkmkend AAAAAAAFGU}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Cond>\par
class SVF::LoadMU< Cond >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b LoadMU} is annotated at each load instruction, representing a memory object is read here \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MSSAMuChi.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::LoadPE Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::LoadPE}
{\xe \v SVF::LoadPE}
{\bkmkstart AAAAAAACJR}
{\bkmkend AAAAAAACJR}
\par
{
{\f2 #include <PAGEdge.h>}}\par
Inheritance diagram for SVF::LoadPE:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_load_p_e.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b LoadPE} ({\b PAGNode} *s, {\b PAGNode} *d){\bkmkstart AAAAAAACJS}
{\bkmkend AAAAAAACJS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACJT}
{\bkmkend AAAAAAACJT}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b LoadPE} *){\bkmkstart AAAAAAACJU}
{\bkmkend AAAAAAACJU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGEdge} *edge){\bkmkstart AAAAAAACJV}
{\bkmkend AAAAAAACJV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGEdgeTy} *edge){\bkmkstart AAAAAAACJW}
{\bkmkend AAAAAAACJW}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Load edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::LoadVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::LoadVFGNode}
{\xe \v SVF::LoadVFGNode}
{\bkmkstart AAAAAAADOV}
{\bkmkend AAAAAAADOV}
\par
{
{\f2 #include <VFGNode.h>}}\par
Inheritance diagram for SVF::LoadVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_load_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b LoadVFGNode} (NodeID id, const {\b LoadPE} *edge){\bkmkstart AAAAAAADOW}
{\bkmkend AAAAAAADOW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADOX}
{\bkmkend AAAAAAADOX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b LoadVFGNode} *){\bkmkstart AAAAAAADOY}
{\bkmkend AAAAAAADOY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b StmtVFGNode} *node){\bkmkstart AAAAAAADOZ}
{\bkmkend AAAAAAADOZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADPA}
{\bkmkend AAAAAAADPA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADPB}
{\bkmkend AAAAAAADPB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b VFGNode} for loads \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::LocationSet Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::LocationSet}
{\xe \v SVF::LocationSet}
{\bkmkstart AAAAAAAEBT}
{\bkmkend AAAAAAAEBT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b LSRelation} \{ {\b NonOverlap}
, {\b Overlap}
, {\b Subset}
, {\b Superset}
, {\b Same}
 \}{\bkmkstart AAAAAAAEBU}
{\bkmkend AAAAAAAEBU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef FieldInfo::ElemNumStridePairVec {\b ElemNumStridePairVec}{\bkmkstart AAAAAAAEBV}
{\bkmkend AAAAAAAEBV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b LocationSet} (Size_t o=0){\bkmkstart AAAAAAAEBW}
{\bkmkend AAAAAAAEBW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b LocationSet} (const {\b LocationSet} &ls){\bkmkstart AAAAAAAEBX}
{\bkmkend AAAAAAAEBX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b LocationSet} (const {\b FieldInfo} &fi){\bkmkstart AAAAAAAEBY}
{\bkmkend AAAAAAAEBY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialization from {\b FieldInfo}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b LocationSet} {\b operator+} (const {\b LocationSet} &rhs) const{\bkmkstart AAAAAAAEBZ}
{\bkmkend AAAAAAAEBZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overload operators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b LocationSet} & {\b operator=} (const {\b LocationSet} &rhs){\bkmkstart AAAAAAAECA}
{\bkmkend AAAAAAAECA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator<} (const {\b LocationSet} &rhs) const{\bkmkstart AAAAAAAECB}
{\bkmkend AAAAAAAECB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b LocationSet} &rhs) const{\bkmkstart AAAAAAAECC}
{\bkmkend AAAAAAAECC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b getOffset} () const{\bkmkstart AAAAAAAECD}
{\bkmkend AAAAAAAECD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get methods. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b getByteOffset} () const{\bkmkstart AAAAAAAECE}
{\bkmkend AAAAAAAECE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setFldIdx} (Size_t idx){\bkmkstart AAAAAAAECF}
{\bkmkend AAAAAAAECF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setByteOffset} (Size_t os){\bkmkstart AAAAAAAECG}
{\bkmkend AAAAAAAECG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const ElemNumStridePairVec & {\b getNumStridePair} () const{\bkmkstart AAAAAAAECH}
{\bkmkend AAAAAAAECH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addElemNumStridePair} (const NodePair &pair)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isConstantOffset} () const{\bkmkstart AAAAAAAECI}
{\bkmkend AAAAAAAECI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return TRUE if this is a constant location set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b intersects} (const {\b LocationSet} &RHS) const{\bkmkstart AAAAAAAECJ}
{\bkmkend AAAAAAAECJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return TRUE if we share any location in common with RHS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b dump} () const{\bkmkstart AAAAAAAECK}
{\bkmkend AAAAAAAECK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump location set. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static LSRelation {\b checkRelation} (const {\b LocationSet} &LHS, const {\b LocationSet} &RHS){\bkmkstart AAAAAAAECL}
{\bkmkend AAAAAAAECL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check relations of two location sets. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b SymbolTableInfo}{\bkmkstart AAAAAAAECM}
{\bkmkend AAAAAAAECM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b LocSymTableInfo}{\bkmkstart AAAAAAAECN}
{\bkmkend AAAAAAAECN}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addElemNumStridePair\:SVF::LocationSet}
{\xe \v SVF::LocationSet\:addElemNumStridePair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LocationSet::addElemNumStridePair (const NodePair &  {\i pair})}}
\par
{\bkmkstart AAAAAAAECO}
{\bkmkend AAAAAAAECO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add element num and stride pair \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The pair will not be added if any number of a stride is zero, because they will not have effect on the locations represented by this {\b LocationSet}.\par
Find the GCD stride\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/LocationSet.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MemoryModel/LocationSet.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::LockAnalysis Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis}
{\bkmkstart AAAAAAAFLL}
{\bkmkend AAAAAAAFLL}
\par
{
{\f2 #include <LockAnalysis.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ValDomain} \{ {\b Empty}
, {\b TDLocked}
, {\b TDUnlocked}
 \}{\bkmkstart AAAAAAAFLM}
{\bkmkend AAAAAAAFLM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
semilattice Empty==>TDUnlocked==>TDLocked }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b CxtStmt} {\b CxtLock}{\bkmkstart AAAAAAAFLN}
{\bkmkend AAAAAAAFLN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b CxtProc} {\b CxtLockProc}{\bkmkstart AAAAAAAFLO}
{\bkmkend AAAAAAAFLO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeBS {\b LockSet}{\bkmkstart AAAAAAAFLP}
{\bkmkend AAAAAAAFLP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef TCT::InstVec {\b InstVec}{\bkmkstart AAAAAAAFLQ}
{\bkmkend AAAAAAAFLQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const Instruction * > {\b InstSet}{\bkmkstart AAAAAAAFLR}
{\bkmkend AAAAAAAFLR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef InstSet {\b CISpan}{\bkmkstart AAAAAAAFLS}
{\bkmkend AAAAAAAFLS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Instruction *, CISpan > {\b CILockToSpan}{\bkmkstart AAAAAAAFLT}
{\bkmkend AAAAAAAFLT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const Function * > {\b FunSet}{\bkmkstart AAAAAAAFLU}
{\bkmkend AAAAAAAFLU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Instruction *, InstSet > {\b InstToInstSetMap}{\bkmkstart AAAAAAAFLV}
{\bkmkend AAAAAAAFLV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CxtStmt}, {\b ValDomain} > {\b CxtStmtToLockFlagMap}{\bkmkstart AAAAAAAFLW}
{\bkmkend AAAAAAAFLW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< {\b CxtStmt} > {\b CxtStmtWorkList}{\bkmkstart AAAAAAAFLX}
{\bkmkend AAAAAAAFLX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< {\b CxtStmt} > {\b LockSpan}{\bkmkstart AAAAAAAFLY}
{\bkmkend AAAAAAAFLY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< {\b CxtStmt} > {\b CxtStmtSet}{\bkmkstart AAAAAAAFLZ}
{\bkmkend AAAAAAAFLZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< {\b CxtLock} > {\b CxtLockSet}{\bkmkstart AAAAAAAFMA}
{\bkmkend AAAAAAAFMA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< {\b CxtLock}, LockSpan > {\b CxtLockToSpan}{\bkmkstart AAAAAAAFMB}
{\bkmkend AAAAAAAFMB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< {\b CxtLock}, NodeBS > {\b CxtLockToLockSet}{\bkmkstart AAAAAAAFMC}
{\bkmkend AAAAAAAFMC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Instruction *, NodeBS > {\b LockSiteToLockSet}{\bkmkstart AAAAAAAFMD}
{\bkmkend AAAAAAAFMD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Instruction *, LockSpan > {\b InstToCxtStmtSet}{\bkmkstart AAAAAAAFME}
{\bkmkend AAAAAAAFME}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CxtStmt}, CxtLockSet > {\b CxtStmtToCxtLockSet}{\bkmkstart AAAAAAAFMF}
{\bkmkend AAAAAAAFMF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< {\b CxtLockProc} > {\b CxtLockProcVec}{\bkmkstart AAAAAAAFMG}
{\bkmkend AAAAAAAFMG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef set< {\b CxtLockProc} > {\b CxtLockProcSet}{\bkmkstart AAAAAAAFMH}
{\bkmkend AAAAAAAFMH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::pair< const Function *, const Function * > {\b FuncPair}{\bkmkstart AAAAAAAFMI}
{\bkmkend AAAAAAAFMI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< FuncPair, bool > {\b FuncPairToBool}{\bkmkstart AAAAAAAFMJ}
{\bkmkend AAAAAAAFMJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b LockAnalysis} ({\b TCT} *t){\bkmkstart AAAAAAAFMK}
{\bkmkend AAAAAAAFMK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b analyze} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b analyzeIntraProcedualLock} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b intraForwardTraverse} (const Instruction *lock, InstSet &unlockset, InstSet &forwardInsts)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b intraBackwardTraverse} (const InstSet &unlockset, InstSet &backwardInsts)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b collectCxtLock} (){\bkmkstart AAAAAAAFML}
{\bkmkend AAAAAAAFML}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b analyzeLockSpanCxtStmt} (){\bkmkstart AAAAAAAFMM}
{\bkmkend AAAAAAAFMM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b collectLockUnlocksites} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b buildCandidateFuncSetforLock} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isIntraLock} (const Instruction *lock) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Intraprocedural locks. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addIntraLock} (const Instruction *lockSite, const InstSet &stmts){\bkmkstart AAAAAAAFMN}
{\bkmkend AAAAAAAFMN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add intra-procedural lock. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addCondIntraLock} (const Instruction *lockSite, const InstSet &stmts){\bkmkstart AAAAAAAFMO}
{\bkmkend AAAAAAAFMO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add intra-procedural lock. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isInsideIntraLock} (const Instruction *stmt) const{\bkmkstart AAAAAAAFMP}
{\bkmkend AAAAAAAFMP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if a statement is inside an intra-procedural lock. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isInsideCondIntraLock} (const Instruction *stmt) const{\bkmkstart AAAAAAAFMQ}
{\bkmkend AAAAAAAFMQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if a statement is inside a partial lock/unlock pair (conditional lock with unconditional unlock) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const InstSet & {\b getIntraLockSet} (const Instruction *stmt) const{\bkmkstart AAAAAAAFMR}
{\bkmkend AAAAAAAFMR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addCxtLock} (const CallStrCxt &cxt, const Instruction *inst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Context-sensitive locks. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasCxtLock} (const {\b CxtLock} &cxtLock) const{\bkmkstart AAAAAAAFMS}
{\bkmkend AAAAAAAFMS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get context-sensitive lock. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b intersects} (const CxtLockSet &lockset1, const CxtLockSet &lockset2) const{\bkmkstart AAAAAAAFMT}
{\bkmkend AAAAAAAFMT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if the intersection of two locksets is not empty. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b alias} (const CxtLockSet &lockset1, const CxtLockSet &lockset2){\bkmkstart AAAAAAAFMU}
{\bkmkend AAAAAAAFMU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if two locksets has at least one alias lock. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isLockCandidateFun} (const Function *fun) const{\bkmkstart AAAAAAAFMV}
{\bkmkend AAAAAAAFMV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if it is a candidate function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasCxtStmtfromInst} (const Instruction *inst) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Context-sensitive statement and lock spans. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CxtStmtSet & {\b getCxtStmtfromInst} (const Instruction *inst) const{\bkmkstart AAAAAAAFMW}
{\bkmkend AAAAAAAFMW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasCxtLockfromCxtStmt} (const {\b CxtStmt} &cts) const{\bkmkstart AAAAAAAFMX}
{\bkmkend AAAAAAAFMX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CxtLockSet & {\b getCxtLockfromCxtStmt} (const {\b CxtStmt} &cts) const{\bkmkstart AAAAAAAFMY}
{\bkmkend AAAAAAAFMY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CxtLockSet & {\b getCxtLockfromCxtStmt} (const {\b CxtStmt} &cts){\bkmkstart AAAAAAAFMZ}
{\bkmkend AAAAAAAFMZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b addCxtStmtToSpan} (const {\b CxtStmt} &cts, const {\b CxtLock} &cl){\bkmkstart AAAAAAAFNA}
{\bkmkend AAAAAAAFNA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add context-sensitive statement. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b removeCxtStmtToSpan} ({\b CxtStmt} &cts, const {\b CxtLock} &cl){\bkmkstart AAAAAAAFNB}
{\bkmkend AAAAAAAFNB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add context-sensitive statement. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b touchCxtStmt} ({\b CxtStmt} &cts){\bkmkstart AAAAAAAFNC}
{\bkmkend AAAAAAAFNC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Touch this context statement. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasSpanfromCxtLock} (const {\b CxtLock} &cl){\bkmkstart AAAAAAAFND}
{\bkmkend AAAAAAAFND}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

LockSpan & {\b getSpanfromCxtLock} (const {\b CxtLock} &cl){\bkmkstart AAAAAAAFNE}
{\bkmkend AAAAAAAFNE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasOneCxtInLockSpan} (const Instruction *I, LockSpan lspan) const{\bkmkstart AAAAAAAFNF}
{\bkmkend AAAAAAAFNF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if one instruction's context stmt is in a lock span. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasAllCxtInLockSpan} (const Instruction *I, LockSpan lspan) const{\bkmkstart AAAAAAAFNG}
{\bkmkend AAAAAAAFNG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isProtectedByCommonLock} (const Instruction *i1, const Instruction *i2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isProtectedByCommonCxtLock} (const Instruction *i1, const Instruction *i2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isProtectedByCommonCxtLock} (const {\b CxtStmt} &cxtStmt1, const {\b CxtStmt} &cxtStmt2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isProtectedByCommonCILock} (const Instruction *i1, const Instruction *i2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInSameSpan} (const Instruction *I1, const Instruction *I2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInSameCSSpan} (const Instruction *i1, const Instruction *i2) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInSameCSSpan} (const {\b CxtStmt} &cxtStmt1, const {\b CxtStmt} &cxtStmt2) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInSameCISpan} (const Instruction *i1, const Instruction *i2) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getNumOfCxtLocks} (){\bkmkstart AAAAAAAFNH}
{\bkmkend AAAAAAAFNH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printLocks} (const {\b CxtStmt} &cts)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print locks and spans. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b lockTime}{\bkmkstart AAAAAAAFNI}
{\bkmkend AAAAAAAFNI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b numOfTotalQueries}{\bkmkstart AAAAAAAFNJ}
{\bkmkend AAAAAAAFNJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b numOfLockedQueries}{\bkmkstart AAAAAAAFNK}
{\bkmkend AAAAAAAFNK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b lockQueriesTime}{\bkmkstart AAAAAAAFNL}
{\bkmkend AAAAAAAFNL}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lock analysis \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addCxtLock\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:addCxtLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVF::LockAnalysis::addCxtLock (const CallStrCxt &  {\i cxt}, const Instruction *  {\i inst}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAFNM}
{\bkmkend AAAAAAAFNM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Context-sensitive locks. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add inter-procedural context-sensitive lock \par
}}
{\xe \v analyze\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:analyze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LockAnalysis::analyze ()}}
\par
{\bkmkstart AAAAAAAFNN}
{\bkmkend AAAAAAAFNN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
context-sensitive forward traversal from each lock site. Generate following results (1) context-sensitive lock site, (2) maps a context-sensitive lock site to its corresponding lock span. \par
}}
{\xe \v analyzeIntraProcedualLock\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:analyzeIntraProcedualLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LockAnalysis::analyzeIntraProcedualLock ()}}
\par
{\bkmkstart AAAAAAAFNO}
{\bkmkend AAAAAAAFNO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Analyze intraprocedural locks A lock is intraprocedural if its lock span is within a procedural \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FIXME:Should we intersect forwardInsts and backwardInsts?\par
}}
{\xe \v buildCandidateFuncSetforLock\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:buildCandidateFuncSetforLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LockAnalysis::buildCandidateFuncSetforLock ()}}
\par
{\bkmkstart AAAAAAAFNP}
{\bkmkend AAAAAAAFNP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect candidate functions for context-sensitive lock analysis \par
}}
{\xe \v collectLockUnlocksites\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:collectLockUnlocksites}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LockAnalysis::collectLockUnlocksites ()}}
\par
{\bkmkstart AAAAAAAFNQ}
{\bkmkend AAAAAAAFNQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect lock/unlock sites \par
}}
{\xe \v hasCxtStmtfromInst\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:hasCxtStmtfromInst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::LockAnalysis::hasCxtStmtfromInst (const Instruction *  {\i inst}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAFNR}
{\bkmkend AAAAAAAFNR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Context-sensitive statement and lock spans. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get LockSet and LockSpan \par
}}
{\xe \v intraBackwardTraverse\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:intraBackwardTraverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LockAnalysis::intraBackwardTraverse (const InstSet &  {\i unlockSet}, InstSet &  {\i backwardInsts})}}
\par
{\bkmkstart AAAAAAAFNS}
{\bkmkend AAAAAAAFNS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Intra-procedural backward traversal \par
}}
{\xe \v intraForwardTraverse\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:intraForwardTraverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LockAnalysis::intraForwardTraverse (const Instruction *  {\i lockSite}, InstSet &  {\i unlockSet}, InstSet &  {\i forwardInsts})}}
\par
{\bkmkstart AAAAAAAFNT}
{\bkmkend AAAAAAAFNT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Intra-procedural forward traversal \par
}}
{\xe \v isInSameCISpan\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:isInSameCISpan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LockAnalysis::isInSameCISpan (const Instruction *  {\i i1}, const Instruction *  {\i i2}) const}}
\par
{\bkmkstart AAAAAAAFNU}
{\bkmkend AAAAAAAFNU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if two instructions are inside same context-insensitive lock span \par
}}
{\xe \v isInSameCSSpan\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:isInSameCSSpan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LockAnalysis::isInSameCSSpan (const {\b CxtStmt} &  {\i cxtStmt1}, const {\b CxtStmt} &  {\i cxtStmt2}) const}}
\par
{\bkmkstart AAAAAAAFNV}
{\bkmkend AAAAAAAFNV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if two context-sensitive instructions are inside same context-insensitive lock spa \par
}}
{\xe \v isInSameCSSpan\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:isInSameCSSpan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LockAnalysis::isInSameCSSpan (const Instruction *  {\i I1}, const Instruction *  {\i I2}) const}}
\par
{\bkmkstart AAAAAAAFNW}
{\bkmkend AAAAAAAFNW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if two instructions are inside at least one common contex-sensitive lock span \par
}}
{\xe \v isInSameSpan\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:isInSameSpan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LockAnalysis::isInSameSpan (const Instruction *  {\i i1}, const Instruction *  {\i i2})}}
\par
{\bkmkstart AAAAAAAFNX}
{\bkmkend AAAAAAAFNX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if two instructions are inside at least one common lock span \par
}}
{\xe \v isIntraLock\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:isIntraLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::LockAnalysis::isIntraLock (const Instruction *  {\i lock}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAFNY}
{\bkmkend AAAAAAAFNY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Intraprocedural locks. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if the lock is an intra-procedural lock \par
}}
{\xe \v isProtectedByCommonCILock\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:isProtectedByCommonCILock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LockAnalysis::isProtectedByCommonCILock (const Instruction *  {\i i1}, const Instruction *  {\i i2})}}
\par
{\bkmkstart AAAAAAAFNZ}
{\bkmkend AAAAAAAFNZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Protected by at least one common context-insensitive lock \par
}}
{\xe \v isProtectedByCommonCxtLock\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:isProtectedByCommonCxtLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LockAnalysis::isProtectedByCommonCxtLock (const {\b CxtStmt} &  {\i cxtStmt1}, const {\b CxtStmt} &  {\i cxtStmt2})}}
\par
{\bkmkstart AAAAAAAFOA}
{\bkmkend AAAAAAAFOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Protected by at least one common context-sensitive lock \par
}}
{\xe \v isProtectedByCommonCxtLock\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:isProtectedByCommonCxtLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LockAnalysis::isProtectedByCommonCxtLock (const Instruction *  {\i i1}, const Instruction *  {\i i2})}}
\par
{\bkmkstart AAAAAAAFOB}
{\bkmkend AAAAAAAFOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Protected by at least one common context-sensitive lock under each context \par
}}
{\xe \v isProtectedByCommonLock\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:isProtectedByCommonLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LockAnalysis::isProtectedByCommonLock (const Instruction *  {\i i1}, const Instruction *  {\i i2})}}
\par
{\bkmkstart AAAAAAAFOC}
{\bkmkend AAAAAAAFOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if two Instructions are protected by common locks echo inst may have multiple cxt stmt we check whether every cxt stmt of instructions is protected by a common lock.\par
Protected by at least one common lock under every context \par
}}
{\xe \v printLocks\:SVF::LockAnalysis}
{\xe \v SVF::LockAnalysis\:printLocks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LockAnalysis::printLocks (const {\b CxtStmt} &  {\i cts})}}
\par
{\bkmkstart AAAAAAAFOD}
{\bkmkend AAAAAAAFOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print locks and spans. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print context-insensitive and context-sensitive locks \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/LockAnalysis.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MTA/LockAnalysis.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::LockValidator Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::LockValidator}
{\xe \v SVF::LockValidator}
{\bkmkstart AAAAAAAIDF}
{\bkmkend AAAAAAAIDF}
Inheritance diagram for SVF::LockValidator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_lock_validator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b LockValidator} ({\b LockAnalysis} *ls){\bkmkstart AAAAAAAIDG}
{\bkmkend AAAAAAAIDG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b protectedByCommonLocks} (const Instruction *I1, const Instruction *I2){\bkmkstart AAAAAAAIDH}
{\bkmkend AAAAAAAIDH}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MTA/LockAnalysis.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::LocObjTypeInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::LocObjTypeInfo}
{\xe \v SVF::LocObjTypeInfo}
{\bkmkstart AAAAAAAGSD}
{\bkmkend AAAAAAAGSD}
Inheritance diagram for SVF::LocObjTypeInfo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_loc_obj_type_info.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b LocObjTypeInfo} (const Value *val, Type *t, Size_t max){\bkmkstart AAAAAAAGSE}
{\bkmkend AAAAAAAGSE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~LocObjTypeInfo} (){\bkmkstart AAAAAAAGSF}
{\bkmkend AAAAAAAGSF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32_t {\b getObjSize} (const Value *val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the size of this object. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getObjSize\:SVF::LocObjTypeInfo}
{\xe \v SVF::LocObjTypeInfo\:getObjSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32_t LocObjTypeInfo::getObjSize (const Value *  {\i val}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEDZ}
{\bkmkend AAAAAAAEDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the size of this object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the size of this object \par
}{
Reimplemented from {\b SVF::ObjTypeInfo} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEDY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/SymbolTableInfo.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MemoryModel/MemModel.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::LocSymTableInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::LocSymTableInfo}
{\xe \v SVF::LocSymTableInfo}
{\bkmkstart AAAAAAAGRZ}
{\bkmkend AAAAAAAGRZ}
\par
{
{\f2 #include <SymbolTableInfo.h>}}\par
Inheritance diagram for SVF::LocSymTableInfo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_loc_sym_table_info.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b LocSymTableInfo} (){\bkmkstart AAAAAAAGSA}
{\bkmkend AAAAAAAGSA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~LocSymTableInfo} (){\bkmkstart AAAAAAAGSB}
{\bkmkend AAAAAAAGSB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b computeGepOffset} (const User *V, {\b LocationSet} &ls)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute gep offset. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b LocationSet} {\b getModulusOffset} (const {\b MemObj} *obj, const {\b LocationSet} &ls)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an offset from a Gep Instruction, return it modulus offset by considering memory layout. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b verifyStructSize} ({\b StInfo} *stInfo, u32_t structSize)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Verify struct size construction. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b collectStructInfo} (const {\b StructType} *T){\bkmkstart AAAAAAAGRD}
{\bkmkend AAAAAAAGRD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect the struct info. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b collectArrayInfo} (const ArrayType *T)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect the array info. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bytes/bits-level modeling of memory locations to handle weakly type languages. (declared with one type but accessed as another) Abstract memory objects are created according to the static allocated size. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v collectArrayInfo\:SVF::LocSymTableInfo}
{\xe \v SVF::LocSymTableInfo\:collectArrayInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LocSymTableInfo::collectArrayInfo (const ArrayType *  {\i T}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGQY}
{\bkmkend AAAAAAAGQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect the array info. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect array information \par
}{
Reimplemented from {\b SVF::SymbolTableInfo} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAGQX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v computeGepOffset\:SVF::LocSymTableInfo}
{\xe \v SVF::LocSymTableInfo\:computeGepOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LocSymTableInfo::computeGepOffset (const User *  {\i V}, {\b LocationSet} &  {\i ls}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGRJ}
{\bkmkend AAAAAAAGRJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute gep offset. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute gep offset \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
variant offset\par
}{
Reimplemented from {\b SVF::SymbolTableInfo} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAGRI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getModulusOffset\:SVF::LocSymTableInfo}
{\xe \v SVF::LocSymTableInfo\:getModulusOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LocationSet} LocSymTableInfo::getModulusOffset (const {\b MemObj} *  {\i obj}, const {\b LocationSet} &  {\i ls}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGRN}
{\bkmkend AAAAAAAGRN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an offset from a Gep Instruction, return it modulus offset by considering memory layout. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given {\b LocationSet} from a Gep Instruction, return a new {\b LocationSet} which matches the field information of this {\b ObjTypeInfo} by considering memory layout \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find an appropriate field for this {\b LocationSet}\par
This location set represent one object\par
if the offset is negative, it's possible that we're looking for an obj node out of range of current struct. Make the offset positive so we can still get a node within current struct to represent this obj.\par
This location set represents multiple objects\par
}{
Reimplemented from {\b SVF::SymbolTableInfo} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAGRM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v verifyStructSize\:SVF::LocSymTableInfo}
{\xe \v SVF::LocSymTableInfo\:verifyStructSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LocSymTableInfo::verifyStructSize ({\b StInfo} *  {\i stinfo}, u32_t  {\i structSize})}}
\par
{\bkmkstart AAAAAAAGSC}
{\bkmkend AAAAAAAGSC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Verify struct size construction. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Verify struct size \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Please note this verify may not be complete as different machine has different alignment mechanism\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/SymbolTableInfo.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MemoryModel/MemModel.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MemObj Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MemObj}
{\xe \v SVF::MemObj}
{\bkmkstart AAAAAAAEED}
{\bkmkend AAAAAAAEED}
\par
{
{\f2 #include <MemModel.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemObj} (const Value *val, SymID id)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemObj} (SymID id, const Type *type=NULL)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for black hole and constant obj. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ~MemObj} (){\bkmkstart AAAAAAAEEE}
{\bkmkend AAAAAAAEEE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b init} (const Value *val){\bkmkstart AAAAAAAEEF}
{\bkmkend AAAAAAAEEF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b init} (const Type *type){\bkmkstart AAAAAAAEEG}
{\bkmkend AAAAAAAEEG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize black hole and constant object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const llvm::Type * {\b getType} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get obj type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b getMaxFieldOffsetLimit} () const{\bkmkstart AAAAAAAEEH}
{\bkmkend AAAAAAAEEH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get max field offset limit. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getRefVal} () const{\bkmkstart AAAAAAAEEI}
{\bkmkend AAAAAAAEEI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the reference value to this object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SymID {\b getSymId} () const{\bkmkstart AAAAAAAEEJ}
{\bkmkend AAAAAAAEEJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the memory object id. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFieldInsensitive} () const{\bkmkstart AAAAAAAEEK}
{\bkmkend AAAAAAAEEK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if its field limit is 0. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setFieldInsensitive} (){\bkmkstart AAAAAAAEEL}
{\bkmkend AAAAAAAEEL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the memory object to be field insensitive. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFieldSensitive} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the memory object to be field sensitive (up to max field limit) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isBlackHoleObj} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether it is a black hole object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFunction} () const{\bkmkstart AAAAAAAEEM}
{\bkmkend AAAAAAAEEM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
object attributes methods }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isGlobalObj} () const{\bkmkstart AAAAAAAEEN}
{\bkmkend AAAAAAAEEN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isStaticObj} () const{\bkmkstart AAAAAAAEEO}
{\bkmkend AAAAAAAEEO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isStack} () const{\bkmkstart AAAAAAAEEP}
{\bkmkend AAAAAAAEEP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isHeap} () const{\bkmkstart AAAAAAAEEQ}
{\bkmkend AAAAAAAEEQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isStruct} () const{\bkmkstart AAAAAAAEER}
{\bkmkend AAAAAAAEER}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isArray} () const{\bkmkstart AAAAAAAEES}
{\bkmkend AAAAAAAEES}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isVarStruct} () const{\bkmkstart AAAAAAAEET}
{\bkmkend AAAAAAAEET}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isVarArray} () const{\bkmkstart AAAAAAAEEU}
{\bkmkend AAAAAAAEEU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isConstStruct} () const{\bkmkstart AAAAAAAEEV}
{\bkmkend AAAAAAAEEV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isConstArray} () const{\bkmkstart AAAAAAAEEW}
{\bkmkend AAAAAAAEEW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isConstant} () const{\bkmkstart AAAAAAAEEX}
{\bkmkend AAAAAAAEEX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasPtrObj} () const{\bkmkstart AAAAAAAEEY}
{\bkmkend AAAAAAAEEY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isNonPtrFieldObj} (const {\b LocationSet} &ls) const{\bkmkstart AAAAAAAEEZ}
{\bkmkend AAAAAAAEEZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b MemObj} &mem) const{\bkmkstart AAAAAAAEFA}
{\bkmkend AAAAAAAEFA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operator overloading. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b destroy} (){\bkmkstart AAAAAAAEFB}
{\bkmkend AAAAAAAEFB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory Object \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MemObj\:SVF::MemObj}
{\xe \v SVF::MemObj\:MemObj}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MemObj::MemObj (const Value *  {\i val}, SymID  {\i id})}}
\par
{\bkmkstart AAAAAAAEFC}
{\bkmkend AAAAAAAEFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor of a memory object \par
}}
{\xe \v MemObj\:SVF::MemObj}
{\xe \v SVF::MemObj\:MemObj}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MemObj::MemObj (SymID  {\i id}, const Type *  {\i type} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAAEFD}
{\bkmkend AAAAAAAEFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor for black hole and constant obj. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor of a memory object \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getType\:SVF::MemObj}
{\xe \v SVF::MemObj\:getType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const Type * MemObj::getType () const}}
\par
{\bkmkstart AAAAAAAEFE}
{\bkmkend AAAAAAAEFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get obj type. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get obj type info. \par
}}
{\xe \v isBlackHoleObj\:SVF::MemObj}
{\xe \v SVF::MemObj\:isBlackHoleObj}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MemObj::isBlackHoleObj () const}}
\par
{\bkmkstart AAAAAAAEFF}
{\bkmkend AAAAAAAEFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether it is a black hole object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether it is a black hole object \par
}}
{\xe \v setFieldSensitive\:SVF::MemObj}
{\xe \v SVF::MemObj\:setFieldSensitive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MemObj::setFieldSensitive ()}}
\par
{\bkmkstart AAAAAAAEFG}
{\bkmkend AAAAAAAEFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the memory object to be field sensitive (up to max field limit) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set mem object to be field sensitive (up to maximum field limit) \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/MemModel.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MemoryModel/MemModel.cpp\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/SymbolTableInfo.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MemRegion Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MemRegion}
{\xe \v SVF::MemRegion}
{\bkmkstart AAAAAAAEZO}
{\bkmkend AAAAAAAEZO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory Region class. }}\par
{
{\f2 #include <MemRegion.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b equalMemRegion}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b equalPointsTo}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b DdNode} * {\b Condition}{\bkmkstart AAAAAAAEZP}
{\bkmkend AAAAAAAEZP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MemRegion} (const PointsTo &cp){\bkmkstart AAAAAAAEZQ}
{\bkmkend AAAAAAAEZQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ~MemRegion} (){\bkmkstart AAAAAAAEZR}
{\bkmkend AAAAAAAEZR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

MRID {\b getMRID} () const{\bkmkstart AAAAAAAEZS}
{\bkmkend AAAAAAAEZS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return memory region ID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const PointsTo & {\b getPointsTo} () const{\bkmkstart AAAAAAAEZT}
{\bkmkend AAAAAAAEZT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return points-to. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b MemRegion} *rhs) const{\bkmkstart AAAAAAAEZU}
{\bkmkend AAAAAAAEZU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operator== overriding. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b dumpStr} () const{\bkmkstart AAAAAAAEZV}
{\bkmkend AAAAAAAEZV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump string. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getRegionSize} () const{\bkmkstart AAAAAAAEZW}
{\bkmkend AAAAAAAEZW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return memory object number inside a region. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory Region class. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MemRegion.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MSSA/MemRegion.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MemSSA Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MemSSA}
{\xe \v SVF::MemSSA}
{\bkmkstart AAAAAAAFCT}
{\bkmkend AAAAAAAFCT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MemRegion::Condition} {\b Condition}{\bkmkstart AAAAAAAFCU}
{\bkmkend AAAAAAAFCU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
define condition here changes needed if we add new type }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MSSAMU}< {\b Condition} > {\b MU}{\bkmkstart AAAAAAAFCV}
{\bkmkend AAAAAAAFCV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b RetMU}< {\b Condition} > {\b RETMU}{\bkmkstart AAAAAAAFCW}
{\bkmkend AAAAAAAFCW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b LoadMU}< {\b Condition} > {\b LOADMU}{\bkmkstart AAAAAAAFCX}
{\bkmkend AAAAAAAFCX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b CallMU}< {\b Condition} > {\b CALLMU}{\bkmkstart AAAAAAAFCY}
{\bkmkend AAAAAAAFCY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MSSACHI}< {\b Condition} > {\b CHI}{\bkmkstart AAAAAAAFCZ}
{\bkmkend AAAAAAAFCZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b EntryCHI}< {\b Condition} > {\b ENTRYCHI}{\bkmkstart AAAAAAAFDA}
{\bkmkend AAAAAAAFDA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b StoreCHI}< {\b Condition} > {\b STORECHI}{\bkmkstart AAAAAAAFDB}
{\bkmkend AAAAAAAFDB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b CallCHI}< {\b Condition} > {\b CALLCHI}{\bkmkstart AAAAAAAFDC}
{\bkmkend AAAAAAAFDC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MSSAPHI}< {\b Condition} > {\b PHI}{\bkmkstart AAAAAAAFDD}
{\bkmkend AAAAAAAFDD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MSSADEF} {\b MDEF}{\bkmkstart AAAAAAAFDE}
{\bkmkend AAAAAAAFDE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< {\b MU} * > {\b MUSet}{\bkmkstart AAAAAAAFDF}
{\bkmkend AAAAAAAFDF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< {\b CHI} * > {\b CHISet}{\bkmkstart AAAAAAAFDG}
{\bkmkend AAAAAAAFDG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< {\b PHI} * > {\b PHISet}{\bkmkstart AAAAAAAFDH}
{\bkmkend AAAAAAAFDH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MRGenerator::MRSet} {\b MRSet}{\bkmkstart AAAAAAAFDI}
{\bkmkend AAAAAAAFDI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define mem region set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const {\b MemRegion} * > {\b MRVector}{\bkmkstart AAAAAAAFDJ}
{\bkmkend AAAAAAAFDJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef Map< const {\b LoadPE} *, MUSet > {\b LoadToMUSetMap}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b StorePE} *, CHISet > {\b StoreToChiSetMap}{\bkmkstart AAAAAAAFDK}
{\bkmkend AAAAAAAFDK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CallBlockNode} *, MUSet > {\b CallSiteToMUSetMap}{\bkmkstart AAAAAAAFDL}
{\bkmkend AAAAAAAFDL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CallBlockNode} *, CHISet > {\b CallSiteToCHISetMap}{\bkmkstart AAAAAAAFDM}
{\bkmkend AAAAAAAFDM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const BasicBlock *, PHISet > {\b BBToPhiSetMap}{\bkmkstart AAAAAAAFDN}
{\bkmkend AAAAAAAFDN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, CHISet > {\b FunToEntryChiSetMap}{\bkmkstart AAAAAAAFDO}
{\bkmkend AAAAAAAFDO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Map from fun to its entry chi set and return mu set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, MUSet > {\b FunToReturnMuSetMap}{\bkmkstart AAAAAAAFDP}
{\bkmkend AAAAAAAFDP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const BasicBlock * > {\b BBList}{\bkmkstart AAAAAAAFDQ}
{\bkmkend AAAAAAAFDQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For phi insertion. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const BasicBlock *, {\b MRSet} > {\b BBToMRSetMap}{\bkmkstart AAAAAAAFDR}
{\bkmkend AAAAAAAFDR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b MemRegion} *, {\b BBList} > {\b MemRegToBBsMap}{\bkmkstart AAAAAAAFDS}
{\bkmkend AAAAAAAFDS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b MemRegion} *, std::vector< {\b MRVer} * > > {\b MemRegToVerStackMap}{\bkmkstart AAAAAAAFDT}
{\bkmkend AAAAAAAFDT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For SSA renaming. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b MemRegion} *, MRVERSION > {\b MemRegToCounterMap}{\bkmkstart AAAAAAAFDU}
{\bkmkend AAAAAAAFDU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PAG::PAGEdgeList {\b PAGEdgeList}{\bkmkstart AAAAAAAFDV}
{\bkmkend AAAAAAAFDV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} edge list. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static double {\b timeOfGeneratingMemRegions} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static double {\b timeOfCreateMUCHI} = 0{\bkmkstart AAAAAAAFDW}
{\bkmkend AAAAAAAFDW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time for generating mu/chi for load/store/calls. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static double {\b timeOfInsertingPHI} = 0{\bkmkstart AAAAAAAFDX}
{\bkmkend AAAAAAAFDX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time for inserting phis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static double {\b timeOfSSARenaming} = 0{\bkmkstart AAAAAAAFDY}
{\bkmkend AAAAAAAFDY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time for SSA rename. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b createMUCHI} (const {\b SVFFunction} &fun)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create mu chi for candidate regions in a function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b insertPHI} (const {\b SVFFunction} &fun){\bkmkstart AAAAAAAFDZ}
{\bkmkend AAAAAAAFDZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Insert phi for candidate regions in a fucntion. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b SSARename} (const {\b SVFFunction} &fun)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SSA rename for a function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b SSARenameBB} (const BasicBlock &bb)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SSA rename for a basic block. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b BVDataPTAImpl} * {\b pta}{\bkmkstart AAAAAAAFEA}
{\bkmkend AAAAAAAFEA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRGenerator} * {\b mrGen}{\bkmkstart AAAAAAAFEB}
{\bkmkend AAAAAAAFEB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DominanceFrontier} * {\b df}{\bkmkstart AAAAAAAFEC}
{\bkmkend AAAAAAAFEC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DominatorTree * {\b dt}{\bkmkstart AAAAAAAFED}
{\bkmkend AAAAAAAFED}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MemSSAStat} * {\b stat}{\bkmkstart AAAAAAAFEE}
{\bkmkend AAAAAAAFEE}
\par
}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemSSA} ({\b BVDataPTAImpl} *p, bool ptrOnlyMSSA)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~MemSSA} (){\bkmkstart AAAAAAAFEF}
{\bkmkend AAAAAAAFEF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAG} * {\b getPAG} (){\bkmkstart AAAAAAAFEG}
{\bkmkend AAAAAAAFEG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return {\b PAG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b BVDataPTAImpl} * {\b getPTA} () const{\bkmkstart AAAAAAAFEH}
{\bkmkend AAAAAAAFEH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return PTA. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRGenerator} * {\b getMRGenerator} (){\bkmkstart AAAAAAAFEI}
{\bkmkend AAAAAAAFEI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return {\b MRGenerator}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b buildMemSSA} (const {\b SVFFunction} &fun, {\b DominanceFrontier} *, DominatorTree *)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start from here. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b performStat} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasMU} (const {\b PAGEdge} *inst) const{\bkmkstart AAAAAAAFEJ}
{\bkmkend AAAAAAAFEJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has mu/chi methods. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasCHI} (const {\b PAGEdge} *inst) const{\bkmkstart AAAAAAAFEK}
{\bkmkend AAAAAAAFEK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasMU} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAAFEL}
{\bkmkend AAAAAAAFEL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasCHI} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAAFEM}
{\bkmkend AAAAAAAFEM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasFuncEntryChi} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAAFEN}
{\bkmkend AAAAAAAFEN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has function entry chi or return mu. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasReturnMu} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAAFEO}
{\bkmkend AAAAAAAFEO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CHISet & {\b getFuncEntryChiSet} (const {\b SVFFunction} *fun){\bkmkstart AAAAAAAFEP}
{\bkmkend AAAAAAAFEP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

MUSet & {\b getReturnMuSet} (const {\b SVFFunction} *fun){\bkmkstart AAAAAAAFEQ}
{\bkmkend AAAAAAAFEQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

MUSet & {\b getMUSet} (const {\b LoadPE} *ld){\bkmkstart AAAAAAAFER}
{\bkmkend AAAAAAAFER}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get methods of mu/chi/phi. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CHISet & {\b getCHISet} (const {\b StorePE} *st){\bkmkstart AAAAAAAFES}
{\bkmkend AAAAAAAFES}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

MUSet & {\b getMUSet} (const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAFET}
{\bkmkend AAAAAAAFET}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CHISet & {\b getCHISet} (const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAFEU}
{\bkmkend AAAAAAAFEU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PHISet & {\b getPHISet} (const BasicBlock *bb){\bkmkstart AAAAAAAFEV}
{\bkmkend AAAAAAAFEV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasPHISet} (const BasicBlock *bb) const{\bkmkstart AAAAAAAFEW}
{\bkmkend AAAAAAAFEW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b LoadToMUSetMap} & {\b getLoadToMUSetMap} (){\bkmkstart AAAAAAAFEX}
{\bkmkend AAAAAAAFEX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

StoreToChiSetMap & {\b getStoreToChiSetMap} (){\bkmkstart AAAAAAAFEY}
{\bkmkend AAAAAAAFEY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FunToReturnMuSetMap & {\b getFunToRetMuSetMap} (){\bkmkstart AAAAAAAFEZ}
{\bkmkend AAAAAAAFEZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FunToEntryChiSetMap} & {\b getFunToEntryChiSetMap} (){\bkmkstart AAAAAAAFFA}
{\bkmkend AAAAAAAFFA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteToMUSetMap & {\b getCallSiteToMuSetMap} (){\bkmkstart AAAAAAAFFB}
{\bkmkend AAAAAAAFFB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteToCHISetMap & {\b getCallSiteToChiSetMap} (){\bkmkstart AAAAAAAFFC}
{\bkmkend AAAAAAAFFC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

BBToPhiSetMap & {\b getBBToPhiSetMap} (){\bkmkstart AAAAAAAFFD}
{\bkmkend AAAAAAAFFD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32_t {\b getLoadMuNum} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stat methods. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32_t {\b getStoreChiNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32_t {\b getFunEntryChiNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32_t {\b getFunRetMuNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32_t {\b getCallSiteMuNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32_t {\b getCallSiteChiNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32_t {\b getBBPhiNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dumpMSSA} ({\b raw_ostream} &Out=SVFUtil::outs())\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print Memory SSA. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v LoadToMUSetMap\:SVF::MemSSA}
{\xe \v SVF::MemSSA\:LoadToMUSetMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef Map<const {\b LoadPE}*, MUSet> {\b SVF::MemSSA::LoadToMUSetMap}}}
\par
{\bkmkstart AAAAAAAFFE}
{\bkmkend AAAAAAAFFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Map loads/stores to its mem regions, TODO:visitAtomicCmpXchgInst, visitAtomicRMWInst?? \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MemSSA\:SVF::MemSSA}
{\xe \v SVF::MemSSA\:MemSSA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MemSSA::MemSSA ({\b BVDataPTAImpl} *  {\i p}, bool  {\i ptrOnlyMSSA})}}
\par
{\bkmkstart AAAAAAAFFF}
{\bkmkend AAAAAAAFFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate whole program memory regions\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v buildMemSSA\:SVF::MemSSA}
{\xe \v SVF::MemSSA\:buildMemSSA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MemSSA::buildMemSSA (const {\b SVFFunction} &  {\i fun}, {\b DominanceFrontier} *  {\i f}, DominatorTree *  {\i t}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFFG}
{\bkmkend AAAAAAAFFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start from here. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start building memory SSA \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create mus/chis for loads/stores/calls for memory regions\par
Insert PHI for memory regions\par
SSA rename for memory regions\par
}}
{\xe \v createMUCHI\:SVF::MemSSA}
{\xe \v SVF::MemSSA\:createMUCHI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MemSSA::createMUCHI (const {\b SVFFunction} &  {\i fun}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFFH}
{\bkmkend AAAAAAAFFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create mu chi for candidate regions in a function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create mu/chi according to memory regions collect used mrs in usedRegs and construction map from region to BB for prune SSA phi insertion \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get all reachable basic blocks from function entry ignore dead basic blocks\par
if the function does not have a reachable return instruction from function entry then we won't create return mu for it\par
}}
{\xe \v dumpMSSA\:SVF::MemSSA}
{\xe \v SVF::MemSSA\:dumpMSSA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MemSSA::dumpMSSA ({\b raw_ostream} &  {\i Out} = {\f2 SVFUtil::outs()})}}
\par
{\bkmkstart AAAAAAAFFI}
{\bkmkend AAAAAAAFFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print Memory SSA. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print SSA \par
}}
{\xe \v getBBPhiNum\:SVF::MemSSA}
{\xe \v SVF::MemSSA\:getBBPhiNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32_t MemSSA::getBBPhiNum () const}}
\par
{\bkmkstart AAAAAAAFFJ}
{\bkmkend AAAAAAAFFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get PHI numbers \par
}}
{\xe \v getCallSiteChiNum\:SVF::MemSSA}
{\xe \v SVF::MemSSA\:getCallSiteChiNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32_t MemSSA::getCallSiteChiNum () const}}
\par
{\bkmkstart AAAAAAAFFK}
{\bkmkend AAAAAAAFFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b CallCHI} numbers \par
}}
{\xe \v getCallSiteMuNum\:SVF::MemSSA}
{\xe \v SVF::MemSSA\:getCallSiteMuNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32_t MemSSA::getCallSiteMuNum () const}}
\par
{\bkmkstart AAAAAAAFFL}
{\bkmkend AAAAAAAFFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b CallMU} numbers \par
}}
{\xe \v getFunEntryChiNum\:SVF::MemSSA}
{\xe \v SVF::MemSSA\:getFunEntryChiNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32_t MemSSA::getFunEntryChiNum () const}}
\par
{\bkmkstart AAAAAAAFFM}
{\bkmkend AAAAAAAFFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b EntryCHI} numbers \par
}}
{\xe \v getFunRetMuNum\:SVF::MemSSA}
{\xe \v SVF::MemSSA\:getFunRetMuNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32_t MemSSA::getFunRetMuNum () const}}
\par
{\bkmkstart AAAAAAAFFN}
{\bkmkend AAAAAAAFFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b RetMU} numbers \par
}}
{\xe \v getLoadMuNum\:SVF::MemSSA}
{\xe \v SVF::MemSSA\:getLoadMuNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32_t MemSSA::getLoadMuNum () const}}
\par
{\bkmkstart AAAAAAAFFO}
{\bkmkend AAAAAAAFFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stat methods. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get loadMU numbers \par
}}
{\xe \v getStoreChiNum\:SVF::MemSSA}
{\xe \v SVF::MemSSA\:getStoreChiNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32_t MemSSA::getStoreChiNum () const}}
\par
{\bkmkstart AAAAAAAFFP}
{\bkmkend AAAAAAAFFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b StoreCHI} numbers \par
}}
{\xe \v performStat\:SVF::MemSSA}
{\xe \v SVF::MemSSA\:performStat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MemSSA::performStat ()}}
\par
{\bkmkstart AAAAAAAFFQ}
{\bkmkend AAAAAAAFFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform statistics. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform statistics \par
}}
{\xe \v SSARename\:SVF::MemSSA}
{\xe \v SVF::MemSSA\:SSARename}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MemSSA::SSARename (const {\b SVFFunction} &  {\i fun}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFFR}
{\bkmkend AAAAAAAFFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SSA rename for a function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SSA construction algorithm \par
}}
{\xe \v SSARenameBB\:SVF::MemSSA}
{\xe \v SVF::MemSSA\:SSARenameBB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MemSSA::SSARenameBB (const BasicBlock &  {\i bb}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFFS}
{\bkmkend AAAAAAAFFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SSA rename for a basic block. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Renaming for each memory regions See the renaming algorithm in book Engineering A Compiler (Figure 9.12) \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v timeOfGeneratingMemRegions\:SVF::MemSSA}
{\xe \v SVF::MemSSA\:timeOfGeneratingMemRegions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double MemSSA::timeOfGeneratingMemRegions = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAFFT}
{\bkmkend AAAAAAAFFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time for allocating regions.\par
Time for allocating regions \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MemSSA.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MSSA/MemSSA.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MemSSADF Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MemSSADF}
{\xe \v SVF::MemSSADF}
{\bkmkstart AAAAAAAFJN}
{\bkmkend AAAAAAAFJN}
\par
{
{\f2 #include <SVFGBuilder.h>}}\par
Inheritance diagram for SVF::MemSSADF:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_mem_s_s_a_d_f.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b runOnDT} (DominatorTree &dt){\bkmkstart AAAAAAAFJO}
{\bkmkend AAAAAAAFJO}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dominator frontier used in MSSA \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/SVFGBuilder.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MemSSAStat Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MemSSAStat}
{\xe \v SVF::MemSSAStat}
{\bkmkstart AAAAAAADCS}
{\bkmkend AAAAAAADCS}
Inheritance diagram for SVF::MemSSAStat:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_mem_s_s_a_stat.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MemSSAStat} ({\b MemSSA} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b performStat} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b printStat} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b TotalTimeOfConstructMemSSA} = "TotalMSSATime"{\bkmkstart AAAAAAADCT}
{\bkmkend AAAAAAADCT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total time for constructing memory SSA. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b TimeOfGeneratingMemRegions} = "GenRegionTime"{\bkmkstart AAAAAAADCU}
{\bkmkend AAAAAAADCU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time for allocating regions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b TimeOfCreateMUCHI} = "GenMUCHITime"{\bkmkstart AAAAAAADCV}
{\bkmkend AAAAAAADCV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time for generating mu/chi for load/store/calls. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b TimeOfInsertingPHI} = "InsertPHITime"{\bkmkstart AAAAAAADCW}
{\bkmkend AAAAAAADCW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time for inserting phis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b TimeOfSSARenaming} = "SSARenameTime"{\bkmkstart AAAAAAADCX}
{\bkmkend AAAAAAADCX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time for SSA rename. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfMaxRegion} = "MaxRegSize"{\bkmkstart AAAAAAADCY}
{\bkmkend AAAAAAADCY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of max points-to set in region. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfAveragePtsInRegion} = "AverageRegSize"{\bkmkstart AAAAAAADCZ}
{\bkmkend AAAAAAADCZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of average points-to set in region. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfMemRegions} = "MemRegions"{\bkmkstart AAAAAAADDA}
{\bkmkend AAAAAAADDA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of memory regions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfEntryChi} = "FunEntryChi"{\bkmkstart AAAAAAADDB}
{\bkmkend AAAAAAADDB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of function entry chi. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfRetMu} = "FunRetMu"{\bkmkstart AAAAAAADDC}
{\bkmkend AAAAAAADDC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of function return mu. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfCSChi} = "CSChiNode"{\bkmkstart AAAAAAADDD}
{\bkmkend AAAAAAADDD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of call site chi. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfCSMu} = "CSMuNode"{\bkmkstart AAAAAAADDE}
{\bkmkend AAAAAAADDE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of call site mu. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfLoadMu} = "LoadMuNode"{\bkmkstart AAAAAAADDF}
{\bkmkend AAAAAAADDF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of load mu. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfStoreChi} = "StoreChiNode"{\bkmkstart AAAAAAADDG}
{\bkmkend AAAAAAADDG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of store chi. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b NumOfMSSAPhi} = "MSSAPhi"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of mssa phi. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfFunHasEntryChi} = "FunHasEntryChi"{\bkmkstart AAAAAAADDH}
{\bkmkend AAAAAAADDH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of functions which have entry chi. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfFunHasRetMu} = "FunHasRetMu"{\bkmkstart AAAAAAADDI}
{\bkmkend AAAAAAADDI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of functions which have return mu. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfCSHasChi} = "CSHasChi"{\bkmkstart AAAAAAADDJ}
{\bkmkend AAAAAAADDJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of call sites which have chi. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfCSHasMu} = "CSHasMu"{\bkmkstart AAAAAAADDK}
{\bkmkend AAAAAAADDK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of call sites which have mu. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfLoadHasMu} = "LoadHasMu"{\bkmkstart AAAAAAADDL}
{\bkmkend AAAAAAADDL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of loads which have mu. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfStoreHasChi} = "StoreHasChi"{\bkmkstart AAAAAAADDM}
{\bkmkend AAAAAAADDM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of stores which have chi. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfBBHasMSSAPhi} = "BBHasMSSAPhi"{\bkmkstart AAAAAAADDN}
{\bkmkend AAAAAAADDN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of basic blocks which have mssa phi. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MemSSAStat\:SVF::MemSSAStat}
{\xe \v SVF::MemSSAStat\:MemSSAStat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MemSSAStat::MemSSAStat ({\b MemSSA} *  {\i memSSA})}}
\par
{\bkmkstart AAAAAAADDO}
{\bkmkend AAAAAAADDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v performStat\:SVF::MemSSAStat}
{\xe \v SVF::MemSSAStat\:performStat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MemSSAStat::performStat (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADDP}
{\bkmkend AAAAAAADDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start stating \par
}{
Reimplemented from {\b SVF::PTAStat} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABEG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v printStat\:SVF::MemSSAStat}
{\xe \v SVF::MemSSAStat\:printStat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MemSSAStat::printStat (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADDQ}
{\bkmkend AAAAAAADDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print statistics \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v NumOfMSSAPhi\:SVF::MemSSAStat}
{\xe \v SVF::MemSSAStat\:NumOfMSSAPhi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * MemSSAStat::NumOfMSSAPhi = "MSSAPhi"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAADDR}
{\bkmkend AAAAAAADDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of mssa phi. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of non-top level ptr phi. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFGStat.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFGStat.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MergeFunctionRets Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MergeFunctionRets}
{\xe \v SVF::MergeFunctionRets}
{\bkmkstart AAAAAAAGDR}
{\bkmkend AAAAAAAGDR}
Inheritance diagram for SVF::MergeFunctionRets:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_merge_function_rets.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

StringRef {\b getPassName} () const{\bkmkstart AAAAAAAGDS}
{\bkmkend AAAAAAAGDS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b runOnModule} (Module &M){\bkmkstart AAAAAAAGDT}
{\bkmkend AAAAAAAGDT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b UnifyFunctionExit} (Module &module){\bkmkstart AAAAAAAGDU}
{\bkmkend AAAAAAAGDU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

UnifyFunctionExitNodes * {\b getUnifyExit} (const Function &fn){\bkmkstart AAAAAAAGDV}
{\bkmkend AAAAAAAGDV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Unified Exit basic block node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b getAnalysisUsage} (AnalysisUsage &AU) const{\bkmkstart AAAAAAAGDW}
{\bkmkend AAAAAAAGDW}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static char {\b ID} = 0{\bkmkstart AAAAAAAGDX}
{\bkmkend AAAAAAAGDX}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/BreakConstantExpr.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/BreakConstantExpr.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MHP Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MHP}
{\xe \v SVF::MHP}
{\bkmkstart AAAAAAAFOE}
{\bkmkend AAAAAAAFOE}
\par
{
{\f2 #include <MHP.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const Function * > {\b FunSet}{\bkmkstart AAAAAAAFOF}
{\bkmkend AAAAAAAFOF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const Instruction * > {\b InstSet}{\bkmkstart AAAAAAAFOG}
{\bkmkend AAAAAAAFOG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b StmtSVFGNode} * > {\b SVFGNodeSet}{\bkmkstart AAAAAAAFOH}
{\bkmkend AAAAAAAFOH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef TCT::InstVec {\b InstVec}{\bkmkstart AAAAAAAFOI}
{\bkmkend AAAAAAAFOI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< {\b CxtThreadStmt} > {\b CxtThreadStmtWorkList}{\bkmkstart AAAAAAAFOJ}
{\bkmkend AAAAAAAFOJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< {\b CxtThreadStmt} > {\b CxtThreadStmtSet}{\bkmkstart AAAAAAAFOK}
{\bkmkend AAAAAAAFOK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CxtThreadStmt}, NodeBS > {\b ThreadStmtToThreadInterleav}{\bkmkstart AAAAAAAFOL}
{\bkmkend AAAAAAAFOL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Instruction *, CxtThreadStmtSet > {\b InstToThreadStmtSetMap}{\bkmkstart AAAAAAAFOM}
{\bkmkend AAAAAAAFOM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< {\b CxtStmt} > {\b LockSpan}{\bkmkstart AAAAAAAFON}
{\bkmkend AAAAAAAFON}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::pair< const Function *, const Function * > {\b FuncPair}{\bkmkstart AAAAAAAFOO}
{\bkmkend AAAAAAAFOO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< FuncPair, bool > {\b FuncPairToBool}{\bkmkstart AAAAAAAFOP}
{\bkmkend AAAAAAAFOP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MHP} ({\b TCT} *t)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~MHP} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b analyze} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start analysis here. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b analyzeInterleaving} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Analyze thread interleaving. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ThreadCallGraph} * {\b getThreadCallGraph} () const{\bkmkstart AAAAAAAFOQ}
{\bkmkend AAAAAAAFOQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b ThreadCallGraph}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b TCT} * {\b getTCT} () const{\bkmkstart AAAAAAAFOR}
{\bkmkend AAAAAAAFOR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Thread Creation Tree. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isConnectedfromMain} (const Function *fun){\bkmkstart AAAAAAAFOS}
{\bkmkend AAAAAAAFOS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether the function is connected from main function in thread call graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b mayHappenInParallel} (const Instruction *i1, const Instruction *i2){\bkmkstart AAAAAAAFOT}
{\bkmkend AAAAAAAFOT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface to query whether two instructions may happen-in-parallel. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b mayHappenInParallelCache} (const Instruction *i1, const Instruction *i2){\bkmkstart AAAAAAAFOU}
{\bkmkend AAAAAAAFOU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b mayHappenInParallelInst} (const Instruction *i1, const Instruction *i2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b executedByTheSameThread} (const Instruction *i1, const Instruction *i2){\bkmkstart AAAAAAAFOV}
{\bkmkend AAAAAAAFOV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const NodeBS & {\b getInterleavingThreads} (const {\b CxtThreadStmt} &cts){\bkmkstart AAAAAAAFOW}
{\bkmkend AAAAAAAFOW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get interleaving thread for statement inst. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasInterleavingThreads} (const {\b CxtThreadStmt} &cts) const{\bkmkstart AAAAAAAFOX}
{\bkmkend AAAAAAAFOX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CxtThreadStmtSet & {\b getThreadStmtSet} (const Instruction *inst) const{\bkmkstart AAAAAAAFOY}
{\bkmkend AAAAAAAFOY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get/has ThreadStmt. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasThreadStmtSet} (const Instruction *inst) const{\bkmkstart AAAAAAAFOZ}
{\bkmkend AAAAAAAFOZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printInterleaving} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print interleaving results. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b numOfTotalQueries}{\bkmkstart AAAAAAAFPA}
{\bkmkend AAAAAAAFPA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total number of queries. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b numOfMHPQueries}{\bkmkstart AAAAAAAFPB}
{\bkmkend AAAAAAAFPB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of queries are answered as may-happen-in-parallel. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b interleavingTime}{\bkmkstart AAAAAAAFPC}
{\bkmkend AAAAAAAFPC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b interleavingQueriesTime}{\bkmkstart AAAAAAAFPD}
{\bkmkend AAAAAAAFPD}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class serves as a base may-happen in parallel analysis for multithreaded program Given a statement under an abstract thread, it tells which abstract threads may be alive at the same time (May-happen-in-parallel). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MHP\:SVF::MHP}
{\xe \v SVF::MHP\:MHP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MHP::MHP ({\b TCT} *  {\i t})}}
\par
{\bkmkstart AAAAAAAFPE}
{\bkmkend AAAAAAAFPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor \par
}}
{\xe \v ~MHP\:SVF::MHP}
{\xe \v SVF::MHP\:~MHP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MHP::~MHP (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFPF}
{\bkmkend AAAAAAAFPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v analyze\:SVF::MHP}
{\xe \v SVF::MHP\:analyze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MHP::analyze ()}}
\par
{\bkmkstart AAAAAAAFPG}
{\bkmkend AAAAAAAFPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start analysis here. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start analysis here \par
}}
{\xe \v analyzeInterleaving\:SVF::MHP}
{\xe \v SVF::MHP\:analyzeInterleaving}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MHP::analyzeInterleaving ()}}
\par
{\bkmkstart AAAAAAAFPH}
{\bkmkend AAAAAAAFPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Analyze thread interleaving. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Analyze thread interleaving \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
handle non-candidate function\par
handle candidate function\par
update non-candidate functions' interleaving\par
}}
{\xe \v mayHappenInParallelInst\:SVF::MHP}
{\xe \v SVF::MHP\:mayHappenInParallelInst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MHP::mayHappenInParallelInst (const Instruction *  {\i i1}, const Instruction *  {\i i2}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFPI}
{\bkmkend AAAAAAAFPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Answer {\b MHP} queries For a pair of ThreadStmts (t1,s1) = <l1> (t2,s2) = <l2> They may happen in parallel if (1) t1 == t2 and t1 inloop/incycle (2) t1!=t2 and t1 \\in l2 and t2 \\in l1 \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO: Any instruction in dead function is assumed no {\b MHP} with others\par
}}
{\xe \v printInterleaving\:SVF::MHP}
{\xe \v SVF::MHP\:printInterleaving}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MHP::printInterleaving ()}}
\par
{\bkmkstart AAAAAAAFPJ}
{\bkmkend AAAAAAAFPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print interleaving results. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print interleaving results \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/MHP.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MTA/MHP.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MHPValidator Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MHPValidator}
{\xe \v SVF::MHPValidator}
{\bkmkstart AAAAAAAIDI}
{\bkmkend AAAAAAAIDI}
Inheritance diagram for SVF::MHPValidator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_m_h_p_validator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MHPValidator} ({\b MHP} *mhp){\bkmkstart AAAAAAAIDJ}
{\bkmkend AAAAAAAIDJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b mayHappenInParallel} (const Instruction *I1, const Instruction *I2){\bkmkstart AAAAAAAIDK}
{\bkmkend AAAAAAAIDK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MTA/MHP.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Move Struct Reference\par \pard\plain 
{\tc\tcl2 \v Move}
{\xe \v Move}
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DdHalfWord {\b x}{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DdHalfWord {\b y}{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned int {\b flags}{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b size}{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b Move} * {\b next}{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/cuddInt.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MRGenerator Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MRGenerator}
{\xe \v SVF::MRGenerator}
{\bkmkstart AAAAAAAFAB}
{\bkmkend AAAAAAAFAB}
\par
{
{\f2 #include <MemRegion.h>}}\par
Inheritance diagram for SVF::MRGenerator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_m_r_generator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< NodeID > {\b WorkList}{\bkmkstart AAAAAAAFAC}
{\bkmkend AAAAAAAFAC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef OrderedSet< const {\b MemRegion} *, {\b MemRegion::equalMemRegion} > {\b MRSet}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get typedef from Pointer Analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b PAGEdge} *, const {\b SVFFunction} * > {\b PAGEdgeToFunMap}{\bkmkstart AAAAAAAFAD}
{\bkmkend AAAAAAAFAD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedSet< PointsTo, {\b MemRegion::equalPointsTo} > {\b PointsToList}{\bkmkstart AAAAAAAFAE}
{\bkmkend AAAAAAAFAE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, PointsToList > {\b FunToPointsToMap}{\bkmkstart AAAAAAAFAF}
{\bkmkend AAAAAAAFAF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< PointsTo, PointsTo, {\b MemRegion::equalPointsTo} > {\b PtsToRepPtsSetMap}{\bkmkstart AAAAAAAFAG}
{\bkmkend AAAAAAAFAG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, {\b MRSet} > {\b FunToMRsMap}{\bkmkstart AAAAAAAFAH}
{\bkmkend AAAAAAAFAH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Map a function to its region set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef Map< const {\b LoadPE} *, {\b MRSet} > {\b LoadsToMRsMap}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b StorePE} *, {\b MRSet} > {\b StoresToMRsMap}{\bkmkstart AAAAAAAFAI}
{\bkmkend AAAAAAAFAI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CallBlockNode} *, {\b MRSet} > {\b CallSiteToMRsMap}{\bkmkstart AAAAAAAFAJ}
{\bkmkend AAAAAAAFAJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b LoadPE} *, PointsTo > {\b LoadsToPointsToMap}{\bkmkstart AAAAAAAFAK}
{\bkmkend AAAAAAAFAK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Map loads/stores/callsites to their cpts set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b StorePE} *, PointsTo > {\b StoresToPointsToMap}{\bkmkstart AAAAAAAFAL}
{\bkmkend AAAAAAAFAL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CallBlockNode} *, PointsTo > {\b CallSiteToPointsToMap}{\bkmkstart AAAAAAAFAM}
{\bkmkend AAAAAAAFAM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef Map< const {\b SVFFunction} *, NodeBS > {\b FunToNodeBSMap}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maps Mod-Ref analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CallBlockNode} *, NodeBS > {\b CallSiteToNodeBSMap}{\bkmkstart AAAAAAAFAN}
{\bkmkend AAAAAAAFAN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Map a callsite to its indirect refs/mods of memory objects. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, NodeBS > {\b NodeToPTSSMap}{\bkmkstart AAAAAAAFAO}
{\bkmkend AAAAAAAFAO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PAG::PAGEdgeList {\b PAGEdgeList}{\bkmkstart AAAAAAAFAP}
{\bkmkend AAAAAAAFAP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} edge list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SCCDetection}< {\b PTACallGraph} * > {\b SCC}{\bkmkstart AAAAAAAFAQ}
{\bkmkend AAAAAAAFAQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call Graph SCC. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRSet} & {\b getMRSet} (){\bkmkstart AAAAAAAFAR}
{\bkmkend AAAAAAAFAR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const PointsTo & {\b getRepPointsTo} (const PointsTo &cpts) const{\bkmkstart AAAAAAAFAS}
{\bkmkend AAAAAAAFAS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get superset cpts set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MemRegion} * {\b getMR} (const PointsTo &cpts) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a memory region according to cpts. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b getMRNum} () const{\bkmkstart AAAAAAAFAT}
{\bkmkend AAAAAAAFAT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~MRGenerator} (){\bkmkstart AAAAAAAFAU}
{\bkmkend AAAAAAAFAU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b generateMRs} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start generating memory regions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getFunction} (const {\b PAGEdge} *pagEdge) const{\bkmkstart AAAAAAAFAV}
{\bkmkend AAAAAAAFAV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the function which {\b PAG} Edge located. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRSet} & {\b getFunMRSet} (const {\b SVFFunction} *fun){\bkmkstart AAAAAAAFAW}
{\bkmkend AAAAAAAFAW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Memory Region set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRSet} & {\b getLoadMRSet} (const {\b LoadPE} *load){\bkmkstart AAAAAAAFAX}
{\bkmkend AAAAAAAFAX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRSet} & {\b getStoreMRSet} (const {\b StorePE} *store){\bkmkstart AAAAAAAFAY}
{\bkmkend AAAAAAAFAY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasRefMRSet} (const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAFAZ}
{\bkmkend AAAAAAAFAZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasModMRSet} (const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAFBA}
{\bkmkend AAAAAAAFBA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRSet} & {\b getCallSiteRefMRSet} (const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAFBB}
{\bkmkend AAAAAAAFBB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRSet} & {\b getCallSiteModMRSet} (const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAFBC}
{\bkmkend AAAAAAAFBC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasPAGEdgeList} (const Instruction *inst){\bkmkstart AAAAAAAFBD}
{\bkmkend AAAAAAAFBD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this instruction has {\b PAG} Edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAGEdgeList} & {\b getPAGEdgesFromInst} (const Instruction *inst){\bkmkstart AAAAAAAFBE}
{\bkmkend AAAAAAAFBE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an instruction, get all its the {\b PAGEdge} (statement) in sequence. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
PointsTo {\b getModInfoForCall} (const {\b CallBlockNode} *cs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
getModRefInfo APIs }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
PointsTo {\b getRefInfoForCall} (const {\b CallBlockNode} *cs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ModRefInfo {\b getModRefInfo} (const {\b CallBlockNode} *cs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ModRefInfo {\b getModRefInfo} (const {\b CallBlockNode} *cs, const Value *V)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ModRefInfo {\b getModRefInfo} (const {\b CallBlockNode} *cs1, const {\b CallBlockNode} *cs2)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRGenerator} ({\b BVDataPTAImpl} *p, bool ptrOnly){\bkmkstart AAAAAAAFBF}
{\bkmkend AAAAAAAFBF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b createMR} (const {\b SVFFunction} *fun, const PointsTo &cpts)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate a memory region and put in into functions which use it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b collectGlobals} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect all global variables for later escape analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b collectModRefForLoadStore} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate regions for loads/stores. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b collectModRefForCall} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate regions for calls/rets. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b partitionMRs} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Partition regions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateAliasMRs} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update aliased regions for loads/stores/callsites. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b sortPointsTo} (const PointsTo &cpts)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a condition pts, insert into cptsToRepCPtsMap for region generation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isAliasedMR} (const PointsTo &cpts, const {\b MemRegion} *mr){\bkmkstart AAAAAAAFBG}
{\bkmkend AAAAAAAFBG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a region is aliased with a conditional points-to. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b getAliasMemRegions} ({\b MRSet} &aliasMRs, const PointsTo &cpts, const {\b SVFFunction} *fun){\bkmkstart AAAAAAAFBH}
{\bkmkend AAAAAAAFBH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all aliased mem regions from function fun according to cpts. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b getMRsForLoad} ({\b MRSet} &aliasMRs, const PointsTo &cpts, const {\b SVFFunction} *){\bkmkstart AAAAAAAEYW}
{\bkmkend AAAAAAAEYW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory regions for a load statement according to cpts. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b getMRsForCallSiteRef} ({\b MRSet} &aliasMRs, const PointsTo &cpts, const {\b SVFFunction} *){\bkmkstart AAAAAAAEYU}
{\bkmkend AAAAAAAEYU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory regions for call site ref according to cpts. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b modRefAnalysis} ({\b PTACallGraphNode} *callGraphNode, {\b WorkList} &worklist)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mod-Ref analysis for callsite invoking this callGraphNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b handleCallsiteModRef} (NodeBS &mod, NodeBS &ref, const {\b CallBlockNode} *cs, const {\b SVFFunction} *fun)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Mod-Ref of a callee function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addCPtsToStore} (PointsTo &cpts, const {\b StorePE} *st, const {\b SVFFunction} *fun){\bkmkstart AAAAAAAFBI}
{\bkmkend AAAAAAAFBI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add cpts to store/load. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addCPtsToLoad} (PointsTo &cpts, const {\b LoadPE} *ld, const {\b SVFFunction} *fun){\bkmkstart AAAAAAAFBJ}
{\bkmkend AAAAAAAFBJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addCPtsToCallSiteRefs} (PointsTo &cpts, const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAFBK}
{\bkmkend AAAAAAAFBK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addCPtsToCallSiteMods} (PointsTo &cpts, const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAFBL}
{\bkmkend AAAAAAAFBL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasCPtsList} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAAFBM}
{\bkmkend AAAAAAAFBM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PointsToList & {\b getPointsToList} (const {\b SVFFunction} *fun){\bkmkstart AAAAAAAFBN}
{\bkmkend AAAAAAAFBN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FunToPointsToMap & {\b getFunToPointsToList} (){\bkmkstart AAAAAAAFBO}
{\bkmkend AAAAAAAFBO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addRefSideEffectOfFunction} (const {\b SVFFunction} *fun, const NodeBS &refs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add/Get methods for side-effect of functions and callsites. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addModSideEffectOfFunction} (const {\b SVFFunction} *fun, const NodeBS &mods)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add indirect def an memory object in the function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addRefSideEffectOfCallSite} (const {\b CallBlockNode} *cs, const NodeBS &refs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add indirect uses an memory object in the function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addModSideEffectOfCallSite} (const {\b CallBlockNode} *cs, const NodeBS &mods)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add indirect def an memory object in the function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const NodeBS & {\b getRefSideEffectOfFunction} (const {\b SVFFunction} *fun){\bkmkstart AAAAAAAFBP}
{\bkmkend AAAAAAAFBP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get indirect refs of a function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const NodeBS & {\b getModSideEffectOfFunction} (const {\b SVFFunction} *fun){\bkmkstart AAAAAAAFBQ}
{\bkmkend AAAAAAAFBQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get indirect mods of a function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const NodeBS & {\b getRefSideEffectOfCallSite} (const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAFBR}
{\bkmkend AAAAAAAFBR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get indirect refs of a callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const NodeBS & {\b getModSideEffectOfCallSite} (const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAFBS}
{\bkmkend AAAAAAAFBS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get indirect mods of a callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasRefSideEffectOfCallSite} (const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAFBT}
{\bkmkend AAAAAAAFBT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has indirect refs of a callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasModSideEffectOfCallSite} (const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAFBU}
{\bkmkend AAAAAAAFBU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has indirect mods of a callsite. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRSet} {\b memRegSet}{\bkmkstart AAAAAAAFBV}
{\bkmkend AAAAAAAFBV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A set of All memory regions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PtsToRepPtsSetMap {\b cptsToRepCPtsMap}{\bkmkstart AAAAAAAFBW}
{\bkmkend AAAAAAAFBW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Map a condition pts to its rep conditional pts (super set points-to) }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory Region Partitioning \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v FunToNodeBSMap\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:FunToNodeBSMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef Map<const {\b SVFFunction}*, NodeBS> {\b SVF::MRGenerator::FunToNodeBSMap}}}
\par
{\bkmkstart AAAAAAAFBX}
{\bkmkend AAAAAAAFBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maps Mod-Ref analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Map a function to its indirect refs/mods of memory objects \par
}}
{\xe \v LoadsToMRsMap\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:LoadsToMRsMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef Map<const {\b LoadPE}*, {\b MRSet}> {\b SVF::MRGenerator::LoadsToMRsMap}}}
\par
{\bkmkstart AAAAAAAFBY}
{\bkmkend AAAAAAAFBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Map loads/stores to its mem regions, TODO:visitAtomicCmpXchgInst, visitAtomicRMWInst?? \par
}}
{\xe \v MRSet\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:MRSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef OrderedSet<const {\b MemRegion}*, {\b MemRegion::equalMemRegion}> {\b SVF::MRGenerator::MRSet}}}
\par
{\bkmkstart AAAAAAAFBZ}
{\bkmkend AAAAAAAFBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get typedef from Pointer Analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define mem region set \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addModSideEffectOfCallSite\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:addModSideEffectOfCallSite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MRGenerator::addModSideEffectOfCallSite (const {\b CallBlockNode} *  {\i cs}, const NodeBS &  {\i mods}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFCA}
{\bkmkend AAAAAAAFCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add indirect def an memory object in the function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add indirect def an memory object in the function \par
}}
{\xe \v addModSideEffectOfFunction\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:addModSideEffectOfFunction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MRGenerator::addModSideEffectOfFunction (const {\b SVFFunction} *  {\i fun}, const NodeBS &  {\i mods}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFCB}
{\bkmkend AAAAAAAFCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add indirect def an memory object in the function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add indirect def an memory object in the function \par
}}
{\xe \v addRefSideEffectOfCallSite\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:addRefSideEffectOfCallSite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MRGenerator::addRefSideEffectOfCallSite (const {\b CallBlockNode} *  {\i cs}, const NodeBS &  {\i refs}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFCC}
{\bkmkend AAAAAAAFCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add indirect uses an memory object in the function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add indirect uses an memory object in the function \par
}}
{\xe \v addRefSideEffectOfFunction\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:addRefSideEffectOfFunction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MRGenerator::addRefSideEffectOfFunction (const {\b SVFFunction} *  {\i fun}, const NodeBS &  {\i refs}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFCD}
{\bkmkend AAAAAAAFCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add/Get methods for side-effect of functions and callsites. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add indirect uses an memory object in the function \par
}}
{\xe \v collectGlobals\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:collectGlobals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MRGenerator::collectGlobals (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFCE}
{\bkmkend AAAAAAAFCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect all global variables for later escape analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect globals for escape analysis \par
}}
{\xe \v collectModRefForCall\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:collectModRefForCall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MRGenerator::collectModRefForCall (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFCF}
{\bkmkend AAAAAAAFCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate regions for calls/rets. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate memory regions for calls \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
collect points-to information for callsites\par
handle all sub scc nodes of this rep node\par
Get mod-ref of all callsites calling callGraphNode\par
mods are treated as both def and use of memory objects\par
}}
{\xe \v collectModRefForLoadStore\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:collectModRefForLoadStore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MRGenerator::collectModRefForLoadStore (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFCG}
{\bkmkend AAAAAAAFCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate regions for loads/stores. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate memory regions for loads/stores \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if this function does not have any caller, then we do not care its MSSA\par
}}
{\xe \v createMR\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:createMR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MRGenerator::createMR (const {\b SVFFunction} *  {\i fun}, const PointsTo &  {\i cpts}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFCH}
{\bkmkend AAAAAAAFCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate a memory region and put in into functions which use it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate a memory region and put in into functions which use it \par
}}
{\xe \v generateMRs\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:generateMRs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MRGenerator::generateMRs (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFCI}
{\bkmkend AAAAAAAFCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start generating memory regions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate memory regions according to pointer analysis results Attach regions on loads/stores \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
collect mod-ref for loads/stores\par
collect mod-ref for calls\par
Partition memory regions\par
attach memory regions for loads/stores/calls\par
}}
{\xe \v getModInfoForCall\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:getModInfoForCall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PointsTo MRGenerator::getModInfoForCall (const {\b CallBlockNode} *  {\i cs})}}
\par
{\bkmkstart AAAAAAAFCJ}
{\bkmkend AAAAAAAFCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
getModRefInfo APIs }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect mod ref for external callsite other than heap alloc external call\par
Obtain the mod sets for a call, used for external ModRefInfo queries \par
}}
{\xe \v getModRefInfo\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:getModRefInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ModRefInfo MRGenerator::getModRefInfo (const {\b CallBlockNode} *  {\i cs})}}
\par
{\bkmkstart AAAAAAAFCK}
{\bkmkend AAAAAAAFCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a CallSite instruction can mod or ref any memory location \par
}}
{\xe \v getModRefInfo\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:getModRefInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ModRefInfo MRGenerator::getModRefInfo (const {\b CallBlockNode} *  {\i cs}, const Value *  {\i V})}}
\par
{\bkmkstart AAAAAAAFCL}
{\bkmkend AAAAAAAFCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a const CallBlockNode* instruction can mod or ref a specific memory location pointed by V \par
}}
{\xe \v getModRefInfo\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:getModRefInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ModRefInfo MRGenerator::getModRefInfo (const {\b CallBlockNode} *  {\i cs1}, const {\b CallBlockNode} *  {\i cs2})}}
\par
{\bkmkstart AAAAAAAFCM}
{\bkmkend AAAAAAAFCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine mod-ref relations between two const CallBlockNode* instructions \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return NoModRef neither two callsites ref or mod any memory\par
Ref: cs1 ref memory mod by cs2\par
Mod: cs1 mod memory ref or mod by cs2\par
ModRef: cs1 ref and mod memory mod by cs2\par
}}
{\xe \v getMR\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:getMR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MemRegion} * MRGenerator::getMR (const PointsTo &  {\i cpts}) const}}
\par
{\bkmkstart AAAAAAAFCN}
{\bkmkend AAAAAAAFCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a memory region according to cpts. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate a memory region and put in into functions which use it \par
}}
{\xe \v getRefInfoForCall\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:getRefInfoForCall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PointsTo MRGenerator::getRefInfoForCall (const {\b CallBlockNode} *  {\i cs})}}
\par
{\bkmkstart AAAAAAAFCO}
{\bkmkend AAAAAAAFCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Obtain the ref sets for a call, used for external ModRefInfo queries \par
}}
{\xe \v handleCallsiteModRef\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:handleCallsiteModRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MRGenerator::handleCallsiteModRef (NodeBS &  {\i mod}, NodeBS &  {\i ref}, const {\b CallBlockNode} *  {\i cs}, const {\b SVFFunction} *  {\i callee}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFCP}
{\bkmkend AAAAAAAFCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Mod-Ref of a callee function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Mod-Ref of a callee function \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if a callee is a heap allocator function, then its mod set of this callsite is the heap object.\par
otherwise, we find the mod/ref sets from the callee function, who has definition and been processed\par
}}
{\xe \v modRefAnalysis\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:modRefAnalysis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MRGenerator::modRefAnalysis ({\b PTACallGraphNode} *  {\i callGraphNode}, {\b WorkList} &  {\i worklist}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFCQ}
{\bkmkend AAAAAAAFCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mod-Ref analysis for callsite invoking this callGraphNode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call site mod-ref analysis Compute mod-ref of all callsites invoking this call graph node \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add ref/mod set of callee to its invocation callsites at caller\par
handle direct callsites\par
handle indirect callsites\par
}}
{\xe \v partitionMRs\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:partitionMRs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MRGenerator::partitionMRs (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEYY}
{\bkmkend AAAAAAAEYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Partition regions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Partition memory regions \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute all superset of all condition points-to sets TODO: we may need some refined region partitioning algorithm here For now, we just collapse all refs/mods objects at callsites into one region Consider modularly partition memory regions to speed up analysis (only partition regions within function scope)\par
Generate memory regions according to condition pts after computing superset\par
}{
Reimplemented in {\b SVF::InterDisjointMRG} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEZL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::IntraDisjointMRG} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEZK \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::DistinctMRG} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEYX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v sortPointsTo\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:sortPointsTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MRGenerator::sortPointsTo (const PointsTo &  {\i cpts}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFCR}
{\bkmkend AAAAAAAFCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a condition pts, insert into cptsToRepCPtsMap for region generation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a condition pts, insert into cptsToRepCPtsMap Always map it to its superset(rep) cpts according to existing items 1) map cpts to its superset(rep) which exists in the map, otherwise its superset is itself 2) adjust existing items in the map if their supersets are cpts \par
}}
{\xe \v updateAliasMRs\:SVF::MRGenerator}
{\xe \v SVF::MRGenerator\:updateAliasMRs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MRGenerator::updateAliasMRs (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFCS}
{\bkmkend AAAAAAAFCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update aliased regions for loads/stores/callsites. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update aliased regions for loads/stores/callsites \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
update stores with its aliased regions\par
update callsites with its aliased regions\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MemRegion.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MSSA/MemRegion.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MRSVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MRSVFGNode}
{\xe \v SVF::MRSVFGNode}
{\bkmkstart AAAAAAACZK}
{\bkmkend AAAAAAACZK}
\par
{
{\f2 #include <SVFGNode.h>}}\par
Inheritance diagram for SVF::MRSVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_m_r_s_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const PointsTo & {\b getPointsTo} () const{\bkmkstart AAAAAAACZL}
{\bkmkend AAAAAAACZL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return points-to of the MR. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACZM}
{\bkmkend AAAAAAACZM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MRSVFGNode} *){\bkmkstart AAAAAAACZN}
{\bkmkend AAAAAAACZN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAACZO}
{\bkmkend AAAAAAACZO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAACZP}
{\bkmkend AAAAAAACZP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRSVFGNode} (NodeID id, {\b VFGNodeK} k){\bkmkstart AAAAAAACZQ}
{\bkmkend AAAAAAACZQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PointsTo {\b cpts}{\bkmkstart AAAAAAACZR}
{\bkmkend AAAAAAACZR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory region {\b VFGNode} (for address-taken objects) \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MRVer Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MRVer}
{\xe \v SVF::MRVer}
{\bkmkstart AAAAAAAFFU}
{\bkmkend AAAAAAAFFU}
\par
{
{\f2 #include <MSSAMuChi.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MSSADEF} {\b MSSADef}{\bkmkstart AAAAAAAFFV}
{\bkmkend AAAAAAAFFV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRVer} (const {\b MemRegion} *m, MRVERSION v, {\b MSSADef} *d){\bkmkstart AAAAAAAFFW}
{\bkmkend AAAAAAAFFW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemRegion} * {\b getMR} () const{\bkmkstart AAAAAAAFFX}
{\bkmkend AAAAAAAFFX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the memory region. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

MRVERSION {\b getSSAVersion} () const{\bkmkstart AAAAAAAFFY}
{\bkmkend AAAAAAAFFY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return SSA version. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MSSADef} * {\b getDef} () const{\bkmkstart AAAAAAAFFZ}
{\bkmkend AAAAAAAFFZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get MSSADef. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory SSA Variable (in the form of SSA versions of each memory region ) \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MSSAMuChi.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MSSA/MemRegion.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MSSACHI< Cond > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MSSACHI< Cond >}
{\xe \v SVF::MSSACHI< Cond >}
{\bkmkstart AAAAAAAFHU}
{\bkmkend AAAAAAAFHU}
\par
{
{\f2 #include <MSSAMuChi.h>}}\par
Inheritance diagram for SVF::MSSACHI< Cond >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_m_s_s_a_c_h_i.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef MSSADEF::DEFTYPE {\b CHITYPE}{\bkmkstart AAAAAAAFHV}
{\bkmkend AAAAAAAFHV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MSSACHI} (CHITYPE t, const {\b MemRegion} *m, Cond c){\bkmkstart AAAAAAAFHW}
{\bkmkend AAAAAAAFHW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor/Destructer for {\b MSSACHI}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setOpVer} ({\b MRVer} *v){\bkmkstart AAAAAAAFHX}
{\bkmkend AAAAAAAFHX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set operand ver. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRVer} * {\b getOpVer} () const{\bkmkstart AAAAAAAFHY}
{\bkmkend AAAAAAAFHY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get operand ver. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Cond {\b getCond} () const{\bkmkstart AAAAAAAFHZ}
{\bkmkend AAAAAAAFHZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get condition. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dump} (){\bkmkstart AAAAAAAFIA}
{\bkmkend AAAAAAAFIA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print CHI. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MSSACHI} *chi){\bkmkstart AAAAAAAFIB}
{\bkmkend AAAAAAAFIB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MSSADEF} *chi){\bkmkstart AAAAAAAFIC}
{\bkmkend AAAAAAAFIC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Cond>\par
class SVF::MSSACHI< Cond >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Indirect Memory Write \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MSSAMuChi.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MSSADEF Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MSSADEF}
{\xe \v SVF::MSSADEF}
{\bkmkstart AAAAAAAFHI}
{\bkmkend AAAAAAAFHI}
\par
{
{\f2 #include <MSSAMuChi.h>}}\par
Inheritance diagram for SVF::MSSADEF:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_m_s_s_a_d_e_f.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b DEFTYPE} \{ {\b SSACHI}
, {\b StoreMSSACHI}
, {\b CallMSSACHI}
, {\b EntryMSSACHI}
, {\b SSAPHI}
 \}{\bkmkstart AAAAAAAFHJ}
{\bkmkend AAAAAAAFHJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MSSADEF} (DEFTYPE t, const {\b MemRegion} *m){\bkmkstart AAAAAAAFHK}
{\bkmkend AAAAAAAFHK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor/Destructer for {\b MSSADEF}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemRegion} * {\b getMR} () const{\bkmkstart AAAAAAAFHL}
{\bkmkend AAAAAAAFHL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return memory region. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DEFTYPE {\b getType} () const{\bkmkstart AAAAAAAFHM}
{\bkmkend AAAAAAAFHM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return type of this CHI. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setResVer} ({\b MRVer} *v){\bkmkstart AAAAAAAFHN}
{\bkmkend AAAAAAAFHN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set result operand ver. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRVer} * {\b getResVer} () const{\bkmkstart AAAAAAAFHO}
{\bkmkend AAAAAAAFHO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set operand vers. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator<} (const {\b MSSADEF} &rhs) const{\bkmkstart AAAAAAAFHP}
{\bkmkend AAAAAAAFHP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Avoid adding duplicated chis and phis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dump} (){\bkmkstart AAAAAAAFHQ}
{\bkmkend AAAAAAAFHQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print MSSADef. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DEFTYPE {\b type}{\bkmkstart AAAAAAAFHR}
{\bkmkend AAAAAAAFHR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemRegion} * {\b mr}{\bkmkstart AAAAAAAFHS}
{\bkmkend AAAAAAAFHS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRVer} * {\b resVer}{\bkmkstart AAAAAAAFHT}
{\bkmkend AAAAAAAFHT}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Indirect Memory Definition 1) {\b MSSACHI} indirect memory object is modified a) {\b StoreCHI} definition at store b) {\b EntryCHI} definition at function entry 2) {\b MSSAPHI} memory object is defined at joint points of a control flow \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MSSAMuChi.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MSSAMU< Cond > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MSSAMU< Cond >}
{\xe \v SVF::MSSAMU< Cond >}
{\bkmkstart AAAAAAAFGA}
{\bkmkend AAAAAAAFGA}
\par
{
{\f2 #include <MSSAMuChi.h>}}\par
Inheritance diagram for SVF::MSSAMU< Cond >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_m_s_s_a_m_u.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b MUTYPE} \{ {\b LoadMSSAMU}
, {\b CallMSSAMU}
, {\b RetMSSAMU}
 \}{\bkmkstart AAAAAAAFGB}
{\bkmkend AAAAAAAFGB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MSSAMU} (MUTYPE t, const {\b MemRegion} *m, Cond c){\bkmkstart AAAAAAAFGC}
{\bkmkend AAAAAAAFGC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor/Destructor for MU. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemRegion} * {\b getMR} () const{\bkmkstart AAAAAAAFGD}
{\bkmkend AAAAAAAFGD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return MR. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

MUTYPE {\b getType} () const{\bkmkstart AAAAAAAFGE}
{\bkmkend AAAAAAAFGE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setVer} ({\b MRVer} *v){\bkmkstart AAAAAAAFGF}
{\bkmkend AAAAAAAFGF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set Ver. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRVer} * {\b getVer} () const{\bkmkstart AAAAAAAFGG}
{\bkmkend AAAAAAAFGG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Ver. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Cond {\b getCond} () const{\bkmkstart AAAAAAAFGH}
{\bkmkend AAAAAAAFGH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return condition. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator<} (const {\b MSSAMU} &rhs) const{\bkmkstart AAAAAAAFGI}
{\bkmkend AAAAAAAFGI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Avoid adding duplicated mus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dump} (){\bkmkstart AAAAAAAFGJ}
{\bkmkend AAAAAAAFGJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print MU. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

MUTYPE {\b type}{\bkmkstart AAAAAAAFGK}
{\bkmkend AAAAAAAFGK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemRegion} * {\b mr}{\bkmkstart AAAAAAAFGL}
{\bkmkend AAAAAAAFGL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MRVer} * {\b ver}{\bkmkstart AAAAAAAFGM}
{\bkmkend AAAAAAAFGM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Cond {\b cond}{\bkmkstart AAAAAAAFGN}
{\bkmkend AAAAAAAFGN}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Cond>\par
class SVF::MSSAMU< Cond >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Indirect Memory Read 1) {\b LoadMU} at each store instruction 2) {\b CallMU} at callsite 3) {\b RetMU} at function return \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MSSAMuChi.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MSSAPHI< Cond > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MSSAPHI< Cond >}
{\xe \v SVF::MSSAPHI< Cond >}
{\bkmkstart AAAAAAAFJA}
{\bkmkend AAAAAAAFJA}
Inheritance diagram for SVF::MSSAPHI< Cond >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_m_s_s_a_p_h_i.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< u32_t, const {\b MRVer} * > {\b OPVers}{\bkmkstart AAAAAAAFJB}
{\bkmkend AAAAAAAFJB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MSSAPHI} (const BasicBlock *b, const {\b MemRegion} *m, Cond c=PathCondAllocator::trueCond()){\bkmkstart AAAAAAAFJC}
{\bkmkend AAAAAAAFJC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructors for PHI. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setOpVer} (const {\b MRVer} *v, u32_t pos){\bkmkstart AAAAAAAFJD}
{\bkmkend AAAAAAAFJD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set operand ver. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MRVer} * {\b getOpVer} (u32_t pos) const{\bkmkstart AAAAAAAFJE}
{\bkmkend AAAAAAAFJE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get operand ver. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getOpVerNum} () const{\bkmkstart AAAAAAAFJF}
{\bkmkend AAAAAAAFJF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the number of operand ver. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers::const_iterator {\b opVerBegin} () const{\bkmkstart AAAAAAAFJG}
{\bkmkend AAAAAAAFJG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operand ver iterators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers::const_iterator {\b opVerEnd} () const{\bkmkstart AAAAAAAFJH}
{\bkmkend AAAAAAAFJH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const BasicBlock * {\b getBasicBlock} () const{\bkmkstart AAAAAAAFJI}
{\bkmkend AAAAAAAFJI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the basic block. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Cond {\b getCond} () const{\bkmkstart AAAAAAAFJJ}
{\bkmkend AAAAAAAFJJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return condition. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dump} (){\bkmkstart AAAAAAAFJK}
{\bkmkend AAAAAAAFJK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print PHI. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MSSAPHI} *phi){\bkmkstart AAAAAAAFJL}
{\bkmkend AAAAAAAFJL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MSSADEF} *phi){\bkmkstart AAAAAAAFJM}
{\bkmkend AAAAAAAFJM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MSSAMuChi.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MSSAPHISVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MSSAPHISVFGNode}
{\xe \v SVF::MSSAPHISVFGNode}
{\bkmkstart AAAAAAADAW}
{\bkmkend AAAAAAADAW}
Inheritance diagram for SVF::MSSAPHISVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_m_s_s_a_p_h_i_s_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< u32_t, const {\b MRVer} * > {\b OPVers}{\bkmkstart AAAAAAADAX}
{\bkmkend AAAAAAADAX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MSSAPHISVFGNode} (NodeID id, const {\b MemSSA::MDEF} *def, {\b VFGNodeK} k=MPhi){\bkmkstart AAAAAAADAY}
{\bkmkend AAAAAAADAY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MRVer} * {\b getOpVer} (u32_t pos) const{\bkmkstart AAAAAAADAZ}
{\bkmkend AAAAAAADAZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MSSA phi operands. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setOpVer} (u32_t pos, const {\b MRVer} *node){\bkmkstart AAAAAAADBA}
{\bkmkend AAAAAAADBA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemSSA::MDEF} * {\b getRes} () const{\bkmkstart AAAAAAADBB}
{\bkmkend AAAAAAADBB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getOpVerNum} () const{\bkmkstart AAAAAAADBC}
{\bkmkend AAAAAAADBC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers::const_iterator {\b opVerBegin} () const{\bkmkstart AAAAAAADBD}
{\bkmkend AAAAAAADBD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers::const_iterator {\b opVerEnd} () const{\bkmkstart AAAAAAADBE}
{\bkmkend AAAAAAADBE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADBF}
{\bkmkend AAAAAAADBF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MSSAPHISVFGNode} *){\bkmkstart AAAAAAADBG}
{\bkmkend AAAAAAADBG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MRSVFGNode} *node){\bkmkstart AAAAAAADBH}
{\bkmkend AAAAAAADBH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADBI}
{\bkmkend AAAAAAADBI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADBJ}
{\bkmkend AAAAAAADBJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemSSA::MDEF} * {\b res}{\bkmkstart AAAAAAADBK}
{\bkmkend AAAAAAADBK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers {\b opVers}{\bkmkstart AAAAAAADBL}
{\bkmkend AAAAAAADBL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MTA Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MTA}
{\xe \v SVF::MTA}
{\bkmkstart AAAAAAAFQE}
{\bkmkend AAAAAAAFQE}
\par
{
{\f2 #include <MTA.h>}}\par
Inheritance diagram for SVF::MTA:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_m_t_a.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const LoadInst * > {\b LoadSet}{\bkmkstart AAAAAAAFQF}
{\bkmkend AAAAAAAFQF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const StoreInst * > {\b StoreSet}{\bkmkstart AAAAAAAFQG}
{\bkmkend AAAAAAAFQG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Function *, ScalarEvolution * > {\b FunToSEMap}{\bkmkstart AAAAAAAFQH}
{\bkmkend AAAAAAAFQH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Function *, LoopInfo * > {\b FunToLoopInfoMap}{\bkmkstart AAAAAAAFQI}
{\bkmkend AAAAAAAFQI}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MTA} (){\bkmkstart AAAAAAAFQJ}
{\bkmkend AAAAAAAFQJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~MTA} (){\bkmkstart AAAAAAAFQK}
{\bkmkend AAAAAAAFQK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b runOnModule} (Module &module){\bkmkstart AAAAAAAFQL}
{\bkmkend AAAAAAAFQL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start the pass here. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b runOnModule} ({\b SVFModule} *module)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start the pass here. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b MHP} * {\b computeMHP} ({\b SVFModule} *module){\bkmkstart AAAAAAAFQM}
{\bkmkend AAAAAAAFQM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute {\b MHP}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b LockAnalysis} * {\b computeLocksets} ({\b TCT} *tct)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute locksets. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b detect} ({\b SVFModule} *module){\bkmkstart AAAAAAAFQN}
{\bkmkend AAAAAAAFQN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform detection. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual StringRef {\b getPassName} () const{\bkmkstart AAAAAAAFQO}
{\bkmkend AAAAAAAFQO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pass name. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dump} (Module &module, {\b MHP} *mhp, {\b LockAnalysis} *lsa){\bkmkstart AAAAAAAFQP}
{\bkmkend AAAAAAAFQP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b getAnalysisUsage} (AnalysisUsage &au) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get analysis usage. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static ScalarEvolution * {\b getSE} (const Function *F){\bkmkstart AAAAAAAFQQ}
{\bkmkend AAAAAAAFQQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static char {\b ID} = 0{\bkmkstart AAAAAAAFQR}
{\bkmkend AAAAAAAFQR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pass ID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static ModulePass * {\b modulePass} = NULL{\bkmkstart AAAAAAAFQS}
{\bkmkend AAAAAAAFQS}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base data race detector \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v computeLocksets\:SVF::MTA}
{\xe \v SVF::MTA\:computeLocksets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LockAnalysis} * MTA::computeLocksets ({\b TCT} *  {\i tct}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFQT}
{\bkmkend AAAAAAAFQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute locksets. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute lock sets \par
}}
{\xe \v getAnalysisUsage\:SVF::MTA}
{\xe \v SVF::MTA\:getAnalysisUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void SVF::MTA::getAnalysisUsage (AnalysisUsage &  {\i au}) const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFQU}
{\bkmkend AAAAAAAFQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get analysis usage. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
do not intend to change the IR in this pass,\par
}}
{\xe \v runOnModule\:SVF::MTA}
{\xe \v SVF::MTA\:runOnModule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MTA::runOnModule ({\b SVFModule} *  {\i module}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFQV}
{\bkmkend AAAAAAAFQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start the pass here. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform data race detection \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/MTA.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MTA/MTA.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MTAAnnotator Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MTAAnnotator}
{\xe \v SVF::MTAAnnotator}
{\bkmkstart AAAAAAAFQW}
{\bkmkend AAAAAAAFQW}
\par
{
{\f2 #include <MTAAnnotator.h>}}\par
Inheritance diagram for SVF::MTAAnnotator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_m_t_a_annotator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const Instruction * > {\b InstSet}{\bkmkstart AAAAAAAFQX}
{\bkmkend AAAAAAAFQX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MTAAnnotator} (){\bkmkstart AAAAAAAFQY}
{\bkmkend AAAAAAAFQY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~MTAAnnotator} (){\bkmkstart AAAAAAAFQZ}
{\bkmkend AAAAAAAFQZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b annotateDRCheck} (Instruction *inst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Annotation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b initialize} ({\b MHP} *mhp, {\b LockAnalysis} *lsa){\bkmkstart AAAAAAAFRA}
{\bkmkend AAAAAAAFRA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pruneThreadLocal} ({\b PointerAnalysis} *pta)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prune candidate instructions that are thread local. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pruneAliasMHP} ({\b PointerAnalysis} *pta)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prune candidate instructions that non-mhp and non-alias with others. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b performAnnotate} (){\bkmkstart AAAAAAAFRB}
{\bkmkend AAAAAAAFRB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform annotation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b collectLoadStoreInst} ({\b SVFModule} *mod){\bkmkstart AAAAAAAFRC}
{\bkmkend AAAAAAAFRC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect all load and store instruction. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getStoreOperand} (const Instruction *inst){\bkmkstart AAAAAAAFRD}
{\bkmkend AAAAAAAFRD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get operand of store and load. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getLoadOperand} (const Instruction *inst){\bkmkstart AAAAAAAFRE}
{\bkmkend AAAAAAAFRE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isMemset} (const Instruction *I){\bkmkstart AAAAAAAFRF}
{\bkmkend AAAAAAAFRF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if Function "F" is memset. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isMemcpy} (const Instruction *I){\bkmkstart AAAAAAAFRG}
{\bkmkend AAAAAAAFRG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if Function "F" is memcpy. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b numOfAllSt}{\bkmkstart AAAAAAAFRH}
{\bkmkend AAAAAAAFRH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b numOfAllLd}{\bkmkstart AAAAAAAFRI}
{\bkmkend AAAAAAAFRI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b numOfNonLocalSt}{\bkmkstart AAAAAAAFRJ}
{\bkmkend AAAAAAAFRJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b numOfNonLocalLd}{\bkmkstart AAAAAAAFRK}
{\bkmkend AAAAAAAFRK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b numOfAliasSt}{\bkmkstart AAAAAAAFRL}
{\bkmkend AAAAAAAFRL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b numOfAliasLd}{\bkmkstart AAAAAAAFRM}
{\bkmkend AAAAAAAFRM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b numOfMHPSt}{\bkmkstart AAAAAAAFRN}
{\bkmkend AAAAAAAFRN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b numOfMHPLd}{\bkmkstart AAAAAAAFRO}
{\bkmkend AAAAAAAFRO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b numOfAnnotatedSt}{\bkmkstart AAAAAAAFRP}
{\bkmkend AAAAAAAFRP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b numOfAnnotatedLd}{\bkmkstart AAAAAAAFRQ}
{\bkmkend AAAAAAAFRQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const u32_t {\b ANNO_MHP} = 0x04{\bkmkstart AAAAAAAFRR}
{\bkmkend AAAAAAAFRR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constant INTERLEV_FLAG values. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const u32_t {\b ANNO_ALIAS} = 0x02{\bkmkstart AAAAAAAFRS}
{\bkmkend AAAAAAAFRS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const u32_t {\b ANNO_LOCAL} = 0x01{\bkmkstart AAAAAAAFRT}
{\bkmkend AAAAAAAFRT}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b MTA} annotation \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v annotateDRCheck\:SVF::MTAAnnotator}
{\xe \v SVF::MTAAnnotator\:annotateDRCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MTAAnnotator::annotateDRCheck (Instruction *  {\i inst})}}
\par
{\bkmkstart AAAAAAAFRU}
{\bkmkend AAAAAAAFRU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Annotation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
memcpy and memset is not annotated\par
}}
{\xe \v pruneAliasMHP\:SVF::MTAAnnotator}
{\xe \v SVF::MTAAnnotator\:pruneAliasMHP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MTAAnnotator::pruneAliasMHP ({\b PointerAnalysis} *  {\i pta})}}
\par
{\bkmkstart AAAAAAAFRV}
{\bkmkend AAAAAAAFRV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prune candidate instructions that non-mhp and non-alias with others. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if it1 == it2, mhp analysis will annotate it1 that locates in loop or recursion. but alias analysis fails to determine whether it1 is in loop or recursion, that means all store instructions will be annotated by alias analysis to guarantee sound.\par
}}
{\xe \v pruneThreadLocal\:SVF::MTAAnnotator}
{\xe \v SVF::MTAAnnotator\:pruneThreadLocal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MTAAnnotator::pruneThreadLocal ({\b PointerAnalysis} *  {\i pta})}}
\par
{\bkmkstart AAAAAAAFRW}
{\bkmkend AAAAAAAFRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prune candidate instructions that are thread local. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
find fork arguments' objects\par
find global pointer-to objects\par
find all non-local objects that are transitively pointed by global and fork arguments.\par
compute all store and load instructions that may operate a non-local object.\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/MTAAnnotator.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MTA/MTAAnnotator.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MTAResultValidator Class Reference\par \pard\plain 
{\tc\tcl2 \v MTAResultValidator}
{\xe \v MTAResultValidator}
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
\par
{
{\f2 #include <MTAResultValidator.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef int {\b INTERLEV_FLAG}{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MTAResultValidator} (MHP *mh){\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b analyze} (){\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::vector< std::string > & {\b split} (const std::string &s, char delim, std::vector< std::string > &elems){\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::vector< std::string > {\b split} (const std::string &s, char delim){\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getIntArg} (const Instruction *inst, unsigned int arg_num){\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::vector< std::string > {\b getStringArg} (const Instruction *inst, unsigned int arg_num){\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallStrCxt {\b getCxtArg} (const Instruction *inst, unsigned int arg_num){\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Instruction * {\b getPreviousMemoryAccessInst} (const Instruction *I){\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b matchCxt} (const CallStrCxt cxt1, const CallStrCxt cxt2) const{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dumpCxt} (const CallStrCxt &cxt) const{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dumpInterlev} (NodeBS &lev){\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b getOutput} (const char *scenario, bool analysisRes){\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b getOutputforInterlevAnalysis} (const char *scenario, INTERLEV_FLAG analysisRes){\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b collectCallsiteTargets} (){\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b collectCxtThreadTargets} (){\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b collectTCTTargets} (){\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b collectInterleavingTargets} (){\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b validateCxtThread} (){\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b validateTCT} (){\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

INTERLEV_FLAG {\b validateInterleaving} (){\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Validate the result of context-sensitive analysis, including context-sensitive thread detection and thread interleaving. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/MTAResultValidator.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MTA/MTAResultValidator.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MTAStat Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MTAStat}
{\xe \v SVF::MTAStat}
{\bkmkstart AAAAAAAFRX}
{\bkmkend AAAAAAAFRX}
\par
{
{\f2 #include <MTAStat.h>}}\par
Inheritance diagram for SVF::MTAStat:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_m_t_a_stat.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const Instruction * > {\b InstSet}{\bkmkstart AAAAAAAFRY}
{\bkmkend AAAAAAAFRY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MTAStat} (){\bkmkstart AAAAAAAFRZ}
{\bkmkend AAAAAAAFRZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b performThreadCallGraphStat} ({\b ThreadCallGraph} *tcg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics for thread call graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b performTCTStat} ({\b TCT} *tct){\bkmkstart AAAAAAAFSA}
{\bkmkend AAAAAAAFSA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics for thread creation tree. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b performMHPPairStat} ({\b MHP} *mhp, {\b LockAnalysis} *lsa)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics for {\b MHP} statement pairs. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b performAnnotationStat} ({\b MTAAnnotator} *anno){\bkmkstart AAAAAAAFSB}
{\bkmkend AAAAAAAFSB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics for annotation. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b TCTTime}{\bkmkstart AAAAAAAFSC}
{\bkmkend AAAAAAAFSC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b MHPTime}{\bkmkstart AAAAAAAFSD}
{\bkmkend AAAAAAAFSD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b FSMPTATime}{\bkmkstart AAAAAAAFSE}
{\bkmkend AAAAAAAFSE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b AnnotationTime}{\bkmkstart AAAAAAAFSF}
{\bkmkend AAAAAAAFSF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics for {\b MTA} \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v performMHPPairStat\:SVF::MTAStat}
{\xe \v SVF::MTAStat\:performMHPPairStat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MTAStat::performMHPPairStat ({\b MHP} *  {\i mhp}, {\b LockAnalysis} *  {\i lsa})}}
\par
{\bkmkstart AAAAAAAFSG}
{\bkmkend AAAAAAAFSG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics for {\b MHP} statement pairs. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterate every memory access pairs write vs read write vs write \par
}}
{\xe \v performThreadCallGraphStat\:SVF::MTAStat}
{\xe \v SVF::MTAStat\:performThreadCallGraphStat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MTAStat::performThreadCallGraphStat ({\b ThreadCallGraph} *  {\i tcg})}}
\par
{\bkmkstart AAAAAAAFSH}
{\bkmkend AAAAAAAFSH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics for thread call graph. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics for thread call graph \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/MTAStat.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MTA/MTAStat.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MTASVFGBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MTASVFGBuilder}
{\xe \v SVF::MTASVFGBuilder}
{\bkmkstart AAAAAAAFKO}
{\bkmkend AAAAAAAFKO}
\par
{
{\f2 #include <FSMPTA.h>}}\par
Inheritance diagram for SVF::MTASVFGBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_m_t_a_s_v_f_g_builder.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PointerAnalysis::CallSiteSet {\b CallSiteSet}{\bkmkstart AAAAAAAFKP}
{\bkmkend AAAAAAAFKP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PointerAnalysis::CallEdgeMap {\b CallEdgeMap}{\bkmkstart AAAAAAAFKQ}
{\bkmkend AAAAAAAFKQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PointerAnalysis::FunctionSet {\b FunctionSet}{\bkmkstart AAAAAAAFKR}
{\bkmkend AAAAAAAFKR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b SVFGNode} * > {\b SVFGNodeSet}{\bkmkstart AAAAAAAFKS}
{\bkmkend AAAAAAAFKS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const {\b SVFGNode} * > {\b SVFGNodeVec}{\bkmkstart AAAAAAAFKT}
{\bkmkend AAAAAAAFKT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeBS {\b SVFGNodeIDSet}{\bkmkstart AAAAAAAFKU}
{\bkmkend AAAAAAAFKU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const Instruction * > {\b InstSet}{\bkmkstart AAAAAAAFKV}
{\bkmkend AAAAAAAFKV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::pair< NodeID, NodeID > {\b NodeIDPair}{\bkmkstart AAAAAAAFKW}
{\bkmkend AAAAAAAFKW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::pair< const {\b StmtSVFGNode} *, LockAnalysis::LockSpan > {\b SVFGNodeLockSpanPair}{\bkmkstart AAAAAAAFKX}
{\bkmkend AAAAAAAFKX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< SVFGNodeLockSpanPair, bool > {\b PairToBoolMap}{\bkmkstart AAAAAAAFKY}
{\bkmkend AAAAAAAFKY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MTASVFGBuilder} ({\b MHP} *m, {\b LockAnalysis} *la){\bkmkstart AAAAAAAFKZ}
{\bkmkend AAAAAAAFKZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~MTASVFGBuilder} (){\bkmkstart AAAAAAAFLA}
{\bkmkend AAAAAAAFLA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u32_t {\b numOfNewSVFGEdges} = 0{\bkmkstart AAAAAAAFLB}
{\bkmkend AAAAAAAFLB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of newly added {\b SVFG} edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u32_t {\b numOfRemovedSVFGEdges} = 0{\bkmkstart AAAAAAAFLC}
{\bkmkend AAAAAAAFLC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u32_t {\b numOfRemovedPTS} = 0{\bkmkstart AAAAAAAFLD}
{\bkmkend AAAAAAAFLD}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b buildSVFG} (){\bkmkstart AAAAAAAFKM}
{\bkmkend AAAAAAAFKM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Re-write create {\b SVFG} method. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SVFG} builder for DDA \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/FSMPTA.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MTA/FSMPTA.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MtrNode Struct Reference\par \pard\plain 
{\tc\tcl2 \v MtrNode}
{\xe \v MtrNode}
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

MtrHalfWord {\b flags}{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

MtrHalfWord {\b low}{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

MtrHalfWord {\b size}{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

MtrHalfWord {\b index}{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b MtrNode} * {\b parent}{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b MtrNode} * {\b child}{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b MtrNode} * {\b elder}{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

struct {\b MtrNode} * {\b younger}{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/mtr.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MutableDFPTData< Key, Datum, Data > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MutableDFPTData< Key, Datum, Data >}
{\xe \v SVF::MutableDFPTData< Key, Datum, Data >}
{\bkmkstart AAAAAAAEFH}
{\bkmkend AAAAAAAEFH}
Inheritance diagram for SVF::MutableDFPTData< Key, Datum, Data >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_mutable_d_f_p_t_data.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b PTData}< Key, Datum, Data > {\b BasePTData}{\bkmkstart AAAAAAAEFI}
{\bkmkend AAAAAAAEFI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MutablePTData}< Key, Datum, Data > {\b BaseMutPTData}{\bkmkstart AAAAAAAEFJ}
{\bkmkend AAAAAAAEFJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b DFPTData}< Key, Datum, Data > {\b BaseDFPTData}{\bkmkstart AAAAAAAEFK}
{\bkmkend AAAAAAAEFK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b BasePTData::PTDataTy} {\b PTDataTy}{\bkmkstart AAAAAAAEFL}
{\bkmkend AAAAAAAEFL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef BasePTData::KeySet {\b KeySet}{\bkmkstart AAAAAAAEFM}
{\bkmkend AAAAAAAEFM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef BaseDFPTData::LocID {\b LocID}{\bkmkstart AAAAAAAEFN}
{\bkmkend AAAAAAAEFN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef BaseMutPTData::PtsMap {\b PtsMap}{\bkmkstart AAAAAAAEFO}
{\bkmkend AAAAAAAEFO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef BaseMutPTData::PtsMapConstIter {\b PtsMapConstIter}{\bkmkstart AAAAAAAEFP}
{\bkmkend AAAAAAAEFP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< LocID, PtsMap > {\b DFPtsMap}{\bkmkstart AAAAAAAEFQ}
{\bkmkend AAAAAAAEFQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Data-flow point-to map. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef DFPtsMap::iterator {\b DFPtsMapIter}{\bkmkstart AAAAAAAEFR}
{\bkmkend AAAAAAAEFR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef DFPtsMap::const_iterator {\b DFPtsMapconstIter}{\bkmkstart AAAAAAAEFS}
{\bkmkend AAAAAAAEFS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MutableDFPTData} (bool reversePT=true, {\b PTDataTy} ty=BaseDFPTData::MutDataFlow){\bkmkstart AAAAAAAEFT}
{\bkmkend AAAAAAAEFT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const PtsMap & {\b getPtsMap} () const{\bkmkstart AAAAAAAEFU}
{\bkmkend AAAAAAAEFU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clear} () override{\bkmkstart AAAAAAAEFV}
{\bkmkend AAAAAAAEFV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears all points-to sets as if nothing is stored. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const Data & {\b getPts} (const Key &var) override{\bkmkstart AAAAAAAEFW}
{\bkmkend AAAAAAAEFW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get points-to set of var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const KeySet & {\b getRevPts} (const Datum &datum) override{\bkmkstart AAAAAAAEFX}
{\bkmkend AAAAAAAEFX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get reverse points-to set of datum. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b hasDFInSet} (LocID loc) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b hasDFOutSet} (LocID loc) const override{\bkmkstart AAAAAAAEFY}
{\bkmkend AAAAAAAEFY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b hasDFInSet} (LocID loc, const Key &var) const override{\bkmkstart AAAAAAAEFZ}
{\bkmkend AAAAAAAEFZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b hasDFOutSet} (LocID loc, const Key &var) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual Data & {\b getDFInPtsSet} (LocID loc, const Key &var) override{\bkmkstart AAAAAAAEGA}
{\bkmkend AAAAAAAEGA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual Data & {\b getDFOutPtsSet} (LocID loc, const Key &var) override{\bkmkstart AAAAAAAEGB}
{\bkmkend AAAAAAAEGB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b updateDFInFromIn} (LocID srcLoc, const Key &srcVar, LocID dstLoc, const Key &dstVar) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateDFInFromOut} (LocID srcLoc, const Key &srcVar, LocID dstLoc, const Key &dstVar) override{\bkmkstart AAAAAAAEGC}
{\bkmkend AAAAAAAEGC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union (IN[dstLoc:dstVar], OUT[srcLoc:srcVar]). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateDFOutFromIn} (LocID srcLoc, const Key &srcVar, LocID dstLoc, const Key &dstVar) override{\bkmkstart AAAAAAAEGD}
{\bkmkend AAAAAAAEGD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union (OUT[dstLoc:dstVar], IN[srcLoc:srcVar]). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateAllDFInFromOut} (LocID srcLoc, const Key &srcVar, LocID dstLoc, const Key &dstVar) override{\bkmkstart AAAAAAAEGE}
{\bkmkend AAAAAAAEGE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union (IN[dstLoc::dstVar], OUT[srcLoc:srcVar]. There is no flag check, unlike the above. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateAllDFInFromIn} (LocID srcLoc, const Key &srcVar, LocID dstLoc, const Key &dstVar) override{\bkmkstart AAAAAAAEGF}
{\bkmkend AAAAAAAEGF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Union (IN[dstLoc::dstVar], IN[srcLoc:srcVar]. There is no flag check, unlike the above. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b updateAllDFOutFromIn} (LocID loc, const Key &singleton, bool strongUpdates) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For each variable var in IN at loc, do updateDFOutFromIn(loc, var, loc, var). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateTLVPts} (LocID srcLoc, const Key &srcVar, const Key &dstVar) override{\bkmkstart AAAAAAAEGG}
{\bkmkend AAAAAAAEGG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update points-to set of top-level pointers with IN[srcLoc:srcVar]. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateATVPts} (const Key &srcVar, LocID dstLoc, const Key &dstVar) override{\bkmkstart AAAAAAAEGH}
{\bkmkend AAAAAAAEGH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update address-taken variables OUT[dstLoc:dstVar] with points-to of top-level pointers. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearAllDFOutUpdatedVar} (LocID) override{\bkmkstart AAAAAAAEGI}
{\bkmkend AAAAAAAEGI}
\par
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \par
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const PtsMap & {\b getDFInPtsMap} (LocID loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const PtsMap & {\b getDFOutPtsMap} (LocID loc){\bkmkstart AAAAAAAEGJ}
{\bkmkend AAAAAAAEGJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b DFPtsMap} & {\b getDFIn} (){\bkmkstart AAAAAAAEGK}
{\bkmkend AAAAAAAEGK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b DFPtsMap} & {\b getDFOut} (){\bkmkstart AAAAAAAEGL}
{\bkmkend AAAAAAAEGL}
\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \par
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b addPts} (const Key &dstKey, const Key &srcKey) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const Key &dstKey, const Key &srcKey) override{\bkmkstart AAAAAAAEGM}
{\bkmkend AAAAAAAEGM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs pts(dstVar) = pts(dstVar) U pts(srcVar). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const Key &dstKey, const Data &srcData) override{\bkmkstart AAAAAAAEGN}
{\bkmkend AAAAAAAEGN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs pts(dstVar) = pts(dstVar) U srcData. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearPts} (const Key &var, const Datum &element) override{\bkmkstart AAAAAAAEGO}
{\bkmkend AAAAAAAEGO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears element from the points-to set of var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearFullPts} (const Key &var) override{\bkmkstart AAAAAAAEGP}
{\bkmkend AAAAAAAEGP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fully clears the points-to set of var. }{
}\par
}\par}
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b dumpPTData} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dumpPts} (const PtsMap &ptsSet, {\b raw_ostream} &O=SVFUtil::outs()) const{\bkmkstart AAAAAAAEGQ}
{\bkmkend AAAAAAAEGQ}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b classof} (const {\b MutableDFPTData}< Key, Datum, Data > *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PTData}< Key, Datum, Data > *ptd){\bkmkstart AAAAAAAEGR}
{\bkmkend AAAAAAAEGR}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b unionPts} (Data &dstData, const Data &srcData)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b addPts} (Data &d, const Datum &e){\bkmkstart AAAAAAAEGS}
{\bkmkend AAAAAAAEGS}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DFPtsMap} {\b dfInPtsMap}{\bkmkstart AAAAAAAEGT}
{\bkmkend AAAAAAAEGT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Data-flow IN set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b DFPtsMap} {\b dfOutPtsMap}{\bkmkstart AAAAAAAEGU}
{\bkmkend AAAAAAAEGU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Data-flow OUT set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MutablePTData}< Key, Datum, Data > {\b mutPTData}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addPts\:SVF::MutableDFPTData< Key, Datum, Data >}
{\xe \v SVF::MutableDFPTData< Key, Datum, Data >\:addPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > virtual bool {\b SVF::MutableDFPTData}< Key, Datum, Data >::addPts (const Key &  {\i dstKey}, const Key &  {\i srcKey}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEGV}
{\bkmkend AAAAAAAEGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Override the methods defined in {\b PTData}. Union/add points-to without adding reverse points-to, used internally \par
}}
{\xe \v classof\:SVF::MutableDFPTData< Key, Datum, Data >}
{\xe \v SVF::MutableDFPTData< Key, Datum, Data >\:classof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > static bool {\b SVF::MutableDFPTData}< Key, Datum, Data >::classof (const {\b MutableDFPTData}< Key, Datum, Data > * ){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEGW}
{\bkmkend AAAAAAAEGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods to support type inquiry through isa, cast, and dyn_cast: \par
}}
{\xe \v dumpPTData\:SVF::MutableDFPTData< Key, Datum, Data >}
{\xe \v SVF::MutableDFPTData< Key, Datum, Data >\:dumpPTData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > virtual void {\b SVF::MutableDFPTData}< Key, Datum, Data >::dumpPTData (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEGX}
{\bkmkend AAAAAAAEGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump the DF IN/OUT set information for debugging purpose \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dump points-to of top-level pointers\par
dump points-to of address-taken variables\par
}{
Implements {\b SVF::PTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADWD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getDFInPtsMap\:SVF::MutableDFPTData< Key, Datum, Data >}
{\xe \v SVF::MutableDFPTData< Key, Datum, Data >\:getDFInPtsMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > const PtsMap& {\b SVF::MutableDFPTData}< Key, Datum, Data >::getDFInPtsMap (LocID  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEGY}
{\bkmkend AAAAAAAEGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get internal flow-sensitive data structures. \par
}}
{\xe \v hasDFInSet\:SVF::MutableDFPTData< Key, Datum, Data >}
{\xe \v SVF::MutableDFPTData< Key, Datum, Data >\:hasDFInSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > virtual bool {\b SVF::MutableDFPTData}< Key, Datum, Data >::hasDFInSet (LocID  {\i loc}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADXM}
{\bkmkend AAAAAAADXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether the DF IN/OUT sets have points-to sets. \par
}{
Implements {\b SVF::DFPTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADXL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v hasDFOutSet\:SVF::MutableDFPTData< Key, Datum, Data >}
{\xe \v SVF::MutableDFPTData< Key, Datum, Data >\:hasDFOutSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > virtual bool {\b SVF::MutableDFPTData}< Key, Datum, Data >::hasDFOutSet (LocID  {\i loc}, const Key &  {\i var}) const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADXO}
{\bkmkend AAAAAAADXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Access points-to set from data-flow IN/OUT set. \par
}{
Implements {\b SVF::DFPTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADXN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v unionPts\:SVF::MutableDFPTData< Key, Datum, Data >}
{\xe \v SVF::MutableDFPTData< Key, Datum, Data >\:unionPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > bool {\b SVF::MutableDFPTData}< Key, Datum, Data >::unionPts (Data &  {\i dstData}, const Data &  {\i srcData}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAEGZ}
{\bkmkend AAAAAAAEGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal union/add points-to helper methods. \par
}}
{\xe \v updateAllDFOutFromIn\:SVF::MutableDFPTData< Key, Datum, Data >}
{\xe \v SVF::MutableDFPTData< Key, Datum, Data >\:updateAllDFOutFromIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > virtual bool {\b SVF::MutableDFPTData}< Key, Datum, Data >::updateAllDFOutFromIn (LocID  {\i loc}, const Key &  {\i singleton}, bool  {\i strongUpdates}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEHA}
{\bkmkend AAAAAAAEHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For each variable var in IN at loc, do updateDFOutFromIn(loc, var, loc, var). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only variables has new pts from IN set need to be updated.\par
Enable strong updates if it is required to do so\par
}{
Implements {\b SVF::DFPTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADXF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::IncMutableDFPTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEHB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updateDFInFromIn\:SVF::MutableDFPTData< Key, Datum, Data >}
{\xe \v SVF::MutableDFPTData< Key, Datum, Data >\:updateDFInFromIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > virtual bool {\b SVF::MutableDFPTData}< Key, Datum, Data >::updateDFInFromIn (LocID  {\i srcLoc}, const Key &  {\i srcVar}, LocID  {\i dstLoc}, const Key &  {\i dstVar}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADXR}
{\bkmkend AAAAAAADXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update points-to for IN/OUT set IN[loc:var] represents the points-to of variable var in the IN set of location loc. union(ptsDst, ptsSrc) represents ptsDst = ptsDst U ptsSrc.\par
Union (IN[dstLoc:dstVar], IN[srcLoc:srcVar]). \par
}{
Implements {\b SVF::DFPTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADXP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::IncMutableDFPTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADXQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mutPTData\:SVF::MutableDFPTData< Key, Datum, Data >}
{\xe \v SVF::MutableDFPTData< Key, Datum, Data >\:mutPTData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > {\b MutablePTData}<Key, Datum, Data> {\b SVF::MutableDFPTData}< Key, Datum, Data >::mutPTData{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAEHC}
{\bkmkend AAAAAAAEHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Backing to implement the basic {\b PTData} methods which are not overridden. This allows us to avoid multiple-inheritance. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/MutablePointsToDS.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MutableDiffPTData< Key, Datum, Data > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MutableDiffPTData< Key, Datum, Data >}
{\xe \v SVF::MutableDiffPTData< Key, Datum, Data >}
{\bkmkstart AAAAAAAEID}
{\bkmkend AAAAAAAEID}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b DiffPTData} implemented with points-to sets which are updated continuously. }}\par
{
{\f2 #include <MutablePointsToDS.h>}}\par
Inheritance diagram for SVF::MutableDiffPTData< Key, Datum, Data >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_mutable_diff_p_t_data.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b PTData}< Key, Datum, Data > {\b BasePTData}{\bkmkstart AAAAAAAEIE}
{\bkmkend AAAAAAAEIE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b DiffPTData}< Key, Datum, Data > {\b BaseDiffPTData}{\bkmkstart AAAAAAAEIF}
{\bkmkend AAAAAAAEIF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b BasePTData::PTDataTy} {\b PTDataTy}{\bkmkstart AAAAAAAEIG}
{\bkmkend AAAAAAAEIG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef BasePTData::KeySet {\b KeySet}{\bkmkstart AAAAAAAEIH}
{\bkmkend AAAAAAAEIH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MutablePTData}< Key, Datum, Data >::PtsMap {\b PtsMap}{\bkmkstart AAAAAAAEII}
{\bkmkend AAAAAAAEII}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MutableDiffPTData} (bool reversePT=true, {\b PTDataTy} ty=PTDataTy::Diff){\bkmkstart AAAAAAAEIJ}
{\bkmkend AAAAAAAEIJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const PtsMap & {\b getPtsMap} () const{\bkmkstart AAAAAAAEIK}
{\bkmkend AAAAAAAEIK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clear} () override{\bkmkstart AAAAAAAEIL}
{\bkmkend AAAAAAAEIL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears all points-to sets as if nothing is stored. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const Data & {\b getPts} (const Key &var) override{\bkmkstart AAAAAAAEIM}
{\bkmkend AAAAAAAEIM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get points-to set of var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const KeySet & {\b getRevPts} (const Datum &datum) override{\bkmkstart AAAAAAAEIN}
{\bkmkend AAAAAAAEIN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get reverse points-to set of datum. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b addPts} (const Key &dstKey, const Datum &element) override{\bkmkstart AAAAAAAEIO}
{\bkmkend AAAAAAAEIO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds element to the points-to set associated with var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const Key &dstKey, const Key &srcKey) override{\bkmkstart AAAAAAAEIP}
{\bkmkend AAAAAAAEIP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs pts(dstVar) = pts(dstVar) U pts(srcVar). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const Key &dstKey, const Data &srcData) override{\bkmkstart AAAAAAAEIQ}
{\bkmkend AAAAAAAEIQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs pts(dstVar) = pts(dstVar) U srcData. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearPts} (const Key &var, const Datum &element) override{\bkmkstart AAAAAAAEIR}
{\bkmkend AAAAAAAEIR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears element from the points-to set of var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearFullPts} (const Key &var) override{\bkmkstart AAAAAAAEIS}
{\bkmkend AAAAAAAEIS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fully clears the points-to set of var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dumpPTData} () override{\bkmkstart AAAAAAAEIT}
{\bkmkend AAAAAAAEIT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump stored keys and points-to sets. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const Data & {\b getDiffPts} (Key &var) override{\bkmkstart AAAAAAAEIU}
{\bkmkend AAAAAAAEIU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get diff points to. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b computeDiffPts} (Key &var, const Data &all) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updatePropaPtsMap} (Key &src, Key &dst) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearPropaPts} (Key &var) override{\bkmkstart AAAAAAAEIV}
{\bkmkend AAAAAAAEIV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear propagated points-to set of var. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b classof} (const {\b MutableDiffPTData}< Key, Datum, Data > *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PTData}< Key, Datum, Data > *ptd){\bkmkstart AAAAAAAEIW}
{\bkmkend AAAAAAAEIW}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Data & {\b getMutDiffPts} (Key &var){\bkmkstart AAAAAAAEIX}
{\bkmkend AAAAAAAEIX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get diff PTS that can be modified. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Data & {\b getPropaPts} (Key &var){\bkmkstart AAAAAAAEIY}
{\bkmkend AAAAAAAEIY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get propagated points to. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Key, typename Datum, typename Data>\par
class SVF::MutableDiffPTData< Key, Datum, Data >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b DiffPTData} implemented with points-to sets which are updated continuously. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v classof\:SVF::MutableDiffPTData< Key, Datum, Data >}
{\xe \v SVF::MutableDiffPTData< Key, Datum, Data >\:classof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > static bool {\b SVF::MutableDiffPTData}< Key, Datum, Data >::classof (const {\b MutableDiffPTData}< Key, Datum, Data > * ){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEIZ}
{\bkmkend AAAAAAAEIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods to support type inquiry through isa, cast, and dyn_cast: \par
}}
{\xe \v computeDiffPts\:SVF::MutableDiffPTData< Key, Datum, Data >}
{\xe \v SVF::MutableDiffPTData< Key, Datum, Data >\:computeDiffPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > virtual bool {\b SVF::MutableDiffPTData}< Key, Datum, Data >::computeDiffPts (Key &  {\i var}, const Data &  {\i all}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADWP}
{\bkmkend AAAAAAADWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute diff points to. Return TRUE if diff is not empty.{
\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab calculate diff: diff = all - propa.\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab update propagated pts: propa = all. \par}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear diff pts.\par
Get all pts.\par
}{
Implements {\b SVF::DiffPTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADWO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updatePropaPtsMap\:SVF::MutableDiffPTData< Key, Datum, Data >}
{\xe \v SVF::MutableDiffPTData< Key, Datum, Data >\:updatePropaPtsMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > virtual void {\b SVF::MutableDiffPTData}< Key, Datum, Data >::updatePropaPtsMap (Key &  {\i src}, Key &  {\i dst}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADWR}
{\bkmkend AAAAAAADWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update dst's propagated points-to set with src's. The final result is the intersection of these two sets. \par
}{
Implements {\b SVF::DiffPTData< Key, Datum, Data >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADWQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/MutablePointsToDS.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MutablePTData< Key, Datum, Data > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MutablePTData< Key, Datum, Data >}
{\xe \v SVF::MutablePTData< Key, Datum, Data >}
{\bkmkstart AAAAAAAEHD}
{\bkmkend AAAAAAAEHD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PTData} implemented using points-to sets which are created once and updated continuously. }}\par
{
{\f2 #include <MutablePointsToDS.h>}}\par
Inheritance diagram for SVF::MutablePTData< Key, Datum, Data >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_mutable_p_t_data.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b PTData}< Key, Datum, Data > {\b BasePTData}{\bkmkstart AAAAAAAEHE}
{\bkmkend AAAAAAAEHE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b BasePTData::PTDataTy} {\b PTDataTy}{\bkmkstart AAAAAAAEHF}
{\bkmkend AAAAAAAEHF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef BasePTData::KeySet {\b KeySet}{\bkmkstart AAAAAAAEHG}
{\bkmkend AAAAAAAEHG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< Key, Data > {\b PtsMap}{\bkmkstart AAAAAAAEHH}
{\bkmkend AAAAAAAEHH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< Datum, KeySet > {\b RevPtsMap}{\bkmkstart AAAAAAAEHI}
{\bkmkend AAAAAAAEHI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PtsMap::iterator {\b PtsMapIter}{\bkmkstart AAAAAAAEHJ}
{\bkmkend AAAAAAAEHJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PtsMap::const_iterator {\b PtsMapConstIter}{\bkmkstart AAAAAAAEHK}
{\bkmkend AAAAAAAEHK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Data::iterator {\b iterator}{\bkmkstart AAAAAAAEHL}
{\bkmkend AAAAAAAEHL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MutablePTData} (bool reversePT=true, {\b PTDataTy} ty=PTDataTy::MutBase){\bkmkstart AAAAAAAEHM}
{\bkmkend AAAAAAAEHM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const PtsMap & {\b getPtsMap} () const{\bkmkstart AAAAAAAEHN}
{\bkmkend AAAAAAAEHN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return Points-to map. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clear} () override{\bkmkstart AAAAAAAEHO}
{\bkmkend AAAAAAAEHO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears all points-to sets as if nothing is stored. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const Data & {\b getPts} (const Key &var) override{\bkmkstart AAAAAAAEHP}
{\bkmkend AAAAAAAEHP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get points-to set of var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const KeySet & {\b getRevPts} (const Datum &datum) override{\bkmkstart AAAAAAAEHQ}
{\bkmkend AAAAAAAEHQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get reverse points-to set of datum. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b addPts} (const Key &dstKey, const Datum &element) override{\bkmkstart AAAAAAAEHR}
{\bkmkend AAAAAAAEHR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds element to the points-to set associated with var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const Key &dstKey, const Key &srcKey) override{\bkmkstart AAAAAAAEHS}
{\bkmkend AAAAAAAEHS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs pts(dstVar) = pts(dstVar) U pts(srcVar). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const Key &dstKey, const Data &srcData) override{\bkmkstart AAAAAAAEHT}
{\bkmkend AAAAAAAEHT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs pts(dstVar) = pts(dstVar) U srcData. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dumpPTData} () override{\bkmkstart AAAAAAAEHU}
{\bkmkend AAAAAAAEHU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump stored keys and points-to sets. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearPts} (const Key &var, const Datum &element) override{\bkmkstart AAAAAAAEHV}
{\bkmkend AAAAAAAEHV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears element from the points-to set of var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearFullPts} (const Key &var) override{\bkmkstart AAAAAAAEHW}
{\bkmkend AAAAAAAEHW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fully clears the points-to set of var. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b classof} (const {\b MutablePTData}< Key, Datum, Data > *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PTData}< Key, Datum, Data > *ptd){\bkmkstart AAAAAAAEHX}
{\bkmkend AAAAAAAEHX}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dumpPts} (const PtsMap &ptsSet, {\b raw_ostream} &O=SVFUtil::outs()) const{\bkmkstart AAAAAAAEHY}
{\bkmkend AAAAAAAEHY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PtsMap {\b ptsMap}{\bkmkstart AAAAAAAEHZ}
{\bkmkend AAAAAAAEHZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

RevPtsMap {\b revPtsMap}{\bkmkstart AAAAAAAEIA}
{\bkmkend AAAAAAAEIA}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b MutableDFPTData< Key, Datum, Data >}{\bkmkstart AAAAAAAEIB}
{\bkmkend AAAAAAAEIB}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Key, typename Datum, typename Data>\par
class SVF::MutablePTData< Key, Datum, Data >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PTData} implemented using points-to sets which are created once and updated continuously. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v classof\:SVF::MutablePTData< Key, Datum, Data >}
{\xe \v SVF::MutablePTData< Key, Datum, Data >\:classof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data > static bool {\b SVF::MutablePTData}< Key, Datum, Data >::classof (const {\b MutablePTData}< Key, Datum, Data > * ){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEIC}
{\bkmkend AAAAAAAEIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods to support type inquiry through isa, cast, and dyn_cast: \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/MutablePointsToDS.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::MutableVersionedPTData< Key, Datum, Data, VersionedKey > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::MutableVersionedPTData< Key, Datum, Data, VersionedKey >}
{\xe \v SVF::MutableVersionedPTData< Key, Datum, Data, VersionedKey >}
{\bkmkstart AAAAAAAEJV}
{\bkmkend AAAAAAAEJV}
\par
{
{\f2 #include <MutablePointsToDS.h>}}\par
Inheritance diagram for SVF::MutableVersionedPTData< Key, Datum, Data, VersionedKey >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_mutable_versioned_p_t_data.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b PTData}< Key, Datum, Data > {\b BasePTData}{\bkmkstart AAAAAAAEJW}
{\bkmkend AAAAAAAEJW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b VersionedPTData}< Key, Datum, Data, VersionedKey > {\b BaseVersionedPTData}{\bkmkstart AAAAAAAEJX}
{\bkmkend AAAAAAAEJX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b BasePTData::PTDataTy} {\b PTDataTy}{\bkmkstart AAAAAAAEJY}
{\bkmkend AAAAAAAEJY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef BasePTData::KeySet {\b KeySet}{\bkmkstart AAAAAAAEJZ}
{\bkmkend AAAAAAAEJZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef BaseVersionedPTData::VersionedKeySet {\b VersionedKeySet}{\bkmkstart AAAAAAAEKA}
{\bkmkend AAAAAAAEKA}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MutableVersionedPTData} (bool reversePT=true, {\b PTDataTy} ty=PTDataTy::MutVersioned){\bkmkstart AAAAAAAEKB}
{\bkmkend AAAAAAAEKB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clear} () override{\bkmkstart AAAAAAAEKC}
{\bkmkend AAAAAAAEKC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears all points-to sets as if nothing is stored. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const Data & {\b getPts} (const Key &vk) override{\bkmkstart AAAAAAAEKD}
{\bkmkend AAAAAAAEKD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get points-to set of var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const Data & {\b getPts} (const VersionedKey &vk) override{\bkmkstart AAAAAAAEKE}
{\bkmkend AAAAAAAEKE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const KeySet & {\b getRevPts} (const Datum &datum) override{\bkmkstart AAAAAAAEKF}
{\bkmkend AAAAAAAEKF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get reverse points-to set of datum. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const VersionedKeySet & {\b getVersionedKeyRevPts} (const Datum &datum) override{\bkmkstart AAAAAAAEKG}
{\bkmkend AAAAAAAEKG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b addPts} (const Key &k, const Datum &element) override{\bkmkstart AAAAAAAEKH}
{\bkmkend AAAAAAAEKH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds element to the points-to set associated with var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b addPts} (const VersionedKey &vk, const Datum &element) override{\bkmkstart AAAAAAAEKI}
{\bkmkend AAAAAAAEKI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const Key &dstVar, const Key &srcVar) override{\bkmkstart AAAAAAAEKJ}
{\bkmkend AAAAAAAEKJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs pts(dstVar) = pts(dstVar) U pts(srcVar). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const VersionedKey &dstVar, const VersionedKey &srcVar) override{\bkmkstart AAAAAAAEKK}
{\bkmkend AAAAAAAEKK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const VersionedKey &dstVar, const Key &srcVar) override{\bkmkstart AAAAAAAEKL}
{\bkmkend AAAAAAAEKL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const Key &dstVar, const VersionedKey &srcVar) override{\bkmkstart AAAAAAAEKM}
{\bkmkend AAAAAAAEKM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const Key &dstVar, const Data &srcData) override{\bkmkstart AAAAAAAEKN}
{\bkmkend AAAAAAAEKN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs pts(dstVar) = pts(dstVar) U srcData. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const VersionedKey &dstVar, const Data &srcData) override{\bkmkstart AAAAAAAEKO}
{\bkmkend AAAAAAAEKO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearPts} (const Key &k, const Datum &element) override{\bkmkstart AAAAAAAEKP}
{\bkmkend AAAAAAAEKP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears element from the points-to set of var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearPts} (const VersionedKey &vk, const Datum &element) override{\bkmkstart AAAAAAAEKQ}
{\bkmkend AAAAAAAEKQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearFullPts} (const Key &k) override{\bkmkstart AAAAAAAEKR}
{\bkmkend AAAAAAAEKR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fully clears the points-to set of var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearFullPts} (const VersionedKey &vk) override{\bkmkstart AAAAAAAEKS}
{\bkmkend AAAAAAAEKS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dumpPTData} () override{\bkmkstart AAAAAAAEKT}
{\bkmkend AAAAAAAEKT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump stored keys and points-to sets. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b classof} (const {\b MutableVersionedPTData}< Key, Datum, Data, VersionedKey > *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PTData}< Key, Datum, Data > *ptd){\bkmkstart AAAAAAAEKU}
{\bkmkend AAAAAAAEKU}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Key, typename Datum, typename Data, typename VersionedKey>\par
class SVF::MutableVersionedPTData< Key, Datum, Data, VersionedKey >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b VersionedPTData} implemented with mutable points-to set (Data). Implemented as a wrapper around two MutablePTDatas: one for Keys, one for VersionedKeys. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v classof\:SVF::MutableVersionedPTData< Key, Datum, Data, VersionedKey >}
{\xe \v SVF::MutableVersionedPTData< Key, Datum, Data, VersionedKey >\:classof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data , typename VersionedKey > static bool {\b SVF::MutableVersionedPTData}< Key, Datum, Data, VersionedKey >::classof (const {\b MutableVersionedPTData}< Key, Datum, Data, VersionedKey > * ){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEKV}
{\bkmkend AAAAAAAEKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods to support type inquiry through isa, cast, and dyn_cast: \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/MutablePointsToDS.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::NodeIDAllocator Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::NodeIDAllocator}
{\xe \v SVF::NodeIDAllocator}
{\bkmkstart AAAAAAAHDB}
{\bkmkend AAAAAAAHDB}
\par
{
{\f2 #include <NodeIDAllocator.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Strategy} \{ {\b NONE}
, {\b DENSE}
, {\b DEBUG}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocation strategy to use. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b allocateObjectId} (void){\bkmkstart AAAAAAAHDC}
{\bkmkend AAAAAAAHDC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate an object ID as determined by the strategy. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b allocateGepObjectId} (NodeID base, u32_t offset, u32_t maxFieldLimit)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b allocateValueId} (void){\bkmkstart AAAAAAAHDD}
{\bkmkend AAAAAAAHDD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate a value ID as determined by the strategy. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b endSymbolAllocation} (void){\bkmkstart AAAAAAAHDE}
{\bkmkend AAAAAAAHDE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Notify the allocator that all symbols have had IDs allocated. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b NodeIDAllocator} * {\b get} (void){\bkmkstart AAAAAAAHDF}
{\bkmkend AAAAAAAHDF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return (singleton) allocator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b unset} (void){\bkmkstart AAAAAAAHDG}
{\bkmkend AAAAAAAHDG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deletes the (singleton) allocator. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const std::string {\b userStrategyDense} = "dense"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const std::string {\b userStrategyDebug} = "debug"{\bkmkstart AAAAAAAHDH}
{\bkmkend AAAAAAAHDH}
\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \par
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const NodeID {\b blackHoleObjectId} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const NodeID {\b constantObjectId} = 1{\bkmkstart AAAAAAAHDI}
{\bkmkend AAAAAAAHDI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const NodeID {\b blackHolePointerId} = 2{\bkmkstart AAAAAAAHDJ}
{\bkmkend AAAAAAAHDJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const NodeID {\b nullPointerId} = 3{\bkmkstart AAAAAAAHDK}
{\bkmkend AAAAAAAHDK}
\par
}
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocates node IDs for objects and values, upon request, according to some strategy which can be user-defined. It is the job of {\b SymbolTableInfo} to tell the {\b NodeIDAllocator} when all symbols have been allocated through endSymbolAllocation. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Strategy\:SVF::NodeIDAllocator}
{\xe \v SVF::NodeIDAllocator\:Strategy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SVF::NodeIDAllocator::Strategy}}}
\par
{\bkmkstart AAAAAAAHDL}
{\bkmkend AAAAAAAHDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocation strategy to use. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v NONE\:SVF::NodeIDAllocator}
{\xe \v SVF::NodeIDAllocator\:NONE}
{\qr NONE{\bkmkstart AAAAAAAHDM}
{\bkmkend AAAAAAAHDM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to initialise from llvm::cl::opt. \par
}\cell }{\row }
{\xe \v DENSE\:SVF::NodeIDAllocator}
{\xe \v SVF::NodeIDAllocator\:DENSE}
{\qr DENSE{\bkmkstart AAAAAAAHDN}
{\bkmkend AAAAAAAHDN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate objects contiguously, separate from values, and vice versa. If [****...*****] is the space of unsigned integers, we allocate as, [ssssooooooo...vvvvvvv] (o = object, v = value, s = special). \par
}\cell }{\row }
{\xe \v DEBUG\:SVF::NodeIDAllocator}
{\xe \v SVF::NodeIDAllocator\:DEBUG}
{\qr DEBUG{\bkmkstart AAAAAAAHDO}
{\bkmkend AAAAAAAHDO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate values and objects as they come in with a single counter. GEP objects are allocated as an offset from their base (see implementation of allocateGepObjectId). The purpose of this allocation strategy is human readability. \par
}\cell }{\row }
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v allocateGepObjectId\:SVF::NodeIDAllocator}
{\xe \v SVF::NodeIDAllocator\:allocateGepObjectId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID SVF::NodeIDAllocator::allocateGepObjectId (NodeID  {\i base}, u32_t  {\i offset}, u32_t  {\i maxFieldLimit})}}
\par
{\bkmkstart AAAAAAAHDP}
{\bkmkend AAAAAAAHDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate a GEP object ID as determined by the strategy. allocateObjectId is still fine for GEP objects, but for some strategies (DEBUG, namely), GEP objects can be allocated differently (more readable, for DEBUG). Regardless, numObjects is shared; there is no special numGepObjects. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v blackHoleObjectId\:SVF::NodeIDAllocator}
{\xe \v SVF::NodeIDAllocator\:blackHoleObjectId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const NodeID SVF::NodeIDAllocator::blackHoleObjectId = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAHDQ}
{\bkmkend AAAAAAAHDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These nodes, and any nodes before them are assumed allocated as objects and values. For simplicity's sake, numObjects and numVals thus start at 4 (and the other counters are set appropriately). \par
}}
{\xe \v userStrategyDense\:SVF::NodeIDAllocator}
{\xe \v SVF::NodeIDAllocator\:userStrategyDense}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::string SVF::NodeIDAllocator::userStrategyDense = "dense"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAHDR}
{\bkmkend AAAAAAAHDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Option strings as written by the user. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/NodeIDAllocator.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Util/NodeIDAllocator.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::NormalGepCGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::NormalGepCGEdge}
{\xe \v SVF::NormalGepCGEdge}
{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
\par
{
{\f2 #include <ConsGEdge.h>}}\par
Inheritance diagram for SVF::NormalGepCGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_normal_gep_c_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b NormalGepCGEdge} ({\b ConstraintNode} *s, {\b ConstraintNode} *d, const {\b LocationSet} &l, EdgeID id){\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b LocationSet} & {\b getLocationSet} () const{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get location set of the gep edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b getOffset} () const{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get location set of the gep edge. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b NormalGepCGEdge} *){\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GepCGEdge} *edge){\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ConstraintEdge} *edge){\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericConsEdgeTy} *edge){\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gep edge with fixed offset size \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ConsGEdge.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::NormalGepPE Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::NormalGepPE}
{\xe \v SVF::NormalGepPE}
{\bkmkstart AAAAAAACKD}
{\bkmkend AAAAAAACKD}
\par
{
{\f2 #include <PAGEdge.h>}}\par
Inheritance diagram for SVF::NormalGepPE:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_normal_gep_p_e.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b NormalGepPE} ({\b PAGNode} *s, {\b PAGNode} *d, const {\b LocationSet} &l){\bkmkstart AAAAAAACKE}
{\bkmkend AAAAAAACKE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getOffset} () const{\bkmkstart AAAAAAACKF}
{\bkmkend AAAAAAACKF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
offset of the gep edge }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b LocationSet} & {\b getLocationSet} () const{\bkmkstart AAAAAAACKG}
{\bkmkend AAAAAAACKG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACKH}
{\bkmkend AAAAAAACKH}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b NormalGepPE} *){\bkmkstart AAAAAAACKI}
{\bkmkend AAAAAAACKI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GepPE} *edge){\bkmkstart AAAAAAACKJ}
{\bkmkend AAAAAAACKJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGEdge} *edge){\bkmkstart AAAAAAACKK}
{\bkmkend AAAAAAACKK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGEdgeTy} *edge){\bkmkstart AAAAAAACKL}
{\bkmkend AAAAAAACKL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gep edge with a fixed offset \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::NullPtrVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::NullPtrVFGNode}
{\xe \v SVF::NullPtrVFGNode}
{\bkmkstart AAAAAAADVI}
{\bkmkend AAAAAAADVI}
\par
{
{\f2 #include <VFGNode.h>}}\par
Inheritance diagram for SVF::NullPtrVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_null_ptr_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b NullPtrVFGNode} (NodeID id, const {\b PAGNode} *n){\bkmkstart AAAAAAADVJ}
{\bkmkend AAAAAAADVJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isPTANode} () const{\bkmkstart AAAAAAADVK}
{\bkmkend AAAAAAADVK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this node is of pointer type (used for pointer analysis). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getPAGNode} () const{\bkmkstart AAAAAAADVL}
{\bkmkend AAAAAAADVL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return corresponding {\b PAGNode}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADVM}
{\bkmkend AAAAAAADVM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b NullPtrVFGNode} *){\bkmkstart AAAAAAADVN}
{\bkmkend AAAAAAADVN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADVO}
{\bkmkend AAAAAAADVO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADVP}
{\bkmkend AAAAAAADVP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dummy Definition for undef and null pointers \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ObjPN Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ObjPN}
{\xe \v SVF::ObjPN}
{\bkmkstart AAAAAAACNH}
{\bkmkend AAAAAAACNH}
Inheritance diagram for SVF::ObjPN:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_obj_p_n.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemObj} * {\b getMemObj} () const{\bkmkstart AAAAAAACNI}
{\bkmkend AAAAAAACNI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return memory object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b getValueName} () const{\bkmkstart AAAAAAACNJ}
{\bkmkend AAAAAAACNJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of a LLVM value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const llvm::Type * {\b getType} () const{\bkmkstart AAAAAAACNK}
{\bkmkend AAAAAAACNK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return type of the value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACNL}
{\bkmkend AAAAAAACNL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ObjPN} *){\bkmkstart AAAAAAACNM}
{\bkmkend AAAAAAACNM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGNode} *node){\bkmkstart AAAAAAACNN}
{\bkmkend AAAAAAACNN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGNodeTy} *node){\bkmkstart AAAAAAACNO}
{\bkmkend AAAAAAACNO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ObjPN} (const Value *val, NodeID i, const {\b MemObj} *m, {\b PNODEK} ty=ObjNode){\bkmkstart AAAAAAACNP}
{\bkmkend AAAAAAACNP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MemObj} * {\b mem}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v mem\:SVF::ObjPN}
{\xe \v SVF::ObjPN\:mem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MemObj}* SVF::ObjPN::mem{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACNQ}
{\bkmkend AAAAAAACNQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
memory object \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ObjTypeInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ObjTypeInfo}
{\xe \v SVF::ObjTypeInfo}
{\bkmkstart AAAAAAAEDA}
{\bkmkend AAAAAAAEDA}
\par
{
{\f2 #include <MemModel.h>}}\par
Inheritance diagram for SVF::ObjTypeInfo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_obj_type_info.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b MEMTYPE} \{ {\b FUNCTION_OBJ} = 0x1
, {\b GLOBVAR_OBJ} = 0x2
, {\b STATIC_OBJ} = 0x4
, {\b STACK_OBJ} = 0x8
, {\b HEAP_OBJ} = 0x10
, {\b VAR_STRUCT_OBJ} = 0x20
, {\b VAR_ARRAY_OBJ} = 0x40
, {\b CONST_STRUCT_OBJ} = 0x80
, {\b CONST_ARRAY_OBJ} = 0x100
, {\b CONST_OBJ} = 0x200
, {\b HASPTR_OBJ} = 0x400
 \}{\bkmkstart AAAAAAAEDB}
{\bkmkend AAAAAAAEDB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ObjTypeInfo} (const Value *, const Type *t, u32_t max){\bkmkstart AAAAAAAEDC}
{\bkmkend AAAAAAAEDC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructors. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ObjTypeInfo} (u32_t max, const Type *t){\bkmkstart AAAAAAAEDD}
{\bkmkend AAAAAAAEDD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~ObjTypeInfo} (){\bkmkstart AAAAAAAEDE}
{\bkmkend AAAAAAAEDE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init} (const Value *value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the object type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual u32_t {\b getObjSize} (const Value *val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b analyzeGlobalStackObjType} (const Value *val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Analyse types of gobal and stack objects. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b analyzeHeapStaticObjType} (const Value *val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Analyse types of heap and static objects. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Type * {\b getType} () const{\bkmkstart AAAAAAAEDF}
{\bkmkend AAAAAAAEDF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get LLVM type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getMaxFieldOffsetLimit} (){\bkmkstart AAAAAAAEDG}
{\bkmkend AAAAAAAEDG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get max field offset limit. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setMaxFieldOffsetLimit} (u32_t limit){\bkmkstart AAAAAAAEDH}
{\bkmkend AAAAAAAEDH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get max field offset limit. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setFlag} (MEMTYPE mask){\bkmkstart AAAAAAAEDI}
{\bkmkend AAAAAAAEDI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flag for this object type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasFlag} (MEMTYPE mask){\bkmkstart AAAAAAAEDJ}
{\bkmkend AAAAAAAEDJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFunction} (){\bkmkstart AAAAAAAEDK}
{\bkmkend AAAAAAAEDK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Object attributes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isGlobalObj} (){\bkmkstart AAAAAAAEDL}
{\bkmkend AAAAAAAEDL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isStaticObj} (){\bkmkstart AAAAAAAEDM}
{\bkmkend AAAAAAAEDM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isStack} (){\bkmkstart AAAAAAAEDN}
{\bkmkend AAAAAAAEDN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isHeap} (){\bkmkstart AAAAAAAEDO}
{\bkmkend AAAAAAAEDO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isVarStruct} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isConstStruct} (){\bkmkstart AAAAAAAEDP}
{\bkmkend AAAAAAAEDP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isStruct} (){\bkmkstart AAAAAAAEDQ}
{\bkmkend AAAAAAAEDQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isVarArray} (){\bkmkstart AAAAAAAEDR}
{\bkmkend AAAAAAAEDR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isConstArray} (){\bkmkstart AAAAAAAEDS}
{\bkmkend AAAAAAAEDS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isArray} (){\bkmkstart AAAAAAAEDT}
{\bkmkend AAAAAAAEDT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isConstant} (){\bkmkstart AAAAAAAEDU}
{\bkmkend AAAAAAAEDU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasPtrObj} (){\bkmkstart AAAAAAAEDV}
{\bkmkend AAAAAAAEDV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isNonPtrFieldObj} (const {\b LocationSet} &ls)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type Info of an abstract memory object \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v analyzeGlobalStackObjType\:SVF::ObjTypeInfo}
{\xe \v SVF::ObjTypeInfo\:analyzeGlobalStackObjType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ObjTypeInfo::analyzeGlobalStackObjType (const Value *  {\i val})}}
\par
{\bkmkstart AAAAAAAEDW}
{\bkmkend AAAAAAAEDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Analyse types of gobal and stack objects. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Analyse types of all flattened fields of this object \par
}}
{\xe \v analyzeHeapStaticObjType\:SVF::ObjTypeInfo}
{\xe \v SVF::ObjTypeInfo\:analyzeHeapStaticObjType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ObjTypeInfo::analyzeHeapStaticObjType (const Value *  {\i val})}}
\par
{\bkmkstart AAAAAAAEDX}
{\bkmkend AAAAAAAEDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Analyse types of heap and static objects. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Analyse types of heap and static objects \par
}}
{\xe \v getObjSize\:SVF::ObjTypeInfo}
{\xe \v SVF::ObjTypeInfo\:getObjSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32_t ObjTypeInfo::getObjSize (const Value *  {\i val}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEDY}
{\bkmkend AAAAAAAEDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the size of this object, derived classes can override this to get more precise object size\par
Return size of this Object \par
}{
Reimplemented in {\b SVF::LocObjTypeInfo} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEDZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v init\:SVF::ObjTypeInfo}
{\xe \v SVF::ObjTypeInfo\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ObjTypeInfo::init (const Value *  {\i val})}}
\par
{\bkmkstart AAAAAAAEEA}
{\bkmkend AAAAAAAEEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the object type. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the type info of an object \par
}}
{\xe \v isNonPtrFieldObj\:SVF::ObjTypeInfo}
{\xe \v SVF::ObjTypeInfo\:isNonPtrFieldObj}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ObjTypeInfo::isNonPtrFieldObj (const {\b LocationSet} &  {\i ls}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEEB}
{\bkmkend AAAAAAAEEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a location set is a pointer type or not \par
}}
{\xe \v isVarStruct\:SVF::ObjTypeInfo}
{\xe \v SVF::ObjTypeInfo\:isVarStruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::ObjTypeInfo::isVarStruct (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEEC}
{\bkmkend AAAAAAAEEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Object attributes (noted that an object can be a nested compound types) e.g. both isStruct and isArray can return true \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/MemModel.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MemoryModel/MemModel.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::OfflineConsG Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::OfflineConsG}
{\xe \v SVF::OfflineConsG}
{\bkmkstart AAAAAAABZW}
{\bkmkend AAAAAAABZW}
\par
{
{\f2 #include <OfflineConsG.h>}}\par
Inheritance diagram for SVF::OfflineConsG:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_offline_cons_g.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SCCDetection}< {\b OfflineConsG} * > {\b OSCC}{\bkmkstart AAAAAAABZX}
{\bkmkend AAAAAAABZX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< {\b LoadCGEdge} * > {\b LoadEdges}{\bkmkstart AAAAAAABZY}
{\bkmkend AAAAAAABZY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< {\b StoreCGEdge} * > {\b StoreEdges}{\bkmkstart AAAAAAABZZ}
{\bkmkend AAAAAAABZZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b OfflineConsG} ({\b PAG} *p){\bkmkstart AAAAAAACAA}
{\bkmkend AAAAAAACAA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasOCGRep} (NodeID node) const{\bkmkstart AAAAAAACAB}
{\bkmkend AAAAAAACAB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getOCGRep} (NodeID node) const{\bkmkstart AAAAAAACAC}
{\bkmkend AAAAAAACAC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const NodeToRepMap & {\b getOCGRepMap} () const{\bkmkstart AAAAAAACAD}
{\bkmkend AAAAAAACAD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isaRef} (NodeID node) const{\bkmkstart AAAAAAACAE}
{\bkmkend AAAAAAACAE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasRef} (NodeID node) const{\bkmkstart AAAAAAACAF}
{\bkmkend AAAAAAACAF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getRef} (NodeID node) const{\bkmkstart AAAAAAACAG}
{\bkmkend AAAAAAACAG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b solveOfflineSCC} ({\b OSCC} *oscc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b buildOfflineMap} ({\b OSCC} *oscc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump} (std::string name)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasNorRep} (NodeID nor) const{\bkmkstart AAAAAAACAH}
{\bkmkend AAAAAAACAH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setNorRep} (NodeID nor, NodeID rep){\bkmkstart AAAAAAACAI}
{\bkmkend AAAAAAACAI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getNorRep} (NodeID nor) const{\bkmkstart AAAAAAACAJ}
{\bkmkend AAAAAAACAJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b solveRep} ({\b OSCC} *oscc, NodeID rep)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b buildOfflineCG} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addRefLoadEdge} (NodeID src, NodeID dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addRefStoreEdge} (NodeID src, NodeID dst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b createRefNode} (NodeID nodeId)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeSet {\b refNodes}{\bkmkstart AAAAAAACAK}
{\bkmkend AAAAAAACAK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeToRepMap {\b nodeToRefMap}{\bkmkstart AAAAAAACAL}
{\bkmkend AAAAAAACAL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeToRepMap {\b norToRepMap}{\bkmkstart AAAAAAACAM}
{\bkmkend AAAAAAACAM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Offline constraint graph for {\b Andersen}'s analysis. In OCG, a 'ref' node is used to represent the point-to set of a constraint node. 'Nor' means a constraint node of its corresponding ref node. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addRefLoadEdge\:SVF::OfflineConsG}
{\xe \v SVF::OfflineConsG\:addRefLoadEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OfflineConsG::addRefLoadEdge (NodeID  {\i src}, NodeID  {\i dst}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAN}
{\bkmkend AAAAAAACAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a copy edge between the ref node of src node and dst node, while meeting a LOAD constraint. \par
}}
{\xe \v addRefStoreEdge\:SVF::OfflineConsG}
{\xe \v SVF::OfflineConsG\:addRefStoreEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OfflineConsG::addRefStoreEdge (NodeID  {\i src}, NodeID  {\i dst}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAO}
{\bkmkend AAAAAAACAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a copy edge between src node and the ref node of dst node, while meeting a STORE constraint. \par
}}
{\xe \v buildOfflineCG\:SVF::OfflineConsG}
{\xe \v SVF::OfflineConsG\:buildOfflineCG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void OfflineConsG::buildOfflineCG (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAP}
{\bkmkend AAAAAAACAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Builder of offline constraint graph \par
}}
{\xe \v buildOfflineMap\:SVF::OfflineConsG}
{\xe \v SVF::OfflineConsG\:buildOfflineMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void OfflineConsG::buildOfflineMap ({\b OSCC} *  {\i oscc})}}
\par
{\bkmkstart AAAAAAACAQ}
{\bkmkend AAAAAAACAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build offline node to rep map, which only collect nodes having a ref node \par
}}
{\xe \v createRefNode\:SVF::OfflineConsG}
{\xe \v SVF::OfflineConsG\:createRefNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool OfflineConsG::createRefNode (NodeID  {\i nodeId}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAR}
{\bkmkend AAAAAAACAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a ref node for a constraint node if it does not have one \par
}}
{\xe \v dump\:SVF::OfflineConsG}
{\xe \v SVF::OfflineConsG\:dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void OfflineConsG::dump (std::string  {\i name})}}
\par
{\bkmkstart AAAAAAACAS}
{\bkmkend AAAAAAACAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump offline constraint graph \par
}}
{\xe \v solveOfflineSCC\:SVF::OfflineConsG}
{\xe \v SVF::OfflineConsG\:solveOfflineSCC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void OfflineConsG::solveOfflineSCC ({\b OSCC} *  {\i oscc})}}
\par
{\bkmkstart AAAAAAACAT}
{\bkmkend AAAAAAACAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Use a offline SCC detector to solve node relations in OCG. Generally, the 'oscc' should be solved first. \par
}}
{\xe \v solveRep\:SVF::OfflineConsG}
{\xe \v SVF::OfflineConsG\:solveRep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID OfflineConsG::solveRep ({\b OSCC} *  {\i oscc}, NodeID  {\i rep}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACAU}
{\bkmkend AAAAAAACAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The rep nodes of offline constraint graph are possible to be 'ref' nodes. These nodes should be replaced by one of its sub nodes which is not a ref node. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/OfflineConsG.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/OfflineConsG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PAG Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PAG}
{\xe \v SVF::PAG}
{\bkmkstart AAAAAAACAV}
{\bkmkend AAAAAAACAV}
\par
{
{\f2 #include <PAG.h>}}\par
Inheritance diagram for SVF::PAG:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_p_a_g.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b CallBlockNode} * > {\b CallSiteSet}{\bkmkstart AAAAAAACAW}
{\bkmkend AAAAAAACAW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< const {\b CallBlockNode} *, NodeID > {\b CallSiteToFunPtrMap}{\bkmkstart AAAAAAACAX}
{\bkmkend AAAAAAACAX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, CallSiteSet > {\b FunPtrToCallSitesMap}{\bkmkstart AAAAAAACAY}
{\bkmkend AAAAAAACAY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, NodeBS > {\b MemObjToFieldsMap}{\bkmkstart AAAAAAACAZ}
{\bkmkend AAAAAAACAZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b PAGEdge} * > {\b PAGEdgeSet}{\bkmkstart AAAAAAACBA}
{\bkmkend AAAAAAACBA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const {\b PAGEdge} * > {\b PAGEdgeList}{\bkmkstart AAAAAAACBB}
{\bkmkend AAAAAAACBB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const {\b PAGNode} * > {\b PAGNodeList}{\bkmkstart AAAAAAACBC}
{\bkmkend AAAAAAACBC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const {\b CopyPE} * > {\b CopyPEList}{\bkmkstart AAAAAAACBD}
{\bkmkend AAAAAAACBD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const {\b BinaryOPPE} * > {\b BinaryOPList}{\bkmkstart AAAAAAACBE}
{\bkmkend AAAAAAACBE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const {\b UnaryOPPE} * > {\b UnaryOPList}{\bkmkstart AAAAAAACBF}
{\bkmkend AAAAAAACBF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const {\b CmpPE} * > {\b CmpPEList}{\bkmkstart AAAAAAACBG}
{\bkmkend AAAAAAACBG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b PAGNode} *, CopyPEList > {\b PHINodeMap}{\bkmkstart AAAAAAACBH}
{\bkmkend AAAAAAACBH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b PAGNode} *, BinaryOPList > {\b BinaryNodeMap}{\bkmkstart AAAAAAACBI}
{\bkmkend AAAAAAACBI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b PAGNode} *, UnaryOPList > {\b UnaryNodeMap}{\bkmkstart AAAAAAACBJ}
{\bkmkend AAAAAAACBJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b PAGNode} *, CmpPEList > {\b CmpNodeMap}{\bkmkstart AAAAAAACBK}
{\bkmkend AAAAAAACBK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, PAGNodeList > {\b FunToArgsListMap}{\bkmkstart AAAAAAACBL}
{\bkmkend AAAAAAACBL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CallBlockNode} *, PAGNodeList > {\b CSToArgsListMap}{\bkmkstart AAAAAAACBM}
{\bkmkend AAAAAAACBM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b RetBlockNode} *, const {\b PAGNode} * > {\b CSToRetMap}{\bkmkstart AAAAAAACBN}
{\bkmkend AAAAAAACBN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, const {\b PAGNode} * > {\b FunToRetMap}{\bkmkstart AAAAAAACBO}
{\bkmkend AAAAAAACBO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, PAGEdgeSet > {\b FunToPAGEdgeSetMap}{\bkmkstart AAAAAAACBP}
{\bkmkend AAAAAAACBP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b ICFGNode} *, PAGEdgeList > {\b Inst2PAGEdgesMap}{\bkmkstart AAAAAAACBQ}
{\bkmkend AAAAAAACBQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, NodeID > {\b NodeToNodeMap}{\bkmkstart AAAAAAACBR}
{\bkmkend AAAAAAACBR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::pair< NodeID, Size_t > {\b NodeOffset}{\bkmkstart AAAAAAACBS}
{\bkmkend AAAAAAACBS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::pair< NodeID, {\b LocationSet} > {\b NodeLocationSet}{\bkmkstart AAAAAAACBT}
{\bkmkend AAAAAAACBT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeOffset, NodeID > {\b NodeOffsetMap}{\bkmkstart AAAAAAACBU}
{\bkmkend AAAAAAACBU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeLocationSet, NodeID > {\b NodeLocationSetMap}{\bkmkstart AAAAAAACBV}
{\bkmkend AAAAAAACBV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Value *, NodeLocationSetMap > {\b GepValPNMap}{\bkmkstart AAAAAAACBW}
{\bkmkend AAAAAAACBW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodePair, NodeID > {\b NodePairSetMap}{\bkmkstart AAAAAAACBX}
{\bkmkend AAAAAAACBX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ICFG} * {\b getICFG} (){\bkmkstart AAAAAAACBY}
{\bkmkend AAAAAAACBY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return {\b ICFG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OrderedNodeSet & {\b getAllValidPtrs} (){\bkmkstart AAAAAAACBZ}
{\bkmkend AAAAAAACBZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return valid pointers. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b initialiseCandidatePointers} (){\bkmkstart AAAAAAACCA}
{\bkmkend AAAAAAACCA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize candidate pointers. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~PAG} (){\bkmkstart AAAAAAACCB}
{\bkmkend AAAAAAACCB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isBuiltFromFile} (){\bkmkstart AAAAAAACCC}
{\bkmkend AAAAAAACCC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this {\b PAG} built from a txt file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFModule} * {\b getModule} (){\bkmkstart AAAAAAACCD}
{\bkmkend AAAAAAACCD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get LLVM Module. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addCallSite} (const {\b CallBlockNode} *call){\bkmkstart AAAAAAACCE}
{\bkmkend AAAAAAACCE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallSiteSet & {\b getCallSiteSet} () const{\bkmkstart AAAAAAACCF}
{\bkmkend AAAAAAACCF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
PAGEdge::PAGEdgeSetTy & {\b getEdgeSet} ({\b PAGEdge::PEDGEK} kind)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get/set methods to get control flow information of a {\b PAGEdge}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGEdge::PAGEdgeSetTy & {\b getPTAEdgeSet} ({\b PAGEdge::PEDGEK} kind){\bkmkstart AAAAAAACCG}
{\bkmkend AAAAAAACCG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get PTA edges set according to its kind. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasPAGEdgeList} (const {\b ICFGNode} *inst) const{\bkmkstart AAAAAAACCH}
{\bkmkend AAAAAAACCH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this instruction has {\b PAG} Edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasPTAPAGEdgeList} (const {\b ICFGNode} *inst) const{\bkmkstart AAAAAAACCI}
{\bkmkend AAAAAAACCI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGEdgeList & {\b getInstPAGEdgeList} (const {\b ICFGNode} *inst){\bkmkstart AAAAAAACCJ}
{\bkmkend AAAAAAACCJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an instruction, get all its PAGEdges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGEdgeList & {\b getInstPTAPAGEdgeList} (const {\b ICFGNode} *inst){\bkmkstart AAAAAAACCK}
{\bkmkend AAAAAAACCK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an instruction, get all its PTA PAGEdges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addToInstPAGEdgeList} ({\b ICFGNode} *inst, {\b PAGEdge} *edge){\bkmkstart AAAAAAACCL}
{\bkmkend AAAAAAACCL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a {\b PAGEdge} into instruction map. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addGlobalPAGEdge} (const {\b PAGEdge} *edge){\bkmkstart AAAAAAACCM}
{\bkmkend AAAAAAACCM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get global PAGEdges (not in a procedure) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGEdgeSet & {\b getGlobalPAGEdgeSet} (){\bkmkstart AAAAAAACCN}
{\bkmkend AAAAAAACCN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get global PAGEdges (not in a procedure) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addPhiNode} (const {\b PAGNode} *res, const {\b CopyPE} *edge){\bkmkstart AAAAAAACCO}
{\bkmkend AAAAAAACCO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add phi node information. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isPhiNode} (const {\b PAGNode} *node) const{\bkmkstart AAAAAAACCP}
{\bkmkend AAAAAAACCP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this {\b PAGNode} is a result operand a of phi node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PHINodeMap & {\b getPhiNodeMap} (){\bkmkstart AAAAAAACCQ}
{\bkmkend AAAAAAACCQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all phi copy edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addBinaryNode} (const {\b PAGNode} *res, const {\b BinaryOPPE} *edge){\bkmkstart AAAAAAACCR}
{\bkmkend AAAAAAACCR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add phi node information. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isBinaryNode} (const {\b PAGNode} *node) const{\bkmkstart AAAAAAACCS}
{\bkmkend AAAAAAACCS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this {\b PAGNode} is a result operand a of phi node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

BinaryNodeMap & {\b getBinaryNodeMap} (){\bkmkstart AAAAAAACCT}
{\bkmkend AAAAAAACCT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all phi copy edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addUnaryNode} (const {\b PAGNode} *res, const {\b UnaryOPPE} *edge){\bkmkstart AAAAAAACCU}
{\bkmkend AAAAAAACCU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add unary node information. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isUnaryNode} (const {\b PAGNode} *node) const{\bkmkstart AAAAAAACCV}
{\bkmkend AAAAAAACCV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this {\b PAGNode} is an unary node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

UnaryNodeMap & {\b getUnaryNodeMap} (){\bkmkstart AAAAAAACCW}
{\bkmkend AAAAAAACCW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all unary edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addCmpNode} (const {\b PAGNode} *res, const {\b CmpPE} *edge){\bkmkstart AAAAAAACCX}
{\bkmkend AAAAAAACCX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add phi node information. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isCmpNode} (const {\b PAGNode} *node) const{\bkmkstart AAAAAAACCY}
{\bkmkend AAAAAAACCY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this {\b PAGNode} is a result operand a of phi node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CmpNodeMap & {\b getCmpNodeMap} (){\bkmkstart AAAAAAACCZ}
{\bkmkend AAAAAAACCZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all phi copy edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addFunArgs} (const {\b SVFFunction} *fun, const {\b PAGNode} *arg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get/set method for function/callsite arguments and returns. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addFunRet} (const {\b SVFFunction} *fun, const {\b PAGNode} *ret){\bkmkstart AAAAAAACDA}
{\bkmkend AAAAAAACDA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add function returns. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addCallSiteArgs} ({\b CallBlockNode} *callBlockNode, const {\b PAGNode} *arg){\bkmkstart AAAAAAACDB}
{\bkmkend AAAAAAACDB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add callsite arguments. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addCallSiteRets} ({\b RetBlockNode} *retBlockNode, const {\b PAGNode} *arg){\bkmkstart AAAAAAACDC}
{\bkmkend AAAAAAACDC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add callsite returns. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasFunArgsList} (const {\b SVFFunction} *func) const{\bkmkstart AAAAAAACDD}
{\bkmkend AAAAAAACDD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function has arguments list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FunToArgsListMap & {\b getFunArgsMap} (){\bkmkstart AAAAAAACDE}
{\bkmkend AAAAAAACDE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get function arguments list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const PAGNodeList & {\b getFunArgsList} (const {\b SVFFunction} *func) const{\bkmkstart AAAAAAACDF}
{\bkmkend AAAAAAACDF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get function arguments list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasCallSiteArgsMap} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAACDG}
{\bkmkend AAAAAAACDG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Callsite has argument list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CSToArgsListMap & {\b getCallSiteArgsMap} (){\bkmkstart AAAAAAACDH}
{\bkmkend AAAAAAACDH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get callsite argument list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const PAGNodeList & {\b getCallSiteArgsList} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAACDI}
{\bkmkend AAAAAAACDI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get callsite argument list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CSToRetMap & {\b getCallSiteRets} (){\bkmkstart AAAAAAACDJ}
{\bkmkend AAAAAAACDJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get callsite return. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getCallSiteRet} (const {\b RetBlockNode} *cs) const{\bkmkstart AAAAAAACDK}
{\bkmkend AAAAAAACDK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get callsite return. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b callsiteHasRet} (const {\b RetBlockNode} *cs) const{\bkmkstart AAAAAAACDL}
{\bkmkend AAAAAAACDL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FunToRetMap & {\b getFunRets} (){\bkmkstart AAAAAAACDM}
{\bkmkend AAAAAAACDM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get function return list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getFunRet} (const {\b SVFFunction} *func) const{\bkmkstart AAAAAAACDN}
{\bkmkend AAAAAAACDN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get function return list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b funHasRet} (const {\b SVFFunction} *func) const{\bkmkstart AAAAAAACDO}
{\bkmkend AAAAAAACDO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b getPAGNodeNum} () const{\bkmkstart AAAAAAACDP}
{\bkmkend AAAAAAACDP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Node and edge statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b getPAGEdgeNum} () const{\bkmkstart AAAAAAACDQ}
{\bkmkend AAAAAAACDQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b getValueNodeNum} () const{\bkmkstart AAAAAAACDR}
{\bkmkend AAAAAAACDR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b getObjectNodeNum} () const{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b getFieldValNodeNum} () const{\bkmkstart AAAAAAACDT}
{\bkmkend AAAAAAACDT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b getFieldObjNodeNum} () const{\bkmkstart AAAAAAACDU}
{\bkmkend AAAAAAACDU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getGepValNode} (const Value *curInst, NodeID base, const {\b LocationSet} &ls) const{\bkmkstart AAAAAAACDV}
{\bkmkend AAAAAAACDV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Due to constaint expression, curInst is used to distinguish different instructions (e.g., memorycpy) when creating {\b GepValPN}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallSiteToFunPtrMap & {\b getIndirectCallsites} () const{\bkmkstart AAAAAAACDW}
{\bkmkend AAAAAAACDW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add/get indirect callsites. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addIndirectCallsites} (const {\b CallBlockNode} *cs, NodeID funPtr){\bkmkstart AAAAAAACDX}
{\bkmkend AAAAAAACDX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getFunPtr} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAACDY}
{\bkmkend AAAAAAACDY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallSiteSet & {\b getIndCallSites} (NodeID funPtr) const{\bkmkstart AAAAAAACDZ}
{\bkmkend AAAAAAACDZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isIndirectCallSites} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAACEA}
{\bkmkend AAAAAAACEA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFunPtr} (NodeID id) const{\bkmkstart AAAAAAACEB}
{\bkmkend AAAAAAACEB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b findPAGNode} (NodeID id) const{\bkmkstart AAAAAAACEC}
{\bkmkend AAAAAAACEC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a pag node according to its ID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAGEdge} * {\b getIntraPAGEdge} (NodeID src, NodeID dst, {\b PAGEdge::PEDGEK} kind){\bkmkstart AAAAAAACED}
{\bkmkend AAAAAAACED}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get an edge according to src, dst and kind. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAGEdge} * {\b getIntraPAGEdge} ({\b PAGNode} *src, {\b PAGNode} *dst, {\b PAGEdge::PEDGEK} kind){\bkmkstart AAAAAAACEE}
{\bkmkend AAAAAAACEE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAGNode} * {\b getPAGNode} (NodeID id) const{\bkmkstart AAAAAAACEF}
{\bkmkend AAAAAAACEF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b PAGNode} ID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b getValueNode} (const Value *V)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b PAG} Node according to LLVM value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasValueNode} (const Value *V){\bkmkstart AAAAAAACEG}
{\bkmkend AAAAAAACEG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b getObjectNode} (const Value *V)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getObjectNode} (const {\b MemObj} *mem){\bkmkstart AAAAAAACEH}
{\bkmkend AAAAAAACEH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
getObject - return mem object id }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b MemObj} * {\b getObject} (NodeID id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemObj} * {\b getObject} (const {\b ObjPN} *node) const{\bkmkstart AAAAAAACEI}
{\bkmkend AAAAAAACEI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getReturnNode} (const {\b SVFFunction} *func) const{\bkmkstart AAAAAAACEJ}
{\bkmkend AAAAAAACEJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
GetReturnNode - Return the unique node representing the return value of a function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getVarargNode} (const {\b SVFFunction} *func) const{\bkmkstart AAAAAAACEK}
{\bkmkend AAAAAAACEK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
getVarargNode - Return the unique node representing the variadic argument of a variadic function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b getGepObjNode} (const {\b MemObj} *obj, const {\b LocationSet} &ls)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a field {\b PAG} Object node according to base mem obj and offset. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b getGepObjNode} (NodeID id, const {\b LocationSet} &ls)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a field obj {\b PAG} node according to a mem obj and a given offset. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getFIObjNode} (const {\b MemObj} *obj) const{\bkmkstart AAAAAAACEL}
{\bkmkend AAAAAAACEL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a field-insensitive obj {\b PAG} node according to a mem obj. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getFIObjNode} (NodeID id) const{\bkmkstart AAAAAAACEM}
{\bkmkend AAAAAAACEM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getBlackHoleNode} () const{\bkmkstart AAAAAAACEN}
{\bkmkend AAAAAAACEN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get black hole and constant id. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getConstantNode} () const{\bkmkstart AAAAAAACEO}
{\bkmkend AAAAAAACEO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getBlkPtr} () const{\bkmkstart AAAAAAACEP}
{\bkmkend AAAAAAACEP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getNullPtr} () const{\bkmkstart AAAAAAACEQ}
{\bkmkend AAAAAAACEQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isBlkPtr} (NodeID id) const{\bkmkstart AAAAAAACER}
{\bkmkend AAAAAAACER}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isNullPtr} (NodeID id) const{\bkmkstart AAAAAAACES}
{\bkmkend AAAAAAACES}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isBlkObjOrConstantObj} (NodeID id) const{\bkmkstart AAAAAAACET}
{\bkmkend AAAAAAACET}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isBlkObj} (NodeID id) const{\bkmkstart AAAAAAACEU}
{\bkmkend AAAAAAACEU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isConstantObj} (NodeID id) const{\bkmkstart AAAAAAACEV}
{\bkmkend AAAAAAACEV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isNonPointerObj} (NodeID id) const{\bkmkstart AAAAAAACEW}
{\bkmkend AAAAAAACEW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemObj} * {\b getBlackHoleObj} () const{\bkmkstart AAAAAAACEX}
{\bkmkend AAAAAAACEX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemObj} * {\b getConstantObj} () const{\bkmkstart AAAAAAACEY}
{\bkmkend AAAAAAACEY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getNodeNumAfterPAGBuild} () const{\bkmkstart AAAAAAACEZ}
{\bkmkend AAAAAAACEZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setNodeNumAfterPAGBuild} (u32_t num){\bkmkstart AAAAAAACFA}
{\bkmkend AAAAAAACFA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b getBaseValNode} (NodeID nodeId)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base and Offset methods for Value and Object node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LocationSet} {\b getLocationSetFromBaseNode} (NodeID nodeId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getBaseObjNode} (NodeID id) const{\bkmkstart AAAAAAACFB}
{\bkmkend AAAAAAACFB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemObj} * {\b getBaseObj} (NodeID id) const{\bkmkstart AAAAAAACFC}
{\bkmkend AAAAAAACFC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeBS & {\b getAllFieldsObjNode} (const {\b MemObj} *obj)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all fields of an object. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeBS & {\b getAllFieldsObjNode} (NodeID id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeBS {\b getFieldsAfterCollapse} (NodeID id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b addNode} ({\b PAGNode} *node, NodeID i)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add node into {\b PAG} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addValNode} (const Value *val, NodeID i){\bkmkstart AAAAAAACFD}
{\bkmkend AAAAAAACFD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a value (pointer) node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addObjNode} (const Value *val, NodeID i){\bkmkstart AAAAAAACFE}
{\bkmkend AAAAAAACFE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a memory obj node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addRetNode} (const {\b SVFFunction} *val, NodeID i){\bkmkstart AAAAAAACFF}
{\bkmkend AAAAAAACFF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a unique return node for a procedure. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addVarargNode} (const {\b SVFFunction} *val, NodeID i){\bkmkstart AAAAAAACFG}
{\bkmkend AAAAAAACFG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a unique vararg node for a procedure. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b addGepValNode} (const Value *curInst, const Value *val, const {\b LocationSet} &ls, NodeID i, const Type *type, u32_t fieldidx)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a temp field value node, this method can only invoked by getGepValNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b addGepObjNode} (const {\b MemObj} *obj, const {\b LocationSet} &ls)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a field obj node, this method can only invoked by getGepObjNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b addFIObjNode} (const {\b MemObj} *obj)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a field-insensitive node, this method can only invoked by getFIGepObjNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addDummyValNode} (){\bkmkstart AAAAAAACFH}
{\bkmkend AAAAAAACFH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a dummy value/object node according to node ID (llvm value is null) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addDummyValNode} (NodeID i){\bkmkstart AAAAAAACFI}
{\bkmkend AAAAAAACFI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addDummyObjNode} (const Type *type=NULL){\bkmkstart AAAAAAACFJ}
{\bkmkend AAAAAAACFJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addDummyObjNode} (NodeID i, const Type *type){\bkmkstart AAAAAAACFK}
{\bkmkend AAAAAAACFK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemObj} * {\b addDummyMemObj} (NodeID i, const Type *type){\bkmkstart AAAAAAACFL}
{\bkmkend AAAAAAACFL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addBlackholeObjNode} (){\bkmkstart AAAAAAACFM}
{\bkmkend AAAAAAACFM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addConstantObjNode} (){\bkmkstart AAAAAAACFN}
{\bkmkend AAAAAAACFN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addBlackholePtrNode} (){\bkmkstart AAAAAAACFO}
{\bkmkend AAAAAAACFO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addValNode} (const Value *, {\b PAGNode} *node, NodeID i){\bkmkstart AAAAAAACFP}
{\bkmkend AAAAAAACFP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a value (pointer) node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addObjNode} (const Value *, {\b PAGNode} *node, NodeID i){\bkmkstart AAAAAAACFQ}
{\bkmkend AAAAAAACFQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a memory obj node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addRetNode} (const {\b SVFFunction} *, {\b PAGNode} *node, NodeID i){\bkmkstart AAAAAAACFR}
{\bkmkend AAAAAAACFR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a unique return node for a procedure. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addVarargNode} (const {\b SVFFunction} *, {\b PAGNode} *node, NodeID i){\bkmkstart AAAAAAACFS}
{\bkmkend AAAAAAACFS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a unique vararg node for a procedure. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addEdge} ({\b PAGNode} *src, {\b PAGNode} *dst, {\b PAGEdge} *edge)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add an edge into {\b PAG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PAGEdge} * {\b hasNonlabeledEdge} ({\b PAGNode} *src, {\b PAGNode} *dst, {\b PAGEdge::PEDGEK} kind)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PAGEdge} * {\b hasLabeledEdge} ({\b PAGNode} *src, {\b PAGNode} *dst, {\b PAGEdge::PEDGEK} kind, const {\b ICFGNode} *cs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AddrPE} * {\b addAddrPE} (NodeID src, NodeID dst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Address edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CopyPE} * {\b addCopyPE} (NodeID src, NodeID dst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Copy edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CmpPE} * {\b addCmpPE} (NodeID src, NodeID dst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Copy edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BinaryOPPE} * {\b addBinaryOPPE} (NodeID src, NodeID dst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Copy edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UnaryOPPE} * {\b addUnaryOPPE} (NodeID src, NodeID dst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Unary edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LoadPE} * {\b addLoadPE} (NodeID src, NodeID dst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Load edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StorePE} * {\b addStorePE} (NodeID src, NodeID dst, const {\b IntraBlockNode} *val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Store edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CallPE} * {\b addCallPE} (NodeID src, NodeID dst, const {\b CallBlockNode} *cs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Call edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RetPE} * {\b addRetPE} (NodeID src, NodeID dst, const {\b CallBlockNode} *cs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Return edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GepPE} * {\b addGepPE} (NodeID src, NodeID dst, const {\b LocationSet} &ls, bool constGep)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Gep edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NormalGepPE} * {\b addNormalGepPE} (NodeID src, NodeID dst, const {\b LocationSet} &ls)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Offset(Gep) edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VariantGepPE} * {\b addVariantGepPE} (NodeID src, NodeID dst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Variant(Gep) edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TDForkPE} * {\b addThreadForkPE} (NodeID src, NodeID dst, const {\b CallBlockNode} *cs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Thread fork edge for parameter passing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TDJoinPE} * {\b addThreadJoinPE} (NodeID src, NodeID dst, const {\b CallBlockNode} *cs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Thread join edge for parameter passing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PAGEdge} * {\b addBlackHoleAddrPE} (NodeID node)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set a pointer points-to black hole (e.g. int2ptr) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isValidPointer} (NodeID nodeId) const{\bkmkstart AAAAAAACFT}
{\bkmkend AAAAAAACFT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a node is a valid pointer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isValidTopLevelPtr} (const {\b PAGNode} *node){\bkmkstart AAAAAAACFU}
{\bkmkend AAAAAAACFU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b getGraphName} () const{\bkmkstart AAAAAAACFV}
{\bkmkend AAAAAAACFV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return graph name. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print {\b PAG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump} (std::string name)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump {\b PAG}. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b PAG} * {\b getPAG} (bool buildFromFile=false){\bkmkstart AAAAAAACFW}
{\bkmkend AAAAAAACFW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Singleton design here to make sure we only have one instance during any analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b releasePAG} (){\bkmkstart AAAAAAACFX}
{\bkmkend AAAAAAACFX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b handleBlackHole} (bool b)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} build configurations. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b totalPTAPAGEdge}{\bkmkstart AAAAAAACFY}
{\bkmkend AAAAAAACFY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Program Assignment Graph for pointer analysis SymID and NodeID are equal here (same numbering). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addAddrPE\:SVF::PAG}
{\xe \v SVF::PAG\:addAddrPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AddrPE} * PAG::addAddrPE (NodeID  {\i src}, NodeID  {\i dst})}}
\par
{\bkmkstart AAAAAAACFZ}
{\bkmkend AAAAAAACFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Address edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Address edge \par
}}
{\xe \v addBinaryOPPE\:SVF::PAG}
{\xe \v SVF::PAG\:addBinaryOPPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BinaryOPPE} * PAG::addBinaryOPPE (NodeID  {\i src}, NodeID  {\i dst})}}
\par
{\bkmkstart AAAAAAACGA}
{\bkmkend AAAAAAACGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Copy edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Compare edge \par
}}
{\xe \v addBlackHoleAddrPE\:SVF::PAG}
{\xe \v SVF::PAG\:addBlackHoleAddrPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PAGEdge} * PAG::addBlackHoleAddrPE (NodeID  {\i node})}}
\par
{\bkmkstart AAAAAAACGB}
{\bkmkend AAAAAAACGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set a pointer points-to black hole (e.g. int2ptr) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add blackhole/constant edge \par
}}
{\xe \v addCallPE\:SVF::PAG}
{\xe \v SVF::PAG\:addCallPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CallPE} * PAG::addCallPE (NodeID  {\i src}, NodeID  {\i dst}, const {\b CallBlockNode} *  {\i cs})}}
\par
{\bkmkstart AAAAAAACGC}
{\bkmkend AAAAAAACGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Call edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Call edge \par
}}
{\xe \v addCmpPE\:SVF::PAG}
{\xe \v SVF::PAG\:addCmpPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CmpPE} * PAG::addCmpPE (NodeID  {\i src}, NodeID  {\i dst})}}
\par
{\bkmkstart AAAAAAACGD}
{\bkmkend AAAAAAACGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Copy edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Compare edge \par
}}
{\xe \v addCopyPE\:SVF::PAG}
{\xe \v SVF::PAG\:addCopyPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CopyPE} * PAG::addCopyPE (NodeID  {\i src}, NodeID  {\i dst})}}
\par
{\bkmkstart AAAAAAACGE}
{\bkmkend AAAAAAACGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Copy edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Copy edge \par
}}
{\xe \v addEdge\:SVF::PAG}
{\xe \v SVF::PAG\:addEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PAG::addEdge ({\b PAGNode} *  {\i src}, {\b PAGNode} *  {\i dst}, {\b PAGEdge} *  {\i edge})}}
\par
{\bkmkstart AAAAAAACGF}
{\bkmkend AAAAAAACGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add an edge into {\b PAG}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a {\b PAG} edge\par
Add a {\b PAG} edge into edge map \par
}}
{\xe \v addFIObjNode\:SVF::PAG}
{\xe \v SVF::PAG\:addFIObjNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID PAG::addFIObjNode (const {\b MemObj} *  {\i obj})}}
\par
{\bkmkstart AAAAAAACGG}
{\bkmkend AAAAAAACGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a field-insensitive node, this method can only invoked by getFIGepObjNode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a field-insensitive node, this method can only invoked by getFIGepObjNode \par
}}
{\xe \v addFunArgs\:SVF::PAG}
{\xe \v SVF::PAG\:addFunArgs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVF::PAG::addFunArgs (const {\b SVFFunction} *  {\i fun}, const {\b PAGNode} *  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGH}
{\bkmkend AAAAAAACGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get/set method for function/callsite arguments and returns. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add function arguments \par
}}
{\xe \v addGepObjNode\:SVF::PAG}
{\xe \v SVF::PAG\:addGepObjNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID PAG::addGepObjNode (const {\b MemObj} *  {\i obj}, const {\b LocationSet} &  {\i ls})}}
\par
{\bkmkstart AAAAAAACGI}
{\bkmkend AAAAAAACGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a field obj node, this method can only invoked by getGepObjNode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a field obj node, this method can only invoked by getGepObjNode \par
}}
{\xe \v addGepPE\:SVF::PAG}
{\xe \v SVF::PAG\:addGepPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GepPE} * PAG::addGepPE (NodeID  {\i src}, NodeID  {\i dst}, const {\b LocationSet} &  {\i ls}, bool  {\i constGep})}}
\par
{\bkmkstart AAAAAAACGJ}
{\bkmkend AAAAAAACGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Gep edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Offset(Gep) edge Find the base node id of src and connect base node to dst node Create gep offset: (offset + baseOff <nested struct gep size>) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Since the offset from base to src is variant, the new gep edge being created is also a {\b VariantGepPE} edge.\par
}}
{\xe \v addGepValNode\:SVF::PAG}
{\xe \v SVF::PAG\:addGepValNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID PAG::addGepValNode (const Value *  {\i curInst}, const Value *  {\i gepVal}, const {\b LocationSet} &  {\i ls}, NodeID  {\i i}, const Type *  {\i type}, u32_t  {\i fieldidx})}}
\par
{\bkmkstart AAAAAAACGK}
{\bkmkend AAAAAAACGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a temp field value node, this method can only invoked by getGepValNode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a temp field value node, this method can only invoked by getGepValNode due to constaint expression, curInst is used to distinguish different instructions (e.g., memorycpy) when creating {\b GepValPN}. \par
}}
{\xe \v addLoadPE\:SVF::PAG}
{\xe \v SVF::PAG\:addLoadPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LoadPE} * PAG::addLoadPE (NodeID  {\i src}, NodeID  {\i dst})}}
\par
{\bkmkstart AAAAAAACGL}
{\bkmkend AAAAAAACGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Load edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Load edge \par
}}
{\xe \v addNode\:SVF::PAG}
{\xe \v SVF::PAG\:addNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID SVF::PAG::addNode ({\b PAGNode} *  {\i node}, NodeID  {\i i}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGM}
{\bkmkend AAAAAAACGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add node into {\b PAG} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a {\b PAG} node into Node map \par
}}
{\xe \v addNormalGepPE\:SVF::PAG}
{\xe \v SVF::PAG\:addNormalGepPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NormalGepPE} * PAG::addNormalGepPE (NodeID  {\i src}, NodeID  {\i dst}, const {\b LocationSet} &  {\i ls})}}
\par
{\bkmkstart AAAAAAACGN}
{\bkmkend AAAAAAACGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Offset(Gep) edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add normal (Gep) edge \par
}}
{\xe \v addRetPE\:SVF::PAG}
{\xe \v SVF::PAG\:addRetPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RetPE} * PAG::addRetPE (NodeID  {\i src}, NodeID  {\i dst}, const {\b CallBlockNode} *  {\i cs})}}
\par
{\bkmkstart AAAAAAACGO}
{\bkmkend AAAAAAACGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Return edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Return edge \par
}}
{\xe \v addStorePE\:SVF::PAG}
{\xe \v SVF::PAG\:addStorePE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StorePE} * PAG::addStorePE (NodeID  {\i src}, NodeID  {\i dst}, const {\b IntraBlockNode} *  {\i curVal})}}
\par
{\bkmkstart AAAAAAACGP}
{\bkmkend AAAAAAACGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Store edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Store edge Note that two store instructions may share the same Store {\b PAGEdge} \par
}}
{\xe \v addThreadForkPE\:SVF::PAG}
{\xe \v SVF::PAG\:addThreadForkPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TDForkPE} * PAG::addThreadForkPE (NodeID  {\i src}, NodeID  {\i dst}, const {\b CallBlockNode} *  {\i cs})}}
\par
{\bkmkstart AAAAAAACGQ}
{\bkmkend AAAAAAACGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Thread fork edge for parameter passing. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Thread fork edge for parameter passing from a spawner to its spawnees \par
}}
{\xe \v addThreadJoinPE\:SVF::PAG}
{\xe \v SVF::PAG\:addThreadJoinPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TDJoinPE} * PAG::addThreadJoinPE (NodeID  {\i src}, NodeID  {\i dst}, const {\b CallBlockNode} *  {\i cs})}}
\par
{\bkmkstart AAAAAAACGR}
{\bkmkend AAAAAAACGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Thread join edge for parameter passing. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Thread fork edge for parameter passing from a spawnee back to its spawners \par
}}
{\xe \v addUnaryOPPE\:SVF::PAG}
{\xe \v SVF::PAG\:addUnaryOPPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UnaryOPPE} * PAG::addUnaryOPPE (NodeID  {\i src}, NodeID  {\i dst})}}
\par
{\bkmkstart AAAAAAACGS}
{\bkmkend AAAAAAACGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Unary edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Unary edge \par
}}
{\xe \v addVariantGepPE\:SVF::PAG}
{\xe \v SVF::PAG\:addVariantGepPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b VariantGepPE} * PAG::addVariantGepPE (NodeID  {\i src}, NodeID  {\i dst})}}
\par
{\bkmkstart AAAAAAACGT}
{\bkmkend AAAAAAACGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Variant(Gep) edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add variant(Gep) edge Find the base node id of src and connect base node to dst node \par
}}
{\xe \v dump\:SVF::PAG}
{\xe \v SVF::PAG\:dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAG::dump (std::string  {\i name})}}
\par
{\bkmkstart AAAAAAACGU}
{\bkmkend AAAAAAACGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump {\b PAG}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump this {\b PAG} \par
}}
{\xe \v getAllFieldsObjNode\:SVF::PAG}
{\xe \v SVF::PAG\:getAllFieldsObjNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeBS & PAG::getAllFieldsObjNode (const {\b MemObj} *  {\i obj})}}
\par
{\bkmkstart AAAAAAACGV}
{\bkmkend AAAAAAACGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all fields of an object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all fields object nodes of an object \par
}}
{\xe \v getAllFieldsObjNode\:SVF::PAG}
{\xe \v SVF::PAG\:getAllFieldsObjNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeBS & PAG::getAllFieldsObjNode (NodeID  {\i id})}}
\par
{\bkmkstart AAAAAAACGW}
{\bkmkend AAAAAAACGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all fields object nodes of an object \par
}}
{\xe \v getBaseValNode\:SVF::PAG}
{\xe \v SVF::PAG\:getBaseValNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID PAG::getBaseValNode (NodeID  {\i nodeId})}}
\par
{\bkmkstart AAAAAAACGX}
{\bkmkend AAAAAAACGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base and Offset methods for Value and Object node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a base pointer node given a field pointer\par
Get a base pointer given a pointer Return the source node of its connected gep edge if this pointer has Otherwise return the node id itself \par
}}
{\xe \v getEdgeSet\:SVF::PAG}
{\xe \v SVF::PAG\:getEdgeSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PAGEdge::PAGEdgeSetTy& SVF::PAG::getEdgeSet ({\b PAGEdge::PEDGEK}  {\i kind}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGY}
{\bkmkend AAAAAAACGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get/set methods to get control flow information of a {\b PAGEdge}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get edges set according to its kind \par
}}
{\xe \v getFieldsAfterCollapse\:SVF::PAG}
{\xe \v SVF::PAG\:getFieldsAfterCollapse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeBS PAG::getFieldsAfterCollapse (NodeID  {\i id})}}
\par
{\bkmkstart AAAAAAACGZ}
{\bkmkend AAAAAAACGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all fields object nodes of an object If this object is collapsed into one field insensitive object Then only return this field insensitive object \par
}}
{\xe \v getGepObjNode\:SVF::PAG}
{\xe \v SVF::PAG\:getGepObjNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID PAG::getGepObjNode (const {\b MemObj} *  {\i obj}, const {\b LocationSet} &  {\i ls})}}
\par
{\bkmkstart AAAAAAACHA}
{\bkmkend AAAAAAACHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a field {\b PAG} Object node according to base mem obj and offset. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a field obj {\b PAG} node according to base mem obj and offset To support flexible field sensitive analysis with regard to MaxFieldOffset offset = offset % obj->getMaxFieldOffsetLimit() to create limited number of mem objects maximum number of field object creation is obj->getMaxFieldOffsetLimit() \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if this obj is field-insensitive, just return the field-insensitive node.\par
}}
{\xe \v getGepObjNode\:SVF::PAG}
{\xe \v SVF::PAG\:getGepObjNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID PAG::getGepObjNode (NodeID  {\i id}, const {\b LocationSet} &  {\i ls})}}
\par
{\bkmkstart AAAAAAACHB}
{\bkmkend AAAAAAACHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a field obj {\b PAG} node according to a mem obj and a given offset. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an object node, find its field object node \par
}}
{\xe \v getLocationSetFromBaseNode\:SVF::PAG}
{\xe \v SVF::PAG\:getLocationSetFromBaseNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LocationSet} PAG::getLocationSetFromBaseNode (NodeID  {\i nodeId})}}
\par
{\bkmkstart AAAAAAACHC}
{\bkmkend AAAAAAACHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a base {\b PAGNode} given a pointer Return the source node of its connected normal gep edge Otherwise return the node id itself Size_t offset : gep offset \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if this node is already a base node\par
}}
{\xe \v getObject\:SVF::PAG}
{\xe \v SVF::PAG\:getObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b MemObj}* SVF::PAG::getObject (NodeID  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHD}
{\bkmkend AAAAAAACHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory object - Return memory object according to pag node id return whole allocated memory object if this node is a gep obj node return NULL is this node is not a {\b ObjPN} type \par
}}
{\xe \v getObjectNode\:SVF::PAG}
{\xe \v SVF::PAG\:getObjectNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID SVF::PAG::getObjectNode (const Value *  {\i V}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHE}
{\bkmkend AAAAAAACHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
getObject - Return the obj node id refer to the memory object for the specified global, heap or alloca instruction according to llvm value. \par
}}
{\xe \v getValueNode\:SVF::PAG}
{\xe \v SVF::PAG\:getValueNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID SVF::PAG::getValueNode (const Value *  {\i V}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHF}
{\bkmkend AAAAAAACHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b PAG} Node according to LLVM value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
getNode - Return the node corresponding to the specified pointer. \par
}}
{\xe \v handleBlackHole\:SVF::PAG}
{\xe \v SVF::PAG\:handleBlackHole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAG::handleBlackHole (bool  {\i b}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHG}
{\bkmkend AAAAAAACHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} build configurations. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether to handle blackhole edge \par
}}
{\xe \v hasLabeledEdge\:SVF::PAG}
{\xe \v SVF::PAG\:hasLabeledEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PAGEdge} * PAG::hasLabeledEdge ({\b PAGNode} *  {\i src}, {\b PAGNode} *  {\i dst}, {\b PAGEdge::PEDGEK}  {\i kind}, const {\b ICFGNode} *  {\i callInst})}}
\par
{\bkmkstart AAAAAAACHH}
{\bkmkend AAAAAAACHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if this labeled edge exits, including store, call and load two store edge can have same dst and src but located in different basic blocks, thus flags are needed to distinguish them\par
Return true if it is an inter-procedural edge \par
}}
{\xe \v hasNonlabeledEdge\:SVF::PAG}
{\xe \v SVF::PAG\:hasNonlabeledEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PAGEdge} * PAG::hasNonlabeledEdge ({\b PAGNode} *  {\i src}, {\b PAGNode} *  {\i dst}, {\b PAGEdge::PEDGEK}  {\i kind})}}
\par
{\bkmkstart AAAAAAACHI}
{\bkmkend AAAAAAACHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if it is an intra-procedural edge \par
}}
{\xe \v print\:SVF::PAG}
{\xe \v SVF::PAG\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAG::print ()}}
\par
{\bkmkstart AAAAAAACHJ}
{\bkmkend AAAAAAACHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print {\b PAG}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print this {\b PAG} graph including its nodes and edges \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAG.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PAGBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder}
{\bkmkstart AAAAAAAGLZ}
{\bkmkend AAAAAAAGLZ}
\par
{
{\f2 #include <PAGBuilder.h>}}\par
Inheritance diagram for SVF::PAGBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_p_a_g_builder.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAGBuilder} (){\bkmkstart AAAAAAAGMA}
{\bkmkend AAAAAAAGMA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~PAGBuilder} (){\bkmkstart AAAAAAAGMB}
{\bkmkend AAAAAAAGMB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b PAG} * {\b build} ({\b SVFModule} *svfModule)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start building {\b PAG} here. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAG} * {\b getPAG} () const{\bkmkstart AAAAAAAGMC}
{\bkmkend AAAAAAAGMC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return {\b PAG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialiseNodes} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize nodes and edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addEdge} (NodeID src, NodeID dst, {\b PAGEdge::PEDGEK} kind, Size_t offset=0, Instruction *cs=NULL){\bkmkstart AAAAAAAGMD}
{\bkmkend AAAAAAAGMD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b sanityCheck} (){\bkmkstart AAAAAAAGME}
{\bkmkend AAAAAAAGME}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sanity check for {\b PAG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getValueNode} (const Value *V){\bkmkstart AAAAAAAGMF}
{\bkmkend AAAAAAAGMF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get different kinds of node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getObjectNode} (const Value *V){\bkmkstart AAAAAAAGMG}
{\bkmkend AAAAAAAGMG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
GetObject - Return the object node (stack/global/heap/function) according to a LLVM Value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getReturnNode} (const {\b SVFFunction} *func){\bkmkstart AAAAAAAGMH}
{\bkmkend AAAAAAAGMH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
getReturnNode - Return the node representing the unique return value of a function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getVarargNode} (const {\b SVFFunction} *func){\bkmkstart AAAAAAAGMI}
{\bkmkend AAAAAAAGMI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
getVarargNode - Return the node representing the unique variadic argument of a function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b visitGlobal} ({\b SVFModule} *svfModule)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle globals including (global variable and functions) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitialGlobal} (const GlobalVariable *gvar, Constant *C, u32_t offset)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b getGlobalVarField} (const GlobalVariable *gvar, u32_t offset)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b processCE} (const Value *val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process constant expression. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b computeGepOffset} (const User *V, {\b LocationSet} &ls)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute offset of a gep instruction or gep constant expression. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleDirectCall} (CallSite cs, const {\b SVFFunction} *F)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle direct call. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleIndCall} (CallSite cs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle indirect call. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleExtCall} (CallSite cs, const {\b SVFFunction} *F)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle external call. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const Type * {\b getBaseTypeAndFlattenedFields} (Value *v, std::vector< {\b LocationSet} > &fields)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addComplexConsForExt} (Value *D, Value *S, u32_t sz=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b visitAllocaInst} ({\b AllocaInst} &AI)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Our visit overrides. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b visitPHINode} (PHINode &I)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b visitStoreInst} (StoreInst &I)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitLoadInst} (LoadInst &I){\bkmkstart AAAAAAAGMJ}
{\bkmkend AAAAAAAGMJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b visitGetElementPtrInst} (GetElementPtrInst &I)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitCallInst} (CallInst &I){\bkmkstart AAAAAAAGMK}
{\bkmkend AAAAAAAGMK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitInvokeInst} (InvokeInst &II){\bkmkstart AAAAAAAGML}
{\bkmkend AAAAAAAGML}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitCallBrInst} (CallBrInst &I){\bkmkstart AAAAAAAGMM}
{\bkmkend AAAAAAAGMM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b visitCallSite} (CallSite cs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b visitReturnInst} (ReturnInst &I)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitCastInst} (CastInst &I){\bkmkstart AAAAAAAGMN}
{\bkmkend AAAAAAAGMN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b visitSelectInst} (SelectInst &I)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b visitExtractValueInst} (ExtractValueInst &EVI)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b visitBranchInst} (BranchInst &I)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitSwitchInst} (SwitchInst &I){\bkmkstart AAAAAAAGMO}
{\bkmkend AAAAAAAGMO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitInsertValueInst} (InsertValueInst &I){\bkmkstart AAAAAAAGMP}
{\bkmkend AAAAAAAGMP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b visitBinaryOperator} (BinaryOperator &I)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b visitUnaryOperator} (UnaryOperator &I)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b visitCmpInst} (CmpInst &I)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitVAArgInst} (VAArgInst &){\bkmkstart AAAAAAAGMQ}
{\bkmkend AAAAAAAGMQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO: do we need to care about these corner cases? }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b visitExtractElementInst} (ExtractElementInst &I)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitInsertElementInst} (InsertElementInst &I){\bkmkstart AAAAAAAGMR}
{\bkmkend AAAAAAAGMR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitShuffleVectorInst} (ShuffleVectorInst &I){\bkmkstart AAAAAAAGMS}
{\bkmkend AAAAAAAGMS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitLandingPadInst} (LandingPadInst &I){\bkmkstart AAAAAAAGMT}
{\bkmkend AAAAAAAGMT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitResumeInst} (ResumeInst &){\bkmkstart AAAAAAAGMU}
{\bkmkend AAAAAAAGMU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Instruction not that often. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitUnreachableInst} (UnreachableInst &){\bkmkstart AAAAAAAGMV}
{\bkmkend AAAAAAAGMV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitFenceInst} (FenceInst &I){\bkmkstart AAAAAAAGMW}
{\bkmkend AAAAAAAGMW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitAtomicCmpXchgInst} (AtomicCmpXchgInst &I){\bkmkstart AAAAAAAGMX}
{\bkmkend AAAAAAAGMX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitAtomicRMWInst} (AtomicRMWInst &I){\bkmkstart AAAAAAAGMY}
{\bkmkend AAAAAAAGMY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b visitInstruction} (Instruction &){\bkmkstart AAAAAAAGMZ}
{\bkmkend AAAAAAAGMZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provide base case for our instruction visit. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setCurrentLocation} (const Value *val, const BasicBlock *bb){\bkmkstart AAAAAAAGNA}
{\bkmkend AAAAAAAGNA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set current basic block in order to keep track of control flow information. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getCurrentValue} () const{\bkmkstart AAAAAAAGNB}
{\bkmkend AAAAAAAGNB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const BasicBlock * {\b getCurrentBB} () const{\bkmkstart AAAAAAAGNC}
{\bkmkend AAAAAAAGNC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addGlobalBlackHoleAddrEdge} (NodeID node, const ConstantExpr *int2Ptrce){\bkmkstart AAAAAAAGND}
{\bkmkend AAAAAAAGND}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add global black hole Address edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b addNullPtrNode} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add NullPtr {\b PAGNode}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b getGepValNode} (const Value *val, const {\b LocationSet} &ls, const Type *baseType, u32_t fieldidx)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCurrentBBAndValueForPAGEdge} ({\b PAGEdge} *edge)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAGEdge} * {\b addBlackHoleAddrEdge} (NodeID node){\bkmkstart AAAAAAAGNE}
{\bkmkend AAAAAAAGNE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b AddrPE} * {\b addAddrEdge} (NodeID src, NodeID dst){\bkmkstart AAAAAAAGNF}
{\bkmkend AAAAAAAGNF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Address edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CopyPE} * {\b addCopyEdge} (NodeID src, NodeID dst){\bkmkstart AAAAAAAGNG}
{\bkmkend AAAAAAAGNG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Copy edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CmpPE} * {\b addCmpEdge} (NodeID src, NodeID dst){\bkmkstart AAAAAAAGNH}
{\bkmkend AAAAAAAGNH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Copy edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b BinaryOPPE} * {\b addBinaryOPEdge} (NodeID src, NodeID dst){\bkmkstart AAAAAAAGNI}
{\bkmkend AAAAAAAGNI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Copy edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b UnaryOPPE} * {\b addUnaryOPEdge} (NodeID src, NodeID dst){\bkmkstart AAAAAAAGNJ}
{\bkmkend AAAAAAAGNJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Unary edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b LoadPE} * {\b addLoadEdge} (NodeID src, NodeID dst){\bkmkstart AAAAAAAGNK}
{\bkmkend AAAAAAAGNK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Load edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b StorePE} * {\b addStoreEdge} (NodeID src, NodeID dst){\bkmkstart AAAAAAAGNL}
{\bkmkend AAAAAAAGNL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Store edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CallPE} * {\b addCallEdge} (NodeID src, NodeID dst, const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAGNM}
{\bkmkend AAAAAAAGNM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Call edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b RetPE} * {\b addRetEdge} (NodeID src, NodeID dst, const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAGNN}
{\bkmkend AAAAAAAGNN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Return edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b GepPE} * {\b addGepEdge} (NodeID src, NodeID dst, const {\b LocationSet} &ls, bool constGep){\bkmkstart AAAAAAAGNO}
{\bkmkend AAAAAAAGNO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Gep edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b NormalGepPE} * {\b addNormalGepEdge} (NodeID src, NodeID dst, const {\b LocationSet} &ls){\bkmkstart AAAAAAAGNP}
{\bkmkend AAAAAAAGNP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Offset(Gep) edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VariantGepPE} * {\b addVariantGepEdge} (NodeID src, NodeID dst){\bkmkstart AAAAAAAGNQ}
{\bkmkend AAAAAAAGNQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Variant(Gep) edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b TDForkPE} * {\b addThreadForkEdge} (NodeID src, NodeID dst, const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAGNR}
{\bkmkend AAAAAAAGNR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Thread fork edge for parameter passing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b TDJoinPE} * {\b addThreadJoinEdge} (NodeID src, NodeID dst, const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAGNS}
{\bkmkend AAAAAAAGNS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add Thread join edge for parameter passing. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} Builder \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addComplexConsForExt\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:addComplexConsForExt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::addComplexConsForExt (Value *  {\i D}, Value *  {\i S}, u32_t  {\i sz} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAGNT}
{\bkmkend AAAAAAAGNT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add the load/store constraints and temp. nodes for the complex constraint *D = *S (where D/S may point to structs). \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If sz is 0, we will add edges for all fields.\par
}}
{\xe \v addNullPtrNode\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:addNullPtrNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID SVF::PAGBuilder::addNullPtrNode (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAGNU}
{\bkmkend AAAAAAAGNU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add NullPtr {\b PAGNode}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
let all undef value or non-determined pointers points-to black hole\par
}}
{\xe \v build\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:build}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PAG} * PAGBuilder::build ({\b SVFModule} *  {\i svfModule}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGNV}
{\bkmkend AAAAAAAGNV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start building {\b PAG} here. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start building {\b PAG} here \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
initial external library information initial {\b PAG} nodes\par
initial {\b PAG} edges: // handle globals\par
handle functions\par
collect return node of function fun\par
Return {\b PAG} node will not be created for function which can not reach the return instruction due to call to abort(), exit(), etc. In 176.gcc of SPEC 2000, function build_objc_string() from c-lang.c shows an example when fun.doesNotReturn() evaluates to TRUE because of abort().\par
To be noted, we do not record arguments which are in declared function without body TODO: what about external functions with {\b PAG} imported by commandline?\par
}}
{\xe \v computeGepOffset\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:computeGepOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PAGBuilder::computeGepOffset (const User *  {\i V}, {\b LocationSet} &  {\i ls})}}
\par
{\bkmkstart AAAAAAAGNW}
{\bkmkend AAAAAAAGNW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute offset of a gep instruction or gep constant expression. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the object node offset according to GEP insn (V). Given a gep edge p = q + i, if "i" is a constant then we return its offset size otherwise if "i" is a variable determined by runtime, then it is a variant offset Return TRUE if the offset of this GEP insn is a constant. \par
}}
{\xe \v getBaseTypeAndFlattenedFields\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:getBaseTypeAndFlattenedFields}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const Type * PAGBuilder::getBaseTypeAndFlattenedFields (Value *  {\i V}, std::vector< {\b LocationSet} > &  {\i fields})}}
\par
{\bkmkstart AAAAAAAGNX}
{\bkmkend AAAAAAAGNX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find the base type and the max possible offset of an object pointed to by (V). \par
}}
{\xe \v getGepValNode\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:getGepValNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID PAGBuilder::getGepValNode (const Value *  {\i val}, const {\b LocationSet} &  {\i ls}, const Type *  {\i baseType}, u32_t  {\i fieldidx})}}
\par
{\bkmkstart AAAAAAAGNY}
{\bkmkend AAAAAAAGNY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a temp field value node according to base value and offset this node is after the initial node method, it is out of scope of symInfo table \par
}}
{\xe \v getGlobalVarField\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:getGlobalVarField}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID PAGBuilder::getGlobalVarField (const GlobalVariable *  {\i gvar}, u32_t  {\i offset})}}
\par
{\bkmkstart AAAAAAAGNZ}
{\bkmkend AAAAAAAGNZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the field of the global variable node FIXME:Here we only get the field that actually used in the program We ignore the initialization of global variable field that not used in the program \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if we did not find the constant expression in the program, then we need to create a gep node for this field\par
}}
{\xe \v handleDirectCall\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:handleDirectCall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::handleDirectCall (CallSite  {\i cs}, const {\b SVFFunction} *  {\i F})}}
\par
{\bkmkstart AAAAAAAGOA}
{\bkmkend AAAAAAAGOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle direct call. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add the constraints for a direct, non-external call. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FIXME: this assertion should be placed for correct checking except bug program like 188.ammp, 300.twolf\par
}}
{\xe \v handleExtCall\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:handleExtCall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::handleExtCall (CallSite  {\i cs}, const {\b SVFFunction} *  {\i callee}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGOB}
{\bkmkend AAAAAAAGOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle external call. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle external calls \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
this case is for strcpy(dst,src); to maintain its semantics we will store src to the base of dst instead of dst. dst = load base store src base\par
create inter-procedural {\b PAG} edges for thread forks\par
pthread_create has 1 arg. apr_thread_create has 2 arg.\par
Connect actual parameter to formal parameter of the start routine\par
handle indirect calls at pthread create APIs e.g., pthread_create(&t1, NULL, fp, ...); const Value* fun = {\b ThreadAPI::getThreadAPI()}->getForkedFun(inst); if(!SVFUtil::isa<Function>(fun)) pag->addIndirectCallsites(cs,pag->getValueNode(fun));\par
If forkedFun does not pass to spawnee as function type but as void pointer remember to update inter-procedural callgraph/PAG/SVFG etc. when indirect call targets are resolved We don't connect the callgraph here, further investigation is need to hanle mod-ref during {\b SVFG} construction.\par
create inter-procedural {\b PAG} edges for hare_parallel_for calls\par
The task function of hare_parallel_for has 3 args.\par
Connect actual parameter to formal parameter of the start routine\par
handle indirect calls at hare_parallel_for (e.g., hare_parallel_for(..., fp, ...); const Value* fun = {\b ThreadAPI::getThreadAPI()}->getForkedFun(inst); if(!SVFUtil::isa<Function>(fun)) pag->addIndirectCallsites(cs,pag->getValueNode(fun));\par
TODO: inter-procedural {\b PAG} edges for thread joins\par
}}
{\xe \v handleIndCall\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:handleIndCall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::handleIndCall (CallSite  {\i cs})}}
\par
{\bkmkstart AAAAAAAGOC}
{\bkmkend AAAAAAAGOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle indirect call. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Indirect call is resolved on-the-fly during pointer analysis \par
}}
{\xe \v InitialGlobal\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:InitialGlobal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::InitialGlobal (const GlobalVariable *  {\i gvar}, Constant *  {\i C}, u32_t  {\i offset})}}
\par
{\bkmkstart AAAAAAAGOD}
{\bkmkend AAAAAAAGOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
src should not point to anything yet\par
}}
{\xe \v initialiseNodes\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:initialiseNodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::initialiseNodes ()}}
\par
{\bkmkstart AAAAAAAGOE}
{\bkmkend AAAAAAAGOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize nodes and edges. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add address edges for constant nodes.\par
}}
{\xe \v processCE\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:processCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::processCE (const Value *  {\i val})}}
\par
{\bkmkstart AAAAAAAGOF}
{\bkmkend AAAAAAAGOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process constant expression. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle constant expression, and connect the gep edge \par
}}
{\xe \v setCurrentBBAndValueForPAGEdge\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:setCurrentBBAndValueForPAGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::setCurrentBBAndValueForPAGEdge ({\b PAGEdge} *  {\i edge})}}
\par
{\bkmkstart AAAAAAAGOG}
{\bkmkend AAAAAAAGOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We assume every {\b GepValPN} and its {\b GepPE} are unique across whole program\par
}}
{\xe \v visitAllocaInst\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:visitAllocaInst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::visitAllocaInst ({\b AllocaInst} &  {\i inst}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGOH}
{\bkmkend AAAAAAAGOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Our visit overrides. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit alloca instructions Add edge V (dst) <\'96 O (src), V here is a value node on {\b PAG}, O is object node on {\b PAG} \par
}}
{\xe \v visitBinaryOperator\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:visitBinaryOperator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::visitBinaryOperator (BinaryOperator &  {\i inst})}}
\par
{\bkmkstart AAAAAAAGOI}
{\bkmkend AAAAAAAGOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit Binary Operator \par
}}
{\xe \v visitBranchInst\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:visitBranchInst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::visitBranchInst (BranchInst &  {\i inst})}}
\par
{\bkmkstart AAAAAAAGOJ}
{\bkmkend AAAAAAAGOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Branch and switch instructions are treated as UnaryOP br cmp label if.then, label if.else \par
}}
{\xe \v visitCallSite\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:visitCallSite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::visitCallSite (CallSite  {\i cs})}}
\par
{\bkmkstart AAAAAAAGOK}
{\bkmkend AAAAAAAGOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect callsite arguments and returns\par
}}
{\xe \v visitCmpInst\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:visitCmpInst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::visitCmpInst (CmpInst &  {\i inst})}}
\par
{\bkmkstart AAAAAAAGOL}
{\bkmkend AAAAAAAGOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit compare instruction \par
}}
{\xe \v visitExtractElementInst\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:visitExtractElementInst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::visitExtractElementInst (ExtractElementInst &  {\i inst})}}
\par
{\bkmkstart AAAAAAAGOM}
{\bkmkend AAAAAAAGOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The \'EF\'BF\'BDextractelement\'EF\'BF\'BD instruction extracts a single scalar element from a vector at a specified index. TODO: for now we just assume the pointer after extraction points to blackhole The first operand of an \'EF\'BF\'BDextractelement\'EF\'BF\'BD instruction is a value of vector type. The second operand is an index indicating the position from which to extract the element.\par
<result> = extractelement <4 x i32> vec, i32 0 ; yields i32 \par
}}
{\xe \v visitExtractValueInst\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:visitExtractValueInst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::visitExtractValueInst (ExtractValueInst &  {\i inst})}}
\par
{\bkmkstart AAAAAAAGON}
{\bkmkend AAAAAAAGON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
visit extract value instructions for structures in registers TODO: for now we just assume the pointer after extraction points to blackhole for example %24 = extractvalue \{ i32, struct.s_hash* \} call34, 0 %24 is a pointer points to first field of a register value call34 however we can not create call34 as an memory object, as it is register value. Is that necessary treat extract value as getelementptr instruction later to get more precise results? \par
}}
{\xe \v visitGetElementPtrInst\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:visitGetElementPtrInst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::visitGetElementPtrInst (GetElementPtrInst &  {\i inst})}}
\par
{\bkmkstart AAAAAAAGOO}
{\bkmkend AAAAAAAGOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit getelementptr instructions \par
}}
{\xe \v visitGlobal\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:visitGlobal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::visitGlobal ({\b SVFModule} *  {\i svfModule})}}
\par
{\bkmkstart AAAAAAAGOP}
{\bkmkend AAAAAAAGOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle globals including (global variable and functions) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit global variables for building {\b PAG} \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
initialize global variable\par
initialize global functions\par
}}
{\xe \v visitPHINode\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:visitPHINode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::visitPHINode (PHINode &  {\i inst})}}
\par
{\bkmkstart AAAAAAAGOQ}
{\bkmkend AAAAAAAGOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit phi instructions \par
}}
{\xe \v visitReturnInst\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:visitReturnInst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::visitReturnInst (ReturnInst &  {\i inst})}}
\par
{\bkmkstart AAAAAAAGOR}
{\bkmkend AAAAAAAGOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit return instructions of a function \par
}}
{\xe \v visitSelectInst\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:visitSelectInst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::visitSelectInst (SelectInst &  {\i inst})}}
\par
{\bkmkstart AAAAAAAGOS}
{\bkmkend AAAAAAAGOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit select instructions \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Two operands have same incoming basic block, both are the current BB\par
}}
{\xe \v visitStoreInst\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:visitStoreInst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::visitStoreInst (StoreInst &  {\i inst})}}
\par
{\bkmkstart AAAAAAAGOT}
{\bkmkend AAAAAAAGOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit store instructions \par
}}
{\xe \v visitUnaryOperator\:SVF::PAGBuilder}
{\xe \v SVF::PAGBuilder\:visitUnaryOperator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilder::visitUnaryOperator (UnaryOperator &  {\i inst})}}
\par
{\bkmkstart AAAAAAAGOU}
{\bkmkend AAAAAAAGOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Visit Unary Operator \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/PAGBuilder.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/PAGBuilder.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PAGBuilderFromFile Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PAGBuilderFromFile}
{\xe \v SVF::PAGBuilderFromFile}
{\bkmkstart AAAAAAAEKW}
{\bkmkend AAAAAAAEKW}
\par
{
{\f2 #include <PAGBuilderFromFile.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAGBuilderFromFile} (std::string f){\bkmkstart AAAAAAAEKX}
{\bkmkend AAAAAAAEKX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ~PAGBuilderFromFile} (){\bkmkstart AAAAAAAEKY}
{\bkmkend AAAAAAAEKY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAG} * {\b getPAG} () const{\bkmkstart AAAAAAAEKZ}
{\bkmkend AAAAAAAEKZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return {\b PAG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b getFileName} () const{\bkmkstart AAAAAAAELA}
{\bkmkend AAAAAAAELA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return file name. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PAG} * {\b build} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start building. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addEdge} (NodeID nodeSrc, NodeID nodeDst, Size_t offset, std::string edge)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build {\b PAG} from a user specified file (for debugging purpose) \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addEdge\:SVF::PAGBuilderFromFile}
{\xe \v SVF::PAGBuilderFromFile\:addEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PAGBuilderFromFile::addEdge (NodeID  {\i srcID}, NodeID  {\i dstID}, Size_t  {\i offsetOrCSId}, std::string  {\i edge})}}
\par
{\bkmkstart AAAAAAAELB}
{\bkmkend AAAAAAAELB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add {\b PAG} edge according to a file format \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sanity check for {\b PAG} from txt\par
}}
{\xe \v build\:SVF::PAGBuilderFromFile}
{\xe \v SVF::PAGBuilderFromFile\:build}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PAG} * PAGBuilderFromFile::build ()}}
\par
{\bkmkstart AAAAAAAELC}
{\bkmkend AAAAAAAELC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start building. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
new gep node's id from lower bound, nodeNum may not reflect the total nodes.\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/PAGBuilderFromFile.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MemoryModel/PAGBuilderFromFile.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PAGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PAGEdge}
{\xe \v SVF::PAGEdge}
{\bkmkstart AAAAAAACHK}
{\bkmkend AAAAAAACHK}
Inheritance diagram for SVF::PAGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_p_a_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b PEDGEK} \{ {\b Addr}
, {\b Copy}
, {\b Store}
, {\b Load}
, {\b Call}
, {\b Ret}
, {\b NormalGep}
, {\b VariantGep}
, {\b ThreadFork}
, {\b ThreadJoin}
, {\b Cmp}
, {\b BinaryOp}
, {\b UnaryOp}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericNode}< {\b PAGNode}, {\b PAGEdge} >::GEdgeSetTy {\b PAGEdgeSetTy}{\bkmkstart AAAAAAACHL}
{\bkmkend AAAAAAACHL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< EdgeID, PAGEdgeSetTy > {\b PAGEdgeToSetMapTy}{\bkmkstart AAAAAAACHM}
{\bkmkend AAAAAAACHM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PAGEdgeToSetMapTy {\b PAGKindToEdgeSetMapTy}{\bkmkstart AAAAAAACHN}
{\bkmkend AAAAAAACHN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PAGEdge} ({\b PAGNode} *s, {\b PAGNode} *d, {\b GEdgeFlag} k)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ~PAGEdge} (){\bkmkstart AAAAAAACHO}
{\bkmkend AAAAAAACHO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

EdgeID {\b getEdgeID} () const{\bkmkstart AAAAAAACHP}
{\bkmkend AAAAAAACHP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return Edge ID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isPTAEdge} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether src and dst nodes are both of pointer type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Instruction * {\b getInst} () const{\bkmkstart AAAAAAACHQ}
{\bkmkend AAAAAAACHQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get/set methods for llvm instruction. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setValue} (const Value *val){\bkmkstart AAAAAAACHR}
{\bkmkend AAAAAAACHR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getValue} () const{\bkmkstart AAAAAAACHS}
{\bkmkend AAAAAAACHS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setBB} (const BasicBlock *bb){\bkmkstart AAAAAAACHT}
{\bkmkend AAAAAAACHT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const BasicBlock * {\b getBB} () const{\bkmkstart AAAAAAACHU}
{\bkmkend AAAAAAACHU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setICFGNode} ({\b ICFGNode} *node){\bkmkstart AAAAAAACHV}
{\bkmkend AAAAAAACHV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ICFGNode} * {\b getICFGNode} () const{\bkmkstart AAAAAAACHW}
{\bkmkend AAAAAAACHW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACHX}
{\bkmkend AAAAAAACHX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGEdge} *){\bkmkstart AAAAAAACHY}
{\bkmkend AAAAAAACHY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ClassOf. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGEdgeTy} *edge){\bkmkstart AAAAAAACHZ}
{\bkmkend AAAAAAACHZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b GEdgeFlag} {\b makeEdgeFlagWithCallInst} (GEdgeKind k, const {\b ICFGNode} *cs){\bkmkstart AAAAAAACIA}
{\bkmkend AAAAAAACIA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute the unique edgeFlag value from edge kind and call site Instruction. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b GEdgeFlag} {\b makeEdgeFlagWithStoreInst} (GEdgeKind k, const {\b ICFGNode} *store)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static Size_t {\b totalEdgeNum}{\bkmkstart AAAAAAACIB}
{\bkmkend AAAAAAACIB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total edge number. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b raw_ostream} & {\b operator<<} ({\b raw_ostream} &o, const {\b PAGEdge} &edge){\bkmkstart AAAAAAACIC}
{\bkmkend AAAAAAACIC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator << for dumping {\b PAGNode} value. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v PEDGEK\:SVF::PAGEdge}
{\xe \v SVF::PAGEdge\:PEDGEK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SVF::PAGEdge::PEDGEK}}}
\par
{\bkmkstart AAAAAAACID}
{\bkmkend AAAAAAACID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Thirteen kinds of {\b PAG} edges Gep represents offset edge for field sensitivity ThreadFork/ThreadJoin is to model parameter passings between thread spawners and spawnees. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PAGEdge\:SVF::PAGEdge}
{\xe \v SVF::PAGEdge\:PAGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PAGEdge::PAGEdge ({\b PAGNode} *  {\i s}, {\b PAGNode} *  {\i d}, {\b GEdgeFlag}  {\i k})}}
\par
{\bkmkstart AAAAAAACIE}
{\bkmkend AAAAAAACIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAGEdge} constructor \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v isPTAEdge\:SVF::PAGEdge}
{\xe \v SVF::PAGEdge\:isPTAEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PAGEdge::isPTAEdge () const}}
\par
{\bkmkstart AAAAAAACIF}
{\bkmkend AAAAAAACIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether src and dst nodes are both of pointer type. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether src and dst nodes are both pointer type \par
}}
{\xe \v makeEdgeFlagWithStoreInst\:SVF::PAGEdge}
{\xe \v SVF::PAGEdge\:makeEdgeFlagWithStoreInst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b GEdgeFlag} SVF::PAGEdge::makeEdgeFlagWithStoreInst (GEdgeKind  {\i k}, const {\b ICFGNode} *  {\i store}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACIG}
{\bkmkend AAAAAAACIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute the unique edgeFlag value from edge kind and store Instruction. Two store instructions may share the same StorePAGEdge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PAGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PAGNode}
{\xe \v SVF::PAGNode}
{\bkmkstart AAAAAAACLV}
{\bkmkend AAAAAAACLV}
Inheritance diagram for SVF::PAGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_p_a_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b PNODEK} \{ {\b ValNode}
, {\b ObjNode}
, {\b RetNode}
, {\b VarargNode}
, {\b GepValNode}
, {\b GepObjNode}
, {\b FIObjNode}
, {\b DummyValNode}
, {\b DummyObjNode}
, {\b CloneGepObjNode}
, {\b CloneFIObjNode}
, {\b CloneDummyObjNode}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PAGNode} (const Value *val, NodeID i, {\b PNODEK} k)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
address-taken pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~PAGNode} (){\bkmkstart AAAAAAACLW}
{\bkmkend AAAAAAACLW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getValue} () const{\bkmkstart AAAAAAACLX}
{\bkmkend AAAAAAACLX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get/has methods of the components. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const Type * {\b getType} () const{\bkmkstart AAAAAAACLY}
{\bkmkend AAAAAAACLY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return type of the value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasValue} () const{\bkmkstart AAAAAAACLZ}
{\bkmkend AAAAAAACLZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isPointer} () const{\bkmkstart AAAAAAACMA}
{\bkmkend AAAAAAACMA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether it is a pointer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTopLevelPtr} () const{\bkmkstart AAAAAAACMB}
{\bkmkend AAAAAAACMB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether it is a top-level pointer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isAddressTakenPtr} () const{\bkmkstart AAAAAAACMC}
{\bkmkend AAAAAAACMC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether it is an address-taken pointer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isConstantData} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b getValueName} () const =0{\bkmkstart AAAAAAACMD}
{\bkmkend AAAAAAACMD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get name of the LLVM value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const Function * {\b getFunction} () const{\bkmkstart AAAAAAACME}
{\bkmkend AAAAAAACME}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the function that this {\b PAGNode} resides in. Return NULL if it is a global or constantexpr node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGEdge::PAGEdgeSetTy & {\b getIncomingEdges} ({\b PAGEdge::PEDGEK} kind){\bkmkstart AAAAAAACMF}
{\bkmkend AAAAAAACMF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get incoming {\b PAG} edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGEdge::PAGEdgeSetTy & {\b getOutgoingEdges} ({\b PAGEdge::PEDGEK} kind){\bkmkstart AAAAAAACMG}
{\bkmkend AAAAAAACMG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get outgoing {\b PAG} edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasIncomingEdges} ({\b PAGEdge::PEDGEK} kind) const{\bkmkstart AAAAAAACMH}
{\bkmkend AAAAAAACMH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has incoming {\b PAG} edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasIncomingVariantGepEdge} () const{\bkmkstart AAAAAAACMI}
{\bkmkend AAAAAAACMI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has incoming VariantGepEdges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGEdge::PAGEdgeSetTy::iterator {\b getIncomingEdgesBegin} ({\b PAGEdge::PEDGEK} kind) const{\bkmkstart AAAAAAACMJ}
{\bkmkend AAAAAAACMJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get incoming {\b PAGEdge} iterator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGEdge::PAGEdgeSetTy::iterator {\b getIncomingEdgesEnd} ({\b PAGEdge::PEDGEK} kind) const{\bkmkstart AAAAAAACMK}
{\bkmkend AAAAAAACMK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get incoming {\b PAGEdge} iterator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasOutgoingEdges} ({\b PAGEdge::PEDGEK} kind) const{\bkmkstart AAAAAAACML}
{\bkmkend AAAAAAACML}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has outgoing {\b PAG} edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGEdge::PAGEdgeSetTy::iterator {\b getOutgoingEdgesBegin} ({\b PAGEdge::PEDGEK} kind) const{\bkmkstart AAAAAAACMM}
{\bkmkend AAAAAAACMM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get outgoing {\b PAGEdge} iterator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGEdge::PAGEdgeSetTy::iterator {\b getOutgoingEdgesEnd} ({\b PAGEdge::PEDGEK} kind) const{\bkmkstart AAAAAAACMN}
{\bkmkend AAAAAAACMN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get outgoing {\b PAGEdge} iterator. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addInEdge} ({\b PAGEdge} *inEdge){\bkmkstart AAAAAAACMO}
{\bkmkend AAAAAAACMO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add methods of the components }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addOutEdge} ({\b PAGEdge} *outEdge){\bkmkstart AAAAAAACMP}
{\bkmkend AAAAAAACMP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACMQ}
{\bkmkend AAAAAAACMQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b value}{\bkmkstart AAAAAAACMR}
{\bkmkend AAAAAAACMR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
value of this {\b PAG} node }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGEdge::PAGKindToEdgeSetMapTy {\b InEdgeKindToSetMap}{\bkmkstart AAAAAAACMS}
{\bkmkend AAAAAAACMS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGEdge::PAGKindToEdgeSetMapTy {\b OutEdgeKindToSetMap}{\bkmkstart AAAAAAACMT}
{\bkmkend AAAAAAACMT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTLPointer}{\bkmkstart AAAAAAACMU}
{\bkmkend AAAAAAACMU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isATPointer}{\bkmkstart AAAAAAACMV}
{\bkmkend AAAAAAACMV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
top-level pointer }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b raw_ostream} & {\b operator<<} ({\b raw_ostream} &o, const {\b PAGNode} &node){\bkmkstart AAAAAAACMW}
{\bkmkend AAAAAAACMW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator << for dumping {\b PAGNode} value. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v PNODEK\:SVF::PAGNode}
{\xe \v SVF::PAGNode\:PNODEK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SVF::PAGNode::PNODEK}}}
\par
{\bkmkstart AAAAAAACMX}
{\bkmkend AAAAAAACMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Nine kinds of {\b PAG} nodes ValNode: llvm pointer value ObjNode: memory object RetNode: unique return node Vararg: unique node for vararg parameter GepValNode: tempory gep value node for field sensitivity GepValNode: tempory gep obj node for field sensitivity FIObjNode: for field insensitive analysis DummyValNode and DummyObjNode: for non-llvm-value node Clone*Node: objects created by TBHC. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PAGNode\:SVF::PAGNode}
{\xe \v SVF::PAGNode\:PAGNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PAGNode::PAGNode (const Value *  {\i val}, NodeID  {\i i}, {\b PNODEK}  {\i k})}}
\par
{\bkmkstart AAAAAAACMY}
{\bkmkend AAAAAAACMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
address-taken pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor\par
{\b PAGNode} constructor \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v isConstantData\:SVF::PAGNode}
{\xe \v SVF::PAGNode\:isConstantData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::PAGNode::isConstantData () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMZ}
{\bkmkend AAAAAAACMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether it is constant data, i.e., "0", "1.001", "str" or llvm's metadata, i.e., metadata !4087 \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PathCondAllocator Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PathCondAllocator}
{\xe \v SVF::PathCondAllocator}
{\bkmkstart AAAAAAAHDS}
{\bkmkend AAAAAAAHDS}
\par
{
{\f2 #include <PathCondAllocator.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b DdNode} {\b Condition}{\bkmkstart AAAAAAAHDT}
{\bkmkend AAAAAAAHDT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< u32_t, {\b Condition} * > {\b CondPosMap}{\bkmkstart AAAAAAAHDU}
{\bkmkend AAAAAAAHDU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a branch to its Condition }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const BasicBlock *, {\b CondPosMap} > {\b BBCondMap}{\bkmkstart AAAAAAAHDV}
{\bkmkend AAAAAAAHDV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b Condition} *, const Instruction * > {\b CondToTermInstMap}{\bkmkstart AAAAAAAHDW}
{\bkmkend AAAAAAAHDW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const BasicBlock * > {\b BasicBlockSet}{\bkmkstart AAAAAAAHDX}
{\bkmkend AAAAAAAHDX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Function *, BasicBlockSet > {\b FunToExitBBsMap}{\bkmkstart AAAAAAAHDY}
{\bkmkend AAAAAAAHDY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a function to all its basic blocks calling program exit }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const BasicBlock *, {\b Condition} * > {\b BBToCondMap}{\bkmkstart AAAAAAAHDZ}
{\bkmkend AAAAAAAHDZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a basic block to its condition during control-flow guard computation }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< const BasicBlock * > {\b CFWorkList}{\bkmkstart AAAAAAAHEA}
{\bkmkend AAAAAAAHEA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
worklist for control-flow guard computation }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< u32_t, {\b Condition} * > {\b IndexToConditionMap}{\bkmkstart AAAAAAAHEB}
{\bkmkend AAAAAAAHEB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PathCondAllocator} (){\bkmkstart AAAAAAAHEC}
{\bkmkend AAAAAAAHEC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~PathCondAllocator} (){\bkmkstart AAAAAAAHED}
{\bkmkend AAAAAAAHED}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b allocate} (const {\b SVFModule} *module)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform path allocation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Instruction * {\b getCondInst} (const {\b Condition} *cond) const{\bkmkstart AAAAAAAHEE}
{\bkmkend AAAAAAAHEE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get llvm conditional expression. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DominatorTree * {\b getDT} (const Function *fun){\bkmkstart AAAAAAAHEF}
{\bkmkend AAAAAAAHEF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get dominators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PostDominatorTree * {\b getPostDT} (const Function *fun){\bkmkstart AAAAAAAHEG}
{\bkmkend AAAAAAAHEG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Postdominators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

LoopInfo * {\b getLoopInfo} (const Function *f){\bkmkstart AAAAAAAHEH}
{\bkmkend AAAAAAAHEH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get LoopInfo. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Condition} * {\b condAnd} ({\b Condition} *lhs, {\b Condition} *rhs){\bkmkstart AAAAAAAHEI}
{\bkmkend AAAAAAAHEI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Condition operations. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Condition} * {\b condOr} ({\b Condition} *lhs, {\b Condition} *rhs){\bkmkstart AAAAAAAHEJ}
{\bkmkend AAAAAAAHEJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Condition} * {\b condNeg} ({\b Condition} *cond){\bkmkstart AAAAAAAHEK}
{\bkmkend AAAAAAAHEK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Condition} * {\b getTrueCond} () const{\bkmkstart AAAAAAAHEL}
{\bkmkend AAAAAAAHEL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Condition} * {\b getFalseCond} () const{\bkmkstart AAAAAAAHEM}
{\bkmkend AAAAAAAHEM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Condition} * {\b getCond} (u32_t i) const{\bkmkstart AAAAAAAHEN}
{\bkmkend AAAAAAAHEN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an index, get its condition. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeBS {\b exactCondElem} ({\b Condition} *cond){\bkmkstart AAAAAAAHEO}
{\bkmkend AAAAAAAHEO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterator every element of the bdd. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b markForRelease} ({\b Condition} *cond){\bkmkstart AAAAAAAHEP}
{\bkmkend AAAAAAAHEP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Decrease reference counting for the bdd. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b printDbg} ({\b Condition} *cond){\bkmkstart AAAAAAAHEQ}
{\bkmkend AAAAAAAHEQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print debug information for this condition. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b dumpCond} ({\b Condition} *cond) const{\bkmkstart AAAAAAAHER}
{\bkmkend AAAAAAAHER}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Condition} * {\b ComputeIntraVFGGuard} (const BasicBlock *src, const BasicBlock *dst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Guard Computation for a value-flow (between two basic blocks) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Condition} * {\b ComputeInterCallVFGGuard} (const BasicBlock *src, const BasicBlock *dst, const BasicBlock *callBB)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Condition} * {\b ComputeInterRetVFGGuard} (const BasicBlock *src, const BasicBlock *dst, const BasicBlock *retBB)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Condition} * {\b getPHIComplementCond} (const BasicBlock *BB1, const BasicBlock *BB2, const BasicBlock *BB0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b clearCFCond} (){\bkmkstart AAAAAAAHES}
{\bkmkend AAAAAAAHES}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setCurEvalVal} (const Value *val){\bkmkstart AAAAAAAHET}
{\bkmkend AAAAAAAHET}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set current value for branch condition evaluation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getCurEvalVal} () const{\bkmkstart AAAAAAAHEU}
{\bkmkend AAAAAAAHEU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get current value for branch condition evaluation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printPathCond} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print out the path condition information. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b Condition} * {\b trueCond} (){\bkmkstart AAAAAAAHEV}
{\bkmkend AAAAAAAHEV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b Condition} * {\b falseCond} (){\bkmkstart AAAAAAAHEW}
{\bkmkend AAAAAAAHEW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u32_t {\b getMemUsage} (){\bkmkstart AAAAAAAHEX}
{\bkmkend AAAAAAAHEX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u32_t {\b getCondNum} (){\bkmkstart AAAAAAAHEY}
{\bkmkend AAAAAAAHEY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u32_t {\b getMaxLiveCondNumber} (){\bkmkstart AAAAAAAHEZ}
{\bkmkend AAAAAAAHEZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u32_t {\b totalCondNum} = 0{\bkmkstart AAAAAAAHFA}
{\bkmkend AAAAAAAHFA}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

BBCondMap {\b bbConds}{\bkmkstart AAAAAAAHFB}
{\bkmkend AAAAAAAHFB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map basic block to its successors/predecessors branch conditions }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

IndexToConditionMap {\b indexToDDNodeMap}{\bkmkstart AAAAAAAHFC}
{\bkmkend AAAAAAAHFC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b BddCondManager} * {\b bddCondMgr} = NULL{\bkmkstart AAAAAAAHFD}
{\bkmkend AAAAAAAHFD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
bbd manager }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PathCondAllocator} allocates conditions for each basic block of a certain CFG. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v allocate\:SVF::PathCondAllocator}
{\xe \v SVF::PathCondAllocator\:allocate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PathCondAllocator::allocate (const {\b SVFModule} *  {\i M})}}
\par
{\bkmkstart AAAAAAAHFE}
{\bkmkend AAAAAAAHFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform path allocation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate path condition for each branch \par
}}
{\xe \v ComputeInterCallVFGGuard\:SVF::PathCondAllocator}
{\xe \v SVF::PathCondAllocator\:ComputeInterCallVFGGuard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PathCondAllocator::Condition} * PathCondAllocator::ComputeInterCallVFGGuard (const BasicBlock *  {\i srcBB}, const BasicBlock *  {\i dstBB}, const BasicBlock *  {\i callBB}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHFF}
{\bkmkend AAAAAAAHFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute calling inter-procedural guards between two SVFGNodes (from caller to callee) src \'96c1--> callBB \'96true--> funEntryBB \'96c2--> dst the InterCallVFGGuard is c1 ^ c2 \par
}}
{\xe \v ComputeInterRetVFGGuard\:SVF::PathCondAllocator}
{\xe \v SVF::PathCondAllocator\:ComputeInterRetVFGGuard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PathCondAllocator::Condition} * PathCondAllocator::ComputeInterRetVFGGuard (const BasicBlock *  {\i srcBB}, const BasicBlock *  {\i dstBB}, const BasicBlock *  {\i retBB}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHFG}
{\bkmkend AAAAAAAHFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute return inter-procedural guards between two SVFGNodes (from callee to caller) src \'96c1--> funExitBB \'96true--> retBB \'96c2--> dst the InterRetVFGGuard is c1 ^ c2 \par
}}
{\xe \v ComputeIntraVFGGuard\:SVF::PathCondAllocator}
{\xe \v SVF::PathCondAllocator\:ComputeIntraVFGGuard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PathCondAllocator::Condition} * PathCondAllocator::ComputeIntraVFGGuard (const BasicBlock *  {\i srcBB}, const BasicBlock *  {\i dstBB}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHFH}
{\bkmkend AAAAAAAHFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Guard Computation for a value-flow (between two basic blocks) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute intra-procedural guards between two SVFGNodes (inside same function) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if the dstBB is the eligible loop exit of the current basic block we can early terminate the computation\par
calculate the branch condition if succ post dominate bb, then we get brCond quicker by using postDT note that we assume loop exit always post dominate loop bodys which means loops are approximated only once.\par
}}
{\xe \v getPHIComplementCond\:SVF::PathCondAllocator}
{\xe \v SVF::PathCondAllocator\:getPHIComplementCond}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PathCondAllocator::Condition} * PathCondAllocator::getPHIComplementCond (const BasicBlock *  {\i BB1}, const BasicBlock *  {\i BB2}, const BasicBlock *  {\i BB0}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHFI}
{\bkmkend AAAAAAAHFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get complement condition (from B1 to B0) according to a complementBB (BB2) at a phi e.g., B0: dstBB; B1:incomingBB; B2:complementBB\par
Get complement phi condition e.g., B0: dstBB; B1:incomingBB; B2:complementBB Assume B0 (phi node) is the successor of both B1 and B2. If B1 dominates B2, and B0 not dominate B2 then condition from B1-->B0 = neg(B1-->B2)^(B1-->B0) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
avoid both BB0 and BB1 dominate BB2 (e.g., while loop), then BB2 is not necessaryly a complement BB\par
}}
{\xe \v printPathCond\:SVF::PathCondAllocator}
{\xe \v SVF::PathCondAllocator\:printPathCond}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PathCondAllocator::printPathCond ()}}
\par
{\bkmkstart AAAAAAAHFJ}
{\bkmkend AAAAAAAHFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print out the path condition information. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print path conditions \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/PathCondAllocator.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Util/PathCondAllocator.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PathStmtDPItem< LocCond > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PathStmtDPItem< LocCond >}
{\xe \v SVF::PathStmtDPItem< LocCond >}
{\bkmkstart AAAAAAAHBL}
{\bkmkend AAAAAAAHBL}
Inheritance diagram for SVF::PathStmtDPItem< LocCond >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_path_stmt_d_p_item.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b VFPathCond::PathCond} {\b PathCond}{\bkmkstart AAAAAAAHBM}
{\bkmkend AAAAAAAHBM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PathStmtDPItem} (const {\b VFPathVar} &var, const LocCond *locCond){\bkmkstart AAAAAAAHBN}
{\bkmkend AAAAAAAHBN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PathStmtDPItem} (const {\b PathStmtDPItem}< LocCond > &dps){\bkmkstart AAAAAAAHBO}
{\bkmkend AAAAAAAHBO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~PathStmtDPItem} (){\bkmkstart AAAAAAAHBP}
{\bkmkend AAAAAAAHBP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VFPathVar} {\b getCondVar} () const{\bkmkstart AAAAAAAHBQ}
{\bkmkend AAAAAAAHBQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b VFPathCond} & {\b getCond} () const{\bkmkstart AAAAAAAHBR}
{\bkmkend AAAAAAAHBR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get value-flow paths. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VFPathCond} & {\b getCond} (){\bkmkstart AAAAAAAHBS}
{\bkmkend AAAAAAAHBS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get value-flow paths. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b addVFPath} ({\b PathCondAllocator} *allocator, {\b PathCond} *c, NodeID from, NodeID to){\bkmkstart AAAAAAAHBT}
{\bkmkend AAAAAAAHBT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a value-flow path (avoid adding duplicated paths) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b pushContext} (NodeID cxt){\bkmkstart AAAAAAAHBU}
{\bkmkend AAAAAAAHBU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b matchContext} (NodeID cxt){\bkmkstart AAAAAAAHBV}
{\bkmkend AAAAAAAHBV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Match context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b PathStmtDPItem}< LocCond > &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PathStmtDPItem}< LocCond > & {\b operator=} (const {\b PathStmtDPItem}< LocCond > &rhs){\bkmkstart AAAAAAAHBW}
{\bkmkend AAAAAAAHBW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b PathStmtDPItem}< LocCond > &rhs) const{\bkmkstart AAAAAAAHBX}
{\bkmkend AAAAAAAHBX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b PathStmtDPItem}< LocCond > &rhs) const{\bkmkstart AAAAAAAHBY}
{\bkmkend AAAAAAAHBY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator!=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dump} () const{\bkmkstart AAAAAAAHBZ}
{\bkmkend AAAAAAAHBZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump dpm info. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator<\:SVF::PathStmtDPItem< LocCond >}
{\xe \v SVF::PathStmtDPItem< LocCond >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class LocCond > bool {\b SVF::PathStmtDPItem}< LocCond >::operator< (const {\b PathStmtDPItem}< LocCond > &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHCA}
{\bkmkend AAAAAAAHCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable compare operator to avoid duplicated item insertion in map or set to be noted that two vectors can also overload operator() \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/DPItem.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PCG Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PCG}
{\xe \v SVF::PCG}
{\bkmkstart AAAAAAAFSI}
{\bkmkend AAAAAAAFSI}
\par
{
{\f2 #include <PCG.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const Function * > {\b FunSet}{\bkmkstart AAAAAAAFSJ}
{\bkmkend AAAAAAAFSJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const Function * > {\b FunVec}{\bkmkstart AAAAAAAFSK}
{\bkmkend AAAAAAAFSK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const Instruction * > {\b CallInstSet}{\bkmkstart AAAAAAAFSL}
{\bkmkend AAAAAAAFSL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< const Function * > {\b FunWorkList}{\bkmkstart AAAAAAAFSM}
{\bkmkend AAAAAAAFSM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< const BasicBlock * > {\b BBWorkList}{\bkmkstart AAAAAAAFSN}
{\bkmkend AAAAAAAFSN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PCG} ({\b PointerAnalysis} *an){\bkmkstart AAAAAAAFSO}
{\bkmkend AAAAAAAFSO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b analyze} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start the pass here. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~PCG} (){\bkmkstart AAAAAAAFSP}
{\bkmkend AAAAAAAFSP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b mayHappenInParallel} (const Instruction *i1, const Instruction *i2) const{\bkmkstart AAAAAAAFSQ}
{\bkmkend AAAAAAAFSQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface to query whether two function may happen-in-parallel. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b mayHappenInParallelBetweenFunctions} (const Function *fun1, const Function *fun2) const{\bkmkstart AAAAAAAFSR}
{\bkmkend AAAAAAAFSR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const FunSet & {\b getMHPFunctions} () const{\bkmkstart AAAAAAAFSS}
{\bkmkend AAAAAAAFSS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initFromThreadAPI} ({\b SVFModule} *module)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize spawner and spawnee sets with threadAPI. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b inferFromCallGraph} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Infer spawner spawnee and followers sets by traversing on callGraph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b collectSpawners} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b collectSpawnees} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b collectFollowers} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b identifyFollowers} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const FunSet & {\b getSpawners} () const{\bkmkstart AAAAAAAFST}
{\bkmkend AAAAAAAFST}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get spawners/spawnees/followers. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const FunSet & {\b getSpawnees} () const{\bkmkstart AAAAAAAFSU}
{\bkmkend AAAAAAAFSU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const FunSet & {\b getFollowers} () const{\bkmkstart AAAAAAAFSV}
{\bkmkend AAAAAAAFSV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FunSet::iterator {\b spawnersBegin} (const Function *fun) const{\bkmkstart AAAAAAAFSW}
{\bkmkend AAAAAAAFSW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterators for thread properties of a procedure. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FunSet::iterator {\b spawnersEnd} (const Function *fun) const{\bkmkstart AAAAAAAFSX}
{\bkmkend AAAAAAAFSX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FunSet::iterator {\b spawneesBegin} (const Function *fun) const{\bkmkstart AAAAAAAFSY}
{\bkmkend AAAAAAAFSY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FunSet::iterator {\b spawneesEnd} (const Function *fun) const{\bkmkstart AAAAAAAFSZ}
{\bkmkend AAAAAAAFSZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FunSet::iterator {\b followersBegin} (const Function *fun) const{\bkmkstart AAAAAAAFTA}
{\bkmkend AAAAAAAFTA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FunSet::iterator {\b followersEnd} (const Function *fun) const{\bkmkstart AAAAAAAFTB}
{\bkmkend AAAAAAAFTB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b interferenceAnalysis} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Thread interferenceAnalysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printResults} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print analysis results. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printTDFuns} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class serves as a base may-happen in parallel analysis for multithreaded program It distinguish thread spawner, spawnee, follower in procedure level by modeling pthread_create, pthread_join, pthread_exit, pthread_cancel synchronization operations \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v analyze\:SVF::PCG}
{\xe \v SVF::PCG\:analyze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PCG::analyze (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFTC}
{\bkmkend AAAAAAAFTC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start the pass here. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether two functions may happen in parallel \par
}}
{\xe \v collectFollowers\:SVF::PCG}
{\xe \v SVF::PCG\:collectFollowers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PCG::collectFollowers ()}}
\par
{\bkmkstart AAAAAAAFTD}
{\bkmkend AAAAAAAFTD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
collect follower procedures which may be called after pthread_create is invoked directly or indirectly a procedure which is called from a follower is also a follower. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
identify initial followers\par
find all the followers recursively on call graph\par
}}
{\xe \v collectSpawnees\:SVF::PCG}
{\xe \v SVF::PCG\:collectSpawnees}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PCG::collectSpawnees ()}}
\par
{\bkmkstart AAAAAAAFTE}
{\bkmkend AAAAAAAFTE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
spawnee: given a spawnee, all its callees on callgraph are spawnees \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
find all the spawnees recursively on call graph\par
}}
{\xe \v collectSpawners\:SVF::PCG}
{\xe \v SVF::PCG\:collectSpawners}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PCG::collectSpawners ()}}
\par
{\bkmkstart AAAAAAAFTF}
{\bkmkend AAAAAAAFTF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
spawner: given a spawner, all its callers on callgraph are spawners \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
find all the spawners recursively on call graph\par
add all the callsites from callers to callee (spawner) as a spawn site.\par
}}
{\xe \v identifyFollowers\:SVF::PCG}
{\xe \v SVF::PCG\:identifyFollowers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PCG::identifyFollowers ()}}
\par
{\bkmkstart AAAAAAAFTG}
{\bkmkend AAAAAAAFTG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Identify initial followers a procedure whose callsite lies in a control flow path that starts just after a spawner's callsite \par
}}
{\xe \v inferFromCallGraph\:SVF::PCG}
{\xe \v SVF::PCG\:inferFromCallGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PCG::inferFromCallGraph ()}}
\par
{\bkmkstart AAAAAAAFTH}
{\bkmkend AAAAAAAFTH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Infer spawner spawnee and followers sets by traversing on callGraph. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Infer spawners and spawnees from call graph. The inference are recursively done spawners: procedures may create a thread and return with the created thread still running spawnees: procedures may be executed as a spawned thread followers: procedures may be invoked by a thread after the thread returns from a spawner (procedure may be called after pthread_creat is called). \par
}}
{\xe \v initFromThreadAPI\:SVF::PCG}
{\xe \v SVF::PCG\:initFromThreadAPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PCG::initFromThreadAPI ({\b SVFModule} *  {\i module})}}
\par
{\bkmkstart AAAAAAAFTI}
{\bkmkend AAAAAAAFTI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize spawner and spawnee sets with threadAPI. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize thread spawners and spawnees from threadAPI functions a procedure is a spawner if it creates a thread and the created thread is still existent on its return a procedure is a spawnee if it is created by fork call \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO: handle indirect call here for the fork Fun\par
}}
{\xe \v interferenceAnalysis\:SVF::PCG}
{\xe \v SVF::PCG\:interferenceAnalysis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PCG::interferenceAnalysis ()}}
\par
{\bkmkstart AAAAAAAFTJ}
{\bkmkend AAAAAAAFTJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Thread interferenceAnalysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Thread interference analysis, Suppose we have a undirected graph G = \{F,E,I\} F denotes procedure, E represents interference edge (x,y) \\in E, x \\in F, y \\in F means execution of x in one thread may overlap execution of y in another thread I(x,y) is a set of memory locations for this interference edge \par
}}
{\xe \v printResults\:SVF::PCG}
{\xe \v SVF::PCG\:printResults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PCG::printResults ()}}
\par
{\bkmkstart AAAAAAAFTK}
{\bkmkend AAAAAAAFTK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print analysis results. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print analysis results \par
}}
{\xe \v printTDFuns\:SVF::PCG}
{\xe \v SVF::PCG\:printTDFuns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PCG::printTDFuns ()}}
\par
{\bkmkstart AAAAAAAFTL}
{\bkmkend AAAAAAAFTL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print Thread sensitive properties for each function \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/PCG.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MTA/PCG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PHIVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PHIVFGNode}
{\xe \v SVF::PHIVFGNode}
{\bkmkstart AAAAAAADRQ}
{\bkmkend AAAAAAADRQ}
Inheritance diagram for SVF::PHIVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_p_h_i_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< u32_t, const {\b PAGNode} * > {\b OPVers}{\bkmkstart AAAAAAADRR}
{\bkmkend AAAAAAADRR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PHIVFGNode} (NodeID id, const {\b PAGNode} *r, {\b VFGNodeK} k=TPhi){\bkmkstart AAAAAAADRS}
{\bkmkend AAAAAAADRS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isPTANode} () const{\bkmkstart AAAAAAADRT}
{\bkmkend AAAAAAADRT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this phi node is of pointer type (used for pointer analysis). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getOpVer} (u32_t pos) const{\bkmkstart AAAAAAADRU}
{\bkmkend AAAAAAADRU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operands at a llvm PHINode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setOpVer} (u32_t pos, const {\b PAGNode} *node){\bkmkstart AAAAAAADRV}
{\bkmkend AAAAAAADRV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getRes} () const{\bkmkstart AAAAAAADRW}
{\bkmkend AAAAAAADRW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getOpVerNum} () const{\bkmkstart AAAAAAADRX}
{\bkmkend AAAAAAADRX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers::const_iterator {\b opVerBegin} () const{\bkmkstart AAAAAAADRY}
{\bkmkend AAAAAAADRY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers::const_iterator {\b opVerEnd} () const{\bkmkstart AAAAAAADRZ}
{\bkmkend AAAAAAADRZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADSA}
{\bkmkend AAAAAAADSA}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PHIVFGNode} *){\bkmkstart AAAAAAADSB}
{\bkmkend AAAAAAADSB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADSC}
{\bkmkend AAAAAAADSC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADSD}
{\bkmkend AAAAAAADSD}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b res}{\bkmkstart AAAAAAADSE}
{\bkmkend AAAAAAADSE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers {\b opVers}{\bkmkstart AAAAAAADSF}
{\bkmkend AAAAAAADSF}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PointerAnalysis Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis}
{\bkmkstart AAAAAAAELD}
{\bkmkend AAAAAAAELD}
Inheritance diagram for SVF::PointerAnalysis:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_pointer_analysis.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b PTATY} \{ {\b Andersen_BASE}
, {\b Andersen_WPA}
, {\b AndersenLCD_WPA}
, {\b AndersenHCD_WPA}
, {\b AndersenHLCD_WPA}
, {\b AndersenSCD_WPA}
, {\b AndersenSFR_WPA}
, {\b AndersenWaveDiff_WPA}
, {\b AndersenWaveDiffWithType_WPA}
, {\b Steensgaard_WPA}
, {\b CSCallString_WPA}
, {\b CSSummary_WPA}
, {\b FSDATAFLOW_WPA}
, {\b FSSPARSE_WPA}
, {\b FSTBHC_WPA}
, {\b VFS_WPA}
, {\b FSCS_WPA}
, {\b FSCSPS_WPA}
, {\b ADAPTFSCS_WPA}
, {\b ADAPTFSCSPS_WPA}
, {\b TypeCPP_WPA}
, {\b FieldS_DDA}
, {\b FlowS_DDA}
, {\b PathS_DDA}
, {\b Cxt_DDA}
, {\b Default_PTA}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer analysis type list. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b PTAImplTy} \{ {\b BaseImpl}
, {\b BVDataImpl}
, {\b CondImpl}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation type: {\b BVDataPTAImpl} or {\b CondPTAImpl}. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::AliasAnalysis {\b AliasAnalysis}{\bkmkstart AAAAAAAELE}
{\bkmkend AAAAAAAELE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Indirect call edges type, map a callsite to a set of callees. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b CallBlockNode} * > {\b CallSiteSet}{\bkmkstart AAAAAAAELF}
{\bkmkend AAAAAAAELF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PAG::CallSiteToFunPtrMap {\b CallSiteToFunPtrMap}{\bkmkstart AAAAAAAELG}
{\bkmkend AAAAAAAELG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b SVFFunction} * > {\b FunctionSet}{\bkmkstart AAAAAAAELH}
{\bkmkend AAAAAAAELH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< const {\b CallBlockNode} *, FunctionSet > {\b CallEdgeMap}{\bkmkstart AAAAAAAELI}
{\bkmkend AAAAAAAELI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SCCDetection}< {\b PTACallGraph} * > {\b CallGraphSCC}{\bkmkstart AAAAAAAELJ}
{\bkmkend AAAAAAAELJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const GlobalValue * > {\b VTableSet}{\bkmkstart AAAAAAAELK}
{\bkmkend AAAAAAAELK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b SVFFunction} * > {\b VFunSet}{\bkmkstart AAAAAAAELL}
{\bkmkend AAAAAAAELL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b getNumOfResolvedIndCallEdge} () const{\bkmkstart AAAAAAAELM}
{\bkmkend AAAAAAAELM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return number of resolved indirect call edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTACallGraph} * {\b getPTACallGraph} () const{\bkmkstart AAAAAAAELN}
{\bkmkend AAAAAAAELN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return call graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CallGraphSCC} * {\b getCallGraphSCC} () const{\bkmkstart AAAAAAAELO}
{\bkmkend AAAAAAAELO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return call graph SCC. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PointerAnalysis} ({\b PAG} *{\b pag}, {\b PTATY} ty={\b Default_PTA}, bool alias_check=true)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTATY} {\b getAnalysisTy} () const{\bkmkstart AAAAAAAELP}
{\bkmkend AAAAAAAELP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type of pointer analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTAImplTy} {\b getImplTy} () const{\bkmkstart AAAAAAAELQ}
{\bkmkend AAAAAAAELQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return implementation type of the pointer analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b printStat} (){\bkmkstart AAAAAAAELR}
{\bkmkend AAAAAAAELR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether print statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b disablePrintStat} (){\bkmkstart AAAAAAAELS}
{\bkmkend AAAAAAAELS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether print statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallEdgeMap & {\b getIndCallMap} (){\bkmkstart AAAAAAAELT}
{\bkmkend AAAAAAAELT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get callees from an indirect callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasIndCSCallees} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAAELU}
{\bkmkend AAAAAAAELU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const FunctionSet & {\b getIndCSCallees} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAAELV}
{\bkmkend AAAAAAAELV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b resolveIndCalls} (const {\b CallBlockNode} *cs, const PointsTo &target, CallEdgeMap &newEdges, LLVMCallGraph *callgraph=NULL)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resolve indirect call edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b matchArgs} (const {\b CallBlockNode} *cs, const {\b SVFFunction} *callee)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Match arguments for callsite at caller and callee. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b callGraphSCCDetection} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CallGraph SCC related methods. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getCallGraphSCCRepNode} (NodeID id) const{\bkmkstart AAAAAAAELW}
{\bkmkend AAAAAAAELW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get SCC rep node of a {\b SVFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b inSameCallGraphSCC} (const {\b SVFFunction} *fun1, const {\b SVFFunction} *fun2){\bkmkstart AAAAAAAELX}
{\bkmkend AAAAAAAELX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return TRUE if this edge is inside a CallGraph SCC, i.e., src node and dst node are in the same SCC on the {\b SVFG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isInRecursion} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAAELY}
{\bkmkend AAAAAAAELY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isLocalVarInRecursiveFun} (NodeID id) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a local variable is in function recursions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b PTAName} () const{\bkmkstart AAAAAAAELZ}
{\bkmkend AAAAAAAELZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return PTA name. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CommonCHGraph} * {\b getCHGraph} () const{\bkmkstart AAAAAAAEMA}
{\bkmkend AAAAAAAEMA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get {\b CHGraph} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b getVFnsFromCHA} (const {\b CallBlockNode} *cs, VFunSet &vfns){\bkmkstart AAAAAAAEMB}
{\bkmkend AAAAAAAEMB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b getVFnsFromPts} (const {\b CallBlockNode} *cs, const PointsTo &target, VFunSet &vfns){\bkmkstart AAAAAAAEMC}
{\bkmkend AAAAAAAEMC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b connectVCallToVFns} (const {\b CallBlockNode} *cs, const VFunSet &vfns, CallEdgeMap &newEdges){\bkmkstart AAAAAAAEMD}
{\bkmkend AAAAAAAEMD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b resolveCPPIndCalls} (const {\b CallBlockNode} *cs, const PointsTo &target, CallEdgeMap &newEdges){\bkmkstart AAAAAAAEME}
{\bkmkend AAAAAAAEME}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resolve cpp indirect call edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b TypeSystem} * {\b getTypeSystem} () const{\bkmkstart AAAAAAAEMF}
{\bkmkend AAAAAAAEMF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get {\b TypeSystem} }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const std::string {\b aliasTestMayAlias} = "MAYALIAS"{\bkmkstart AAAAAAAEMG}
{\bkmkend AAAAAAAEMG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const std::string {\b aliasTestMayAliasMangled} = "_Z8MAYALIASPvS_"{\bkmkstart AAAAAAAEMH}
{\bkmkend AAAAAAAEMH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const std::string {\b aliasTestNoAlias} = "NOALIAS"{\bkmkstart AAAAAAAEMI}
{\bkmkend AAAAAAAEMI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const std::string {\b aliasTestNoAliasMangled} = "_Z7NOALIASPvS_"{\bkmkstart AAAAAAAEMJ}
{\bkmkend AAAAAAAEMJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const std::string {\b aliasTestPartialAlias} = "PARTIALALIAS"{\bkmkstart AAAAAAAEMK}
{\bkmkend AAAAAAAEMK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const std::string {\b aliasTestPartialAliasMangled} = "_Z12PARTIALALIASPvS_"{\bkmkstart AAAAAAAEML}
{\bkmkend AAAAAAAEML}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const std::string {\b aliasTestMustAlias} = "MUSTALIAS"{\bkmkstart AAAAAAAEMM}
{\bkmkend AAAAAAAEMM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const std::string {\b aliasTestMustAliasMangled} = "_Z9MUSTALIASPvS_"{\bkmkstart AAAAAAAEMN}
{\bkmkend AAAAAAAEMN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const std::string {\b aliasTestFailMayAlias} = "EXPECTEDFAIL_MAYALIAS"{\bkmkstart AAAAAAAEMO}
{\bkmkend AAAAAAAEMO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const std::string {\b aliasTestFailMayAliasMangled} = "_Z21EXPECTEDFAIL_MAYALIASPvS_"{\bkmkstart AAAAAAAEMP}
{\bkmkend AAAAAAAEMP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const std::string {\b aliasTestFailNoAlias} = "EXPECTEDFAIL_NOALIAS"{\bkmkstart AAAAAAAEMQ}
{\bkmkend AAAAAAAEMQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const std::string {\b aliasTestFailNoAliasMangled} = "_Z20EXPECTEDFAIL_NOALIASPvS_"{\bkmkstart AAAAAAAEMR}
{\bkmkend AAAAAAAEMR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b print_stat}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User input flags. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b alias_validation}{\bkmkstart AAAAAAAEMS}
{\bkmkend AAAAAAAEMS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flag for validating points-to/alias results. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b OnTheFlyIterBudgetForStat}{\bkmkstart AAAAAAAEMT}
{\bkmkend AAAAAAAEMT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flag for iteration budget for on-the-fly statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFModule} * {\b svfMod}{\bkmkstart AAAAAAAEMU}
{\bkmkend AAAAAAAEMU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Module. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTATY} {\b ptaTy}{\bkmkstart AAAAAAAEMV}
{\bkmkend AAAAAAAEMV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer analysis Type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTAImplTy} {\b ptaImplTy}{\bkmkstart AAAAAAAEMW}
{\bkmkend AAAAAAAEMW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PTA implementation type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTAStat} * {\b stat}{\bkmkstart AAAAAAAEMX}
{\bkmkend AAAAAAAEMX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTACallGraph} * {\b ptaCallGraph}{\bkmkstart AAAAAAAEMY}
{\bkmkend AAAAAAAEMY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call graph used for pointer analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CallGraphSCC} * {\b callGraphSCC}{\bkmkstart AAAAAAAEMZ}
{\bkmkend AAAAAAAEMZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC for CallGraph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ICFG} * {\b icfg}{\bkmkstart AAAAAAAENA}
{\bkmkend AAAAAAAENA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interprocedural control-flow graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b TypeSystem} * {\b typeSystem}{\bkmkstart AAAAAAAENB}
{\bkmkend AAAAAAAENB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b TypeSystem}. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b PAG} * {\b pag} = NULL{\bkmkstart AAAAAAAENC}
{\bkmkend AAAAAAAENC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b CommonCHGraph} * {\b chgraph} = NULL{\bkmkstart AAAAAAAEND}
{\bkmkend AAAAAAAEND}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CHGraph}. }{
}\par
}\par}
}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PAG} * {\b getPAG} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTAStat} * {\b getStat} () const{\bkmkstart AAAAAAAENE}
{\bkmkend AAAAAAAENE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get PTA stat. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFModule} * {\b getModule} () const{\bkmkstart AAAAAAAENF}
{\bkmkend AAAAAAAENF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Module. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OrderedNodeSet & {\b getAllValidPtrs} (){\bkmkstart AAAAAAAENG}
{\bkmkend AAAAAAAENG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all Valid Pointers for resolution. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~PointerAnalysis} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialization of a pointer analysis, including building symbol table and {\b PAG} etc. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b finalize} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalization of a pointer analysis, including checking alias correctness. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b analyze} ()=0{\bkmkstart AAAAAAAENH}
{\bkmkend AAAAAAAENH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start Analysis here (main part of pointer analysis). It needs to be implemented in child class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b computeDDAPts} (NodeID){\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute points-to results on-demand, overridden by derived classes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual AliasResult {\b alias} (const MemoryLocation &LocA, const MemoryLocation &LocB)=0{\bkmkstart AAAAAAAENI}
{\bkmkend AAAAAAAENI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface exposed to users of our pointer analysis, given Location infos. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual AliasResult {\b alias} (const Value *V1, const Value *V2)=0{\bkmkstart AAAAAAAENJ}
{\bkmkend AAAAAAAENJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface exposed to users of our pointer analysis, given Value infos. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual AliasResult {\b alias} (NodeID node1, NodeID node2)=0{\bkmkstart AAAAAAAENK}
{\bkmkend AAAAAAAENK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface exposed to users of our pointer analysis, given PAGNodeID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const PointsTo & {\b getPts} (NodeID ptr)=0{\bkmkstart AAAAAAAENL}
{\bkmkend AAAAAAAENL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get points-to targets of a pointer. It needs to be implemented in child class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const NodeSet & {\b getRevPts} (NodeID nodeId)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearPts} (){\bkmkstart AAAAAAAENM}
{\bkmkend AAAAAAAENM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear points-to data. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printIndCSTargets} (const {\b CallBlockNode} *cs, const FunctionSet &targets)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print targets of a function pointer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dumpTopLevelPtsTo} (){\bkmkstart AAAAAAAENN}
{\bkmkend AAAAAAAENN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dumpAllPts} (){\bkmkstart AAAAAAAENO}
{\bkmkend AAAAAAAENO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dumpCPts} (){\bkmkstart AAAAAAAENP}
{\bkmkend AAAAAAAENP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b dumpPts} (NodeID ptr, const PointsTo &pts)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printIndCSTargets} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dumpAllTypes} (){\bkmkstart AAAAAAAENQ}
{\bkmkend AAAAAAAENQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dumpStat} (){\bkmkstart AAAAAAAENR}
{\bkmkend AAAAAAAENR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump the statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b containBlackHoleNode} (const PointsTo &pts){\bkmkstart AAAAAAAENS}
{\bkmkend AAAAAAAENS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Determine whether a points-to contains a black hole or constant node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b containConstantNode} (const PointsTo &pts){\bkmkstart AAAAAAAENT}
{\bkmkend AAAAAAAENT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isBlkObjOrConstantObj} (NodeID ptd) const{\bkmkstart AAAAAAAENU}
{\bkmkend AAAAAAAENU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isNonPointerObj} (NodeID ptd) const{\bkmkstart AAAAAAAENV}
{\bkmkend AAAAAAAENV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isHeapMemObj} (NodeID id) const{\bkmkstart AAAAAAAENW}
{\bkmkend AAAAAAAENW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this object is heap or array. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isArrayMemObj} (NodeID id) const{\bkmkstart AAAAAAAENX}
{\bkmkend AAAAAAAENX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isFIObjNode} (NodeID id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getBaseObjNode} (NodeID id){\bkmkstart AAAAAAAENY}
{\bkmkend AAAAAAAENY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getFIObjNode} (NodeID id){\bkmkstart AAAAAAAENZ}
{\bkmkend AAAAAAAENZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getGepObjNode} (NodeID id, const {\b LocationSet} &ls){\bkmkstart AAAAAAAEOA}
{\bkmkend AAAAAAAEOA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const NodeBS & {\b getAllFieldsObjNode} (NodeID id){\bkmkstart AAAAAAAEOB}
{\bkmkend AAAAAAAEOB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setObjFieldInsensitive} (NodeID id){\bkmkstart AAAAAAAEOC}
{\bkmkend AAAAAAAEOC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFieldInsensitive} (NodeID id) const{\bkmkstart AAAAAAAEOD}
{\bkmkend AAAAAAAEOD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallSiteToFunPtrMap & {\b getIndirectCallsites} () const{\bkmkstart AAAAAAAEOE}
{\bkmkend AAAAAAAEOE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return all indirect callsites. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getFunPtr} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAAEOF}
{\bkmkend AAAAAAAEOF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return function pointer {\b PAGNode} at a callsite cs. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b validateTests} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Alias check functions to verify correctness of pointer analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b validateSuccessTests} (std::string fun)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b validateExpectedFailureTests} (std::string fun)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b dumpGraph} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether to dump the graph for debugging purpose. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetObjFieldSensitive} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset all object node as field-sensitive. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v PTAImplTy\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:PTAImplTy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SVF::PointerAnalysis::PTAImplTy}}}
\par
{\bkmkstart AAAAAAAEOG}
{\bkmkend AAAAAAAEOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation type: {\b BVDataPTAImpl} or {\b CondPTAImpl}. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v BaseImpl\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:BaseImpl}
{\qr BaseImpl{\bkmkstart AAAAAAAEOH}
{\bkmkend AAAAAAAEOH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents PointerAnalaysis. \par
}\cell }{\row }
{\xe \v BVDataImpl\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:BVDataImpl}
{\qr BVDataImpl{\bkmkstart AAAAAAAEOI}
{\bkmkend AAAAAAAEOI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents {\b BVDataPTAImpl}. \par
}\cell }{\row }
{\xe \v CondImpl\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:CondImpl}
{\qr CondImpl{\bkmkstart AAAAAAAEOJ}
{\bkmkend AAAAAAAEOJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents {\b CondPTAImpl}. \par
}\cell }{\row }
}
}
{\xe \v PTATY\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:PTATY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SVF::PointerAnalysis::PTATY}}}
\par
{\bkmkstart AAAAAAAEOK}
{\bkmkend AAAAAAAEOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer analysis type list. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Andersen_BASE\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:Andersen_BASE}
{\qr Andersen_BASE{\bkmkstart AAAAAAAEOL}
{\bkmkend AAAAAAAEOL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base {\b Andersen} PTA. \par
}\cell }{\row }
{\xe \v Andersen_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:Andersen_WPA}
{\qr Andersen_WPA{\bkmkstart AAAAAAAEOM}
{\bkmkend AAAAAAAEOM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Andersen} PTA. \par
}\cell }{\row }
{\xe \v AndersenLCD_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:AndersenLCD_WPA}
{\qr AndersenLCD_WPA{\bkmkstart AAAAAAAEON}
{\bkmkend AAAAAAAEON}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lazy cycle detection andersen-style WPA. \par
}\cell }{\row }
{\xe \v AndersenHCD_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:AndersenHCD_WPA}
{\qr AndersenHCD_WPA{\bkmkstart AAAAAAAEOO}
{\bkmkend AAAAAAAEOO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hybird cycle detection andersen-style WPA. \par
}\cell }{\row }
{\xe \v AndersenHLCD_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:AndersenHLCD_WPA}
{\qr AndersenHLCD_WPA{\bkmkstart AAAAAAAEOP}
{\bkmkend AAAAAAAEOP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hybird lazy cycle detection andersen-style WPA. \par
}\cell }{\row }
{\xe \v AndersenSCD_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:AndersenSCD_WPA}
{\qr AndersenSCD_WPA{\bkmkstart AAAAAAAEOQ}
{\bkmkend AAAAAAAEOQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Selective cycle detection andersen-style WPA. \par
}\cell }{\row }
{\xe \v AndersenSFR_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:AndersenSFR_WPA}
{\qr AndersenSFR_WPA{\bkmkstart AAAAAAAEOR}
{\bkmkend AAAAAAAEOR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stride-based field representation. \par
}\cell }{\row }
{\xe \v AndersenWaveDiff_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:AndersenWaveDiff_WPA}
{\qr AndersenWaveDiff_WPA{\bkmkstart AAAAAAAEOS}
{\bkmkend AAAAAAAEOS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Diff wave propagation andersen-style WPA. \par
}\cell }{\row }
{\xe \v AndersenWaveDiffWithType_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:AndersenWaveDiffWithType_WPA}
{\qr AndersenWaveDiffWithType_WPA{\bkmkstart AAAAAAAEOT}
{\bkmkend AAAAAAAEOT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Diff wave propagation with type info andersen-style WPA. \par
}\cell }{\row }
{\xe \v Steensgaard_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:Steensgaard_WPA}
{\qr Steensgaard_WPA{\bkmkstart AAAAAAAEOU}
{\bkmkend AAAAAAAEOU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Steensgaard} PTA. \par
}\cell }{\row }
{\xe \v CSCallString_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:CSCallString_WPA}
{\qr CSCallString_WPA{\bkmkstart AAAAAAAEOV}
{\bkmkend AAAAAAAEOV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call string based context sensitive WPA. \par
}\cell }{\row }
{\xe \v CSSummary_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:CSSummary_WPA}
{\qr CSSummary_WPA{\bkmkstart AAAAAAAEOW}
{\bkmkend AAAAAAAEOW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Summary based context sensitive WPA. \par
}\cell }{\row }
{\xe \v FSDATAFLOW_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:FSDATAFLOW_WPA}
{\qr FSDATAFLOW_WPA{\bkmkstart AAAAAAAEOX}
{\bkmkend AAAAAAAEOX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Traditional Dataflow-based flow sensitive WPA. \par
}\cell }{\row }
{\xe \v FSSPARSE_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:FSSPARSE_WPA}
{\qr FSSPARSE_WPA{\bkmkstart AAAAAAAEOY}
{\bkmkend AAAAAAAEOY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sparse flow sensitive WPA. \par
}\cell }{\row }
{\xe \v FSTBHC_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:FSTBHC_WPA}
{\qr FSTBHC_WPA{\bkmkstart AAAAAAAEOZ}
{\bkmkend AAAAAAAEOZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sparse flow-sensitive type-based heap cloning WPA. \par
}\cell }{\row }
{\xe \v VFS_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:VFS_WPA}
{\qr VFS_WPA{\bkmkstart AAAAAAAEPA}
{\bkmkend AAAAAAAEPA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Versioned sparse flow-sensitive WPA. \par
}\cell }{\row }
{\xe \v FSCS_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:FSCS_WPA}
{\qr FSCS_WPA{\bkmkstart AAAAAAAEPB}
{\bkmkend AAAAAAAEPB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flow-, context- sensitive WPA. \par
}\cell }{\row }
{\xe \v FSCSPS_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:FSCSPS_WPA}
{\qr FSCSPS_WPA{\bkmkstart AAAAAAAEPC}
{\bkmkend AAAAAAAEPC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flow-, context-, path- sensitive WPA. \par
}\cell }{\row }
{\xe \v ADAPTFSCS_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:ADAPTFSCS_WPA}
{\qr ADAPTFSCS_WPA{\bkmkstart AAAAAAAEPD}
{\bkmkend AAAAAAAEPD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adaptive Flow-, context-, sensitive WPA. \par
}\cell }{\row }
{\xe \v ADAPTFSCSPS_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:ADAPTFSCSPS_WPA}
{\qr ADAPTFSCSPS_WPA{\bkmkstart AAAAAAAEPE}
{\bkmkend AAAAAAAEPE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adaptive Flow-, context-, path- sensitive WPA. \par
}\cell }{\row }
{\xe \v TypeCPP_WPA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:TypeCPP_WPA}
{\qr TypeCPP_WPA{\bkmkstart AAAAAAAEPF}
{\bkmkend AAAAAAAEPF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type-based analysis for C++. \par
}\cell }{\row }
{\xe \v FieldS_DDA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:FieldS_DDA}
{\qr FieldS_DDA{\bkmkstart AAAAAAAEPG}
{\bkmkend AAAAAAAEPG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Field sensitive DDA. \par
}\cell }{\row }
{\xe \v FlowS_DDA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:FlowS_DDA}
{\qr FlowS_DDA{\bkmkstart AAAAAAAEPH}
{\bkmkend AAAAAAAEPH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flow sensitive DDA. \par
}\cell }{\row }
{\xe \v PathS_DDA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:PathS_DDA}
{\qr PathS_DDA{\bkmkstart AAAAAAAEPI}
{\bkmkend AAAAAAAEPI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Guarded value-flow DDA. \par
}\cell }{\row }
{\xe \v Cxt_DDA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:Cxt_DDA}
{\qr Cxt_DDA{\bkmkstart AAAAAAAEPJ}
{\bkmkend AAAAAAAEPJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
context sensitive DDA \par
}\cell }{\row }
{\xe \v Default_PTA\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:Default_PTA}
{\qr Default_PTA{\bkmkstart AAAAAAAEPK}
{\bkmkend AAAAAAAEPK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
default pta without any analysis \par
}\cell }{\row }
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PointerAnalysis\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:PointerAnalysis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PointerAnalysis::PointerAnalysis ({\b PAG} *  {\i p}, {\b PTATY}  {\i ty} = {\f2 {\b Default_PTA}}, bool  {\i alias_check} = {\f2 true})}}
\par
{\bkmkstart AAAAAAAEPL}
{\bkmkend AAAAAAAEPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor \par
}}
{\xe \v ~PointerAnalysis\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:~PointerAnalysis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PointerAnalysis::~PointerAnalysis (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEPM}
{\bkmkend AAAAAAAEPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v callGraphSCCDetection\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:callGraphSCCDetection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVF::PointerAnalysis::callGraphSCCDetection (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEPN}
{\bkmkend AAAAAAAEPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CallGraph SCC related methods. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CallGraph SCC detection \par
}}
{\xe \v dumpGraph\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:dumpGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PointerAnalysis::dumpGraph (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAEPO}
{\bkmkend AAAAAAAEPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether to dump the graph for debugging purpose. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flag in order to dump graph \par
}}
{\xe \v dumpPts\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:dumpPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PointerAnalysis::dumpPts (NodeID  {\i ptr}, const PointsTo &  {\i pts}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEPP}
{\bkmkend AAAAAAAEPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump points-to of top-level pointers ({\b ValPN}) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
print the points-to set of node which has the maximum pts size.\par
}}
{\xe \v finalize\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:finalize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PointerAnalysis::finalize (void ){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEPQ}
{\bkmkend AAAAAAAEPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalization of a pointer analysis, including checking alias correctness. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalize the analysis after solving Given the alias results, verify whether it is correct or not using alias check functions \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print statistics\par
Dump results\par
}{
Reimplemented in {\b SVF::VersionedFlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEPR \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::FlowSensitiveTBHC} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEPS \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::FlowDDA} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABIJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::ContextDDA} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::TypeAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEPT \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::FlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEPU \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEPV \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::AndersenBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEPW \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::CondPTAImpl< Cond >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEPX \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::CondPTAImpl< ContextCond >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEPX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getPAG\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:getPAG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PAG}* SVF::PointerAnalysis::getPAG () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEPY}
{\bkmkend AAAAAAAEPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get/set {\b PAG} \par
}}
{\xe \v getRevPts\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:getRevPts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual const NodeSet& SVF::PointerAnalysis::getRevPts (NodeID  {\i nodeId}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAEPZ}
{\bkmkend AAAAAAAEPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an object, get all the nodes having whose pointsto contains the object. Similar to getPts, this also needs to be implemented in child classes. \par
}{
Implemented in {\b SVF::CondPTAImpl< Cond >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQA \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::CondPTAImpl< ContextCond >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQA \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::BVDataPTAImpl} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v initialize\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PointerAnalysis::initialize (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialization of a pointer analysis, including building symbol table and {\b PAG} etc. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialization of pointer analysis \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
initialise pta call graph for every pointer analysis instance\par
}{
Reimplemented in {\b SVF::VersionedFlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQC \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::FlowSensitiveTBHC} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQD \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::FlowDDA} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABII \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::ContextDDA} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::TypeAnalysis} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQE \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::FlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQF \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::AndersenSFR} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQG \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::AndersenHLCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::AndersenHCD} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQI \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::AndersenBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAEQK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isFIObjNode\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:isFIObjNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::PointerAnalysis::isFIObjNode (NodeID  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEQL}
{\bkmkend AAAAAAAEQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For field-sensitivity \par
}}
{\xe \v isLocalVarInRecursiveFun\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:isLocalVarInRecursiveFun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PointerAnalysis::isLocalVarInRecursiveFun (NodeID  {\i id}) const}}
\par
{\bkmkstart AAAAAAAEQM}
{\bkmkend AAAAAAAEQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a local variable is in function recursions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return TRUE if this node is a local variable of recursive function. \par
}}
{\xe \v matchArgs\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:matchArgs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PointerAnalysis::matchArgs (const {\b CallBlockNode} *  {\i cs}, const {\b SVFFunction} *  {\i callee})}}
\par
{\bkmkstart AAAAAAAEQN}
{\bkmkend AAAAAAAEQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Match arguments for callsite at caller and callee. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Match arguments for callsite at caller and callee \par
}}
{\xe \v printIndCSTargets\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:printIndCSTargets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PointerAnalysis::printIndCSTargets ()}}
\par
{\bkmkstart AAAAAAAEQO}
{\bkmkend AAAAAAAEQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print all indirect callsites \par
}}
{\xe \v printIndCSTargets\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:printIndCSTargets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PointerAnalysis::printIndCSTargets (const {\b CallBlockNode} *  {\i cs}, const FunctionSet &  {\i targets})}}
\par
{\bkmkstart AAAAAAAEQP}
{\bkmkend AAAAAAAEQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print targets of a function pointer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print indirect call targets at an indirect callsite \par
}}
{\xe \v resetObjFieldSensitive\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:resetObjFieldSensitive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PointerAnalysis::resetObjFieldSensitive (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAEQQ}
{\bkmkend AAAAAAAEQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset all object node as field-sensitive. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset field sensitivity \par
}}
{\xe \v resolveIndCalls\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:resolveIndCalls}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PointerAnalysis::resolveIndCalls (const {\b CallBlockNode} *  {\i cs}, const PointsTo &  {\i target}, CallEdgeMap &  {\i newEdges}, LLVMCallGraph *  {\i callgraph} = {\f2 NULL}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEQR}
{\bkmkend AAAAAAAEQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resolve indirect call edges. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resolve indirect calls \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
discover indirect pointer target\par
if the arg size does not match then we do not need to connect this parameter even if the callee is a variadic function (the first parameter of variadic function is its paramter number)\par
}}
{\xe \v validateExpectedFailureTests\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:validateExpectedFailureTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PointerAnalysis::validateExpectedFailureTests (std::string  {\i fun}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEQS}
{\bkmkend AAAAAAAEQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer analysis validator \par
}}
{\xe \v validateSuccessTests\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:validateSuccessTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PointerAnalysis::validateSuccessTests (std::string  {\i fun}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEQT}
{\bkmkend AAAAAAAEQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find the alias check functions annotated in the C files check whether the alias analysis results consistent with the alias check function itself \par
}}
{\xe \v validateTests\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:validateTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PointerAnalysis::validateTests (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAEQU}
{\bkmkend AAAAAAAEQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Alias check functions to verify correctness of pointer analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Validate test cases \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v print_stat\:SVF::PointerAnalysis}
{\xe \v SVF::PointerAnalysis\:print_stat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::PointerAnalysis::print_stat{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAEQV}
{\bkmkend AAAAAAAEQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User input flags. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flag for printing the statistic results \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/PointerAnalysis.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MemoryModel/PointerAnalysis.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ProgSlice Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ProgSlice}
{\xe \v SVF::ProgSlice}
{\bkmkstart AAAAAAAFXS}
{\bkmkend AAAAAAAFXS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b SVFGNode} * > {\b SVFGNodeSet}{\bkmkstart AAAAAAAFXT}
{\bkmkend AAAAAAAFXT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef SVFGNodeSet::const_iterator {\b SVFGNodeSetIter}{\bkmkstart AAAAAAAFXU}
{\bkmkend AAAAAAAFXU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b PathCondAllocator::Condition} {\b Condition}{\bkmkstart AAAAAAAFXV}
{\bkmkend AAAAAAAFXV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFGNode} *, {\b Condition} * > {\b SVFGNodeToCondMap}{\bkmkstart AAAAAAAFXW}
{\bkmkend AAAAAAAFXW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a SVFGNode to its condition during value-flow guard computation }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< const {\b SVFGNode} * > {\b VFWorkList}{\bkmkstart AAAAAAAFXX}
{\bkmkend AAAAAAAFXX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
worklist for value-flow guard computation }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< const BasicBlock * > {\b CFWorkList}{\bkmkstart AAAAAAAFXY}
{\bkmkend AAAAAAAFXY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
worklist for control-flow guard computation }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ProgSlice} (const {\b SVFGNode} *src, {\b PathCondAllocator} *pa, const {\b SVFG} *graph){\bkmkstart AAAAAAAFXZ}
{\bkmkend AAAAAAAFXZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~ProgSlice} (){\bkmkstart AAAAAAAFYA}
{\bkmkend AAAAAAAFYA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getForwardSliceSize} () const{\bkmkstart AAAAAAAFYB}
{\bkmkend AAAAAAAFYB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getBackwardSliceSize} () const{\bkmkstart AAAAAAAFYC}
{\bkmkend AAAAAAAFYC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addToForwardSlice} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAFYD}
{\bkmkend AAAAAAAFYD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Forward and backward slice operations. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addToBackwardSlice} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAFYE}
{\bkmkend AAAAAAAFYE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b inForwardSlice} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAFYF}
{\bkmkend AAAAAAAFYF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b inBackwardSlice} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAFYG}
{\bkmkend AAAAAAAFYG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SVFGNodeSetIter {\b forwardSliceBegin} () const{\bkmkstart AAAAAAAFYH}
{\bkmkend AAAAAAAFYH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SVFGNodeSetIter {\b forwardSliceEnd} () const{\bkmkstart AAAAAAAFYI}
{\bkmkend AAAAAAAFYI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SVFGNodeSetIter {\b backwardSliceBegin} () const{\bkmkstart AAAAAAAFYJ}
{\bkmkend AAAAAAAFYJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SVFGNodeSetIter {\b backwardSliceEnd} () const{\bkmkstart AAAAAAAFYK}
{\bkmkend AAAAAAAFYK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFGNode} * {\b getSource} () const{\bkmkstart AAAAAAAFYL}
{\bkmkend AAAAAAAFYL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
root and sink operations }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addToSinks} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAFYM}
{\bkmkend AAAAAAAFYM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const SVFGNodeSet & {\b getSinks} () const{\bkmkstart AAAAAAAFYN}
{\bkmkend AAAAAAAFYN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SVFGNodeSetIter {\b sinksBegin} () const{\bkmkstart AAAAAAAFYO}
{\bkmkend AAAAAAAFYO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SVFGNodeSetIter {\b sinksEnd} () const{\bkmkstart AAAAAAAFYP}
{\bkmkend AAAAAAAFYP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setPartialReachable} (){\bkmkstart AAAAAAAFYQ}
{\bkmkend AAAAAAAFYQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setAllReachable} (){\bkmkstart AAAAAAAFYR}
{\bkmkend AAAAAAAFYR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b setReachGlobal} (){\bkmkstart AAAAAAAFYS}
{\bkmkend AAAAAAAFYS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isPartialReachable} () const{\bkmkstart AAAAAAAFYT}
{\bkmkend AAAAAAAFYT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isAllReachable} () const{\bkmkstart AAAAAAAFYU}
{\bkmkend AAAAAAAFYU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isReachGlobal} () const{\bkmkstart AAAAAAAFYV}
{\bkmkend AAAAAAAFYV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b AllPathReachableSolve} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Guarded reachability solve. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isSatisfiableForAll} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isSatisfiableForPairs} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const Value * {\b getLLVMValue} (const {\b SVFGNode} *node) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get llvm value from a SVFGNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getCallSite} (const {\b SVFGEdge} *edge) const{\bkmkstart AAAAAAAFYW}
{\bkmkend AAAAAAAFYW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get callsite ID and get returnsiteID from SVFGEdge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getRetSite} (const {\b SVFGEdge} *edge) const{\bkmkstart AAAAAAAFYX}
{\bkmkend AAAAAAAFYX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Condition} * {\b condAnd} ({\b Condition} *lhs, {\b Condition} *rhs){\bkmkstart AAAAAAAFYY}
{\bkmkend AAAAAAAFYY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Condition operations. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Condition} * {\b condOr} ({\b Condition} *lhs, {\b Condition} *rhs){\bkmkstart AAAAAAAFYZ}
{\bkmkend AAAAAAAFYZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Condition} * {\b condNeg} ({\b Condition} *cond){\bkmkstart AAAAAAAFZA}
{\bkmkend AAAAAAAFZA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Condition} * {\b getTrueCond} () const{\bkmkstart AAAAAAAFZB}
{\bkmkend AAAAAAAFZB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Condition} * {\b getFalseCond} () const{\bkmkstart AAAAAAAFZC}
{\bkmkend AAAAAAAFZC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b dumpCond} ({\b Condition} *cond) const{\bkmkstart AAAAAAAFZD}
{\bkmkend AAAAAAAFZD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b evalFinalCond} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Evaluate final condition. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b annotatePaths} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Annotate program according to final condition. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFG} * {\b getSVFG} () const{\bkmkstart AAAAAAAFZE}
{\bkmkend AAAAAAAFZE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Release memory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clearCFCond} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear Control flow conditions before each VF computation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Condition} * {\b getVFCond} (const {\b SVFGNode} *node) const{\bkmkstart AAAAAAAFZF}
{\bkmkend AAAAAAAFZF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get/set VF (value-flow) and CF (control-flow) conditions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b setVFCond} (const {\b SVFGNode} *node, {\b Condition} *cond){\bkmkstart AAAAAAAFZG}
{\bkmkend AAAAAAAFZG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Condition} * {\b ComputeIntraVFGGuard} (const BasicBlock *src, const BasicBlock *dst){\bkmkstart AAAAAAAFZH}
{\bkmkend AAAAAAAFZH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute guards for value-flows. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Condition} * {\b ComputeInterCallVFGGuard} (const BasicBlock *src, const BasicBlock *dst, const BasicBlock *callBB){\bkmkstart AAAAAAAFZI}
{\bkmkend AAAAAAAFZI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Condition} * {\b ComputeInterRetVFGGuard} (const BasicBlock *src, const BasicBlock *dst, const BasicBlock *retBB){\bkmkstart AAAAAAAFZJ}
{\bkmkend AAAAAAAFZJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const BasicBlock * {\b getSVFGNodeBB} (const {\b SVFGNode} *node) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFGNode} * {\b getCurSVFGNode} () const{\bkmkstart AAAAAAAFZK}
{\bkmkend AAAAAAAFZK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get/set current {\b SVFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setCurSVFGNode} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAFZL}
{\bkmkend AAAAAAAFZL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setFinalCond} ({\b Condition} *cond){\bkmkstart AAAAAAAFZM}
{\bkmkend AAAAAAAFZM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set final condition after all path reachability analysis. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AllPathReachableSolve\:SVF::ProgSlice}
{\xe \v SVF::ProgSlice\:AllPathReachableSolve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ProgSlice::AllPathReachableSolve ()}}
\par
{\bkmkstart AAAAAAAFZN}
{\bkmkend AAAAAAAFZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Guarded reachability solve. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute path conditions for nodes on the backward slice path condition of each node is calculated starting from root node (source) Given a SVFGNode n, its path condition C is allocated (path_i stands for one of m program paths reaches n)\par
C = \\bigvee Guard(path_i), 0 < i < m Guard(path_i) = \\bigwedge VFGGuard(x,y), suppose (x,y) are two SVFGNode nodes on path_i \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
mark source node conditions to be true\par
clean up the control flow conditions for next round guard computation\par
}}
{\xe \v annotatePaths\:SVF::ProgSlice}
{\xe \v SVF::ProgSlice\:annotatePaths}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ProgSlice::annotatePaths ()}}
\par
{\bkmkstart AAAAAAAFZO}
{\bkmkend AAAAAAAFZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Annotate program according to final condition. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Annotate program paths according to the final path condition computed \par
}}
{\xe \v clearCFCond\:SVF::ProgSlice}
{\xe \v SVF::ProgSlice\:clearCFCond}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVF::ProgSlice::clearCFCond (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFZP}
{\bkmkend AAAAAAAFZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear Control flow conditions before each VF computation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO: how to clean bdd memory\par
}}
{\xe \v destroy\:SVF::ProgSlice}
{\xe \v SVF::ProgSlice\:destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ProgSlice::destroy (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFZQ}
{\bkmkend AAAAAAAFZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Release memory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO: how to clean bdd memory\par
}}
{\xe \v evalFinalCond\:SVF::ProgSlice}
{\xe \v SVF::ProgSlice\:evalFinalCond}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string ProgSlice::evalFinalCond () const}}
\par
{\bkmkstart AAAAAAAFZR}
{\bkmkend AAAAAAAFZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Evaluate final condition. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Evaluate Atoms of a condition TODO: for now we only evaluate one path, evaluate every single path\par
Atom \'96 a propositional valirable: a, b, c Literal \'96 an atom or its negation: a, ~a Clause \'96 A disjunction of some literals: a \\vee b CNF formula \'96 a conjunction of some clauses: (a \\vee b ) \\wedge (c \\vee d) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
print leak path after eliminating duplicated element\par
}}
{\xe \v getLLVMValue\:SVF::ProgSlice}
{\xe \v SVF::ProgSlice\:getLLVMValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const Value * ProgSlice::getLLVMValue (const {\b SVFGNode} *  {\i node}) const}}
\par
{\bkmkstart AAAAAAAFZS}
{\bkmkend AAAAAAAFZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get llvm value from a SVFGNode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return llvm value for addr/copy/gep/load/phi/actualParam/formalParam/actualRet/formalRet but not for store/mssaphi/actualIn/acutalOut/formalIn/formalOut \par
}}
{\xe \v getSVFGNodeBB\:SVF::ProgSlice}
{\xe \v SVF::ProgSlice\:getSVFGNodeBB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const BasicBlock* SVF::ProgSlice::getSVFGNodeBB (const {\b SVFGNode} *  {\i node}) const{\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFZT}
{\bkmkend AAAAAAAFZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the basic block where a SVFGNode resides in a SVFGNode may not in a basic block if it is not a program statement (e.g. {\b PAGEdge} is an global assignment or NullPtrSVFGNode) \par
}}
{\xe \v isSatisfiableForAll\:SVF::ProgSlice}
{\xe \v SVF::ProgSlice\:isSatisfiableForAll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ProgSlice::isSatisfiableForAll ()}}
\par
{\bkmkstart AAAAAAAFZU}
{\bkmkend AAAAAAAFZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Solve by computing disjunction of conditions from all sinks (e.g., memory leak) \par
}}
{\xe \v isSatisfiableForPairs\:SVF::ProgSlice}
{\xe \v SVF::ProgSlice\:isSatisfiableForPairs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ProgSlice::isSatisfiableForPairs ()}}
\par
{\bkmkstart AAAAAAAFZV}
{\bkmkend AAAAAAAFZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Solve by analysing each pair of sinks (e.g., double free) \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SABER/ProgSlice.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SABER/ProgSlice.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PTACallGraph Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PTACallGraph}
{\xe \v SVF::PTACallGraph}
{\bkmkstart AAAAAAACSA}
{\bkmkend AAAAAAACSA}
Inheritance diagram for SVF::PTACallGraph:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_p_t_a_call_graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b CGEK} \{ {\b NormCallGraph}
, {\b ThdCallGraph}
 \}{\bkmkstart AAAAAAACSB}
{\bkmkend AAAAAAACSB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PTACallGraphEdge::CallGraphEdgeSet {\b CallGraphEdgeSet}{\bkmkstart AAAAAAACSC}
{\bkmkend AAAAAAACSC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, {\b PTACallGraphNode} * > {\b FunToCallGraphNodeMap}{\bkmkstart AAAAAAACSD}
{\bkmkend AAAAAAACSD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CallBlockNode} *, CallGraphEdgeSet > {\b CallInstToCallGraphEdgesMap}{\bkmkstart AAAAAAACSE}
{\bkmkend AAAAAAACSE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::pair< const {\b CallBlockNode} *, const {\b SVFFunction} * > {\b CallSitePair}{\bkmkstart AAAAAAACSF}
{\bkmkend AAAAAAACSF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< CallSitePair, CallSiteID > {\b CallSiteToIdMap}{\bkmkstart AAAAAAACSG}
{\bkmkend AAAAAAACSG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< CallSiteID, CallSitePair > {\b IdToCallSiteMap}{\bkmkstart AAAAAAACSH}
{\bkmkend AAAAAAACSH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b SVFFunction} * > {\b FunctionSet}{\bkmkstart AAAAAAACSI}
{\bkmkend AAAAAAACSI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< const {\b CallBlockNode} *, FunctionSet > {\b CallEdgeMap}{\bkmkstart AAAAAAACSJ}
{\bkmkend AAAAAAACSJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef CallGraphEdgeSet::iterator {\b CallGraphEdgeIter}{\bkmkstart AAAAAAACSK}
{\bkmkend AAAAAAACSK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef CallGraphEdgeSet::const_iterator {\b CallGraphEdgeConstIter}{\bkmkstart AAAAAAACSL}
{\bkmkend AAAAAAACSL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTACallGraph} (CGEK k=NormCallGraph){\bkmkstart AAAAAAACSM}
{\bkmkend AAAAAAACSM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addCallGraphNode} (const {\b SVFFunction} *fun)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add callgraph Node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~PTACallGraph} (){\bkmkstart AAAAAAACSN}
{\bkmkend AAAAAAACSN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CGEK {\b getKind} () const{\bkmkstart AAAAAAACSO}
{\bkmkend AAAAAAACSO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return type of this callgraph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallEdgeMap & {\b getIndCallMap} (){\bkmkstart AAAAAAACSP}
{\bkmkend AAAAAAACSP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get callees from an indirect callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasIndCSCallees} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAACSQ}
{\bkmkend AAAAAAACSQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const FunctionSet & {\b getIndCSCallees} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAACSR}
{\bkmkend AAAAAAACSR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getTotalCallSiteNumber} () const{\bkmkstart AAAAAAACSS}
{\bkmkend AAAAAAACSS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b getNumOfResolvedIndCallEdge} () const{\bkmkstart AAAAAAACST}
{\bkmkend AAAAAAACST}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallInstToCallGraphEdgesMap & {\b getCallInstToCallGraphEdgesMap} () const{\bkmkstart AAAAAAACSU}
{\bkmkend AAAAAAACSU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b verifyCallGraph} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Issue a warning if the function which has indirect call sites can not be reached from program entry. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTACallGraphNode} * {\b getCallGraphNode} (NodeID id) const{\bkmkstart AAAAAAACSV}
{\bkmkend AAAAAAACSV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get call graph node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTACallGraphNode} * {\b getCallGraphNode} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAACSW}
{\bkmkend AAAAAAACSW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteID {\b addCallSite} (const {\b CallBlockNode} *cs, const {\b SVFFunction} *callee){\bkmkstart AAAAAAACSX}
{\bkmkend AAAAAAACSX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add/Get CallSiteID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteID {\b getCallSiteID} (const {\b CallBlockNode} *cs, const {\b SVFFunction} *callee) const{\bkmkstart AAAAAAACSY}
{\bkmkend AAAAAAACSY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasCallSiteID} (const {\b CallBlockNode} *cs, const {\b SVFFunction} *callee) const{\bkmkstart AAAAAAACSZ}
{\bkmkend AAAAAAACSZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallSitePair & {\b getCallSitePair} (CallSiteID id) const{\bkmkstart AAAAAAACTA}
{\bkmkend AAAAAAACTA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getCallSite} (CallSiteID id) const{\bkmkstart AAAAAAACTB}
{\bkmkend AAAAAAACTB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getCallerOfCallSite} (CallSiteID id) const{\bkmkstart AAAAAAACTC}
{\bkmkend AAAAAAACTC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getCalleeOfCallSite} (CallSiteID id) const{\bkmkstart AAAAAAACTD}
{\bkmkend AAAAAAACTD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PTACallGraphEdge} * {\b hasGraphEdge} ({\b PTACallGraphNode} *src, {\b PTACallGraphNode} *dst, PTACallGraphEdge::CEDGEK kind, CallSiteID csId) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we have aleady created this call graph edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PTACallGraphEdge} * {\b getGraphEdge} ({\b PTACallGraphNode} *src, {\b PTACallGraphNode} *dst, PTACallGraphEdge::CEDGEK kind, CallSiteID csId)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get call graph edge via nodes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b getCallees} (const {\b CallBlockNode} *cs, FunctionSet &callees){\bkmkstart AAAAAAACTE}
{\bkmkend AAAAAAACTE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all callees for a callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasCallGraphEdge} (const {\b CallBlockNode} *inst) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get call graph edge via call instruction. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallGraphEdgeSet::const_iterator {\b getCallEdgeBegin} (const {\b CallBlockNode} *inst) const{\bkmkstart AAAAAAACTF}
{\bkmkend AAAAAAACTF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallGraphEdgeSet::const_iterator {\b getCallEdgeEnd} (const {\b CallBlockNode} *inst) const{\bkmkstart AAAAAAACTG}
{\bkmkend AAAAAAACTG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addEdge} ({\b PTACallGraphEdge} *edge){\bkmkstart AAAAAAACTH}
{\bkmkend AAAAAAACTH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add call graph edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addDirectCallGraphEdge} (const {\b CallBlockNode} *call, const {\b SVFFunction} *callerFun, const {\b SVFFunction} *calleeFun)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add direct/indirect call edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addIndirectCallGraphEdge} (const {\b CallBlockNode} *cs, const {\b SVFFunction} *callerFun, const {\b SVFFunction} *calleeFun)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getAllCallSitesInvokingCallee} (const {\b SVFFunction} *callee, PTACallGraphEdge::CallInstSet &csSet)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get callsites invoking the callee. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getDirCallSitesInvokingCallee} (const {\b SVFFunction} *callee, PTACallGraphEdge::CallInstSet &csSet)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getIndCallSitesInvokingCallee} (const {\b SVFFunction} *callee, PTACallGraphEdge::CallInstSet &csSet)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isReachableBetweenFunctions} (const {\b SVFFunction} *srcFn, const {\b SVFFunction} *dstFn) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether its reachable between two functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump} (const std::string &filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump the graph. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FunToCallGraphNodeMap {\b funToCallGraphNodeMap}{\bkmkstart AAAAAAACTI}
{\bkmkend AAAAAAACTI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Call Graph node map. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallInstToCallGraphEdgesMap {\b callinstToCallGraphEdgesMap}{\bkmkstart AAAAAAACTJ}
{\bkmkend AAAAAAACTJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Map a call instruction to its corresponding call edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b callGraphNodeNum}{\bkmkstart AAAAAAACTK}
{\bkmkend AAAAAAACTK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b numOfResolvedIndCallEdge}{\bkmkstart AAAAAAACTL}
{\bkmkend AAAAAAACTL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addCallGraphNode\:SVF::PTACallGraph}
{\xe \v SVF::PTACallGraph\:addCallGraphNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PTACallGraph::addCallGraphNode (const {\b SVFFunction} *  {\i fun})}}
\par
{\bkmkstart AAAAAAACTM}
{\bkmkend AAAAAAACTM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add callgraph Node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add call graph node \par
}}
{\xe \v addDirectCallGraphEdge\:SVF::PTACallGraph}
{\xe \v SVF::PTACallGraph\:addDirectCallGraphEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PTACallGraph::addDirectCallGraphEdge (const {\b CallBlockNode} *  {\i cs}, const {\b SVFFunction} *  {\i callerFun}, const {\b SVFFunction} *  {\i calleeFun})}}
\par
{\bkmkstart AAAAAAACTN}
{\bkmkend AAAAAAACTN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add direct/indirect call edges. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add direct call edges \par
}}
{\xe \v addIndirectCallGraphEdge\:SVF::PTACallGraph}
{\xe \v SVF::PTACallGraph\:addIndirectCallGraphEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PTACallGraph::addIndirectCallGraphEdge (const {\b CallBlockNode} *  {\i cs}, const {\b SVFFunction} *  {\i callerFun}, const {\b SVFFunction} *  {\i calleeFun})}}
\par
{\bkmkstart AAAAAAACTO}
{\bkmkend AAAAAAACTO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add indirect call edge to update call graph \par
}}
{\xe \v destroy\:SVF::PTACallGraph}
{\xe \v SVF::PTACallGraph\:destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PTACallGraph::destroy (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACTP}
{\bkmkend AAAAAAACTP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory has been cleaned up at {\b GenericGraph} \par
}}
{\xe \v dump\:SVF::PTACallGraph}
{\xe \v SVF::PTACallGraph\:dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PTACallGraph::dump (const std::string &  {\i filename})}}
\par
{\bkmkstart AAAAAAACTQ}
{\bkmkend AAAAAAACTQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump the graph. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump call graph into dot file \par
}}
{\xe \v getAllCallSitesInvokingCallee\:SVF::PTACallGraph}
{\xe \v SVF::PTACallGraph\:getAllCallSitesInvokingCallee}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PTACallGraph::getAllCallSitesInvokingCallee (const {\b SVFFunction} *  {\i callee}, PTACallGraphEdge::CallInstSet &  {\i csSet})}}
\par
{\bkmkstart AAAAAAACTR}
{\bkmkend AAAAAAACTR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get callsites invoking the callee. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all callsite invoking this callee \par
}}
{\xe \v getDirCallSitesInvokingCallee\:SVF::PTACallGraph}
{\xe \v SVF::PTACallGraph\:getDirCallSitesInvokingCallee}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PTACallGraph::getDirCallSitesInvokingCallee (const {\b SVFFunction} *  {\i callee}, PTACallGraphEdge::CallInstSet &  {\i csSet})}}
\par
{\bkmkstart AAAAAAACTS}
{\bkmkend AAAAAAACTS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get direct callsite invoking this callee \par
}}
{\xe \v getGraphEdge\:SVF::PTACallGraph}
{\xe \v SVF::PTACallGraph\:getGraphEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PTACallGraphEdge} * PTACallGraph::getGraphEdge ({\b PTACallGraphNode} *  {\i src}, {\b PTACallGraphNode} *  {\i dst}, PTACallGraphEdge::CEDGEK  {\i kind}, CallSiteID  {\i csId})}}
\par
{\bkmkstart AAAAAAACTT}
{\bkmkend AAAAAAACTT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get call graph edge via nodes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get CallGraph edge via nodes \par
}}
{\xe \v getIndCallSitesInvokingCallee\:SVF::PTACallGraph}
{\xe \v SVF::PTACallGraph\:getIndCallSitesInvokingCallee}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PTACallGraph::getIndCallSitesInvokingCallee (const {\b SVFFunction} *  {\i callee}, PTACallGraphEdge::CallInstSet &  {\i csSet})}}
\par
{\bkmkstart AAAAAAACTU}
{\bkmkend AAAAAAACTU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get indirect callsite invoking this callee \par
}}
{\xe \v hasCallGraphEdge\:SVF::PTACallGraph}
{\xe \v SVF::PTACallGraph\:hasCallGraphEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::PTACallGraph::hasCallGraphEdge (const {\b CallBlockNode} *  {\i inst}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACTV}
{\bkmkend AAAAAAACTV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get call graph edge via call instruction. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
whether this call instruction has a valid call graph edge \par
}}
{\xe \v hasGraphEdge\:SVF::PTACallGraph}
{\xe \v SVF::PTACallGraph\:hasGraphEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PTACallGraphEdge} * PTACallGraph::hasGraphEdge ({\b PTACallGraphNode} *  {\i src}, {\b PTACallGraphNode} *  {\i dst}, PTACallGraphEdge::CEDGEK  {\i kind}, CallSiteID  {\i csId}) const}}
\par
{\bkmkstart AAAAAAACTW}
{\bkmkend AAAAAAACTW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we have aleady created this call graph edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we have already created this call graph edge \par
}}
{\xe \v isReachableBetweenFunctions\:SVF::PTACallGraph}
{\xe \v SVF::PTACallGraph\:isReachableBetweenFunctions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PTACallGraph::isReachableBetweenFunctions (const {\b SVFFunction} *  {\i srcFn}, const {\b SVFFunction} *  {\i dstFn}) const}}
\par
{\bkmkstart AAAAAAACTX}
{\bkmkend AAAAAAACTX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether its reachable between two functions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether its reachable between two functions \par
}}
{\xe \v verifyCallGraph\:SVF::PTACallGraph}
{\xe \v SVF::PTACallGraph\:verifyCallGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PTACallGraph::verifyCallGraph ()}}
\par
{\bkmkstart AAAAAAACTY}
{\bkmkend AAAAAAACTY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Issue a warning if the function which has indirect call sites can not be reached from program entry. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Issue a warning if the function which has indirect call sites can not be reached from program entry. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PTACallGraph.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PTACallGraph.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PTACallGraphEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PTACallGraphEdge}
{\xe \v SVF::PTACallGraphEdge}
{\bkmkstart AAAAAAACQT}
{\bkmkend AAAAAAACQT}
Inheritance diagram for SVF::PTACallGraphEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_p_t_a_call_graph_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b CEDGEK} \{ {\b CallRetEdge}
, {\b TDForkEdge}
, {\b TDJoinEdge}
, {\b HareParForEdge}
 \}{\bkmkstart AAAAAAACQU}
{\bkmkend AAAAAAACQU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b CallBlockNode} * > {\b CallInstSet}{\bkmkstart AAAAAAACQV}
{\bkmkend AAAAAAACQV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericNode}< {\b PTACallGraphNode}, {\b PTACallGraphEdge} >::GEdgeSetTy {\b CallGraphEdgeSet}{\bkmkstart AAAAAAACQW}
{\bkmkend AAAAAAACQW}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTACallGraphEdge} ({\b PTACallGraphNode} *s, {\b PTACallGraphNode} *d, CEDGEK kind, CallSiteID cs){\bkmkstart AAAAAAACQX}
{\bkmkend AAAAAAACQX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~PTACallGraphEdge} (){\bkmkstart AAAAAAACQY}
{\bkmkend AAAAAAACQY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteID {\b getCallSiteID} () const{\bkmkstart AAAAAAACQZ}
{\bkmkend AAAAAAACQZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get direct and indirect calls. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isDirectCallEdge} () const{\bkmkstart AAAAAAACRA}
{\bkmkend AAAAAAACRA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isIndirectCallEdge} () const{\bkmkstart AAAAAAACRB}
{\bkmkend AAAAAAACRB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallInstSet & {\b getDirectCalls} (){\bkmkstart AAAAAAACRC}
{\bkmkend AAAAAAACRC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallInstSet & {\b getIndirectCalls} (){\bkmkstart AAAAAAACRD}
{\bkmkend AAAAAAACRD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallInstSet & {\b getDirectCalls} () const{\bkmkstart AAAAAAACRE}
{\bkmkend AAAAAAACRE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallInstSet & {\b getIndirectCalls} () const{\bkmkstart AAAAAAACRF}
{\bkmkend AAAAAAACRF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addDirectCallSite} (const {\b CallBlockNode} *call){\bkmkstart AAAAAAACRG}
{\bkmkend AAAAAAACRG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add direct and indirect callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addInDirectCallSite} (const {\b CallBlockNode} *call){\bkmkstart AAAAAAACRH}
{\bkmkend AAAAAAACRH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallInstSet::const_iterator {\b directCallsBegin} () const{\bkmkstart AAAAAAACRI}
{\bkmkend AAAAAAACRI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterators for direct and indirect callsites. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallInstSet::const_iterator {\b directCallsEnd} () const{\bkmkstart AAAAAAACRJ}
{\bkmkend AAAAAAACRJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallInstSet::const_iterator {\b indirectCallsBegin} () const{\bkmkstart AAAAAAACRK}
{\bkmkend AAAAAAACRK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallInstSet::const_iterator {\b indirectCallsEnd} () const{\bkmkstart AAAAAAACRL}
{\bkmkend AAAAAAACRL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACRM}
{\bkmkend AAAAAAACRM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b GEdgeFlag} {\b makeEdgeFlagWithInvokeID} (GEdgeKind k, CallSiteID cs){\bkmkstart AAAAAAACRN}
{\bkmkend AAAAAAACRN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute the unique edgeFlag value from edge kind and CallSiteID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PTACallGraphEdge} *){\bkmkstart AAAAAAACRO}
{\bkmkend AAAAAAACRO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ClassOf. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericCallGraphEdgeTy} *edge){\bkmkstart AAAAAAACRP}
{\bkmkend AAAAAAACRP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b raw_ostream} & {\b operator<<} ({\b raw_ostream} &o, const {\b PTACallGraphEdge} &edge){\bkmkstart AAAAAAACRQ}
{\bkmkend AAAAAAACRQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator << for dumping {\b ICFG} node ID. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PTACallGraph.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PTACallGraph.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PTACallGraphNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PTACallGraphNode}
{\xe \v SVF::PTACallGraphNode}
{\bkmkstart AAAAAAACRR}
{\bkmkend AAAAAAACRR}
Inheritance diagram for SVF::PTACallGraphNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_p_t_a_call_graph_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PTACallGraphEdge::CallGraphEdgeSet {\b CallGraphEdgeSet}{\bkmkstart AAAAAAACRS}
{\bkmkend AAAAAAACRS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PTACallGraphEdge::CallGraphEdgeSet::iterator {\b iterator}{\bkmkstart AAAAAAACRT}
{\bkmkend AAAAAAACRT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PTACallGraphEdge::CallGraphEdgeSet::const_iterator {\b const_iterator}{\bkmkstart AAAAAAACRU}
{\bkmkend AAAAAAACRU}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTACallGraphNode} (NodeID i, const {\b SVFFunction} *f){\bkmkstart AAAAAAACRV}
{\bkmkend AAAAAAACRV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getFunction} () const{\bkmkstart AAAAAAACRW}
{\bkmkend AAAAAAACRW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get function of this call node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isReachableFromProgEntry} () const{\bkmkstart AAAAAAACRX}
{\bkmkend AAAAAAACRX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return TRUE if this function can be reached from main. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACRY}
{\bkmkend AAAAAAACRY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b raw_ostream} & {\b operator<<} ({\b raw_ostream} &o, const {\b PTACallGraphNode} &node){\bkmkstart AAAAAAACRZ}
{\bkmkend AAAAAAACRZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator << for dumping {\b ICFG} node ID. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PTACallGraph.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PTACallGraph.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PTACFInfoBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PTACFInfoBuilder}
{\xe \v SVF::PTACFInfoBuilder}
{\bkmkstart AAAAAAAGHN}
{\bkmkend AAAAAAAGHN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Function *, DominatorTree * > {\b FunToDTMap}{\bkmkstart AAAAAAAGHO}
{\bkmkend AAAAAAAGHO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a function to its dominator tree }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Function *, PostDominatorTree * > {\b FunToPostDTMap}{\bkmkstart AAAAAAAGHP}
{\bkmkend AAAAAAAGHP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a function to its post dominator tree }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Function *, LoopInfo * > {\b FunToLoopInfoMap}{\bkmkstart AAAAAAAGHQ}
{\bkmkend AAAAAAAGHQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a function to its loop info }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTACFInfoBuilder} (){\bkmkstart AAAAAAAGHR}
{\bkmkend AAAAAAAGHR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

LoopInfo * {\b getLoopInfo} (const Function *f){\bkmkstart AAAAAAAGHS}
{\bkmkend AAAAAAAGHS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get loop info of a function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PostDominatorTree * {\b getPostDT} (const Function *f){\bkmkstart AAAAAAAGHT}
{\bkmkend AAAAAAAGHT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get post dominator tree of a function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

DominatorTree * {\b getDT} (const Function *f){\bkmkstart AAAAAAAGHU}
{\bkmkend AAAAAAAGHU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get dominator tree of a function. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/DataFlowUtil.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/DataFlowUtil.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PTASCEV Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PTASCEV}
{\xe \v SVF::PTASCEV}
{\bkmkstart AAAAAAAGGZ}
{\bkmkend AAAAAAAGGZ}
\par
{
{\f2 #include <DataFlowUtil.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTASCEV} (const Value *p, const SCEV *s, ScalarEvolution *SE){\bkmkstart AAAAAAAGHA}
{\bkmkend AAAAAAAGHA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTASCEV} (const {\b PTASCEV} &ptase){\bkmkstart AAAAAAAGHB}
{\bkmkend AAAAAAAGHB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~PTASCEV} (){\bkmkstart AAAAAAAGHC}
{\bkmkend AAAAAAAGHC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b PTASCEV} &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTASCEV} & {\b operator=} (const {\b PTASCEV} &rhs){\bkmkstart AAAAAAAGHD}
{\bkmkend AAAAAAAGHD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b PTASCEV} &rhs) const{\bkmkstart AAAAAAAGHE}
{\bkmkend AAAAAAAGHE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b PTASCEV} &rhs) const{\bkmkstart AAAAAAAGHF}
{\bkmkend AAAAAAAGHF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const SCEV * {\b scev}{\bkmkstart AAAAAAAGHG}
{\bkmkend AAAAAAAGHG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b start}{\bkmkstart AAAAAAAGHH}
{\bkmkend AAAAAAAGHH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b step}{\bkmkstart AAAAAAAGHI}
{\bkmkend AAAAAAAGHI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b ptr}{\bkmkstart AAAAAAAGHJ}
{\bkmkend AAAAAAAGHJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b inloop}{\bkmkstart AAAAAAAGHK}
{\bkmkend AAAAAAAGHK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned {\b tripcount}{\bkmkstart AAAAAAAGHL}
{\bkmkend AAAAAAAGHL}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wrapper for SCEV collected from function pass ScalarEvolution \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator<\:SVF::PTASCEV}
{\xe \v SVF::PTASCEV\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::PTASCEV::operator< (const {\b PTASCEV} &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAGHM}
{\bkmkend AAAAAAAGHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable compare operator to avoid duplicated item insertion in map or set to be noted that two vectors can also overload operator() \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/DataFlowUtil.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PTAStat Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PTAStat}
{\xe \v SVF::PTAStat}
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
\par
{
{\f2 #include <PTAStat.h>}}\par
Inheritance diagram for SVF::PTAStat:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_p_t_a_stat.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const char *, u32_t > {\b NUMStatMap}{\bkmkstart AAAAAAAEUJ}
{\bkmkend AAAAAAAEUJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const char *, double > {\b TIMEStatMap}{\bkmkstart AAAAAAAEUK}
{\bkmkend AAAAAAAEUK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTAStat} ({\b PointerAnalysis} *p){\bkmkstart AAAAAAAEUL}
{\bkmkend AAAAAAAEUL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b startClk} (){\bkmkstart AAAAAAAEUM}
{\bkmkend AAAAAAAEUM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b endClk} (){\bkmkstart AAAAAAAEUN}
{\bkmkend AAAAAAAEUN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b performStat} (){\bkmkstart AAAAAAAEUO}
{\bkmkend AAAAAAAEUO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b printStat} (string str=""){\bkmkstart AAAAAAAEUP}
{\bkmkend AAAAAAAEUP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b performStatPerQuery} (NodeID){\bkmkstart AAAAAAAEUQ}
{\bkmkend AAAAAAAEUQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b printStatPerQuery} (NodeID, const PointsTo &){\bkmkstart AAAAAAAEUR}
{\bkmkend AAAAAAAEUR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b callgraphStat} (){\bkmkstart AAAAAAAEUS}
{\bkmkend AAAAAAAEUS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b setMarkedClocksOnly} (void){\bkmkstart AAAAAAAEUT}
{\bkmkend AAAAAAAEUT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets setMarkedClocksOnly through MarkedClocksOnly in PTAStat.cpp. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static double {\b getClk} (bool mark=false)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NUMStatMap {\b generalNumMap}{\bkmkstart AAAAAAAEUU}
{\bkmkend AAAAAAAEUU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NUMStatMap {\b PTNumStatMap}{\bkmkstart AAAAAAAEUV}
{\bkmkend AAAAAAAEUV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

TIMEStatMap {\b timeStatMap}{\bkmkstart AAAAAAAEUW}
{\bkmkend AAAAAAAEUW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeBS {\b localVarInRecursion}{\bkmkstart AAAAAAAEUX}
{\bkmkend AAAAAAAEUX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b startTime}{\bkmkstart AAAAAAAEUY}
{\bkmkend AAAAAAAEUY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b endTime}{\bkmkstart AAAAAAAEUZ}
{\bkmkend AAAAAAAEUZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b TotalAnalysisTime} = "TotalTime"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total analysis time. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b SCCDetectionTime} = "SCCDetectTime"{\bkmkstart AAAAAAAEVA}
{\bkmkend AAAAAAAEVA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total SCC detection time. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b SCCMergeTime} = "SCCMergeTime"{\bkmkstart AAAAAAAEVB}
{\bkmkend AAAAAAAEVB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total SCC merge time. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b ProcessLoadStoreTime} = "LoadStoreTime"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of processing loads and stores }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b ProcessCopyGepTime} = "CopyGepTime"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of processing copys and geps }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b UpdateCallGraphTime} = "UpdateCGTime"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of updating call graph }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b TotalNumOfPointers} = "TotalPointers"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total {\b PAG} value node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b TotalNumOfObjects} = "TotalObjects"{\bkmkstart AAAAAAAEVC}
{\bkmkend AAAAAAAEVC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total {\b PAG} object node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b TotalNumOfFieldObjects} = "TotalFieldObjects"{\bkmkstart AAAAAAAEVD}
{\bkmkend AAAAAAAEVD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total {\b PAG} field object node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b MaxStructSize} = "MaxStructSize"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Max struct size. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b TotalNumOfEdges} = "TotalPAGEdges"{\bkmkstart AAAAAAAEVE}
{\bkmkend AAAAAAAEVE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total {\b PAG} edge number. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfAddrs} = "AddrsNum"{\bkmkstart AAAAAAAEVF}
{\bkmkend AAAAAAAEVF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} addr edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfLoads} = "LoadsNum"{\bkmkstart AAAAAAAEVG}
{\bkmkend AAAAAAAEVG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} load edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfStores} = "StoresNum"{\bkmkstart AAAAAAAEVH}
{\bkmkend AAAAAAAEVH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} store edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfCopys} = "CopysNum"{\bkmkstart AAAAAAAEVI}
{\bkmkend AAAAAAAEVI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} copy edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfGeps} = "GepsNum"{\bkmkstart AAAAAAAEVJ}
{\bkmkend AAAAAAAEVJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} gep edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfCalls} = "CallsNum"{\bkmkstart AAAAAAAEVK}
{\bkmkend AAAAAAAEVK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} call edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfReturns} = "ReturnsNum"{\bkmkstart AAAAAAAEVL}
{\bkmkend AAAAAAAEVL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} return edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b NumOfProcessedAddrs} = "AddrProcessed"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} processed addr edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b NumOfProcessedLoads} = "LoadProcessed"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} processed load edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b NumOfProcessedStores} = "StoreProcessed"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} processed store edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b NumOfProcessedCopys} = "CopyProcessed"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} processed copy edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b NumOfProcessedGeps} = "GepProcessed"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} processed gep edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b NumOfSfr} = "NumOfSFRs"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
num of field representatives }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfFieldExpand} = "NumOfFieldExpand"{\bkmkstart AAAAAAAEVM}
{\bkmkend AAAAAAAEVM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b NumOfFunctionObjs} = "FunctionObjs"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function numbers. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfGlobalObjs} = "GlobalObjs"{\bkmkstart AAAAAAAEVN}
{\bkmkend AAAAAAAEVN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} global object node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfHeapObjs} = "HeapObjs"{\bkmkstart AAAAAAAEVO}
{\bkmkend AAAAAAAEVO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} heap object node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfStackObjs} = "StackObjs"{\bkmkstart AAAAAAAEVP}
{\bkmkend AAAAAAAEVP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} stack object node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b NumOfObjsHasVarStruct} = "VarStructObj"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} object node has var struct (maybe nested with array) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b NumOfObjsHasVarArray} = "VarArrayObj"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} object node has var array (maybe nested with struct) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfObjsHasConstStruct} = "ConstStructObj"{\bkmkstart AAAAAAAEVQ}
{\bkmkend AAAAAAAEVQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} object node has const struct (maybe nested with array) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfObjsHasConstArray} = "ConstArrayObj"{\bkmkstart AAAAAAAEVR}
{\bkmkend AAAAAAAEVR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} object node has const array (maybe nested with struct) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfNonPtrObjs} = "NonPtrObj"{\bkmkstart AAAAAAAEVS}
{\bkmkend AAAAAAAEVS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} object node which is non pointer type object (do not have pts) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b NumOfConstantObjs} = "ConstantObj"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} object node which is purely constant. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumberOfFieldInsensitiveObj} = "FIObjNum"{\bkmkstart AAAAAAAEVT}
{\bkmkend AAAAAAAEVT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumberOfFieldSensitiveObj} = "FSObjNum"{\bkmkstart AAAAAAAEVU}
{\bkmkend AAAAAAAEVU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfPointers} = "Pointers"{\bkmkstart AAAAAAAEVV}
{\bkmkend AAAAAAAEVV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} value node, each of them maps to a llvm value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfGepFieldPointers} = "DYFieldPtrs"{\bkmkstart AAAAAAAEVW}
{\bkmkend AAAAAAAEVW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} gep value node (field value, dynamically created dummy node) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfMemObjects} = "MemObjects"{\bkmkstart AAAAAAAEVX}
{\bkmkend AAAAAAAEVX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} object node, each of them maps to a llvm value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfGepFieldObjects} = "DYFieldObjs"{\bkmkstart AAAAAAAEVY}
{\bkmkend AAAAAAAEVY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} gep object node (field obj, dynamically created dummy node) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b AveragePointsToSetSize} = "AvgPtsSetSize"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Average points-to size of all variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b AverageTopLevPointsToSetSize} = "AvgTopLvlPtsSize"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Average points-to size of top-level variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b MaxPointsToSetSize} = "MaxPtsSetSize"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Max points-to size. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfIterations} = "Iterations"{\bkmkstart AAAAAAAEVZ}
{\bkmkend AAAAAAAEVZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of iterations during resolution. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfIndirectCallSites} = "IndCallSites"{\bkmkstart AAAAAAAEWA}
{\bkmkend AAAAAAAEWA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of indirect callsites. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfIndirectEdgeSolved} = "IndEdgeSolved"{\bkmkstart AAAAAAAEWB}
{\bkmkend AAAAAAAEWB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of indirect calledge resolved. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfSCCDetection} = "NumOfSCCDetect"{\bkmkstart AAAAAAAEWC}
{\bkmkend AAAAAAAEWC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of scc detection performed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfCycles} = "TotalCycleNum"{\bkmkstart AAAAAAAEWD}
{\bkmkend AAAAAAAEWD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of scc cycles detected. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b NumOfPWCCycles} = "TotalPWCCycleNum"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of scc cycles detected. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfNodesInCycles} = "NodesInCycles"{\bkmkstart AAAAAAAEWE}
{\bkmkend AAAAAAAEWE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of nodes in cycles detected. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b MaxNumOfNodesInSCC} = "MaxNodesInSCC"\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
max Number of nodes in one scc }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const char * {\b NumOfNullPointer} = "NullPointer"{\bkmkstart AAAAAAAEWF}
{\bkmkend AAAAAAAEWF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of pointers points-to null. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b markedClocksOnly} = false\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer Analysis Statistics \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getClk\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:getClk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static double SVF::PTAStat::getClk (bool  {\i mark} = {\f2 false}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWG}
{\bkmkend AAAAAAAEWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When mark is true, real clock is always returned. When mark is false, it is only returned when markedClocksOnly is not set; this is the default case. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v AveragePointsToSetSize\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:AveragePointsToSetSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::AveragePointsToSetSize = "AvgPtsSetSize"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWH}
{\bkmkend AAAAAAAEWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Average points-to size of all variables. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Average Points-to set size. \par
}}
{\xe \v AverageTopLevPointsToSetSize\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:AverageTopLevPointsToSetSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::AverageTopLevPointsToSetSize = "AvgTopLvlPtsSize"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWI}
{\bkmkend AAAAAAAEWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Average points-to size of top-level variables. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Average Points-to set size of top level pointers. \par
}}
{\xe \v markedClocksOnly\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:markedClocksOnly}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PTAStat::markedClocksOnly = false{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWJ}
{\bkmkend AAAAAAAEWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If set, only return the clock when getClk is called as getClk(true). Retrieving the clock is slow but it should be fine for a few calls. This is good for benchmarking when we don't need to know how long processLoad takes, for example (many calls), but want to know things like total solve time. Does not affect CLOCK_IN_MS. \par
}}
{\xe \v MaxNumOfNodesInSCC\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:MaxNumOfNodesInSCC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::MaxNumOfNodesInSCC = "MaxNodesInSCC"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWK}
{\bkmkend AAAAAAAEWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
max Number of nodes in one scc }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
max Number of nodes in one scc cycle \par
}}
{\xe \v MaxPointsToSetSize\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:MaxPointsToSetSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::MaxPointsToSetSize = "MaxPtsSetSize"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWL}
{\bkmkend AAAAAAAEWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Max points-to size. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Max Points-to set size. \par
}}
{\xe \v MaxStructSize\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:MaxStructSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::MaxStructSize = "MaxStructSize"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWM}
{\bkmkend AAAAAAAEWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Max struct size. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Max struct size (bytes) \par
}}
{\xe \v NumOfConstantObjs\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:NumOfConstantObjs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::NumOfConstantObjs = "ConstantObj"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWN}
{\bkmkend AAAAAAAEWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} object node which is purely constant. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} object node which is purely scalar. \par
}}
{\xe \v NumOfFunctionObjs\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:NumOfFunctionObjs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::NumOfFunctionObjs = "FunctionObjs"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWO}
{\bkmkend AAAAAAAEWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function numbers. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
function numbers \par
}}
{\xe \v NumOfObjsHasVarArray\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:NumOfObjsHasVarArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::NumOfObjsHasVarArray = "VarArrayObj"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWP}
{\bkmkend AAAAAAAEWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} object node has var array (maybe nested with struct) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} object node has array (maybe nested with struct) \par
}}
{\xe \v NumOfObjsHasVarStruct\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:NumOfObjsHasVarStruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::NumOfObjsHasVarStruct = "VarStructObj"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWQ}
{\bkmkend AAAAAAAEWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} object node has var struct (maybe nested with array) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} object node has struct (maybe nested with array) \par
}}
{\xe \v NumOfProcessedAddrs\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:NumOfProcessedAddrs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::NumOfProcessedAddrs = "AddrProcessed"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWR}
{\bkmkend AAAAAAAEWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} processed addr edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} addr processed edge. \par
}}
{\xe \v NumOfProcessedCopys\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:NumOfProcessedCopys}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::NumOfProcessedCopys = "CopyProcessed"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWS}
{\bkmkend AAAAAAAEWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} processed copy edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} copy processed edge. \par
}}
{\xe \v NumOfProcessedGeps\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:NumOfProcessedGeps}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::NumOfProcessedGeps = "GepProcessed"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWT}
{\bkmkend AAAAAAAEWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} processed gep edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} gep processed edge. \par
}}
{\xe \v NumOfProcessedLoads\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:NumOfProcessedLoads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::NumOfProcessedLoads = "LoadProcessed"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWU}
{\bkmkend AAAAAAAEWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} processed load edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} load processed edge. \par
}}
{\xe \v NumOfProcessedStores\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:NumOfProcessedStores}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::NumOfProcessedStores = "StoreProcessed"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWV}
{\bkmkend AAAAAAAEWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} processed store edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} store processed edge. \par
}}
{\xe \v NumOfPWCCycles\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:NumOfPWCCycles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::NumOfPWCCycles = "TotalPWCCycleNum"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWW}
{\bkmkend AAAAAAAEWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of scc cycles detected. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of pwc scc cycles detected. \par
}}
{\xe \v NumOfSfr\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:NumOfSfr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::NumOfSfr = "NumOfSFRs"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWX}
{\bkmkend AAAAAAAEWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
num of field representatives }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
number of field representatives \par
}}
{\xe \v ProcessCopyGepTime\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:ProcessCopyGepTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::ProcessCopyGepTime = "CopyGepTime"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWY}
{\bkmkend AAAAAAAEWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of processing copys and geps }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
process copy and gep time \par
}}
{\xe \v ProcessLoadStoreTime\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:ProcessLoadStoreTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::ProcessLoadStoreTime = "LoadStoreTime"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEWZ}
{\bkmkend AAAAAAAEWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of processing loads and stores }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
process load and store time \par
}}
{\xe \v TotalAnalysisTime\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:TotalAnalysisTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::TotalAnalysisTime = "TotalTime"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEXA}
{\bkmkend AAAAAAAEXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total analysis time. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} value nodes. \par
}}
{\xe \v TotalNumOfPointers\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:TotalNumOfPointers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::TotalNumOfPointers = "TotalPointers"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEXB}
{\bkmkend AAAAAAAEXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total {\b PAG} value node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} value nodes. \par
}}
{\xe \v UpdateCallGraphTime\:SVF::PTAStat}
{\xe \v SVF::PTAStat\:UpdateCallGraphTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * PTAStat::UpdateCallGraphTime = "UpdateCGTime"{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAEXC}
{\bkmkend AAAAAAAEXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
time of updating call graph }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
process copy and gep time \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/PTAStat.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Util/PTAStat.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PTAType Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PTAType}
{\xe \v SVF::PTAType}
{\bkmkstart AAAAAAAEXD}
{\bkmkend AAAAAAAEXD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTAType} (const Type *ty){\bkmkstart AAAAAAAEXE}
{\bkmkend AAAAAAAEXE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Type * {\b getLLVMType} () const{\bkmkstart AAAAAAAEXF}
{\bkmkend AAAAAAAEXF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the contained llvm type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dump} () const{\bkmkstart AAAAAAAEXG}
{\bkmkend AAAAAAAEXG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump the type. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b PTAType} &ty) const{\bkmkstart AAAAAAAEXH}
{\bkmkend AAAAAAAEXH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operator overloading. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b PTAType} &ty) const{\bkmkstart AAAAAAAEXI}
{\bkmkend AAAAAAAEXI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator<} (const {\b PTAType} &ty) const{\bkmkstart AAAAAAAEXJ}
{\bkmkend AAAAAAAEXJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator>} (const {\b PTAType} &ty) const{\bkmkstart AAAAAAAEXK}
{\bkmkend AAAAAAAEXK}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/PTAType.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::PTData< Key, Datum, Data > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::PTData< Key, Datum, Data >}
{\xe \v SVF::PTData< Key, Datum, Data >}
{\bkmkstart AAAAAAADVQ}
{\bkmkend AAAAAAADVQ}
\par
{
{\f2 #include <AbstractPointsToDS.h>}}\par
Inheritance diagram for SVF::PTData< Key, Datum, Data >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_p_t_data.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b PTDataTy} \{ {\b Base}
, {\b MutBase}
, {\b Diff}
, {\b MutDiff}
, {\b DataFlow}
, {\b MutDataFlow}
, {\b IncMutDataFlow}
, {\b Versioned}
, {\b MutVersioned}
 \}{\bkmkstart AAAAAAADVR}
{\bkmkend AAAAAAADVR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Types of a points-to data structures. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< Key > {\b KeySet}{\bkmkstart AAAAAAADVS}
{\bkmkend AAAAAAADVS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTData} (bool reversePT=true, {\b PTDataTy} ty=PTDataTy::Base){\bkmkstart AAAAAAADVT}
{\bkmkend AAAAAAADVT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTDataTy} {\b getPTDTY} () const{\bkmkstart AAAAAAADVU}
{\bkmkend AAAAAAADVU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the type of points-to data structure that this is. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clear} ()=0{\bkmkstart AAAAAAADVV}
{\bkmkend AAAAAAADVV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears all points-to sets as if nothing is stored. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const Data & {\b getPts} (const Key &var)=0{\bkmkstart AAAAAAADVW}
{\bkmkend AAAAAAADVW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get points-to set of var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const KeySet & {\b getRevPts} (const Datum &datum)=0{\bkmkstart AAAAAAADVX}
{\bkmkend AAAAAAADVX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get reverse points-to set of datum. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b addPts} (const Key &var, const Datum &element)=0{\bkmkstart AAAAAAADVY}
{\bkmkend AAAAAAADVY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds element to the points-to set associated with var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const Key &dstVar, const Key &srcVar)=0{\bkmkstart AAAAAAADVZ}
{\bkmkend AAAAAAADVZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs pts(dstVar) = pts(dstVar) U pts(srcVar). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const Key &dstVar, const Data &srcData)=0{\bkmkstart AAAAAAADWA}
{\bkmkend AAAAAAADWA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs pts(dstVar) = pts(dstVar) U srcData. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearPts} (const Key &var, const Datum &element)=0{\bkmkstart AAAAAAADWB}
{\bkmkend AAAAAAADWB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears element from the points-to set of var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearFullPts} (const Key &var)=0{\bkmkstart AAAAAAADWC}
{\bkmkend AAAAAAADWC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fully clears the points-to set of var. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dumpPTData} ()=0{\bkmkstart AAAAAAADWD}
{\bkmkend AAAAAAADWD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump stored keys and points-to sets. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b rev}{\bkmkstart AAAAAAADWE}
{\bkmkend AAAAAAADWE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we maintain reverse points-to sets or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTDataTy} {\b ptdTy}{\bkmkstart AAAAAAADWF}
{\bkmkend AAAAAAADWF}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Key, typename Datum, typename Data>\par
class SVF::PTData< Key, Datum, Data >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Basic points-to data structure Given a key (variable/condition variable), return its points-to data (pts/condition pts) It is designed flexible for different context, heap and path sensitive analysis Context Insensitive Key --> Variable, Data --> PointsTo Context sensitive: Key --> {\b CondVar}, Data --> PointsTo Heap sensitive: Key --> Variable Data --> {\b CondPointsToSet} Context and heap sensitive: Key --> {\b CondVar}, Data --> {\b CondPointsToSet}\par
This class is abstract to allow for multiple methods of actually storing points-to sets. Key: "owning" variable of a points-to set. Datum: elements in points-to sets. Data: the points-to set; a collection of Datums. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/AbstractPointsToDS.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RaceResultValidator Class Reference\par \pard\plain 
{\tc\tcl2 \v RaceResultValidator}
{\xe \v RaceResultValidator}
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Validate the result of concurrent analysis. }}\par
{
{\f2 #include <MTAResultValidator.h>}}\par
Inheritance diagram for RaceResultValidator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_race_result_validator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AccessPair}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef int {\b RC_FLAG}{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~RaceResultValidator} (){\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b init} (SVFModule *M){\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialization. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b analyze} (){\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b release} (){\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Release resource. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasValidationTarget} () const{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the input program has validation target. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b mayAccessAliases} (const Instruction *I1, const Instruction *I2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b mayHappenInParallel} (const Instruction *I1, const Instruction *I2){\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b protectedByCommonLocks} (const Instruction *I1, const Instruction *I2){\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b mayHaveDataRace} (const Instruction *I1, const Instruction *I2){\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b collectValidationTargets} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b validateAll} (){\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform validation for all targets. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b getOutput} (const char *scenario, bool analysisRes, bool expectedRes){\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the validation result string of a single validation scenario. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Validate the result of concurrent analysis. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The properties to validate of two memory accesses include one or more of the following four: (1) they may accesses aliases; (2) they may happen in parallel; (3) they are protected by common lock(s); (4) they may cause a data race error. The ground truth are specified by the "RC_ACCESS" function in the target program.\par
Users may utilize this result validator to validate their analysis with one or more of the four properties, by inheriting the RCResultValidator class. The corresponding virtual function of the desired property should be overridden. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v collectValidationTargets\:RaceResultValidator}
{\xe \v RaceResultValidator\:collectValidationTargets}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RaceResultValidator::collectValidationTargets (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect the targets for validations. The targets should be memory access Instructions in pairs. The collected targets are stored in the member variable "accessPairs". \par
}}
{\xe \v mayAccessAliases\:RaceResultValidator}
{\xe \v RaceResultValidator\:mayAccessAliases}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool RaceResultValidator::mayAccessAliases (const Instruction *  {\i I1}, const Instruction *  {\i I2}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface to the specific validation properties. Override one or more to implement your own analysis. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/MTAResultValidator.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::RetBlockNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::RetBlockNode}
{\xe \v SVF::RetBlockNode}
{\bkmkstart AAAAAAABZE}
{\bkmkend AAAAAAABZE}
\par
{
{\f2 #include <ICFGNode.h>}}\par
Inheritance diagram for SVF::RetBlockNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_ret_block_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b RetBlockNode} (NodeID id, const Instruction *c, {\b CallBlockNode} *cb){\bkmkstart AAAAAAABZF}
{\bkmkend AAAAAAABZF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Instruction * {\b getCallSite} () const{\bkmkstart AAAAAAABZG}
{\bkmkend AAAAAAABZG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return callsite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getCallBlockNode} () const{\bkmkstart AAAAAAABZH}
{\bkmkend AAAAAAABZH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getActualRet} () const{\bkmkstart AAAAAAABZI}
{\bkmkend AAAAAAABZI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return actual return parameter. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addActualRet} (const {\b PAGNode} *ar){\bkmkstart AAAAAAABZJ}
{\bkmkend AAAAAAABZJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add actual return parameter. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAABZK}
{\bkmkend AAAAAAABZK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b RetBlockNode} *){\bkmkstart AAAAAAABZL}
{\bkmkend AAAAAAABZL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b InterBlockNode} *node){\bkmkstart AAAAAAABZM}
{\bkmkend AAAAAAABZM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ICFGNode} *node){\bkmkstart AAAAAAABZN}
{\bkmkend AAAAAAABZN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericICFGNodeTy} *node){\bkmkstart AAAAAAABZO}
{\bkmkend AAAAAAABZO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return {\b ICFGNode} containing (at most one) {\b ActualRetVFGNode} at a callsite \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ICFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::RetCFGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::RetCFGEdge}
{\xe \v SVF::RetCFGEdge}
{\bkmkstart AAAAAAABVZ}
{\bkmkend AAAAAAABVZ}
\par
{
{\f2 #include <ICFGEdge.h>}}\par
Inheritance diagram for SVF::RetCFGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_ret_c_f_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b RetCFGEdge} ({\b ICFGNode} *s, {\b ICFGNode} *d, const Instruction *c){\bkmkstart AAAAAAABWA}
{\bkmkend AAAAAAABWA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Instruction * {\b getCallSite} () const{\bkmkstart AAAAAAABWB}
{\bkmkend AAAAAAABWB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return callsite ID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAABWC}
{\bkmkend AAAAAAABWC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b RetCFGEdge} *){\bkmkstart AAAAAAABWD}
{\bkmkend AAAAAAABWD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ICFGEdge} *edge){\bkmkstart AAAAAAABWE}
{\bkmkend AAAAAAABWE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericICFGEdgeTy} *edge){\bkmkstart AAAAAAABWF}
{\bkmkend AAAAAAABWF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return {\b ICFG} edge representing parameter/return passing from a callee to a caller \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ICFGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ICFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::RetDirSVFGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::RetDirSVFGEdge}
{\xe \v SVF::RetDirSVFGEdge}
{\bkmkstart AAAAAAADNN}
{\bkmkend AAAAAAADNN}
\par
{
{\f2 #include <VFGEdge.h>}}\par
Inheritance diagram for SVF::RetDirSVFGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_ret_dir_s_v_f_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b RetDirSVFGEdge} ({\b VFGNode} *s, {\b VFGNode} *d, CallSiteID id){\bkmkstart AAAAAAADNO}
{\bkmkend AAAAAAADNO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteID {\b getCallSiteId} () const{\bkmkstart AAAAAAADNP}
{\bkmkend AAAAAAADNP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return callsite ID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADNQ}
{\bkmkend AAAAAAADNQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b RetDirSVFGEdge} *){\bkmkstart AAAAAAADNR}
{\bkmkend AAAAAAADNR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b DirectSVFGEdge} *edge){\bkmkstart AAAAAAADNS}
{\bkmkend AAAAAAADNS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGEdge} *edge){\bkmkstart AAAAAAADNT}
{\bkmkend AAAAAAADNT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGEdgeTy} *edge){\bkmkstart AAAAAAADNU}
{\bkmkend AAAAAAADNU}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SVFG} return edge connecting direct value-flows from a callee to its caller at a callsite \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::RetIndSVFGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::RetIndSVFGEdge}
{\xe \v SVF::RetIndSVFGEdge}
{\bkmkstart AAAAAAACYV}
{\bkmkend AAAAAAACYV}
\par
{
{\f2 #include <SVFGEdge.h>}}\par
Inheritance diagram for SVF::RetIndSVFGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_ret_ind_s_v_f_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b RetIndSVFGEdge} ({\b VFGNode} *s, {\b VFGNode} *d, CallSiteID id){\bkmkstart AAAAAAACYW}
{\bkmkend AAAAAAACYW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteID {\b getCallSiteId} () const{\bkmkstart AAAAAAACYX}
{\bkmkend AAAAAAACYX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACYY}
{\bkmkend AAAAAAACYY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b RetIndSVFGEdge} *){\bkmkstart AAAAAAACYZ}
{\bkmkend AAAAAAACYZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b IndirectSVFGEdge} *edge){\bkmkstart AAAAAAACZA}
{\bkmkend AAAAAAACZA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGEdge} *edge){\bkmkstart AAAAAAACZB}
{\bkmkend AAAAAAACZB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGEdgeTy} *edge){\bkmkstart AAAAAAACZC}
{\bkmkend AAAAAAACZC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SVFG} return edge representing direct value-flows from a callee to its caller at a callsite \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::RetMU< Cond > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::RetMU< Cond >}
{\xe \v SVF::RetMU< Cond >}
{\bkmkstart AAAAAAAFHC}
{\bkmkend AAAAAAAFHC}
\par
{
{\f2 #include <MSSAMuChi.h>}}\par
Inheritance diagram for SVF::RetMU< Cond >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_ret_m_u.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b RetMU} (const {\b SVFFunction} *f, const {\b MemRegion} *m, Cond c=PathCondAllocator::trueCond()){\bkmkstart AAAAAAAFHD}
{\bkmkend AAAAAAAFHD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor/Destructor for MU. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getFunction} () const{\bkmkstart AAAAAAAFHE}
{\bkmkend AAAAAAAFHE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dump} (){\bkmkstart AAAAAAAFHF}
{\bkmkend AAAAAAAFHF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print MU. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b RetMU} *){\bkmkstart AAAAAAAFHG}
{\bkmkend AAAAAAAFHG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MSSAMU}< Cond > *mu){\bkmkstart AAAAAAAFHH}
{\bkmkend AAAAAAAFHH}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Cond>\par
class SVF::RetMU< Cond >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b RetMU} is annotated at function return, representing memory objects returns to callers \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MSSAMuChi.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::RetPE Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::RetPE}
{\xe \v SVF::RetPE}
{\bkmkstart AAAAAAACLB}
{\bkmkend AAAAAAACLB}
\par
{
{\f2 #include <PAGEdge.h>}}\par
Inheritance diagram for SVF::RetPE:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_ret_p_e.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b RetPE} ({\b PAGNode} *s, {\b PAGNode} *d, const {\b CallBlockNode} *i, GEdgeKind k=PAGEdge::Ret){\bkmkstart AAAAAAACLC}
{\bkmkend AAAAAAACLC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getCallInst} () const{\bkmkstart AAAAAAACLD}
{\bkmkend AAAAAAACLD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get method for call instruction at caller. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getCallSite} () const{\bkmkstart AAAAAAACLE}
{\bkmkend AAAAAAACLE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACLF}
{\bkmkend AAAAAAACLF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b classof} (const {\b RetPE} *)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the callsite instruction return to }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGEdge} *edge){\bkmkstart AAAAAAACLG}
{\bkmkend AAAAAAACLG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGEdgeTy} *edge){\bkmkstart AAAAAAACLH}
{\bkmkend AAAAAAACLH}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v classof\:SVF::RetPE}
{\xe \v SVF::RetPE\:classof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static bool SVF::RetPE::classof (const {\b RetPE} * ){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACLI}
{\bkmkend AAAAAAACLI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the callsite instruction return to }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::RetPN Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::RetPN}
{\xe \v SVF::RetPN}
{\bkmkstart AAAAAAACOW}
{\bkmkend AAAAAAACOW}
Inheritance diagram for SVF::RetPN:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_ret_p_n.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b RetPN} (const {\b SVFFunction} *val, NodeID i){\bkmkstart AAAAAAACOX}
{\bkmkend AAAAAAACOX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::string {\b getValueName} () const{\bkmkstart AAAAAAACOY}
{\bkmkend AAAAAAACOY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of a LLVM value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACOZ}
{\bkmkend AAAAAAACOZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b RetPN} *){\bkmkstart AAAAAAACPA}
{\bkmkend AAAAAAACPA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGNode} *node){\bkmkstart AAAAAAACPB}
{\bkmkend AAAAAAACPB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGNodeTy} *node){\bkmkstart AAAAAAACPC}
{\bkmkend AAAAAAACPC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SaberAnnotator Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SaberAnnotator}
{\xe \v SVF::SaberAnnotator}
{\bkmkstart AAAAAAAFZW}
{\bkmkend AAAAAAAFZW}
\par
{
{\f2 #include <SaberAnnotator.h>}}\par
Inheritance diagram for SVF::SaberAnnotator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_saber_annotator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SaberAnnotator} ({\b ProgSlice} *slice){\bkmkstart AAAAAAAFZX}
{\bkmkend AAAAAAAFZX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~SaberAnnotator} (){\bkmkstart AAAAAAAFZY}
{\bkmkend AAAAAAAFZY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b annotateSource} (){\bkmkstart AAAAAAAFZZ}
{\bkmkend AAAAAAAFZZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Annotation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b annotateSinks} (){\bkmkstart AAAAAAAGAA}
{\bkmkend AAAAAAAGAA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b annotateFeasibleBranch} (const BranchInst *brInst, u32_t succPos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b annotateInfeasibleBranch} (const BranchInst *brInst, u32_t succPos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b annotateSwitch} (SwitchInst *brInst, u32_t succPos)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Saber annotation \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v annotateFeasibleBranch\:SVF::SaberAnnotator}
{\xe \v SVF::SaberAnnotator\:annotateFeasibleBranch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SaberAnnotator::annotateFeasibleBranch (const BranchInst *  {\i brInst}, u32_t  {\i succPos})}}
\par
{\bkmkstart AAAAAAAGAB}
{\bkmkend AAAAAAAGAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Annotate branch instruction and its corresponding feasible path \par
}}
{\xe \v annotateInfeasibleBranch\:SVF::SaberAnnotator}
{\xe \v SVF::SaberAnnotator\:annotateInfeasibleBranch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SaberAnnotator::annotateInfeasibleBranch (const BranchInst *  {\i brInst}, u32_t  {\i succPos})}}
\par
{\bkmkstart AAAAAAAGAC}
{\bkmkend AAAAAAAGAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Annotate branch instruction and its corresponding infeasible path \par
}}
{\xe \v annotateSwitch\:SVF::SaberAnnotator}
{\xe \v SVF::SaberAnnotator\:annotateSwitch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SaberAnnotator::annotateSwitch (SwitchInst *  {\i switchInst}, u32_t  {\i succPos})}}
\par
{\bkmkstart AAAAAAAGAD}
{\bkmkend AAAAAAAGAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Annotate switch instruction and its corresponding feasible path \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SABER/SaberAnnotator.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SABER/SaberAnnotator.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SaberCheckerAPI Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SaberCheckerAPI}
{\xe \v SVF::SaberCheckerAPI}
{\bkmkstart AAAAAAAGAE}
{\bkmkend AAAAAAAGAE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b CHECKER_TYPE} \{ {\b CK_DUMMY} = 0
, {\b CK_ALLOC}
, {\b CK_FREE}
, {\b CK_FOPEN}
, {\b CK_FCLOSE}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::StringMap< {\b CHECKER_TYPE} > {\b TDAPIMap}{\bkmkstart AAAAAAAGAF}
{\bkmkend AAAAAAAGAF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isMemAlloc} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAAGAG}
{\bkmkend AAAAAAAGAG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if this call is a memory allocation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isMemAlloc} (const Instruction *inst) const{\bkmkstart AAAAAAAGAH}
{\bkmkend AAAAAAAGAH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isMemAlloc} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAAGAI}
{\bkmkend AAAAAAAGAI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isMemDealloc} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAAGAJ}
{\bkmkend AAAAAAAGAJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if this call is a memory deallocation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isMemDealloc} (const Instruction *inst) const{\bkmkstart AAAAAAAGAK}
{\bkmkend AAAAAAAGAK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isMemDealloc} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAAGAL}
{\bkmkend AAAAAAAGAL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFOpen} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAAGAM}
{\bkmkend AAAAAAAGAM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if this call is a file open. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFOpen} (const Instruction *inst) const{\bkmkstart AAAAAAAGAN}
{\bkmkend AAAAAAAGAN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFOpen} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAAGAO}
{\bkmkend AAAAAAAGAO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFClose} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAAGAP}
{\bkmkend AAAAAAAGAP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if this call is a file close. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFClose} (const Instruction *inst) const{\bkmkstart AAAAAAAGAQ}
{\bkmkend AAAAAAAGAQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isFClose} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAAGAR}
{\bkmkend AAAAAAAGAR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b SaberCheckerAPI} * {\b getCheckerAPI} (){\bkmkstart AAAAAAAGAS}
{\bkmkend AAAAAAAGAS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a static reference. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v CHECKER_TYPE\:SVF::SaberCheckerAPI}
{\xe \v SVF::SaberCheckerAPI\:CHECKER_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SVF::SaberCheckerAPI::CHECKER_TYPE}}}
\par
{\bkmkstart AAAAAAAGAT}
{\bkmkend AAAAAAAGAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v CK_ALLOC\:SVF::SaberCheckerAPI}
{\xe \v SVF::SaberCheckerAPI\:CK_ALLOC}
{\qr CK_ALLOC{\bkmkstart AAAAAAAGAU}
{\bkmkend AAAAAAAGAU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dummy type \par
}\cell }{\row }
{\xe \v CK_FREE\:SVF::SaberCheckerAPI}
{\xe \v SVF::SaberCheckerAPI\:CK_FREE}
{\qr CK_FREE{\bkmkstart AAAAAAAGAV}
{\bkmkend AAAAAAAGAV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
memory allocation \par
}\cell }{\row }
{\xe \v CK_FOPEN\:SVF::SaberCheckerAPI}
{\xe \v SVF::SaberCheckerAPI\:CK_FOPEN}
{\qr CK_FOPEN{\bkmkstart AAAAAAAGAW}
{\bkmkend AAAAAAAGAW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
memory deallocation \par
}\cell }{\row }
{\xe \v CK_FCLOSE\:SVF::SaberCheckerAPI}
{\xe \v SVF::SaberCheckerAPI\:CK_FCLOSE}
{\qr CK_FCLOSE{\bkmkstart AAAAAAAGAX}
{\bkmkend AAAAAAAGAX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
File open. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
File close \par
}\cell }{\row }
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SABER/SaberCheckerAPI.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SABER/SaberCheckerAPI.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SaberSVFGBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SaberSVFGBuilder}
{\xe \v SVF::SaberSVFGBuilder}
{\bkmkstart AAAAAAAGAY}
{\bkmkend AAAAAAAGAY}
Inheritance diagram for SVF::SaberSVFGBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_saber_s_v_f_g_builder.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b SVFGNode} * > {\b SVFGNodeSet}{\bkmkstart AAAAAAAGAZ}
{\bkmkend AAAAAAAGAZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, NodeBS > {\b NodeToPTSSMap}{\bkmkstart AAAAAAAGBA}
{\bkmkend AAAAAAAGBA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< NodeID > {\b WorkList}{\bkmkstart AAAAAAAGBB}
{\bkmkend AAAAAAAGBB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SaberSVFGBuilder} (){\bkmkstart AAAAAAAGBC}
{\bkmkend AAAAAAAGBC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~SaberSVFGBuilder} (){\bkmkstart AAAAAAAGBD}
{\bkmkend AAAAAAAGBD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isGlobalSVFGNode} (const {\b SVFGNode} *node) const{\bkmkstart AAAAAAAGBE}
{\bkmkend AAAAAAAGBE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addActualParmVFGNode} (const {\b PAGNode} *pagNode, const {\b CallBlockNode} *cs){\bkmkstart AAAAAAAGBF}
{\bkmkend AAAAAAAGBF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add {\b ActualParmVFGNode}. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b buildSVFG} (){\bkmkstart AAAAAAAFKL}
{\bkmkend AAAAAAAFKL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Re-write create {\b SVFG} method. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SABER/SaberSVFGBuilder.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SABER/SaberSVFGBuilder.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SCCDetection< GraphType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SCCDetection< GraphType >}
{\xe \v SVF::SCCDetection< GraphType >}
{\bkmkstart AAAAAAAHFK}
{\bkmkend AAAAAAAHFK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GNodeSCCInfo}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::stack< NodeID > {\b GNodeStack}{\bkmkstart AAAAAAAHFL}
{\bkmkend AAAAAAAHFL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, {\b GNodeSCCInfo} > {\b GNODESCCInfoMap}{\bkmkstart AAAAAAAHFM}
{\bkmkend AAAAAAAHFM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, NodeID > {\b NodeToNodeMap}{\bkmkstart AAAAAAAHFN}
{\bkmkend AAAAAAAHFN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SCCDetection} (const GraphType &GT){\bkmkstart AAAAAAAHFO}
{\bkmkend AAAAAAAHFO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

GNodeStack & {\b topoNodeStack} (){\bkmkstart AAAAAAAHFP}
{\bkmkend AAAAAAAHFP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const GNODESCCInfoMap & {\b GNodeSCCInfo} () const{\bkmkstart AAAAAAAHFQ}
{\bkmkend AAAAAAAHFQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b repNode} (NodeID n) const{\bkmkstart AAAAAAAHFR}
{\bkmkend AAAAAAAHFR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get the rep node if not found return itself }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isInCycle} (NodeID n) const{\bkmkstart AAAAAAAHFS}
{\bkmkend AAAAAAAHFS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
whether the node is in a cycle }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const NodeBS & {\b subNodes} (NodeID n) const{\bkmkstart AAAAAAAHFT}
{\bkmkend AAAAAAAHFT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get all subnodes in one scc, if size is empty insert itself into the set }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const NodeBS & {\b getRepNodes} () const{\bkmkstart AAAAAAAHFU}
{\bkmkend AAAAAAAHFU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get all repNodeID }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const GraphType & {\b graph} (){\bkmkstart AAAAAAAHFV}
{\bkmkend AAAAAAAHFV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b find} (void){\bkmkstart AAAAAAAHFW}
{\bkmkend AAAAAAAHFW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b find} (NodeSet &candidates){\bkmkstart AAAAAAAHFX}
{\bkmkend AAAAAAAHFX}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/SCC.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::simplify_type< From > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::simplify_type< From >}
{\xe \v SVF::SVFUtil::simplify_type< From >}
{\bkmkstart AAAAAAAIDT}
{\bkmkend AAAAAAAIDT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

using {\b SimpleType} = From{\bkmkstart AAAAAAAIDU}
{\bkmkend AAAAAAAIDU}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static SimpleType & {\b getSimplifiedValue} (From &Val){\bkmkstart AAAAAAAIDV}
{\bkmkend AAAAAAAIDV}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFUtil::simplify_type< const From > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFUtil::simplify_type< const From >}
{\xe \v SVF::SVFUtil::simplify_type< const From >}
{\bkmkstart AAAAAAAIDW}
{\bkmkend AAAAAAAIDW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

using {\b NonConstSimpleType} = typename {\b simplify_type}< From >::SimpleType{\bkmkstart AAAAAAAIDX}
{\bkmkend AAAAAAAIDX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

using {\b SimpleType} = typename llvm::add_const_past_pointer< NonConstSimpleType >::type{\bkmkstart AAAAAAAIDY}
{\bkmkend AAAAAAAIDY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

using {\b RetType} = typename llvm::add_lvalue_reference_if_not_pointer< SimpleType >::type{\bkmkstart AAAAAAAIDZ}
{\bkmkend AAAAAAAIDZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static RetType {\b getSimplifiedValue} (const From &Val){\bkmkstart AAAAAAAIEA}
{\bkmkend AAAAAAAIEA}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/Casting.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SrcSnkDDA Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SrcSnkDDA}
{\xe \v SVF::SrcSnkDDA}
{\bkmkstart AAAAAAAFXO}
{\bkmkend AAAAAAAFXO}
\par
{
{\f2 #include <SrcSnkDDA.h>}}\par
Inheritance diagram for SVF::SrcSnkDDA:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_src_snk_d_d_a.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef ProgSlice::SVFGNodeSet {\b SVFGNodeSet}{\bkmkstart AAAAAAAGBG}
{\bkmkend AAAAAAAGBG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFGNode} *, {\b ProgSlice} * > {\b SVFGNodeToSliceMap}{\bkmkstart AAAAAAAGBH}
{\bkmkend AAAAAAAGBH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef SVFGNodeSet::const_iterator {\b SVFGNodeSetIter}{\bkmkstart AAAAAAAGBI}
{\bkmkend AAAAAAAGBI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b CxtDPItem} {\b DPIm}{\bkmkstart AAAAAAAGBJ}
{\bkmkend AAAAAAAGBJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< {\b DPIm} > {\b DPImSet}{\bkmkstart AAAAAAAGBK}
{\bkmkend AAAAAAAGBK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dpitem set }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFGNode} *, {\b DPImSet} > {\b SVFGNodeToDPItemsMap}{\bkmkstart AAAAAAAGBL}
{\bkmkend AAAAAAAGBL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a SVFGNode to its visited dpitems }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b CallBlockNode} * > {\b CallSiteSet}{\bkmkstart AAAAAAAGBM}
{\bkmkend AAAAAAAGBM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeBS {\b SVFGNodeBS}{\bkmkstart AAAAAAAGBN}
{\bkmkend AAAAAAAGBN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b ProgSlice::VFWorkList} {\b WorkList}{\bkmkstart AAAAAAAGBO}
{\bkmkend AAAAAAAGBO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SrcSnkDDA} (){\bkmkstart AAAAAAAGBP}
{\bkmkend AAAAAAAGBP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~SrcSnkDDA} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b analyze} ({\b SVFModule} *module)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start analysis here. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initialize} ({\b SVFModule} *module)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b finalize} (){\bkmkstart AAAAAAAGBQ}
{\bkmkend AAAAAAAGBQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAG} * {\b getPAG} () const{\bkmkstart AAAAAAAGBR}
{\bkmkend AAAAAAAGBR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b PAG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFG} * {\b getSVFG} () const{\bkmkstart AAAAAAAGBS}
{\bkmkend AAAAAAAGBS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b SVFG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTACallGraph} * {\b getCallgraph} () const{\bkmkstart AAAAAAAGBT}
{\bkmkend AAAAAAAGBT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Callgraph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isGlobalSVFGNode} (const {\b SVFGNode} *node) const{\bkmkstart AAAAAAAGBU}
{\bkmkend AAAAAAAGBU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this svfg node may access global variable. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setCurSlice} (const {\b SVFGNode} *src)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Slice operations. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ProgSlice} * {\b getCurSlice} () const{\bkmkstart AAAAAAAGBV}
{\bkmkend AAAAAAAGBV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addSinkToCurSlice} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAGBW}
{\bkmkend AAAAAAAGBW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isInCurForwardSlice} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAGBX}
{\bkmkend AAAAAAAGBX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isInCurBackwardSlice} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAGBY}
{\bkmkend AAAAAAAGBY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addToCurForwardSlice} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAGBZ}
{\bkmkend AAAAAAAGBZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addToCurBackwardSlice} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAGCA}
{\bkmkend AAAAAAAGCA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isInAWrapper} (const {\b SVFGNode} *src, CallSiteSet &csIdSet)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Identify allocation wrappers. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b reportBug} ({\b ProgSlice} *slice)=0{\bkmkstart AAAAAAAGCB}
{\bkmkend AAAAAAAGCB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
report bug on the current analyzed slice }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const SVFGNodeSet & {\b getSources} () const{\bkmkstart AAAAAAAGCC}
{\bkmkend AAAAAAAGCC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get sources/sinks. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SVFGNodeSetIter {\b sourcesBegin} () const{\bkmkstart AAAAAAAGCD}
{\bkmkend AAAAAAAGCD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SVFGNodeSetIter {\b sourcesEnd} () const{\bkmkstart AAAAAAAGCE}
{\bkmkend AAAAAAAGCE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addToSources} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAGCF}
{\bkmkend AAAAAAAGCF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const SVFGNodeSet & {\b getSinks} () const{\bkmkstart AAAAAAAGCG}
{\bkmkend AAAAAAAGCG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SVFGNodeSetIter {\b sinksBegin} () const{\bkmkstart AAAAAAAGCH}
{\bkmkend AAAAAAAGCH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SVFGNodeSetIter {\b sinksEnd} () const{\bkmkstart AAAAAAAGCI}
{\bkmkend AAAAAAAGCI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addToSinks} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAGCJ}
{\bkmkend AAAAAAAGCJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PathCondAllocator} * {\b getPathAllocator} () const{\bkmkstart AAAAAAAGCK}
{\bkmkend AAAAAAAGCK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get path condition allocator. }{
}\par
}\par}
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b initSrcs} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b initSnks} ()=0{\bkmkstart AAAAAAAGCL}
{\bkmkend AAAAAAAGCL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isSourceLikeFun} (const {\b SVFFunction} *fun)=0{\bkmkstart AAAAAAAGCM}
{\bkmkend AAAAAAAGCM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isSinkLikeFun} (const {\b SVFFunction} *fun)=0{\bkmkstart AAAAAAAGCN}
{\bkmkend AAAAAAAGCN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isSource} (const {\b SVFGNode} *node)=0{\bkmkstart AAAAAAAGCO}
{\bkmkend AAAAAAAGCO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isSink} (const {\b SVFGNode} *node)=0{\bkmkstart AAAAAAAGCP}
{\bkmkend AAAAAAAGCP}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b FWProcessCurNode} (const {\b DPIm} &item){\bkmkstart AAAAAAAGCQ}
{\bkmkend AAAAAAAGCQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Forward traverse. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b BWProcessCurNode} (const {\b DPIm} &item){\bkmkstart AAAAAAAGCR}
{\bkmkend AAAAAAAGCR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Backward traverse. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b FWProcessOutgoingEdge} (const {\b DPIm} &item, {\b SVFGEdge} *edge)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate information forward by matching context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b BWProcessIncomingEdge} (const {\b DPIm} &item, {\b SVFGEdge} *edge)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate information backward without matching context, as forward analysis already did it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b forwardVisited} (const {\b SVFGNode} *node, const {\b DPIm} &item){\bkmkstart AAAAAAAGCS}
{\bkmkend AAAAAAAGCS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether has been visited or not, in order to avoid recursion on {\b SVFG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addForwardVisited} (const {\b SVFGNode} *node, const {\b DPIm} &item){\bkmkstart AAAAAAAGCT}
{\bkmkend AAAAAAAGCT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b backwardVisited} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAGCU}
{\bkmkend AAAAAAAGCU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addBackwardVisited} (const {\b SVFGNode} *node){\bkmkstart AAAAAAAGCV}
{\bkmkend AAAAAAAGCV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b clearVisitedMap} (){\bkmkstart AAAAAAAGCW}
{\bkmkend AAAAAAAGCW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isAllPathReachable} (){\bkmkstart AAAAAAAGCX}
{\bkmkend AAAAAAAGCX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether it is all path reachable from a source. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isSomePathReachable} (){\bkmkstart AAAAAAAGCY}
{\bkmkend AAAAAAAGCY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether it is some path reachable from a source. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dumpSlices} (){\bkmkstart AAAAAAAGCZ}
{\bkmkend AAAAAAAGCZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump {\b SVFG} with annotated slice informaiton. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b annotateSlice} ({\b ProgSlice} *slice){\bkmkstart AAAAAAAGDA}
{\bkmkend AAAAAAAGDA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b printBDDStat} (){\bkmkstart AAAAAAAGDB}
{\bkmkend AAAAAAAGDB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SaberSVFGBuilder} {\b memSSA}{\bkmkstart AAAAAAAGDC}
{\bkmkend AAAAAAAGDC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFG} * {\b svfg}{\bkmkstart AAAAAAAGDD}
{\bkmkend AAAAAAAGDD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTACallGraph} * {\b ptaCallGraph}{\bkmkstart AAAAAAAGDE}
{\bkmkend AAAAAAAGDE}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
General source-sink analysis, which serves as a base analysis to be extended for various clients \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ~SrcSnkDDA\:SVF::SrcSnkDDA}
{\xe \v SVF::SrcSnkDDA\:~SrcSnkDDA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual SVF::SrcSnkDDA::~SrcSnkDDA (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGDF}
{\bkmkend AAAAAAAGDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the following shared by multiple checkers, thus can not be released.\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v analyze\:SVF::SrcSnkDDA}
{\xe \v SVF::SrcSnkDDA\:analyze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SrcSnkDDA::analyze ({\b SVFModule} *  {\i module}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGDG}
{\bkmkend AAAAAAAGDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start analysis here. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
do not consider there is bug when reaching a global SVFGNode if we touch a global, then we assume the client uses this memory until the program exits.\par
}}
{\xe \v BWProcessIncomingEdge\:SVF::SrcSnkDDA}
{\xe \v SVF::SrcSnkDDA\:BWProcessIncomingEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SrcSnkDDA::BWProcessIncomingEdge (const {\b DPIm} &  {\i item}, {\b SVFGEdge} *  {\i edge}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGDH}
{\bkmkend AAAAAAAGDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate information backward without matching context, as forward analysis already did it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate information backward without matching context, as forward analysis already did it \par
}}
{\xe \v FWProcessOutgoingEdge\:SVF::SrcSnkDDA}
{\xe \v SVF::SrcSnkDDA\:FWProcessOutgoingEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SrcSnkDDA::FWProcessOutgoingEdge (const {\b DPIm} &  {\i item}, {\b SVFGEdge} *  {\i edge}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGDI}
{\bkmkend AAAAAAAGDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate information forward by matching context. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate information forward by matching context \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
handle globals here\par
perform context sensitive reachability\par
whether this dstNode has been visited or not\par
}}
{\xe \v initialize\:SVF::SrcSnkDDA}
{\xe \v SVF::SrcSnkDDA\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SrcSnkDDA::initialize ({\b SVFModule} *  {\i module}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGDJ}
{\bkmkend AAAAAAAGDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
allocate control-flow graph branch conditions\par
}}
{\xe \v initSrcs\:SVF::SrcSnkDDA}
{\xe \v SVF::SrcSnkDDA\:initSrcs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void SVF::SrcSnkDDA::initSrcs (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAFXQ}
{\bkmkend AAAAAAAFXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize sources and sinks \par
}{
Implemented in {\b SVF::LeakChecker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFXP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v isInAWrapper\:SVF::SrcSnkDDA}
{\xe \v SVF::SrcSnkDDA\:isInAWrapper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SrcSnkDDA::isInAWrapper (const {\b SVFGNode} *  {\i src}, CallSiteSet &  {\i csIdSet})}}
\par
{\bkmkstart AAAAAAAGDK}
{\bkmkend AAAAAAAGDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Identify allocation wrappers. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
determine whether a SVFGNode n is in a allocation wrapper function, if so, return all SVFGNodes which receive the value of node n \par
}}
{\xe \v setCurSlice\:SVF::SrcSnkDDA}
{\xe \v SVF::SrcSnkDDA\:setCurSlice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SrcSnkDDA::setCurSlice (const {\b SVFGNode} *  {\i src}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGDL}
{\bkmkend AAAAAAAGDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Slice operations. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set current slice. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SABER/SrcSnkDDA.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SABER/SrcSnkDDA.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
st_generator Struct Reference\par \pard\plain 
{\tc\tcl2 \v st_generator}
{\xe \v st_generator}
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b st_table} * {\b table}{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b st_table_entry} * {\b entry}{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b index}{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/st.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
st_table Struct Reference\par \pard\plain 
{\tc\tcl2 \v st_table}
{\xe \v st_table}
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int(* {\b compare} )(const char *, const char *){\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int(* {\b hash} )(char *, int){\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b num_bins}{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b num_entries}{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b max_density}{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b reorder_flag}{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

double {\b grow_factor}{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b st_table_entry} ** {\b bins}{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/st.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
st_table_entry Struct Reference\par \pard\plain 
{\tc\tcl2 \v st_table_entry}
{\xe \v st_table_entry}
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

char * {\b key}{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

char * {\b record}{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b st_table_entry} * {\b next}{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/CUDD/st.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::Steensgaard Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::Steensgaard}
{\xe \v SVF::Steensgaard}
{\bkmkstart AAAAAAAHXW}
{\bkmkend AAAAAAAHXW}
Inheritance diagram for SVF::Steensgaard:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_steensgaard.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, NodeID > {\b NodeToEquivClassMap}{\bkmkstart AAAAAAAHXX}
{\bkmkend AAAAAAAHXX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, Set< NodeID > > {\b NodeToSubsMap}{\bkmkstart AAAAAAAHXY}
{\bkmkend AAAAAAAHXY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Steensgaard} ({\b PAG} *_pag){\bkmkstart AAAAAAAHXZ}
{\bkmkend AAAAAAAHXZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b solveWorklist} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b processAllAddr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b ecUnion} (NodeID id, NodeID ec){\bkmkstart AAAAAAAHYA}
{\bkmkend AAAAAAAHYA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
merge node into equiv class and merge node's pts into ec's pts }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const PointsTo & {\b getPts} (NodeID id){\bkmkstart AAAAAAAESI}
{\bkmkend AAAAAAAESI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operation of points-to set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (NodeID id, const PointsTo &target){\bkmkstart AAAAAAAESN}
{\bkmkend AAAAAAAESN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pts(id) = pts(id) U target }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (NodeID id, NodeID ptd){\bkmkstart AAAAAAAHYB}
{\bkmkend AAAAAAAHYB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pts(id) = pts(id) U pts(ptd) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b getECNode} (NodeID id) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setEC} (NodeID node, NodeID rep){\bkmkstart AAAAAAAHYC}
{\bkmkend AAAAAAAHYC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Set< NodeID > & {\b getSubNodes} (NodeID id){\bkmkstart AAAAAAAHYD}
{\bkmkend AAAAAAAHYD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addSubNode} (NodeID node, NodeID sub){\bkmkstart AAAAAAAHYE}
{\bkmkend AAAAAAAHYE}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b Steensgaard} * {\b createSteensgaard} ({\b PAG} *_pag){\bkmkstart AAAAAAAHYF}
{\bkmkend AAAAAAAHYF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an singleton instance. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b releaseSteensgaard} (){\bkmkstart AAAAAAAHYG}
{\bkmkend AAAAAAAHYG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b Steensgaard} *){\bkmkstart AAAAAAAHYH}
{\bkmkend AAAAAAAHYH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b AndersenBase} *pta){\bkmkstart AAAAAAAHYI}
{\bkmkend AAAAAAAHYI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PointerAnalysis} *pta){\bkmkstart AAAAAAAHYJ}
{\bkmkend AAAAAAAHYJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getECNode\:SVF::Steensgaard}
{\xe \v SVF::Steensgaard\:getECNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID SVF::Steensgaard::getECNode (NodeID  {\i id}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHYK}
{\bkmkend AAAAAAAHYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
API for equivalence class operations Every constraint node maps to an unique equivalence class EC An equivalence class has a set of sub constraint nodes. \par
}}
{\xe \v processAllAddr\:SVF::Steensgaard}
{\xe \v SVF::Steensgaard\:processAllAddr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Steensgaard::processAllAddr ()}}
\par
{\bkmkstart AAAAAAAHYL}
{\bkmkend AAAAAAAHYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process address edges \par
}}
{\xe \v solveWorklist\:SVF::Steensgaard}
{\xe \v SVF::Steensgaard\:solveWorklist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Steensgaard::solveWorklist (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHYM}
{\bkmkend AAAAAAAHYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Steensgaard} analysis \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
foreach ptd \\in pts(p)\par
*p = q : EC(o) == EC(q)\par
q = p : EC(q) == EC(p)\par
q = &p->f : EC(q) == EC(p)\par
}{
Reimplemented from {\b SVF::WPASolver< GraphType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHQQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/Steensgaard.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/Steensgaard.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::StInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::StInfo}
{\xe \v SVF::StInfo}
{\bkmkstart AAAAAAAECP}
{\bkmkend AAAAAAAECP}
\par
{
{\f2 #include <MemModel.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b StInfo} (){\bkmkstart AAAAAAAECQ}
{\bkmkend AAAAAAAECQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ~StInfo} (){\bkmkstart AAAAAAAECR}
{\bkmkend AAAAAAAECR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const llvm::Type * {\b getFieldTypeWithFldIdx} (u32_t fldIdx){\bkmkstart AAAAAAAECS}
{\bkmkend AAAAAAAECS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get method for fields of a struct. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const llvm::Type * {\b getFieldTypeWithByteOffset} (u32_t offset){\bkmkstart AAAAAAAECT}
{\bkmkend AAAAAAAECT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::vector< u32_t > & {\b getFieldIdxVec} (){\bkmkstart AAAAAAAECU}
{\bkmkend AAAAAAAECU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::vector< u32_t > & {\b getFieldOffsetVec} (){\bkmkstart AAAAAAAECV}
{\bkmkend AAAAAAAECV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::vector< {\b FieldInfo} > & {\b getFlattenFieldInfoVec} (){\bkmkstart AAAAAAAECW}
{\bkmkend AAAAAAAECW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addFldWithType} (u32_t fldIdx, u32_t offset, const llvm::Type *type){\bkmkstart AAAAAAAECX}
{\bkmkend AAAAAAAECX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add field (index and offset) with its corresponding type. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b setMaxFieldLimit} (u32_t limit){\bkmkstart AAAAAAAECY}
{\bkmkend AAAAAAAECY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u32_t {\b getMaxFieldLimit} (){\bkmkstart AAAAAAAECZ}
{\bkmkend AAAAAAAECZ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct information \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/MemModel.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MemoryModel/MemModel.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::StmtDPItem< LocCond > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::StmtDPItem< LocCond >}
{\xe \v SVF::StmtDPItem< LocCond >}
{\bkmkstart AAAAAAAGYM}
{\bkmkend AAAAAAAGYM}
\par
{
{\f2 #include <DPItem.h>}}\par
Inheritance diagram for SVF::StmtDPItem< LocCond >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_stmt_d_p_item.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b StmtDPItem} (NodeID c, const LocCond *locCond){\bkmkstart AAAAAAAGYN}
{\bkmkend AAAAAAAGYN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b StmtDPItem} (const {\b StmtDPItem} &dps){\bkmkstart AAAAAAAGYO}
{\bkmkend AAAAAAAGYO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~StmtDPItem} (){\bkmkstart AAAAAAAGYP}
{\bkmkend AAAAAAAGYP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const LocCond * {\b getLoc} () const{\bkmkstart AAAAAAAGYQ}
{\bkmkend AAAAAAAGYQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setLoc} (const LocCond *l){\bkmkstart AAAAAAAGYR}
{\bkmkend AAAAAAAGYR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set location. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setLocVar} (const LocCond *l, NodeID v){\bkmkstart AAAAAAAGYS}
{\bkmkend AAAAAAAGYS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set location and pointer id. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b StmtDPItem} &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b StmtDPItem} & {\b operator=} (const {\b StmtDPItem} &rhs){\bkmkstart AAAAAAAGYT}
{\bkmkend AAAAAAAGYT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b StmtDPItem} &rhs) const{\bkmkstart AAAAAAAGYU}
{\bkmkend AAAAAAAGYU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b StmtDPItem} &rhs) const{\bkmkstart AAAAAAAGYV}
{\bkmkend AAAAAAAGYV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator!=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dump} () const{\bkmkstart AAAAAAAGYW}
{\bkmkend AAAAAAAGYW}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const LocCond * {\b curloc}{\bkmkstart AAAAAAAGYX}
{\bkmkend AAAAAAAGYX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class LocCond>\par
class SVF::StmtDPItem< LocCond >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b FlowSensitive} {\b DPItem} \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator<\:SVF::StmtDPItem< LocCond >}
{\xe \v SVF::StmtDPItem< LocCond >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class LocCond > bool {\b SVF::StmtDPItem}< LocCond >::operator< (const {\b StmtDPItem}< LocCond > &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAGYY}
{\bkmkend AAAAAAAGYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable compare operator to avoid duplicated item insertion in map or set to be noted that two vectors can also overload operator() \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/DPItem.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::StmtVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::StmtVFGNode}
{\xe \v SVF::StmtVFGNode}
{\bkmkstart AAAAAAADOI}
{\bkmkend AAAAAAADOI}
\par
{
{\f2 #include <VFGNode.h>}}\par
Inheritance diagram for SVF::StmtVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_stmt_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b StmtVFGNode} (NodeID id, const {\b PAGEdge} *e, {\b VFGNodeK} k){\bkmkstart AAAAAAADOJ}
{\bkmkend AAAAAAADOJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isPTANode} () const{\bkmkstart AAAAAAADOK}
{\bkmkend AAAAAAADOK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this node is used for pointer analysis. Both src and dst PAGNodes are of ptr type. }{
}\par
}\par}
}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PAGEdge} * {\b getPAGEdge} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getPAGSrcNodeID} () const{\bkmkstart AAAAAAADOL}
{\bkmkend AAAAAAADOL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getPAGDstNodeID} () const{\bkmkstart AAAAAAADOM}
{\bkmkend AAAAAAADOM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAGNode} * {\b getPAGSrcNode} () const{\bkmkstart AAAAAAADON}
{\bkmkend AAAAAAADON}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAGNode} * {\b getPAGDstNode} () const{\bkmkstart AAAAAAADOO}
{\bkmkend AAAAAAADOO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const Instruction * {\b getInst} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADOP}
{\bkmkend AAAAAAADOP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b StmtVFGNode} *){\bkmkstart AAAAAAADOQ}
{\bkmkend AAAAAAADOQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADOR}
{\bkmkend AAAAAAADOR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADOS}
{\bkmkend AAAAAAADOS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ICFG} node stands for a program statement \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getInst\:SVF::StmtVFGNode}
{\xe \v SVF::StmtVFGNode\:getInst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const Instruction* SVF::StmtVFGNode::getInst () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADOT}
{\bkmkend AAAAAAADOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
should return a valid instruction unless it is a global {\b PAGEdge}\par
}}
{\xe \v getPAGEdge\:SVF::StmtVFGNode}
{\xe \v SVF::StmtVFGNode\:getPAGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PAGEdge}* SVF::StmtVFGNode::getPAGEdge () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADOU}
{\bkmkend AAAAAAADOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAGNode} and {\b PAGEdge} \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::StoreCGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::StoreCGEdge}
{\xe \v SVF::StoreCGEdge}
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
\par
{
{\f2 #include <ConsGEdge.h>}}\par
Inheritance diagram for SVF::StoreCGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_store_c_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b StoreCGEdge} ({\b ConstraintNode} *s, {\b ConstraintNode} *d, EdgeID id){\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b StoreCGEdge} *){\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ConstraintEdge} *edge){\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericConsEdgeTy} *edge){\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Store edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ConsGEdge.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::StoreCHI< Cond > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::StoreCHI< Cond >}
{\xe \v SVF::StoreCHI< Cond >}
{\bkmkstart AAAAAAAFID}
{\bkmkend AAAAAAAFID}
\par
{
{\f2 #include <MSSAMuChi.h>}}\par
Inheritance diagram for SVF::StoreCHI< Cond >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_store_c_h_i.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b StoreCHI} (const BasicBlock *b, const {\b StorePE} *i, const {\b MemRegion} *m, Cond c=PathCondAllocator::trueCond()){\bkmkstart AAAAAAAFIE}
{\bkmkend AAAAAAAFIE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructors for {\b StoreCHI}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const BasicBlock * {\b getBasicBlock} () const{\bkmkstart AAAAAAAFIF}
{\bkmkend AAAAAAAFIF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get basic block. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b StorePE} * {\b getStoreInst} () const{\bkmkstart AAAAAAAFIG}
{\bkmkend AAAAAAAFIG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get store instruction. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b dump} (){\bkmkstart AAAAAAAFIH}
{\bkmkend AAAAAAAFIH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print CHI. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b StoreCHI} *chi){\bkmkstart AAAAAAAFII}
{\bkmkend AAAAAAAFII}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MSSACHI}< Cond > *chi){\bkmkstart AAAAAAAFIJ}
{\bkmkend AAAAAAAFIJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b MSSADEF} *chi){\bkmkstart AAAAAAAFIK}
{\bkmkend AAAAAAAFIK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Cond>\par
class SVF::StoreCHI< Cond >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b StoreCHI} is annotated at each store instruction, representing a memory object is modified here \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/MSSAMuChi.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::StorePE Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::StorePE}
{\xe \v SVF::StorePE}
{\bkmkstart AAAAAAACJL}
{\bkmkend AAAAAAACJL}
\par
{
{\f2 #include <PAGEdge.h>}}\par
Inheritance diagram for SVF::StorePE:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_store_p_e.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b StorePE} ({\b PAGNode} *s, {\b PAGNode} *d, const {\b IntraBlockNode} *st){\bkmkstart AAAAAAACJM}
{\bkmkend AAAAAAACJM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACJN}
{\bkmkend AAAAAAACJN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b StorePE} *){\bkmkstart AAAAAAACJO}
{\bkmkend AAAAAAACJO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGEdge} *edge){\bkmkstart AAAAAAACJP}
{\bkmkend AAAAAAACJP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGEdgeTy} *edge){\bkmkstart AAAAAAACJQ}
{\bkmkend AAAAAAACJQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Store edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::StoreVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::StoreVFGNode}
{\xe \v SVF::StoreVFGNode}
{\bkmkstart AAAAAAADPC}
{\bkmkend AAAAAAADPC}
\par
{
{\f2 #include <VFGNode.h>}}\par
Inheritance diagram for SVF::StoreVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_store_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b StoreVFGNode} (NodeID id, const {\b StorePE} *edge){\bkmkstart AAAAAAADPD}
{\bkmkend AAAAAAADPD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADPE}
{\bkmkend AAAAAAADPE}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b StoreVFGNode} *){\bkmkstart AAAAAAADPF}
{\bkmkend AAAAAAADPF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b StmtVFGNode} *node){\bkmkstart AAAAAAADPG}
{\bkmkend AAAAAAADPG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADPH}
{\bkmkend AAAAAAADPH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADPI}
{\bkmkend AAAAAAADPI}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b VFGNode} for stores \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFBasicBlock Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFBasicBlock}
{\xe \v SVF::SVFBasicBlock}
{\bkmkstart AAAAAAAGTJ}
{\bkmkend AAAAAAAGTJ}
Inheritance diagram for SVF::SVFBasicBlock:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_s_v_f_basic_block.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFBasicBlock} (const std::string &val){\bkmkstart AAAAAAAGTK}
{\bkmkend AAAAAAAGTK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/BasicTypes.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFFunction Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFFunction}
{\xe \v SVF::SVFFunction}
{\bkmkstart AAAAAAAGSZ}
{\bkmkend AAAAAAAGSZ}
Inheritance diagram for SVF::SVFFunction:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_s_v_f_function.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFFunction} (const std::string &val){\bkmkstart AAAAAAAGTA}
{\bkmkend AAAAAAAGTA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFFunction} (Function *f){\bkmkstart AAAAAAAGTB}
{\bkmkend AAAAAAAGTB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Function * {\b getLLVMFun} () const{\bkmkstart AAAAAAAGTC}
{\bkmkend AAAAAAAGTC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isDeclaration} () const{\bkmkstart AAAAAAAGTD}
{\bkmkend AAAAAAAGTD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isIntrinsic} () const{\bkmkstart AAAAAAAGTE}
{\bkmkend AAAAAAAGTE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b arg_size} () const{\bkmkstart AAAAAAAGTF}
{\bkmkend AAAAAAAGTF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isVarArg} () const{\bkmkstart AAAAAAAGTG}
{\bkmkend AAAAAAAGTG}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/BasicTypes.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFG Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFG}
{\xe \v SVF::SVFG}
{\bkmkstart AAAAAAACTZ}
{\bkmkend AAAAAAACTZ}
\par
{
{\f2 #include <SVFG.h>}}\par
Inheritance diagram for SVF::SVFG:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_s_v_f_g.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef VFGNodeIDToNodeMapTy {\b SVFGNodeIDToNodeMapTy}{\bkmkstart AAAAAAACUA}
{\bkmkend AAAAAAACUA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b PAGNode} *, NodeID > {\b PAGNodeToDefMapTy}{\bkmkstart AAAAAAACUB}
{\bkmkend AAAAAAACUB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b MRVer} *, NodeID > {\b MSSAVarToDefMapTy}{\bkmkstart AAAAAAACUC}
{\bkmkend AAAAAAACUC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeBS {\b ActualINSVFGNodeSet}{\bkmkstart AAAAAAACUD}
{\bkmkend AAAAAAACUD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeBS {\b ActualOUTSVFGNodeSet}{\bkmkstart AAAAAAACUE}
{\bkmkend AAAAAAACUE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeBS {\b FormalINSVFGNodeSet}{\bkmkstart AAAAAAACUF}
{\bkmkend AAAAAAACUF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef NodeBS {\b FormalOUTSVFGNodeSet}{\bkmkstart AAAAAAACUG}
{\bkmkend AAAAAAACUG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CallBlockNode} *, ActualINSVFGNodeSet > {\b CallSiteToActualINsMapTy}{\bkmkstart AAAAAAACUH}
{\bkmkend AAAAAAACUH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CallBlockNode} *, ActualOUTSVFGNodeSet > {\b CallSiteToActualOUTsMapTy}{\bkmkstart AAAAAAACUI}
{\bkmkend AAAAAAACUI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, FormalINSVFGNodeSet > {\b FunctionToFormalINsMapTy}{\bkmkstart AAAAAAACUJ}
{\bkmkend AAAAAAACUJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, FormalOUTSVFGNodeSet > {\b FunctionToFormalOUTsMapTy}{\bkmkstart AAAAAAACUK}
{\bkmkend AAAAAAACUK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef MemSSA::MUSet {\b MUSet}{\bkmkstart AAAAAAACUL}
{\bkmkend AAAAAAACUL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef MemSSA::CHISet {\b CHISet}{\bkmkstart AAAAAAACUM}
{\bkmkend AAAAAAACUM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef MemSSA::PHISet {\b PHISet}{\bkmkstart AAAAAAACUN}
{\bkmkend AAAAAAACUN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MemSSA::MU} {\b MU}{\bkmkstart AAAAAAACUO}
{\bkmkend AAAAAAACUO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MemSSA::CHI} {\b CHI}{\bkmkstart AAAAAAACUP}
{\bkmkend AAAAAAACUP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MemSSA::LOADMU} {\b LOADMU}{\bkmkstart AAAAAAACUQ}
{\bkmkend AAAAAAACUQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MemSSA::STORECHI} {\b STORECHI}{\bkmkstart AAAAAAACUR}
{\bkmkend AAAAAAACUR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MemSSA::RETMU} {\b RETMU}{\bkmkstart AAAAAAACUS}
{\bkmkend AAAAAAACUS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MemSSA::ENTRYCHI} {\b ENTRYCHI}{\bkmkstart AAAAAAACUT}
{\bkmkend AAAAAAACUT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MemSSA::CALLCHI} {\b CALLCHI}{\bkmkstart AAAAAAACUU}
{\bkmkend AAAAAAACUU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b MemSSA::CALLMU} {\b CALLMU}{\bkmkstart AAAAAAACUV}
{\bkmkend AAAAAAACUV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~SVFG} (){\bkmkstart AAAAAAACUW}
{\bkmkend AAAAAAACUW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFGStat} * {\b getStat} () const{\bkmkstart AAAAAAACUX}
{\bkmkend AAAAAAACUX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b clearMSSA} (){\bkmkstart AAAAAAACUY}
{\bkmkend AAAAAAACUY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear MSSA. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MemSSA} * {\b getMSSA} () const{\bkmkstart AAAAAAACUZ}
{\bkmkend AAAAAAACUZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b SVFG} memory SSA. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PointerAnalysis} * {\b getPTA} () const{\bkmkstart AAAAAAACVA}
{\bkmkend AAAAAAACVA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Pointer Analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFGNode} * {\b getSVFGNode} (NodeID id) const{\bkmkstart AAAAAAACVB}
{\bkmkend AAAAAAACVB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a {\b SVFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasSVFGNode} (NodeID id) const{\bkmkstart AAAAAAACVC}
{\bkmkend AAAAAAACVC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether has the SVFGNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFGEdge} * {\b getSVFGEdge} (const {\b SVFGNode} *src, const {\b SVFGNode} *dst, {\b SVFGEdge::VFGEdgeK} kind){\bkmkstart AAAAAAACVD}
{\bkmkend AAAAAAACVD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a {\b SVFG} edge according to src and dst. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getInterVFEdgesForIndirectCallSite} (const {\b CallBlockNode} *cs, const {\b SVFFunction} *callee, SVFGEdgeSetTy &edges)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all inter value flow edges of a indirect call site. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump} (const std::string &file, bool simple=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump graph into dot file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b connectCallerAndCallee} (const {\b CallBlockNode} *cs, const {\b SVFFunction} *callee, SVFGEdgeSetTy &edges)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect {\b SVFG} nodes between caller and callee for indirect call site. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFGNode} * {\b getDefSVFGNode} (const {\b PAGNode} *pagNode) const{\bkmkstart AAAAAAACVE}
{\bkmkend AAAAAAACVE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a pagNode, return its definition site. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b performStat} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasActualINSVFGNodes} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAACVF}
{\bkmkend AAAAAAACVF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has a SVFGNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasActualOUTSVFGNodes} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAACVG}
{\bkmkend AAAAAAACVG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasFormalINSVFGNodes} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAACVH}
{\bkmkend AAAAAAACVH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasFormalOUTSVFGNodes} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAACVI}
{\bkmkend AAAAAAACVI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

ActualINSVFGNodeSet & {\b getActualINSVFGNodes} (const {\b CallBlockNode} *cs){\bkmkstart AAAAAAACVJ}
{\bkmkend AAAAAAACVJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get SVFGNode set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

ActualOUTSVFGNodeSet & {\b getActualOUTSVFGNodes} (const {\b CallBlockNode} *cs){\bkmkstart AAAAAAACVK}
{\bkmkend AAAAAAACVK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FormalINSVFGNodeSet & {\b getFormalINSVFGNodes} (const {\b SVFFunction} *fun){\bkmkstart AAAAAAACVL}
{\bkmkend AAAAAAACVL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FormalOUTSVFGNodeSet & {\b getFormalOUTSVFGNodes} (const {\b SVFFunction} *fun){\bkmkstart AAAAAAACVM}
{\bkmkend AAAAAAACVM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SVFFunction} * {\b isFunEntrySVFGNode} (const {\b SVFGNode} *node) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a node is function entry SVFGNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CallBlockNode} * {\b isCallSiteRetSVFGNode} (const {\b SVFGNode} *node) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a node is callsite return SVFGNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeSVFGEdge} ({\b SVFGEdge} *edge){\bkmkstart AAAAAAACVN}
{\bkmkend AAAAAAACVN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove a {\b SVFG} edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeSVFGNode} ({\b SVFGNode} *node){\bkmkstart AAAAAAACVO}
{\bkmkend AAAAAAACVO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove a SVFGNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b addSVFGEdge} ({\b SVFGEdge} *edge){\bkmkstart AAAAAAACVP}
{\bkmkend AAAAAAACVP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add {\b SVFG} edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getSVFGNodeNum} () const{\bkmkstart AAAAAAACVQ}
{\bkmkend AAAAAAACVQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return total {\b SVFG} node number. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SVFG} ({\b MemSSA} *mssa, {\b VFGK} k)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b buildSVFG} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start building {\b SVFG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFGEdge} * {\b addIntraIndirectVFEdge} (NodeID srcId, NodeID dstId, const PointsTo &cpts){\bkmkstart AAAAAAACVR}
{\bkmkend AAAAAAACVR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add indirect def-use edges of a memory region between two statements,. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFGEdge} * {\b addCallIndirectVFEdge} (NodeID srcId, NodeID dstId, const PointsTo &cpts, CallSiteID csId){\bkmkstart AAAAAAACVS}
{\bkmkend AAAAAAACVS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFGEdge} * {\b addRetIndirectVFEdge} (NodeID srcId, NodeID dstId, const PointsTo &cpts, CallSiteID csId){\bkmkstart AAAAAAACVT}
{\bkmkend AAAAAAACVT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SVFGEdge} * {\b addThreadMHPIndirectVFEdge} (NodeID srcId, NodeID dstId, const PointsTo &cpts)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFGEdge} * {\b addInterIndirectVFCallEdge} (const {\b ActualINSVFGNode} *src, const {\b FormalINSVFGNode} *dst, CallSiteID csId){\bkmkstart AAAAAAACVU}
{\bkmkend AAAAAAACVU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add inter VF edge from callsite mu to function entry chi. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SVFGEdge} * {\b addInterIndirectVFRetEdge} (const {\b FormalOUTSVFGNode} *src, const {\b ActualOUTSVFGNode} *dst, CallSiteID csId)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add inter VF edge from function exit mu to callsite chi. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b connectAInAndFIn} (const {\b ActualINSVFGNode} *actualIn, const {\b FormalINSVFGNode} *formalIn, CallSiteID csId, SVFGEdgeSetTy &edges)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect {\b SVFG} nodes between caller and callee for indirect call site. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b connectFOutAndAOut} (const {\b FormalOUTSVFGNode} *formalOut, const {\b ActualOUTSVFGNode} *actualOut, CallSiteID csId, SVFGEdgeSetTy &edges){\bkmkstart AAAAAAACVV}
{\bkmkend AAAAAAACVV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect formal-out and actual-out. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b getInterVFEdgeAtIndCSFromAPToFP} (const {\b PAGNode} *cs_arg, const {\b PAGNode} *fun_arg, const {\b CallBlockNode} *, CallSiteID csId, SVFGEdgeSetTy &edges){\bkmkstart AAAAAAACVW}
{\bkmkend AAAAAAACVW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get inter value flow edges between indirect call site and callee. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b getInterVFEdgeAtIndCSFromFRToAR} (const {\b PAGNode} *fun_ret, const {\b PAGNode} *cs_ret, CallSiteID csId, SVFGEdgeSetTy &edges){\bkmkstart AAAAAAACVX}
{\bkmkend AAAAAAACVX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b getInterVFEdgeAtIndCSFromAInToFIn} ({\b ActualINSVFGNode} *actualIn, const {\b SVFFunction} *callee, SVFGEdgeSetTy &edges){\bkmkstart AAAAAAACVY}
{\bkmkend AAAAAAACVY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b getInterVFEdgeAtIndCSFromFOutToAOut} ({\b ActualOUTSVFGNode} *actualOut, const {\b SVFFunction} *callee, SVFGEdgeSetTy &edges){\bkmkstart AAAAAAACVZ}
{\bkmkend AAAAAAACVZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setDef} (const {\b PAGNode} *pagNode, const {\b SVFGNode} *node){\bkmkstart AAAAAAACWA}
{\bkmkend AAAAAAACWA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a {\b PAGNode}, set/get its def {\b SVFG} node (definition of top level pointers) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getDef} (const {\b PAGNode} *pagNode) const{\bkmkstart AAAAAAACWB}
{\bkmkend AAAAAAACWB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasDef} (const {\b PAGNode} *pagNode) const{\bkmkstart AAAAAAACWC}
{\bkmkend AAAAAAACWC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setDef} (const {\b MRVer} *mvar, const {\b SVFGNode} *node){\bkmkstart AAAAAAACWD}
{\bkmkend AAAAAAACWD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a MSSADef, set/get its def {\b SVFG} node (definition of address-taken variables) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getDef} (const {\b MRVer} *mvar) const{\bkmkstart AAAAAAACWE}
{\bkmkend AAAAAAACWE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addSVFGNodesForAddrTakenVars} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create {\b SVFG} nodes for address-taken variables. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b connectIndirectSVFGEdges} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect direct {\b SVFG} edges between two {\b SVFG} nodes (value-flow of top address-taken variables) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b connectFromGlobalToProgEntry} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect indirect {\b SVFG} edges from global initializers (store) to main function entry. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b addSVFGNode} ({\b SVFGNode} *node, {\b ICFGNode} *icfgNode){\bkmkstart AAAAAAACWF}
{\bkmkend AAAAAAACWF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add {\b SVFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addFormalINSVFGNode} (const {\b MemSSA::ENTRYCHI} *chi){\bkmkstart AAAAAAACWG}
{\bkmkend AAAAAAACWG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add memory Function entry chi {\b SVFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addFormalOUTSVFGNode} (const {\b MemSSA::RETMU} *mu){\bkmkstart AAAAAAACWH}
{\bkmkend AAAAAAACWH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add memory Function return mu {\b SVFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addActualINSVFGNode} (const {\b MemSSA::CALLMU} *mu){\bkmkstart AAAAAAACWI}
{\bkmkend AAAAAAACWI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add memory callsite mu {\b SVFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addActualOUTSVFGNode} (const {\b MemSSA::CALLCHI} *chi){\bkmkstart AAAAAAACWJ}
{\bkmkend AAAAAAACWJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add memory callsite chi {\b SVFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addIntraMSSAPHISVFGNode} (const {\b MemSSA::PHI} *phi){\bkmkstart AAAAAAACWK}
{\bkmkend AAAAAAACWK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add memory SSA PHI {\b SVFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasFuncEntryChi} (const {\b SVFFunction} *func) const{\bkmkstart AAAAAAACWL}
{\bkmkend AAAAAAACWL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has function for EntryCHI/RetMU/CallCHI/CallMU. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasFuncRetMu} (const {\b SVFFunction} *func) const{\bkmkstart AAAAAAACWM}
{\bkmkend AAAAAAACWM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasCallSiteChi} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAACWN}
{\bkmkend AAAAAAACWN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasCallSiteMu} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAACWO}
{\bkmkend AAAAAAACWO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

MSSAVarToDefMapTy {\b MSSAVarToDefMap}{\bkmkstart AAAAAAACWP}
{\bkmkend AAAAAAACWP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a memory SSA operator to its definition {\b SVFG} node }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteToActualINsMapTy {\b callSiteToActualINMap}{\bkmkstart AAAAAAACWQ}
{\bkmkend AAAAAAACWQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteToActualOUTsMapTy {\b callSiteToActualOUTMap}{\bkmkstart AAAAAAACWR}
{\bkmkend AAAAAAACWR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FunctionToFormalINsMapTy {\b funToFormalINMap}{\bkmkstart AAAAAAACWS}
{\bkmkend AAAAAAACWS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FunctionToFormalOUTsMapTy {\b funToFormalOUTMap}{\bkmkstart AAAAAAACWT}
{\bkmkend AAAAAAACWT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFGStat} * {\b stat}{\bkmkstart AAAAAAACWU}
{\bkmkend AAAAAAACWU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MemSSA} * {\b mssa}{\bkmkstart AAAAAAACWV}
{\bkmkend AAAAAAACWV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PointerAnalysis} * {\b pta}{\bkmkstart AAAAAAACWW}
{\bkmkend AAAAAAACWW}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b SVFGBuilder}{\bkmkstart AAAAAAACWX}
{\bkmkend AAAAAAACWX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b SaberSVFGBuilder}{\bkmkstart AAAAAAACWY}
{\bkmkend AAAAAAACWY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b TaintSVFGBuilder}{\bkmkstart AAAAAAACWZ}
{\bkmkend AAAAAAACWZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b DDASVFGBuilder}{\bkmkstart AAAAAAACXA}
{\bkmkend AAAAAAACXA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b MTASVFGBuilder}{\bkmkstart AAAAAAACXB}
{\bkmkend AAAAAAACXB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b RcSvfgBuilder}{\bkmkstart AAAAAAACXC}
{\bkmkend AAAAAAACXC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sparse value flow graph Each node stands for a definition, each edge stands for value flow relations \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SVFG\:SVF::SVFG}
{\xe \v SVF::SVFG\:SVFG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SVFG::SVFG ({\b MemSSA} *  {\i _mssa}, {\b VFGK}  {\i k}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACXD}
{\bkmkend AAAAAAACXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addInterIndirectVFRetEdge\:SVF::SVFG}
{\xe \v SVF::SVFG\:addInterIndirectVFRetEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SVFGEdge} * SVFG::addInterIndirectVFRetEdge (const {\b FormalOUTSVFGNode} *  {\i src}, const {\b ActualOUTSVFGNode} *  {\i dst}, CallSiteID  {\i csId}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACXE}
{\bkmkend AAAAAAACXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add inter VF edge from function exit mu to callsite chi. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add inter VF edge from function exit mu to callsite chi \par
}}
{\xe \v addSVFGNodesForAddrTakenVars\:SVF::SVFG}
{\xe \v SVF::SVFG\:addSVFGNodesForAddrTakenVars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVFG::addSVFGNodesForAddrTakenVars (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACXF}
{\bkmkend AAAAAAACXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create {\b SVFG} nodes for address-taken variables. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set defs for address-taken vars defined at phi/chi/call create corresponding def and use nodes for address-taken vars (a.k.a MRVers) initialize memory SSA phi nodes (phi of address-taken variables)\par
initialize memory SSA entry chi nodes\par
initialize memory SSA return mu nodes\par
initialize memory SSA callsite mu nodes\par
initialize memory SSA callsite chi nodes\par
}}
{\xe \v addThreadMHPIndirectVFEdge\:SVF::SVFG}
{\xe \v SVF::SVFG\:addThreadMHPIndirectVFEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SVFGEdge} * SVFG::addThreadMHPIndirectVFEdge (NodeID  {\i srcId}, NodeID  {\i dstId}, const PointsTo &  {\i cpts}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACXG}
{\bkmkend AAAAAAACXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add def-use edges of a memory region between two may-happen-in-parallel statements for multithreaded program \par
}}
{\xe \v buildSVFG\:SVF::SVFG}
{\xe \v SVF::SVFG\:buildSVFG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVFG::buildSVFG (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACXH}
{\bkmkend AAAAAAACXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start building {\b SVFG}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build {\b SVFG} 1) build {\b SVFG} nodes a) statements for top level pointers (PAGEdges) b) operators of address-taken variables ({\b MSSAPHI} and {\b MSSACHI}) 2) connect {\b SVFG} edges a) between two statements (PAGEdges) b) between two memory SSA operators ({\b MSSAPHI} {\b MSSAMU} and {\b MSSACHI}) \par
}{
Reimplemented in {\b SVF::SVFGOPT} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACXI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v connectAInAndFIn\:SVF::SVFG}
{\xe \v SVF::SVFG\:connectAInAndFIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void SVF::SVFG::connectAInAndFIn (const {\b ActualINSVFGNode} *  {\i actualIn}, const {\b FormalINSVFGNode} *  {\i formalIn}, CallSiteID  {\i csId}, SVFGEdgeSetTy &  {\i edges}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACXJ}
{\bkmkend AAAAAAACXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect {\b SVFG} nodes between caller and callee for indirect call site. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect actual-in and formal-in \par
}{
Reimplemented in {\b SVF::SVFGOPT} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACXK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v connectCallerAndCallee\:SVF::SVFG}
{\xe \v SVF::SVFG\:connectCallerAndCallee}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVFG::connectCallerAndCallee (const {\b CallBlockNode} *  {\i cs}, const {\b SVFFunction} *  {\i callee}, SVFGEdgeSetTy &  {\i edges}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACXL}
{\bkmkend AAAAAAACXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect {\b SVFG} nodes between caller and callee for indirect call site. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect actual params/return to formal params/return for top-level variables. Also connect indirect actual in/out and formal in/out. \par
}{
Reimplemented from {\b SVF::VFG} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACXM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v connectFromGlobalToProgEntry\:SVF::SVFG}
{\xe \v SVF::SVFG\:connectFromGlobalToProgEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVFG::connectFromGlobalToProgEntry (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACXN}
{\bkmkend AAAAAAACXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect indirect {\b SVFG} edges from global initializers (store) to main function entry. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect indirect {\b SVFG} edges from global initializers (store) to main function entry \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
connect this store to main function entry\par
add indirect value flow edge\par
}}
{\xe \v connectIndirectSVFGEdges\:SVF::SVFG}
{\xe \v SVF::SVFG\:connectIndirectSVFGEdges}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVFG::connectIndirectSVFGEdges (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACXO}
{\bkmkend AAAAAAACXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect direct {\b SVFG} edges between two {\b SVFG} nodes (value-flow of top address-taken variables) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
There's no need to connect actual out node to its definition site in the same function.\par
}}
{\xe \v destroy\:SVF::SVFG}
{\xe \v SVF::SVFG\:destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVFG::destroy (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACXP}
{\bkmkend AAAAAAACXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory has been cleaned up at {\b GenericGraph} \par
}}
{\xe \v dump\:SVF::SVFG}
{\xe \v SVF::SVFG\:dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVFG::dump (const std::string &  {\i file}, bool  {\i simple} = {\f2 false})}}
\par
{\bkmkstart AAAAAAACXQ}
{\bkmkend AAAAAAACXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump graph into dot file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump {\b SVFG} \par
}}
{\xe \v getInterVFEdgesForIndirectCallSite\:SVF::SVFG}
{\xe \v SVF::SVFG\:getInterVFEdgesForIndirectCallSite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVFG::getInterVFEdgesForIndirectCallSite (const {\b CallBlockNode} *  {\i callBlockNode}, const {\b SVFFunction} *  {\i callee}, SVFGEdgeSetTy &  {\i edges})}}
\par
{\bkmkstart AAAAAAACXR}
{\bkmkend AAAAAAACXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all inter value flow edges of a indirect call site. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all inter value flow edges at this indirect call site, including call and return edges. \par
}}
{\xe \v isCallSiteRetSVFGNode\:SVF::SVFG}
{\xe \v SVF::SVFG\:isCallSiteRetSVFGNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CallBlockNode} * SVFG::isCallSiteRetSVFGNode (const {\b SVFGNode} *  {\i node}) const}}
\par
{\bkmkstart AAAAAAACXS}
{\bkmkend AAAAAAACXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a node is callsite return SVFGNode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this is an callsite return SVFGNode (actual return, actual out) \par
}}
{\xe \v isFunEntrySVFGNode\:SVF::SVFG}
{\xe \v SVF::SVFG\:isFunEntrySVFGNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SVFFunction} * SVFG::isFunEntrySVFGNode (const {\b SVFGNode} *  {\i node}) const}}
\par
{\bkmkstart AAAAAAACXT}
{\bkmkend AAAAAAACXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a node is function entry SVFGNode. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this is an function entry SVFGNode (formal parameter, formal In) \par
}}
{\xe \v performStat\:SVF::SVFG}
{\xe \v SVF::SVFG\:performStat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVFG::performStat ()}}
\par
{\bkmkstart AAAAAAACXU}
{\bkmkend AAAAAAACXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform statistics. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Perform Statistics \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFG.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFGBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFGBuilder}
{\xe \v SVF::SVFGBuilder}
{\bkmkstart AAAAAAAFJP}
{\bkmkend AAAAAAAFJP}
\par
{
{\f2 #include <SVFGBuilder.h>}}\par
Inheritance diagram for SVF::SVFGBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_s_v_f_g_builder.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PointerAnalysis::CallSiteSet {\b CallSiteSet}{\bkmkstart AAAAAAAFJQ}
{\bkmkend AAAAAAAFJQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PointerAnalysis::CallEdgeMap {\b CallEdgeMap}{\bkmkstart AAAAAAAFJR}
{\bkmkend AAAAAAAFJR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PointerAnalysis::FunctionSet {\b FunctionSet}{\bkmkstart AAAAAAAFJS}
{\bkmkend AAAAAAAFJS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef SVFG::SVFGEdgeSetTy {\b SVFGEdgeSet}{\bkmkstart AAAAAAAFJT}
{\bkmkend AAAAAAAFJT}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFGBuilder} (bool _SVFGWithIndCall=false){\bkmkstart AAAAAAAFJU}
{\bkmkend AAAAAAAFJU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~SVFGBuilder} (){\bkmkstart AAAAAAAFJV}
{\bkmkend AAAAAAAFJV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFG} * {\b buildPTROnlySVFG} ({\b BVDataPTAImpl} *pta){\bkmkstart AAAAAAAFJW}
{\bkmkend AAAAAAAFJW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFG} * {\b buildPTROnlySVFGWithoutOPT} ({\b BVDataPTAImpl} *pta){\bkmkstart AAAAAAAFJX}
{\bkmkend AAAAAAAFJX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFG} * {\b buildFullSVFG} ({\b BVDataPTAImpl} *pta){\bkmkstart AAAAAAAFJY}
{\bkmkend AAAAAAAFJY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFG} * {\b buildFullSVFGWithoutOPT} ({\b BVDataPTAImpl} *pta){\bkmkstart AAAAAAAFJZ}
{\bkmkend AAAAAAAFJZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFG} * {\b getSVFG} () const{\bkmkstart AAAAAAAFKA}
{\bkmkend AAAAAAAFKA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b SVFG} instance. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b markValidVFEdge} (SVFGEdgeSet &edges){\bkmkstart AAAAAAAFKB}
{\bkmkend AAAAAAAFKB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mark feasible VF edge by removing it from set vfEdgesAtIndCallSite. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isSpuriousVFEdgeAtIndCallSite} (const {\b SVFGEdge} *edge){\bkmkstart AAAAAAAFKC}
{\bkmkend AAAAAAAFKC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if this is an VF Edge pre-connected by {\b Andersen}'s analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b MemSSA} * {\b buildMSSA} ({\b BVDataPTAImpl} *pta, bool ptrOnlyMSSA){\bkmkstart AAAAAAAFKD}
{\bkmkend AAAAAAAFKD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build Memory SSA. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b releaseSVFG} (){\bkmkstart AAAAAAAFKE}
{\bkmkend AAAAAAAFKE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b SVFG} * {\b globalSvfg} = NULL{\bkmkstart AAAAAAAFKF}
{\bkmkend AAAAAAAFKF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SVFG} * {\b build} ({\b BVDataPTAImpl} *pta, {\b VFG::VFGK} kind)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a DDA {\b SVFG}. By default actualOut and FormalIN are removed, unless withAOFI is set true. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b buildSVFG} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Can be rewritten by subclasses. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b releaseMemory} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Release global {\b SVFG}. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SVFGEdgeSet {\b vfEdgesAtIndCallSite}{\bkmkstart AAAAAAAFKG}
{\bkmkend AAAAAAAFKG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SVFG} Edges connected at indirect call/ret sites. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFG} * {\b svfg}{\bkmkstart AAAAAAAFKH}
{\bkmkend AAAAAAAFKH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b SVFGWithIndCall}{\bkmkstart AAAAAAAFKI}
{\bkmkend AAAAAAAFKI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SVFG} with precomputed indirect call edges. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SVFG} Builder \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v build\:SVF::SVFGBuilder}
{\xe \v SVF::SVFGBuilder\:build}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SVFG} * SVFGBuilder::build ({\b BVDataPTAImpl} *  {\i pta}, {\b VFG::VFGK}  {\i kind}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAFKJ}
{\bkmkend AAAAAAAFKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a DDA {\b SVFG}. By default actualOut and FormalIN are removed, unless withAOFI is set true. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create DDA {\b SVFG}. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Note that we use callgraph from andersen analysis here\par
Update call graph using pre-analysis results\par
}}
{\xe \v buildSVFG\:SVF::SVFGBuilder}
{\xe \v SVF::SVFGBuilder\:buildSVFG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVFGBuilder::buildSVFG (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFKK}
{\bkmkend AAAAAAAFKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Can be rewritten by subclasses. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create {\b SVFG} \par
}{
Reimplemented in {\b SVF::SaberSVFGBuilder} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFKL \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::MTASVFGBuilder} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAFKM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v releaseMemory\:SVF::SVFGBuilder}
{\xe \v SVF::SVFGBuilder\:releaseMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVFGBuilder::releaseMemory (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAFKN}
{\bkmkend AAAAAAAFKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Release global {\b SVFG}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Release memory \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MSSA/SVFGBuilder.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MSSA/SVFGBuilder.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFGlobal Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFGlobal}
{\xe \v SVF::SVFGlobal}
{\bkmkstart AAAAAAAGTH}
{\bkmkend AAAAAAAGTH}
Inheritance diagram for SVF::SVFGlobal:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_s_v_f_global.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFGlobal} (const std::string &val){\bkmkstart AAAAAAAGTI}
{\bkmkend AAAAAAAGTI}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/BasicTypes.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFGOPT Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFGOPT}
{\xe \v SVF::SVFGOPT}
{\bkmkstart AAAAAAADCH}
{\bkmkend AAAAAAADCH}
\par
{
{\f2 #include <SVFGOPT.h>}}\par
Inheritance diagram for SVF::SVFGOPT:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_s_v_f_g_o_p_t.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFGOPT} ({\b MemSSA} *_mssa, {\b VFGK} kind){\bkmkstart AAAAAAADCI}
{\bkmkend AAAAAAADCI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~SVFGOPT} (){\bkmkstart AAAAAAADCJ}
{\bkmkend AAAAAAADCJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setTokeepActualOutFormalIn} (){\bkmkstart AAAAAAADCK}
{\bkmkend AAAAAAADCK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setTokeepAllSelfCycle} (){\bkmkstart AAAAAAADCL}
{\bkmkend AAAAAAADCL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setTokeepContextSelfCycle} (){\bkmkstart AAAAAAADCM}
{\bkmkend AAAAAAADCM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b buildSVFG} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start building {\b SVFG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b connectAParamAndFParam} (const {\b PAGNode} *cs_arg, const {\b PAGNode} *fun_arg, const {\b CallBlockNode} *, CallSiteID csId, SVFGEdgeSetTy &edges){\bkmkstart AAAAAAADCN}
{\bkmkend AAAAAAADCN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect {\b SVFG} nodes between caller and callee for indirect call sites. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b connectFRetAndARet} (const {\b PAGNode} *fun_ret, const {\b PAGNode} *cs_ret, CallSiteID csId, SVFGEdgeSetTy &edges){\bkmkstart AAAAAAADCO}
{\bkmkend AAAAAAADCO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect formal-ret and actual ret. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b connectAInAndFIn} (const {\b ActualINSVFGNode} *actualIn, const {\b FormalINSVFGNode} *formalIn, CallSiteID csId, SVFGEdgeSetTy &edges){\bkmkstart AAAAAAACXK}
{\bkmkend AAAAAAACXK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect actual-in and formal-in. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b connectFOutAndAOut} (const {\b FormalOUTSVFGNode} *formalOut, const {\b ActualOUTSVFGNode} *actualOut, CallSiteID csId, SVFGEdgeSetTy &edges){\bkmkstart AAAAAAADCP}
{\bkmkend AAAAAAADCP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect formal-out and actual-out. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getActualINDef} (NodeID ai) const{\bkmkstart AAAAAAADCQ}
{\bkmkend AAAAAAADCQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get def-site of actual-in/formal-out. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getFormalOUTDef} (NodeID fo) const{\bkmkstart AAAAAAADCR}
{\bkmkend AAAAAAADCR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optimised {\b SVFG}.{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab FormalParam/ActualRet is converted into Phi. ActualParam/FormalRet becomes the operands of Phi nodes created at callee/caller's entry/callsite.\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab ActualIns/ActualOuts resides at direct call sites id removed. Sources of its incoming edges are connected with the destinations of its outgoing edges directly.\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab FormalIns/FormalOuts reside at the entry/exit of non-address-taken functions is removed as ActualIn/ActualOuts.\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
4.\tab {\b MSSAPHI} nodes are removed if it have no self cycle. Otherwise depends on user option. \par}
\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v buildSVFG\:SVF::SVFGOPT}
{\xe \v SVF::SVFGOPT\:buildSVFG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVFGOPT::buildSVFG (){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACXI}
{\bkmkend AAAAAAACXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start building {\b SVFG}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build {\b SVFG} 1) build {\b SVFG} nodes a) statements for top level pointers (PAGEdges) b) operators of address-taken variables ({\b MSSAPHI} and {\b MSSACHI}) 2) connect {\b SVFG} edges a) between two statements (PAGEdges) b) between two memory SSA operators ({\b MSSAPHI} {\b MSSAMU} and {\b MSSACHI}) \par
}{
Reimplemented from {\b SVF::SVFG} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACXH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFGOPT.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFGOPT.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFGStat Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFGStat}
{\xe \v SVF::SVFGStat}
{\bkmkstart AAAAAAADDS}
{\bkmkend AAAAAAADDS}
Inheritance diagram for SVF::SVFGStat:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_s_v_f_g_stat.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b SVFGNode} * > {\b SVFGNodeSet}{\bkmkstart AAAAAAADDT}
{\bkmkend AAAAAAADDT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedSet< const {\b SVFGEdge} * > {\b SVFGEdgeSet}{\bkmkstart AAAAAAADDU}
{\bkmkend AAAAAAADDU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SCCDetection}< {\b SVFG} * > {\b SVFGSCC}{\bkmkstart AAAAAAADDV}
{\bkmkend AAAAAAADDV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SVFGStat} ({\b SVFG} *g)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b performStat} (){\bkmkstart AAAAAAADDW}
{\bkmkend AAAAAAADDW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b printStat} (){\bkmkstart AAAAAAADDX}
{\bkmkend AAAAAAADDX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b performSCCStat} (SVFGEdgeSet insensitiveCalRetEdges){\bkmkstart AAAAAAADDY}
{\bkmkend AAAAAAADDY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dirVFEdgeStart} (){\bkmkstart AAAAAAADDZ}
{\bkmkend AAAAAAADDZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dirVFEdgeEnd} (){\bkmkstart AAAAAAADEA}
{\bkmkend AAAAAAADEA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b indVFEdgeStart} (){\bkmkstart AAAAAAADEB}
{\bkmkend AAAAAAADEB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b indVFEdgeEnd} (){\bkmkstart AAAAAAADEC}
{\bkmkend AAAAAAADEC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b TLVFNodeStart} (){\bkmkstart AAAAAAADED}
{\bkmkend AAAAAAADED}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b TLVFNodeEnd} (){\bkmkstart AAAAAAADEE}
{\bkmkend AAAAAAADEE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b ATVFNodeStart} (){\bkmkstart AAAAAAADEF}
{\bkmkend AAAAAAADEF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b ATVFNodeEnd} (){\bkmkstart AAAAAAADEG}
{\bkmkend AAAAAAADEG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b sfvgOptStart} (){\bkmkstart AAAAAAADEH}
{\bkmkend AAAAAAADEH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b sfvgOptEnd} (){\bkmkstart AAAAAAADEI}
{\bkmkend AAAAAAADEI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addToSources} (const {\b SVFGNode} *node){\bkmkstart AAAAAAADEJ}
{\bkmkend AAAAAAADEJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addToSinks} (const {\b SVFGNode} *node){\bkmkstart AAAAAAADEK}
{\bkmkend AAAAAAADEK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addToForwardSlice} (const {\b SVFGNode} *node){\bkmkstart AAAAAAADEL}
{\bkmkend AAAAAAADEL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addToBackwardSlice} (const {\b SVFGNode} *node){\bkmkstart AAAAAAADEM}
{\bkmkend AAAAAAADEM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b inForwardSlice} (const {\b SVFGNode} *node) const{\bkmkstart AAAAAAADEN}
{\bkmkend AAAAAAADEN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b inBackwardSlice} (const {\b SVFGNode} *node) const{\bkmkstart AAAAAAADEO}
{\bkmkend AAAAAAADEO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isSource} (const {\b SVFGNode} *node) const{\bkmkstart AAAAAAADEP}
{\bkmkend AAAAAAADEP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isSink} (const {\b SVFGNode} *node) const{\bkmkstart AAAAAAADEQ}
{\bkmkend AAAAAAADEQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SVFGStat\:SVF::SVFGStat}
{\xe \v SVF::SVFGStat\:SVFGStat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SVFGStat::SVFGStat ({\b SVFG} *  {\i g})}}
\par
{\bkmkstart AAAAAAADER}
{\bkmkend AAAAAAADER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFGStat.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFGStat.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFInstruction Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFInstruction}
{\xe \v SVF::SVFInstruction}
{\bkmkstart AAAAAAAGTL}
{\bkmkend AAAAAAAGTL}
Inheritance diagram for SVF::SVFInstruction:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_s_v_f_instruction.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFInstruction} (const std::string &val){\bkmkstart AAAAAAAGTM}
{\bkmkend AAAAAAAGTM}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/BasicTypes.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFModule Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFModule}
{\xe \v SVF::SVFModule}
{\bkmkstart AAAAAAAHGU}
{\bkmkend AAAAAAAHGU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const {\b SVFFunction} * > {\b FunctionSetType}{\bkmkstart AAAAAAAHGV}
{\bkmkend AAAAAAAHGV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< Function * > {\b LLVMFunctionSetType}{\bkmkstart AAAAAAAHGW}
{\bkmkend AAAAAAAHGW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< GlobalVariable * > {\b GlobalSetType}{\bkmkstart AAAAAAAHGX}
{\bkmkend AAAAAAAHGX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< GlobalAlias * > {\b AliasSetType}{\bkmkstart AAAAAAAHGY}
{\bkmkend AAAAAAAHGY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Function *, const {\b SVFFunction} * > {\b LLVMFun2SVFFunMap}{\bkmkstart AAAAAAAHGZ}
{\bkmkend AAAAAAAHGZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef FunctionSetType::iterator {\b iterator}{\bkmkstart AAAAAAAHHA}
{\bkmkend AAAAAAAHHA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterators type def. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef FunctionSetType::const_iterator {\b const_iterator}{\bkmkstart AAAAAAAHHB}
{\bkmkend AAAAAAAHHB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef LLVMFunctionSetType::iterator {\b llvm_iterator}{\bkmkstart AAAAAAAHHC}
{\bkmkend AAAAAAAHHC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef LLVMFunctionSetType::const_iterator {\b llvm_const_iterator}{\bkmkstart AAAAAAAHHD}
{\bkmkend AAAAAAAHHD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef GlobalSetType::iterator {\b global_iterator}{\bkmkstart AAAAAAAHHE}
{\bkmkend AAAAAAAHHE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef GlobalSetType::const_iterator {\b const_global_iterator}{\bkmkstart AAAAAAAHHF}
{\bkmkend AAAAAAAHHF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef AliasSetType::iterator {\b alias_iterator}{\bkmkstart AAAAAAAHHG}
{\bkmkend AAAAAAAHHG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef AliasSetType::const_iterator {\b const_alias_iterator}{\bkmkstart AAAAAAAHHH}
{\bkmkend AAAAAAAHHH}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFModule} (std::string moduleName=""){\bkmkstart AAAAAAAHHI}
{\bkmkend AAAAAAAHHI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructors. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getSVFFunction} (const Function *fun) const{\bkmkstart AAAAAAAHHJ}
{\bkmkend AAAAAAAHHJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::string & {\b getModuleIdentifier} () const{\bkmkstart AAAAAAAHHK}
{\bkmkend AAAAAAAHHK}
\par
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \par
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addFunctionSet} (Function *fun){\bkmkstart AAAAAAAHHL}
{\bkmkend AAAAAAAHHL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addGlobalSet} (GlobalVariable *glob){\bkmkstart AAAAAAAHHM}
{\bkmkend AAAAAAAHHM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addAliasSet} (GlobalAlias *alias){\bkmkstart AAAAAAAHHN}
{\bkmkend AAAAAAAHHN}
\par
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \par
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
llvm_iterator {\b llvmFunBegin} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

llvm_const_iterator {\b llvmFunBegin} () const{\bkmkstart AAAAAAAHHO}
{\bkmkend AAAAAAAHHO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

llvm_iterator {\b llvmFunEnd} (){\bkmkstart AAAAAAAHHP}
{\bkmkend AAAAAAAHHP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

llvm_const_iterator {\b llvmFunEnd} () const{\bkmkstart AAAAAAAHHQ}
{\bkmkend AAAAAAAHHQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b iterator} {\b begin} (){\bkmkstart AAAAAAAHHR}
{\bkmkend AAAAAAAHHR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b begin} () const{\bkmkstart AAAAAAAHHS}
{\bkmkend AAAAAAAHHS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b iterator} {\b end} (){\bkmkstart AAAAAAAHHT}
{\bkmkend AAAAAAAHHT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b end} () const{\bkmkstart AAAAAAAHHU}
{\bkmkend AAAAAAAHHU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

global_iterator {\b global_begin} (){\bkmkstart AAAAAAAHHV}
{\bkmkend AAAAAAAHHV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_global_iterator {\b global_begin} () const{\bkmkstart AAAAAAAHHW}
{\bkmkend AAAAAAAHHW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

global_iterator {\b global_end} (){\bkmkstart AAAAAAAHHX}
{\bkmkend AAAAAAAHHX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_global_iterator {\b global_end} () const{\bkmkstart AAAAAAAHHY}
{\bkmkend AAAAAAAHHY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

alias_iterator {\b alias_begin} (){\bkmkstart AAAAAAAHHZ}
{\bkmkend AAAAAAAHHZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_alias_iterator {\b alias_begin} () const{\bkmkstart AAAAAAAHIA}
{\bkmkend AAAAAAAHIA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

alias_iterator {\b alias_end} (){\bkmkstart AAAAAAAHIB}
{\bkmkend AAAAAAAHIB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_alias_iterator {\b alias_end} () const{\bkmkstart AAAAAAAHIC}
{\bkmkend AAAAAAAHIC}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b setPagFromTXT} (std::string txt){\bkmkstart AAAAAAAHID}
{\bkmkend AAAAAAAHID}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static std::string {\b pagFileName} (){\bkmkstart AAAAAAAHIE}
{\bkmkend AAAAAAAHIE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b pagReadFromTXT} (){\bkmkstart AAAAAAAHIF}
{\bkmkend AAAAAAAHIF}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v llvmFunBegin\:SVF::SVFModule}
{\xe \v SVF::SVFModule\:llvmFunBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
llvm_iterator SVF::SVFModule::llvmFunBegin (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHIG}
{\bkmkend AAAAAAAHIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterators \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/SVFModule.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/LLVMModule.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SVFValue Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SVFValue}
{\xe \v SVF::SVFValue}
{\bkmkstart AAAAAAAHGI}
{\bkmkend AAAAAAAHGI}
Inheritance diagram for SVF::SVFValue:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_s_v_f_value.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b SVFValKind} \{ {\b SVFVal}
, {\b SVFFunc}
, {\b SVFGlob}
, {\b SVFBB}
, {\b SVFInst}
 \}{\bkmkstart AAAAAAAHGJ}
{\bkmkend AAAAAAAHGJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef s32_t {\b GNodeK}{\bkmkstart AAAAAAAHGK}
{\bkmkend AAAAAAAHGK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFValue} (const std::string &val, SVFValKind k){\bkmkstart AAAAAAAHGL}
{\bkmkend AAAAAAAHGL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

GNodeK {\b getKind} () const{\bkmkstart AAAAAAAHGM}
{\bkmkend AAAAAAAHGM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the type of this {\b SVFValue}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator()} (const {\b SVFValue} *lhs, const {\b SVFValue} *rhs) const{\bkmkstart AAAAAAAHGN}
{\bkmkend AAAAAAAHGN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add the hash function for std::set (we also can overload operator< to implement this) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} ({\b SVFValue} *rhs) const{\bkmkstart AAAAAAAHGO}
{\bkmkend AAAAAAAHGO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} ({\b SVFValue} *rhs) const{\bkmkstart AAAAAAAHGP}
{\bkmkend AAAAAAAHGP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const llvm::StringRef {\b getName} () const{\bkmkstart AAAAAAAHGQ}
{\bkmkend AAAAAAAHGQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::string & {\b getValue} () const{\bkmkstart AAAAAAAHGR}
{\bkmkend AAAAAAAHGR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b SVFValue} *node){\bkmkstart AAAAAAAHGS}
{\bkmkend AAAAAAAHGS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

llvm::raw_ostream & {\b operator<<} (llvm::raw_ostream &o, const {\b SVFValue} &node){\bkmkstart AAAAAAAHGT}
{\bkmkend AAAAAAAHGT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator << for dumping {\b ICFG} node ID. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/SVFBasicTypes.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::SymbolTableInfo Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo}
{\bkmkstart AAAAAAAGOV}
{\bkmkend AAAAAAAGOV}
\par
{
{\f2 #include <SymbolTableInfo.h>}}\par
Inheritance diagram for SVF::SymbolTableInfo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_symbol_table_info.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef OrderedMap< const Value *, SymID > {\b ValueToIDMapTy}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
various maps defined }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< SymID, {\b MemObj} * > {\b IDToMemMapTy}{\bkmkstart AAAAAAAGOW}
{\bkmkend AAAAAAAGOW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sym id to memory object map }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< const Function *, SymID > {\b FunToIDMapTy}{\bkmkstart AAAAAAAGOX}
{\bkmkend AAAAAAAGOX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
function to sym id map }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< SymID, {\b SYMTYPE} > {\b IDToSymTyMapTy}{\bkmkstart AAAAAAAGOY}
{\bkmkend AAAAAAAGOY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sym id to sym type map }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< const Type *, {\b StInfo} * > {\b TypeToFieldInfoMap}{\bkmkstart AAAAAAAGOZ}
{\bkmkend AAAAAAAGOZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct type to struct info map }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< CallSite > {\b CallSiteSet}{\bkmkstart AAAAAAAGPA}
{\bkmkend AAAAAAAGPA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< const Instruction *, CallSiteID > {\b CallSiteToIDMapTy}{\bkmkstart AAAAAAAGPB}
{\bkmkend AAAAAAAGPB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< CallSiteID, const Instruction * > {\b IDToCallSiteMapTy}{\bkmkstart AAAAAAAGPC}
{\bkmkend AAAAAAAGPC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setModelConstants} (bool _modelConstants){\bkmkstart AAAAAAAGPD}
{\bkmkend AAAAAAAGPD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set / Get modelConstants. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b getModelConstants} () const{\bkmkstart AAAAAAAGPE}
{\bkmkend AAAAAAAGPE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallSiteSet & {\b getCallSiteSet} () const{\bkmkstart AAAAAAAGPF}
{\bkmkend AAAAAAAGPF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get callsite set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SVFModule} * {\b getModule} (){\bkmkstart AAAAAAAGPG}
{\bkmkend AAAAAAAGPG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Module. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getTypeSizeInBytes} (const Type *type){\bkmkstart AAAAAAAGPH}
{\bkmkend AAAAAAAGPH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper method to get the size of the type from target data layout. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32_t {\b getTypeSizeInBytes} (const {\b StructType} *sty, u32_t field_index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b buildMemModel} ({\b SVFModule} *svfModule)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start building memory model. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b collectSym} (const Value *val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
collect the syms }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b collectVal} (const Value *val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b collectObj} (const Value *val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b collectRet} (const Function *val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b collectVararg} (const Function *val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isConstantObjSym} (const Value *val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b createBlkOrConstantObj} (SymID symId){\bkmkstart AAAAAAAGPI}
{\bkmkend AAAAAAAGPI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MemObj} * {\b getBlkObj} () const{\bkmkstart AAAAAAAGPJ}
{\bkmkend AAAAAAAGPJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MemObj} * {\b getConstantObj} () const{\bkmkstart AAAAAAAGPK}
{\bkmkend AAAAAAAGPK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SymID {\b blkPtrSymID} () const{\bkmkstart AAAAAAAGPL}
{\bkmkend AAAAAAAGPL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SymID {\b nullPtrSymID} () const{\bkmkstart AAAAAAAGPM}
{\bkmkend AAAAAAAGPM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SymID {\b constantSymID} () const{\bkmkstart AAAAAAAGPN}
{\bkmkend AAAAAAAGPN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SymID {\b blackholeSymID} () const{\bkmkstart AAAAAAAGPO}
{\bkmkend AAAAAAAGPO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b MemObj} * {\b createDummyObj} (SymID symId, const Type *type){\bkmkstart AAAAAAAGPP}
{\bkmkend AAAAAAAGPP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Can only be invoked by PAG::addDummyNode() when creaing {\b PAG} from file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleGlobalCE} (const GlobalVariable *G)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle constant expression. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleGlobalInitializerCE} (const Constant *C, u32_t offset)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleCE} (const Value *val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SymID {\b getValSym} (const Value *val){\bkmkstart AAAAAAAGPQ}
{\bkmkend AAAAAAAGPQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get different kinds of syms. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasValSym} (const Value *val){\bkmkstart AAAAAAAGPR}
{\bkmkend AAAAAAAGPR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getGlobalRep} (const Value *val) const{\bkmkstart AAAAAAAGPS}
{\bkmkend AAAAAAAGPS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
find the unique defined global across multiple modules }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SymID {\b getObjSym} (const Value *val) const{\bkmkstart AAAAAAAGPT}
{\bkmkend AAAAAAAGPT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b MemObj} * {\b getObj} (SymID id) const{\bkmkstart AAAAAAAGPU}
{\bkmkend AAAAAAAGPU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SymID {\b getRetSym} (const Function *val) const{\bkmkstart AAAAAAAGPV}
{\bkmkend AAAAAAAGPV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

SymID {\b getVarargSym} (const Function *val) const{\bkmkstart AAAAAAAGPW}
{\bkmkend AAAAAAAGPW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

Size_t {\b getTotalSymNum} () const{\bkmkstart AAAAAAAGPX}
{\bkmkend AAAAAAAGPX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getMaxStructSize} () const{\bkmkstart AAAAAAAGPY}
{\bkmkend AAAAAAAGPY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ValueToIDMapTy} & {\b valSyms} (){\bkmkstart AAAAAAAGPZ}
{\bkmkend AAAAAAAGPZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get different kinds of syms maps. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ValueToIDMapTy} & {\b objSyms} (){\bkmkstart AAAAAAAGQA}
{\bkmkend AAAAAAAGQA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b IDToMemMapTy} & {\b idToObjMap} (){\bkmkstart AAAAAAAGQB}
{\bkmkend AAAAAAAGQB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FunToIDMapTy} & {\b retSyms} (){\bkmkstart AAAAAAAGQC}
{\bkmkend AAAAAAAGQC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FunToIDMapTy} & {\b varargSyms} (){\bkmkstart AAAAAAAGQD}
{\bkmkend AAAAAAAGQD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TypeToFieldInfoMap::iterator {\b getStructInfoIter} (const Type *T)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get struct info. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b StInfo} * {\b getStructInfo} (const Type *T){\bkmkstart AAAAAAAGQE}
{\bkmkend AAAAAAAGQE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a reference to StructInfo. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::vector< u32_t > & {\b getFattenFieldIdxVec} (const Type *T){\bkmkstart AAAAAAAGQF}
{\bkmkend AAAAAAAGQF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a reference to the components of struct_info. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::vector< u32_t > & {\b getFattenFieldOffsetVec} (const Type *T){\bkmkstart AAAAAAAGQG}
{\bkmkend AAAAAAAGQG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::vector< {\b FieldInfo} > & {\b getFlattenFieldInfoVec} (const Type *T){\bkmkstart AAAAAAAGQH}
{\bkmkend AAAAAAAGQH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Type * {\b getOrigSubTypeWithFldInx} (const Type *baseType, u32_t field_idx){\bkmkstart AAAAAAAGQI}
{\bkmkend AAAAAAAGQI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Type * {\b getOrigSubTypeWithByteOffset} (const Type *baseType, u32_t byteOffset){\bkmkstart AAAAAAAGQJ}
{\bkmkend AAAAAAAGQJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b computeGepOffset} (const User *V, {\b LocationSet} &ls)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute gep offset. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const Type * {\b getBaseTypeAndFlattenedFields} (const Value *V, std::vector< {\b LocationSet} > &fields)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the base type and max offset. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
u32_t {\b getFields} (std::vector< {\b LocationSet} > &fields, const Type *T, u32_t msz)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replace fields with flatten fields of T if the number of its fields is larger than msz. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b collectTypeInfo} (const Type *T)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect type info. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b LocationSet} {\b getModulusOffset} (const {\b MemObj} *obj, const {\b LocationSet} &ls)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an offset from a Gep Instruction, return it modulus offset by considering memory layout. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printFlattenFields} (const Type *type)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Debug method. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b SymbolTableInfo} * {\b SymbolInfo} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Singleton design here to make sure we only have one instance during any analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b releaseSymbolInfo} (){\bkmkstart AAAAAAAGQK}
{\bkmkend AAAAAAAGQK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b DataLayout} * {\b getDataLayout} (Module *mod){\bkmkstart AAAAAAAGQL}
{\bkmkend AAAAAAAGQL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get target machine data layout. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b isNullPtrSym} (const Value *val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
special value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b isBlackholeSym} (const Value *val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b isBlkPtr} (NodeID id){\bkmkstart AAAAAAAGQM}
{\bkmkend AAAAAAAGQM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b isNullPtr} (NodeID id){\bkmkstart AAAAAAAGQN}
{\bkmkend AAAAAAAGQN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b isBlkObj} (NodeID id){\bkmkstart AAAAAAAGQO}
{\bkmkend AAAAAAAGQO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b isConstantObj} (NodeID id){\bkmkstart AAAAAAAGQP}
{\bkmkend AAAAAAAGQP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b isBlkObjOrConstantObj} (NodeID id){\bkmkstart AAAAAAAGQQ}
{\bkmkend AAAAAAAGQQ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static SymID {\b totalSymNum} = 0{\bkmkstart AAAAAAAGQR}
{\bkmkend AAAAAAAGQR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SymbolTableInfo} (void){\bkmkstart AAAAAAAGQS}
{\bkmkend AAAAAAAGQS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b collectStructInfo} (const {\b StructType} *T)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect the struct info. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b collectArrayInfo} (const ArrayType *T)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect the array info. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b collectSimpleTypeInfo} (const Type *T)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect simple type (non-aggregate) info. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TypeToFieldInfoMap} {\b typeToFieldInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Type * {\b maxStruct}{\bkmkstart AAAAAAAGQT}
{\bkmkend AAAAAAAGQT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The struct type with the most fields. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b maxStSize}{\bkmkstart AAAAAAAGQU}
{\bkmkend AAAAAAAGQU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The number of fields in max_struct. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Symbol table of the memory model for analysis \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v ValueToIDMapTy\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:ValueToIDMapTy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef OrderedMap<const Value *, SymID> {\b SVF::SymbolTableInfo::ValueToIDMapTy}}}
\par
{\bkmkstart AAAAAAAGQV}
{\bkmkend AAAAAAAGQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
various maps defined }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
llvm value to sym id map local (%) and global (@) identifiers are pointer types which have a value node id. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v buildMemModel\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:buildMemModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SymbolTableInfo::buildMemModel ({\b SVFModule} *  {\i svfModule})}}
\par
{\bkmkstart AAAAAAAGQW}
{\bkmkend AAAAAAAGQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start building memory model. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method identify which is value sym and which is object sym \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if (SVFUtil::isa<InlineAsm>(Callee))\par
}}
{\xe \v collectArrayInfo\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:collectArrayInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SymbolTableInfo::collectArrayInfo (const ArrayType *  {\i ty}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGQX}
{\bkmkend AAAAAAAGQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect the array info. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fill in {\b StInfo} for an array type. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array itself only has one field which is the inner most element\par
Array's flatten field infor is the same as its element's flatten infor.\par
append the additional number\par
}{
Reimplemented in {\b SVF::LocSymTableInfo} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAGQY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v collectObj\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:collectObj}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SymbolTableInfo::collectObj (const Value *  {\i val})}}
\par
{\bkmkstart AAAAAAAGQZ}
{\bkmkend AAAAAAAGQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get memory object sym, if not available create a new one \par
}}
{\xe \v collectRet\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:collectRet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SymbolTableInfo::collectRet (const Function *  {\i val})}}
\par
{\bkmkstart AAAAAAAGRA}
{\bkmkend AAAAAAAGRA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create unique return sym, if not available create a new one \par
}}
{\xe \v collectSimpleTypeInfo\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:collectSimpleTypeInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SymbolTableInfo::collectSimpleTypeInfo (const Type *  {\i ty}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGRB}
{\bkmkend AAAAAAAGRB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect simple type (non-aggregate) info. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect simple type (non-aggregate) info \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only one field\par
}}
{\xe \v collectStructInfo\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:collectStructInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SymbolTableInfo::collectStructInfo (const {\b StructType} *  {\i sty}){\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGRC}
{\bkmkend AAAAAAAGRC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect the struct info. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fill in struct_info for T. Given a Struct type, we recursively extend and record its fields and types. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The struct info should not be processed before\par
FIXME: As the layout size is uint_64, here we assume offset with uint_32 (Size_t) is large enough and will not cause overflow\par
}{
Reimplemented in {\b SVF::LocSymTableInfo} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAGRD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v collectSym\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:collectSym}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SymbolTableInfo::collectSym (const Value *  {\i val})}}
\par
{\bkmkstart AAAAAAAGRE}
{\bkmkend AAAAAAAGRE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
collect the syms }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect symbols, including value and object syms \par
}}
{\xe \v collectTypeInfo\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:collectTypeInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SymbolTableInfo::collectTypeInfo (const Type *  {\i ty})}}
\par
{\bkmkstart AAAAAAAGRF}
{\bkmkend AAAAAAAGRF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect type info. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Collect a LLVM type info \par
}}
{\xe \v collectVal\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:collectVal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SymbolTableInfo::collectVal (const Value *  {\i val})}}
\par
{\bkmkstart AAAAAAAGRG}
{\bkmkend AAAAAAAGRG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get value sym, if not available create a new one \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
handle global constant expression here\par
}}
{\xe \v collectVararg\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:collectVararg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SymbolTableInfo::collectVararg (const Function *  {\i val})}}
\par
{\bkmkstart AAAAAAAGRH}
{\bkmkend AAAAAAAGRH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create vararg sym, if not available create a new one \par
}}
{\xe \v computeGepOffset\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:computeGepOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SymbolTableInfo::computeGepOffset (const User *  {\i V}, {\b LocationSet} &  {\i ls}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGRI}
{\bkmkend AAAAAAAGRI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute gep offset. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute gep offset \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
given a gep edge p = q + i,\par
}{
Reimplemented in {\b SVF::LocSymTableInfo} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAGRJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getBaseTypeAndFlattenedFields\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:getBaseTypeAndFlattenedFields}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const Type * SymbolTableInfo::getBaseTypeAndFlattenedFields (const Value *  {\i V}, std::vector< {\b LocationSet} > &  {\i fields})}}
\par
{\bkmkstart AAAAAAAGRK}
{\bkmkend AAAAAAAGRK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the base type and max offset. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find the base type and the max possible offset for an object pointed to by (V). \par
}}
{\xe \v getFields\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:getFields}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32_t SymbolTableInfo::getFields (std::vector< {\b LocationSet} > &  {\i fields}, const Type *  {\i T}, u32_t  {\i msz})}}
\par
{\bkmkstart AAAAAAAGRL}
{\bkmkend AAAAAAAGRL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replace fields with flatten fields of T if the number of its fields is larger than msz. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replace fields with flatten fields of T if the number of its fields is larger than msz. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replace fields with T's flatten fields.\par
}}
{\xe \v getModulusOffset\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:getModulusOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LocationSet} SymbolTableInfo::getModulusOffset (const {\b MemObj} *  {\i obj}, const {\b LocationSet} &  {\i ls}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAGRM}
{\bkmkend AAAAAAAGRM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an offset from a Gep Instruction, return it modulus offset by considering memory layout. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get modulus offset given the type information \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if the offset is negative, it's possible that we're looking for an obj node out of range of current struct. Make the offset positive so we can still get a node within current struct to represent this obj.\par
}{
Reimplemented in {\b SVF::LocSymTableInfo} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAGRN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getStructInfoIter\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:getStructInfoIter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TypeToFieldInfoMap::iterator SVF::SymbolTableInfo::getStructInfoIter (const Type *  {\i T}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAGRO}
{\bkmkend AAAAAAAGRO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get struct info. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get an iterator for StructInfo, designed as internal methods \par
}}
{\xe \v getTypeSizeInBytes\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:getTypeSizeInBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
u32_t SymbolTableInfo::getTypeSizeInBytes (const {\b StructType} *  {\i sty}, u32_t  {\i field_index})}}
\par
{\bkmkstart AAAAAAAGRP}
{\bkmkend AAAAAAAGRP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if this struct type does not have any element, i.e., opaque\par
}}
{\xe \v handleCE\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:handleCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SymbolTableInfo::handleCE (const Value *  {\i val})}}
\par
{\bkmkstart AAAAAAAGRQ}
{\bkmkend AAAAAAAGRQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle constant expression \par
}}
{\xe \v handleGlobalCE\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:handleGlobalCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SymbolTableInfo::handleGlobalCE (const GlobalVariable *  {\i G})}}
\par
{\bkmkstart AAAAAAAGRR}
{\bkmkend AAAAAAAGRR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle constant expression. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle global constant expression \par
}}
{\xe \v handleGlobalInitializerCE\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:handleGlobalInitializerCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SymbolTableInfo::handleGlobalInitializerCE (const Constant *  {\i C}, u32_t  {\i offset})}}
\par
{\bkmkstart AAAAAAAGRS}
{\bkmkend AAAAAAAGRS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle global variable initialization \par
}}
{\xe \v isBlackholeSym\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:isBlackholeSym}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SymbolTableInfo::isBlackholeSym (const Value *  {\i val}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAGRT}
{\bkmkend AAAAAAAGRT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check whether this value is a black hole \par
}}
{\xe \v isConstantObjSym\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:isConstantObjSym}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SymbolTableInfo::isConstantObjSym (const Value *  {\i val})}}
\par
{\bkmkstart AAAAAAAGRU}
{\bkmkend AAAAAAAGRU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check whether this value points-to a constant object \par
}}
{\xe \v isNullPtrSym\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:isNullPtrSym}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SymbolTableInfo::isNullPtrSym (const Value *  {\i val}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAGRV}
{\bkmkend AAAAAAAGRV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
special value }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check whether this value is null pointer \par
}}
{\xe \v printFlattenFields\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:printFlattenFields}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SymbolTableInfo::printFlattenFields (const Type *  {\i type})}}
\par
{\bkmkstart AAAAAAAGRW}
{\bkmkend AAAAAAAGRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Debug method. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All rest types are scalar type?\par
}}
{\xe \v SymbolInfo\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:SymbolInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SymbolTableInfo} * SymbolTableInfo::SymbolInfo (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAGRX}
{\bkmkend AAAAAAAGRX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Singleton design here to make sure we only have one instance during any analysis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the symbol table instance \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v typeToFieldInfo\:SVF::SymbolTableInfo}
{\xe \v SVF::SymbolTableInfo\:typeToFieldInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TypeToFieldInfoMap} SVF::SymbolTableInfo::typeToFieldInfo{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAGRY}
{\bkmkend AAAAAAAGRY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Every type T is mapped to {\b StInfo} which contains size (fsize) , offset(foffset) fsize[i] is the number of fields in the largest such struct, else fsize[i] = 1. fsize[0] is always the size of the expanded struct. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/SymbolTableInfo.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/SymbolTableInfo.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::TCT Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::TCT}
{\xe \v SVF::TCT}
{\bkmkstart AAAAAAAFUC}
{\bkmkend AAAAAAAFUC}
Inheritance diagram for SVF::TCT:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_t_c_t.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef TCTEdge::ThreadCreateEdgeSet {\b ThreadCreateEdgeSet}{\bkmkstart AAAAAAAFUD}
{\bkmkend AAAAAAAFUD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef ThreadCreateEdgeSet::iterator {\b TCTNodeIter}{\bkmkstart AAAAAAAFUE}
{\bkmkend AAAAAAAFUE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const Function * > {\b FunSet}{\bkmkstart AAAAAAAFUF}
{\bkmkend AAAAAAAFUF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const Instruction * > {\b InstVec}{\bkmkstart AAAAAAAFUG}
{\bkmkend AAAAAAAFUG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const Instruction * > {\b InstSet}{\bkmkstart AAAAAAAFUH}
{\bkmkend AAAAAAAFUH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b PTACallGraphNode} * > {\b PTACGNodeSet}{\bkmkstart AAAAAAAFUI}
{\bkmkend AAAAAAAFUI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CxtThread}, {\b TCTNode} * > {\b CxtThreadToNodeMap}{\bkmkstart AAAAAAAFUJ}
{\bkmkend AAAAAAAFUJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CxtThread}, CallStrCxt > {\b CxtThreadToForkCxt}{\bkmkstart AAAAAAAFUK}
{\bkmkend AAAAAAAFUK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CxtThread}, const Function * > {\b CxtThreadToFun}{\bkmkstart AAAAAAAFUL}
{\bkmkend AAAAAAAFUL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Instruction *, const Loop * > {\b InstToLoopMap}{\bkmkstart AAAAAAAFUM}
{\bkmkend AAAAAAAFUM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< {\b CxtThreadProc} > {\b CxtThreadProcVec}{\bkmkstart AAAAAAAFUN}
{\bkmkend AAAAAAAFUN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef set< {\b CxtThreadProc} > {\b CxtThreadProcSet}{\bkmkstart AAAAAAAFUO}
{\bkmkend AAAAAAAFUO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SCCDetection}< {\b PTACallGraph} * > {\b ThreadCallGraphSCC}{\bkmkstart AAAAAAAFUP}
{\bkmkend AAAAAAAFUP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b TCT} ({\b PointerAnalysis} *p){\bkmkstart AAAAAAAFUQ}
{\bkmkend AAAAAAAFUQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~TCT} (){\bkmkstart AAAAAAAFUR}
{\bkmkend AAAAAAAFUR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ThreadCallGraph} * {\b getThreadCallGraph} () const{\bkmkstart AAAAAAAFUS}
{\bkmkend AAAAAAAFUS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get TCG. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PointerAnalysis} * {\b getPTA} () const{\bkmkstart AAAAAAAFUT}
{\bkmkend AAAAAAAFUT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get PTA. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b TCTNode} * {\b getTCTNode} (NodeID id) const{\bkmkstart AAAAAAAFUU}
{\bkmkend AAAAAAAFUU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b TCT} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TCTEdge} * {\b hasGraphEdge} ({\b TCTNode} *src, {\b TCTNode} *dst, TCTEdge::CEDGEK kind) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we have aleady created this call graph edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TCTEdge} * {\b getGraphEdge} ({\b TCTNode} *src, {\b TCTNode} *dst, TCTEdge::CEDGEK kind)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get call graph edge via nodes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

ThreadCreateEdgeSet::const_iterator {\b getChildrenBegin} (const {\b TCTNode} *node) const{\bkmkstart AAAAAAAFUV}
{\bkmkend AAAAAAAFUV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get children and parent nodes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

ThreadCreateEdgeSet::const_iterator {\b getChildrenEnd} (const {\b TCTNode} *node) const{\bkmkstart AAAAAAAFUW}
{\bkmkend AAAAAAAFUW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

ThreadCreateEdgeSet::const_iterator {\b getParentsBegin} (const {\b TCTNode} *node) const{\bkmkstart AAAAAAAFUX}
{\bkmkend AAAAAAAFUX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

ThreadCreateEdgeSet::const_iterator {\b getParentsEnd} (const {\b TCTNode} *node) const{\bkmkstart AAAAAAAFUY}
{\bkmkend AAAAAAAFUY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const FunSet & {\b getMakredProcs} () const{\bkmkstart AAAAAAAFUZ}
{\bkmkend AAAAAAAFUZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get marked candidate functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const FunSet & {\b getEntryProcs} () const{\bkmkstart AAAAAAAFVA}
{\bkmkend AAAAAAAFVA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get marked candidate functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getTCTNodeNum} () const{\bkmkstart AAAAAAAFVB}
{\bkmkend AAAAAAAFVB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get Statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getTCTEdgeNum} () const{\bkmkstart AAAAAAAFVC}
{\bkmkend AAAAAAAFVC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getMaxCxtSize} () const{\bkmkstart AAAAAAAFVD}
{\bkmkend AAAAAAAFVD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasTCTNode} (const {\b CxtThread} &ct) const{\bkmkstart AAAAAAAFVE}
{\bkmkend AAAAAAAFVE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find/Get {\b TCT} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b TCTNode} * {\b getTCTNode} (const {\b CxtThread} &ct) const{\bkmkstart AAAAAAAFVF}
{\bkmkend AAAAAAAFVF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isCandidateFun} (const Function *fun) const{\bkmkstart AAAAAAAFVG}
{\bkmkend AAAAAAAFVG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether it is a candidate function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b inSameCallGraphSCC} (const {\b PTACallGraphNode} *src, const {\b PTACallGraphNode} *dst){\bkmkstart AAAAAAAFVH}
{\bkmkend AAAAAAAFVH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether two functions in the same callgraph scc. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasParentThread} (NodeID tid) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get parent and sibling threads. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getParentThread} (NodeID tid) const{\bkmkstart AAAAAAAFVI}
{\bkmkend AAAAAAAFVI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get parent thread. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const NodeBS {\b getAncestorThread} (NodeID tid) const{\bkmkstart AAAAAAAFVJ}
{\bkmkend AAAAAAAFVJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get all ancestor threads. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const NodeBS {\b getSiblingThread} (NodeID tid) const{\bkmkstart AAAAAAAFVK}
{\bkmkend AAAAAAAFVK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get sibling threads. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallStrCxt & {\b getCxtOfCxtThread} (const {\b CxtThread} &ct) const{\bkmkstart AAAAAAAFVL}
{\bkmkend AAAAAAAFVL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get the context of a thread at its spawning site (fork site) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Function * {\b getStartRoutineOfCxtThread} (const {\b CxtThread} &ct) const{\bkmkstart AAAAAAAFVM}
{\bkmkend AAAAAAAFVM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get the start routine function of a thread }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Loop * {\b getJoinLoop} (const Instruction *join){\bkmkstart AAAAAAAFVN}
{\bkmkend AAAAAAAFVN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get loop for join site. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isJoinMustExecutedInLoop} (const Loop *lp, const Instruction *join)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if a join instruction must be executed inside a loop. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const Loop * {\b getLoop} (const Instruction *inst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get loop for an instruction. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const DominatorTree * {\b getDT} (const Function *fun){\bkmkstart AAAAAAAFVO}
{\bkmkend AAAAAAAFVO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get dominator for a function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const PostDominatorTree * {\b getPostDT} (const Function *fun){\bkmkstart AAAAAAAFVP}
{\bkmkend AAAAAAAFVP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get dominator for a function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const Loop * {\b getLoop} (const BasicBlock *bb)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get loop for fork/join site. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ScalarEvolution * {\b getSE} (const Instruction *inst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get SE for function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getNextInsts} (const Instruction *inst, InstVec &instSet)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the next instructions following control flow. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pushCxt} (CallStrCxt &cxt, const Instruction *call, const Function *callee)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push calling context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b matchCxt} (CallStrCxt &cxt, const Instruction *call, const Function *callee)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Match context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b pushCxt} (CallStrCxt &cxt, CallSiteID csId){\bkmkstart AAAAAAAFVQ}
{\bkmkend AAAAAAAFVQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isJoinSiteInRecursion} (const Instruction *join) const{\bkmkstart AAAAAAAFVR}
{\bkmkend AAAAAAAFVR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a join site is in recursion. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dumpCxt} (CallStrCxt &cxt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump calling context. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump} (const std::string &filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump the graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print {\b TCT} information. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v dump\:SVF::TCT}
{\xe \v SVF::TCT\:dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TCT::dump (const std::string &  {\i filename})}}
\par
{\bkmkstart AAAAAAAFVS}
{\bkmkend AAAAAAAFVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump the graph. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump call graph into dot file \par
}}
{\xe \v dumpCxt\:SVF::TCT}
{\xe \v SVF::TCT\:dumpCxt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TCT::dumpCxt (CallStrCxt &  {\i cxt})}}
\par
{\bkmkstart AAAAAAAFVT}
{\bkmkend AAAAAAAFVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump calling context. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump calling context information \par
}}
{\xe \v getGraphEdge\:SVF::TCT}
{\xe \v SVF::TCT\:getGraphEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TCTEdge} * TCT::getGraphEdge ({\b TCTNode} *  {\i src}, {\b TCTNode} *  {\i dst}, TCTEdge::CEDGEK  {\i kind})}}
\par
{\bkmkstart AAAAAAAFVU}
{\bkmkend AAAAAAAFVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get call graph edge via nodes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get CallGraph edge via nodes \par
}}
{\xe \v getLoop\:SVF::TCT}
{\xe \v SVF::TCT\:getLoop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const Loop * TCT::getLoop (const BasicBlock *  {\i bb})}}
\par
{\bkmkstart AAAAAAAFVV}
{\bkmkend AAAAAAAFVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get loop for fork/join site. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get loop for fork/join site \par
}}
{\xe \v getLoop\:SVF::TCT}
{\xe \v SVF::TCT\:getLoop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const Loop * TCT::getLoop (const Instruction *  {\i inst})}}
\par
{\bkmkstart AAAAAAAFVW}
{\bkmkend AAAAAAAFVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get loop for an instruction. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get loop for fork/join site \par
}}
{\xe \v getNextInsts\:SVF::TCT}
{\xe \v SVF::TCT\:getNextInsts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TCT::getNextInsts (const Instruction *  {\i curInst}, InstVec &  {\i instList})}}
\par
{\bkmkstart AAAAAAAFVX}
{\bkmkend AAAAAAAFVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the next instructions following control flow. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the next instructions following control flow \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
traverse to successive statements\par
if we are sitting at the loop header, then go inside the loop but ignore loop exit\par
}}
{\xe \v getSE\:SVF::TCT}
{\xe \v SVF::TCT\:getSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ScalarEvolution * TCT::getSE (const Instruction *  {\i inst})}}
\par
{\bkmkstart AAAAAAAFVY}
{\bkmkend AAAAAAAFVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get SE for function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get SE for function \par
}}
{\xe \v hasGraphEdge\:SVF::TCT}
{\xe \v SVF::TCT\:hasGraphEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TCTEdge} * TCT::hasGraphEdge ({\b TCTNode} *  {\i src}, {\b TCTNode} *  {\i dst}, TCTEdge::CEDGEK  {\i kind}) const}}
\par
{\bkmkstart AAAAAAAFVZ}
{\bkmkend AAAAAAAFVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we have aleady created this call graph edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we have already created this call graph edge \par
}}
{\xe \v hasParentThread\:SVF::TCT}
{\xe \v SVF::TCT\:hasParentThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::TCT::hasParentThread (NodeID  {\i tid}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAFWA}
{\bkmkend AAAAAAAFWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get parent and sibling threads. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has parent thread \par
}}
{\xe \v isJoinMustExecutedInLoop\:SVF::TCT}
{\xe \v SVF::TCT\:isJoinMustExecutedInLoop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TCT::isJoinMustExecutedInLoop (const Loop *  {\i lp}, const Instruction *  {\i join})}}
\par
{\bkmkstart AAAAAAAFWB}
{\bkmkend AAAAAAAFWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if a join instruction must be executed inside a loop. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if a join instruction must be executed inside a loop joinbb should post dominate the successive basic block of a loop header \par
}}
{\xe \v matchCxt\:SVF::TCT}
{\xe \v SVF::TCT\:matchCxt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TCT::matchCxt (CallStrCxt &  {\i cxt}, const Instruction *  {\i call}, const Function *  {\i callee})}}
\par
{\bkmkstart AAAAAAAFWC}
{\bkmkend AAAAAAAFWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Match context. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Match calling context \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
handle calling context for candidate functions only\par
partial match\par
}}
{\xe \v print\:SVF::TCT}
{\xe \v SVF::TCT\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TCT::print () const}}
\par
{\bkmkstart AAAAAAAFWD}
{\bkmkend AAAAAAAFWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print {\b TCT} information. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print {\b TCT} information \par
}}
{\xe \v pushCxt\:SVF::TCT}
{\xe \v SVF::TCT\:pushCxt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TCT::pushCxt (CallStrCxt &  {\i cxt}, const Instruction *  {\i call}, const Function *  {\i callee})}}
\par
{\bkmkstart AAAAAAAFWE}
{\bkmkend AAAAAAAFWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push calling context. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push calling context \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
handle calling context for candidate functions only\par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/TCT.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/MTA/TCT.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::TCTEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::TCTEdge}
{\xe \v SVF::TCTEdge}
{\bkmkstart AAAAAAAFTM}
{\bkmkend AAAAAAAFTM}
Inheritance diagram for SVF::TCTEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_t_c_t_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b CEDGEK} \{ {\b ThreadCreateEdge}
 \}{\bkmkstart AAAAAAAFTN}
{\bkmkend AAAAAAAFTN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const Instruction * > {\b CallInstSet}{\bkmkstart AAAAAAAFTO}
{\bkmkend AAAAAAAFTO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericNode}< {\b TCTNode}, {\b TCTEdge} >::GEdgeSetTy {\b ThreadCreateEdgeSet}{\bkmkstart AAAAAAAFTP}
{\bkmkend AAAAAAAFTP}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b TCTEdge} ({\b TCTNode} *s, {\b TCTNode} *d, CEDGEK kind){\bkmkstart AAAAAAAFTQ}
{\bkmkend AAAAAAAFTQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~TCTEdge} (){\bkmkstart AAAAAAAFTR}
{\bkmkend AAAAAAAFTR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b TCTEdge} *edge){\bkmkstart AAAAAAAFTS}
{\bkmkend AAAAAAAFTS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Classof. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericTCTEdgeTy} *edge){\bkmkstart AAAAAAAFTT}
{\bkmkend AAAAAAAFTT}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/TCT.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::TCTNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::TCTNode}
{\xe \v SVF::TCTNode}
{\bkmkstart AAAAAAAFTU}
{\bkmkend AAAAAAAFTU}
Inheritance diagram for SVF::TCTNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_t_c_t_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b TCTNode} (NodeID i, const {\b CxtThread} &cctx){\bkmkstart AAAAAAAFTV}
{\bkmkend AAAAAAAFTV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dump} (){\bkmkstart AAAAAAAFTW}
{\bkmkend AAAAAAAFTW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CxtThread} & {\b getCxtThread} () const{\bkmkstart AAAAAAAFTX}
{\bkmkend AAAAAAAFTX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b CxtThread}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isInloop} () const{\bkmkstart AAAAAAAFTY}
{\bkmkend AAAAAAAFTY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inloop, incycle attributes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isIncycle} () const{\bkmkstart AAAAAAAFTZ}
{\bkmkend AAAAAAAFTZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setMultiforked} (bool value){\bkmkstart AAAAAAAFUA}
{\bkmkend AAAAAAAFUA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isMultiforked} () const{\bkmkstart AAAAAAAFUB}
{\bkmkend AAAAAAAFUB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MTA/TCT.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::TDForkPE Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::TDForkPE}
{\xe \v SVF::TDForkPE}
{\bkmkstart AAAAAAACLJ}
{\bkmkend AAAAAAACLJ}
\par
{
{\f2 #include <PAGEdge.h>}}\par
Inheritance diagram for SVF::TDForkPE:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_t_d_fork_p_e.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b TDForkPE} ({\b PAGNode} *s, {\b PAGNode} *d, const {\b CallBlockNode} *i){\bkmkstart AAAAAAACLK}
{\bkmkend AAAAAAACLK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACLL}
{\bkmkend AAAAAAACLL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b TDForkPE} *){\bkmkstart AAAAAAACLM}
{\bkmkend AAAAAAACLM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGEdge} *edge){\bkmkstart AAAAAAACLN}
{\bkmkend AAAAAAACLN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGEdgeTy} *edge){\bkmkstart AAAAAAACLO}
{\bkmkend AAAAAAACLO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Thread Fork Edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::TDJoinPE Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::TDJoinPE}
{\xe \v SVF::TDJoinPE}
{\bkmkstart AAAAAAACLP}
{\bkmkend AAAAAAACLP}
\par
{
{\f2 #include <PAGEdge.h>}}\par
Inheritance diagram for SVF::TDJoinPE:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_t_d_join_p_e.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b TDJoinPE} ({\b PAGNode} *s, {\b PAGNode} *d, const {\b CallBlockNode} *i){\bkmkstart AAAAAAACLQ}
{\bkmkend AAAAAAACLQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACLR}
{\bkmkend AAAAAAACLR}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b TDJoinPE} *){\bkmkstart AAAAAAACLS}
{\bkmkend AAAAAAACLS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGEdge} *edge){\bkmkstart AAAAAAACLT}
{\bkmkend AAAAAAACLT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGEdgeTy} *edge){\bkmkstart AAAAAAACLU}
{\bkmkend AAAAAAACLU}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Thread Join Edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ThreadAPI Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI}
{\bkmkstart AAAAAAAHIH}
{\bkmkend AAAAAAAHIH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b TD_TYPE} \{ {\b TD_DUMMY} = 0
, {\b TD_FORK}
, {\b TD_JOIN}
, {\b TD_DETACH}
, {\b TD_ACQUIRE}
, {\b TD_TRY_ACQUIRE}
, {\b TD_RELEASE}
, {\b TD_EXIT}
, {\b TD_CANCEL}
, {\b TD_COND_WAIT}
, {\b TD_COND_SIGNAL}
, {\b TD_COND_BROADCAST}
, {\b TD_MUTEX_INI}
, {\b TD_MUTEX_DESTROY}
, {\b TD_CONDVAR_INI}
, {\b TD_CONDVAR_DESTROY}
, {\b TD_BAR_INIT}
, {\b TD_BAR_WAIT}
, {\b HARE_PAR_FOR}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::StringMap< {\b TD_TYPE} > {\b TDAPIMap}{\bkmkstart AAAAAAAHII}
{\bkmkend AAAAAAAHII}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getCallee} (const Instruction *inst) const{\bkmkstart AAAAAAAHIJ}
{\bkmkend AAAAAAAHIJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the callee/callsite/func. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b SVFFunction} * {\b getCallee} (const CallSite cs) const{\bkmkstart AAAAAAAHIK}
{\bkmkend AAAAAAAHIK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const CallSite {\b getLLVMCallSite} (const Instruction *inst) const{\bkmkstart AAAAAAAHIL}
{\bkmkend AAAAAAAHIL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTDFork} (const Instruction *inst) const{\bkmkstart AAAAAAAHIM}
{\bkmkend AAAAAAAHIM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if this call create a new thread. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTDFork} (CallSite cs) const{\bkmkstart AAAAAAAHIN}
{\bkmkend AAAAAAAHIN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isHareParFor} (const Instruction *inst) const{\bkmkstart AAAAAAAHIO}
{\bkmkend AAAAAAAHIO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if this call proceeds a hare_parallel_for. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isHareParFor} (CallSite cs) const{\bkmkstart AAAAAAAHIP}
{\bkmkend AAAAAAAHIP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const Value * {\b getForkedThread} (const Instruction *inst) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return arguments/attributes of pthread_create / hare_parallel_for. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getForkedThread} (CallSite cs) const{\bkmkstart AAAAAAAHIQ}
{\bkmkend AAAAAAAHIQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const Value * {\b getForkedFun} (const Instruction *inst) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getForkedFun} (CallSite cs) const{\bkmkstart AAAAAAAHIR}
{\bkmkend AAAAAAAHIR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const Value * {\b getActualParmAtForkSite} (const Instruction *inst) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getActualParmAtForkSite} (CallSite cs) const{\bkmkstart AAAAAAAHIS}
{\bkmkend AAAAAAAHIS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getTaskFuncAtHareParForSite} (const Instruction *inst) const{\bkmkstart AAAAAAAHIT}
{\bkmkend AAAAAAAHIT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the task function (i.e., the 5th parameter) of the hare_parallel_for call. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getTaskFuncAtHareParForSite} (CallSite cs) const{\bkmkstart AAAAAAAHIU}
{\bkmkend AAAAAAAHIU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getTaskDataAtHareParForSite} (const Instruction *inst) const{\bkmkstart AAAAAAAHIV}
{\bkmkend AAAAAAAHIV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the task data (i.e., the 6th parameter) of the hare_parallel_for call. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getTaskDataAtHareParForSite} (CallSite cs) const{\bkmkstart AAAAAAAHIW}
{\bkmkend AAAAAAAHIW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTDJoin} (const Instruction *inst) const{\bkmkstart AAAAAAAHIX}
{\bkmkend AAAAAAAHIX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if this call wait for a worker thread. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTDJoin} (CallSite cs) const{\bkmkstart AAAAAAAHIY}
{\bkmkend AAAAAAAHIY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const Value * {\b getJoinedThread} (const Instruction *inst) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return arguments/attributes of pthread_join. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getJoinedThread} (CallSite cs) const{\bkmkstart AAAAAAAHIZ}
{\bkmkend AAAAAAAHIZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const Value * {\b getRetParmAtJoinedSite} (const Instruction *inst) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getRetParmAtJoinedSite} (CallSite cs) const{\bkmkstart AAAAAAAHJA}
{\bkmkend AAAAAAAHJA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTDExit} (const Instruction *inst) const{\bkmkstart AAAAAAAHJB}
{\bkmkend AAAAAAAHJB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if this call exits/terminate a thread. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTDExit} (CallSite cs) const{\bkmkstart AAAAAAAHJC}
{\bkmkend AAAAAAAHJC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTDAcquire} (const Instruction *inst) const{\bkmkstart AAAAAAAHJD}
{\bkmkend AAAAAAAHJD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if this call acquire a lock. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTDAcquire} (CallSite cs) const{\bkmkstart AAAAAAAHJE}
{\bkmkend AAAAAAAHJE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTDRelease} (const Instruction *inst) const{\bkmkstart AAAAAAAHJF}
{\bkmkend AAAAAAAHJF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if this call release a lock. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTDRelease} (CallSite cs) const{\bkmkstart AAAAAAAHJG}
{\bkmkend AAAAAAAHJG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const Value * {\b getLockVal} (const Instruction *inst) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return lock value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const Value * {\b getLockVal} (CallSite cs) const{\bkmkstart AAAAAAAHJH}
{\bkmkend AAAAAAAHJH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTDBarWait} (const Instruction *inst) const{\bkmkstart AAAAAAAHJI}
{\bkmkend AAAAAAAHJI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if this call waits for a barrier. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isTDBarWait} (CallSite cs) const{\bkmkstart AAAAAAAHJJ}
{\bkmkend AAAAAAAHJJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b performAPIStat} ({\b SVFModule} *m){\bkmkstart AAAAAAAHJK}
{\bkmkend AAAAAAAHJK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b statInit} (llvm::StringMap< u32_t > &tdAPIStatMap){\bkmkstart AAAAAAAHJL}
{\bkmkend AAAAAAAHJL}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b ThreadAPI} * {\b getThreadAPI} (){\bkmkstart AAAAAAAHJM}
{\bkmkend AAAAAAAHJM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a static reference. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v TD_TYPE\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SVF::ThreadAPI::TD_TYPE}}}
\par
{\bkmkstart AAAAAAAHJN}
{\bkmkend AAAAAAAHJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v TD_FORK\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_FORK}
{\qr TD_FORK{\bkmkstart AAAAAAAHJO}
{\bkmkend AAAAAAAHJO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dummy type \par
}\cell }{\row }
{\xe \v TD_JOIN\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_JOIN}
{\qr TD_JOIN{\bkmkstart AAAAAAAHJP}
{\bkmkend AAAAAAAHJP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a new thread \par
}\cell }{\row }
{\xe \v TD_DETACH\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_DETACH}
{\qr TD_DETACH{\bkmkstart AAAAAAAHJQ}
{\bkmkend AAAAAAAHJQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
wait for a thread to join \par
}\cell }{\row }
{\xe \v TD_ACQUIRE\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_ACQUIRE}
{\qr TD_ACQUIRE{\bkmkstart AAAAAAAHJR}
{\bkmkend AAAAAAAHJR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
detach a thread directly instead wait for it to join \par
}\cell }{\row }
{\xe \v TD_TRY_ACQUIRE\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_TRY_ACQUIRE}
{\qr TD_TRY_ACQUIRE{\bkmkstart AAAAAAAHJS}
{\bkmkend AAAAAAAHJS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
acquire a lock \par
}\cell }{\row }
{\xe \v TD_RELEASE\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_RELEASE}
{\qr TD_RELEASE{\bkmkstart AAAAAAAHJT}
{\bkmkend AAAAAAAHJT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
try to acquire a lock \par
}\cell }{\row }
{\xe \v TD_EXIT\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_EXIT}
{\qr TD_EXIT{\bkmkstart AAAAAAAHJU}
{\bkmkend AAAAAAAHJU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
release a lock \par
}\cell }{\row }
{\xe \v TD_CANCEL\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_CANCEL}
{\qr TD_CANCEL{\bkmkstart AAAAAAAHJV}
{\bkmkend AAAAAAAHJV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exit/kill a thread \par
}\cell }{\row }
{\xe \v TD_COND_WAIT\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_COND_WAIT}
{\qr TD_COND_WAIT{\bkmkstart AAAAAAAHJW}
{\bkmkend AAAAAAAHJW}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
cancel a thread by another \par
}\cell }{\row }
{\xe \v TD_COND_SIGNAL\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_COND_SIGNAL}
{\qr TD_COND_SIGNAL{\bkmkstart AAAAAAAHJX}
{\bkmkend AAAAAAAHJX}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
wait a condition \par
}\cell }{\row }
{\xe \v TD_COND_BROADCAST\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_COND_BROADCAST}
{\qr TD_COND_BROADCAST{\bkmkstart AAAAAAAHJY}
{\bkmkend AAAAAAAHJY}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
signal a condition \par
}\cell }{\row }
{\xe \v TD_MUTEX_INI\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_MUTEX_INI}
{\qr TD_MUTEX_INI{\bkmkstart AAAAAAAHJZ}
{\bkmkend AAAAAAAHJZ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
broadcast a condition \par
}\cell }{\row }
{\xe \v TD_MUTEX_DESTROY\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_MUTEX_DESTROY}
{\qr TD_MUTEX_DESTROY{\bkmkstart AAAAAAAHKA}
{\bkmkend AAAAAAAHKA}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
initial a mutex variable \par
}\cell }{\row }
{\xe \v TD_CONDVAR_INI\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_CONDVAR_INI}
{\qr TD_CONDVAR_INI{\bkmkstart AAAAAAAHKB}
{\bkmkend AAAAAAAHKB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
initial a mutex variable \par
}\cell }{\row }
{\xe \v TD_CONDVAR_DESTROY\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_CONDVAR_DESTROY}
{\qr TD_CONDVAR_DESTROY{\bkmkstart AAAAAAAHKC}
{\bkmkend AAAAAAAHKC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
initial a mutex variable \par
}\cell }{\row }
{\xe \v TD_BAR_INIT\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_BAR_INIT}
{\qr TD_BAR_INIT{\bkmkstart AAAAAAAHKD}
{\bkmkend AAAAAAAHKD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
initial a mutex variable \par
}\cell }{\row }
{\xe \v TD_BAR_WAIT\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:TD_BAR_WAIT}
{\qr TD_BAR_WAIT{\bkmkstart AAAAAAAHKE}
{\bkmkend AAAAAAAHKE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Barrier init. \par
}\cell }{\row }
{\xe \v HARE_PAR_FOR\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:HARE_PAR_FOR}
{\qr HARE_PAR_FOR{\bkmkstart AAAAAAAHKF}
{\bkmkend AAAAAAAHKF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Barrier wait. \par
}\cell }{\row }
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getActualParmAtForkSite\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:getActualParmAtForkSite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const Value* SVF::ThreadAPI::getActualParmAtForkSite (const Instruction *  {\i inst}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHKG}
{\bkmkend AAAAAAAHKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the forth argument of the call, Note that, it is the sole argument of start routine ( a void* pointer ) \par
}}
{\xe \v getForkedFun\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:getForkedFun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const Value* SVF::ThreadAPI::getForkedFun (const Instruction *  {\i inst}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHKH}
{\bkmkend AAAAAAAHKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the third argument of the call, Note that, it could be function type or a void* pointer \par
}}
{\xe \v getForkedThread\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:getForkedThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const Value* SVF::ThreadAPI::getForkedThread (const Instruction *  {\i inst}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHKI}
{\bkmkend AAAAAAAHKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return arguments/attributes of pthread_create / hare_parallel_for. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the first argument of the call, Note that, it is the pthread_t pointer \par
}}
{\xe \v getJoinedThread\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:getJoinedThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const Value* SVF::ThreadAPI::getJoinedThread (const Instruction *  {\i inst}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHKJ}
{\bkmkend AAAAAAAHKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return arguments/attributes of pthread_join. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the first argument of the call, Note that, it is the pthread_t pointer \par
}}
{\xe \v getLockVal\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:getLockVal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const Value* SVF::ThreadAPI::getLockVal (const Instruction *  {\i inst}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHKK}
{\bkmkend AAAAAAAHKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return lock value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First argument of pthread_mutex_lock/pthread_mutex_unlock \par
}}
{\xe \v getRetParmAtJoinedSite\:SVF::ThreadAPI}
{\xe \v SVF::ThreadAPI\:getRetParmAtJoinedSite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const Value* SVF::ThreadAPI::getRetParmAtJoinedSite (const Instruction *  {\i inst}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHKL}
{\bkmkend AAAAAAAHKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the send argument of the call, Note that, it is the pthread_t pointer \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/ThreadAPI.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Util/ThreadAPI.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ThreadCallGraph Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ThreadCallGraph}
{\xe \v SVF::ThreadCallGraph}
{\bkmkstart AAAAAAADFM}
{\bkmkend AAAAAAADFM}
\par
{
{\f2 #include <ThreadCallGraph.h>}}\par
Inheritance diagram for SVF::ThreadCallGraph:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_thread_call_graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b CallBlockNode} * > {\b InstSet}{\bkmkstart AAAAAAADFN}
{\bkmkend AAAAAAADFN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef InstSet {\b CallSiteSet}{\bkmkstart AAAAAAADFO}
{\bkmkend AAAAAAADFO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< const Instruction * > {\b InstVector}{\bkmkstart AAAAAAADFP}
{\bkmkend AAAAAAADFP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const Instruction *, InstSet > {\b CallToInstMap}{\bkmkstart AAAAAAADFQ}
{\bkmkend AAAAAAADFQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< CallSiteSet * > {\b CtxSet}{\bkmkstart AAAAAAADFR}
{\bkmkend AAAAAAADFR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef ThreadForkEdge::ForkEdgeSet {\b ForkEdgeSet}{\bkmkstart AAAAAAADFS}
{\bkmkend AAAAAAADFS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CallBlockNode} *, ForkEdgeSet > {\b CallInstToForkEdgesMap}{\bkmkstart AAAAAAADFT}
{\bkmkend AAAAAAADFT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef ThreadJoinEdge::JoinEdgeSet {\b JoinEdgeSet}{\bkmkstart AAAAAAADFU}
{\bkmkend AAAAAAADFU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CallBlockNode} *, JoinEdgeSet > {\b CallInstToJoinEdgesMap}{\bkmkstart AAAAAAADFV}
{\bkmkend AAAAAAADFV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef HareParForEdge::ParForEdgeSet {\b ParForEdgeSet}{\bkmkstart AAAAAAADFW}
{\bkmkend AAAAAAADFW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b CallBlockNode} *, ParForEdgeSet > {\b CallInstToParForEdgesMap}{\bkmkstart AAAAAAADFX}
{\bkmkend AAAAAAADFX}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ThreadCallGraph} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~ThreadCallGraph} (){\bkmkstart AAAAAAADFY}
{\bkmkend AAAAAAADFY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b updateCallGraph} ({\b PointerAnalysis} *pta){\bkmkstart AAAAAAADFZ}
{\bkmkend AAAAAAADFZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update call graph using pointer results. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateJoinEdge} ({\b PointerAnalysis} *pta)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update join edge using pointer analysis results. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasThreadForkEdge} (const {\b CallBlockNode} *cs) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get call graph edge via call instruction. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

ForkEdgeSet::const_iterator {\b getForkEdgeBegin} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAADGA}
{\bkmkend AAAAAAADGA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

ForkEdgeSet::const_iterator {\b getForkEdgeEnd} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAADGB}
{\bkmkend AAAAAAADGB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasThreadJoinEdge} (const {\b CallBlockNode} *cs) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get call graph edge via call instruction. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

JoinEdgeSet::const_iterator {\b getJoinEdgeBegin} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAADGC}
{\bkmkend AAAAAAADGC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

JoinEdgeSet::const_iterator {\b getJoinEdgeEnd} (const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAADGD}
{\bkmkend AAAAAAADGD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b getJoinSites} (const {\b PTACallGraphNode} *routine, InstSet &csSet){\bkmkstart AAAAAAADGE}
{\bkmkend AAAAAAADGE}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ThreadCallGraph} *){\bkmkstart AAAAAAADGF}
{\bkmkend AAAAAAADGF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ClassOf. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PTACallGraph} *g){\bkmkstart AAAAAAADGG}
{\bkmkend AAAAAAADGG}
\par
}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isForksite} (const {\b CallBlockNode} *csInst)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isJoinsite} (const {\b CallBlockNode} *csInst){\bkmkstart AAAAAAADGH}
{\bkmkend AAAAAAADGH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isParForSite} (const {\b CallBlockNode} *csInst){\bkmkstart AAAAAAADGI}
{\bkmkend AAAAAAADGI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteSet::const_iterator {\b forksitesBegin} () const{\bkmkstart AAAAAAADGJ}
{\bkmkend AAAAAAADGJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fork sites iterators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteSet::const_iterator {\b forksitesEnd} () const{\bkmkstart AAAAAAADGK}
{\bkmkend AAAAAAADGK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteSet::const_iterator {\b joinsitesBegin} () const{\bkmkstart AAAAAAADGL}
{\bkmkend AAAAAAADGL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Join sites iterators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteSet::const_iterator {\b joinsitesEnd} () const{\bkmkstart AAAAAAADGM}
{\bkmkend AAAAAAADGM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteSet::const_iterator {\b parForSitesBegin} () const{\bkmkstart AAAAAAADGN}
{\bkmkend AAAAAAADGN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
hare_parallel_for sites iterators }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteSet::const_iterator {\b parForSitesEnd} () const{\bkmkstart AAAAAAADGO}
{\bkmkend AAAAAAADGO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getNumOfForksite} () const{\bkmkstart AAAAAAADGP}
{\bkmkend AAAAAAADGP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Num of fork/join sites. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getNumOfJoinsite} () const{\bkmkstart AAAAAAADGQ}
{\bkmkend AAAAAAADGQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getNumOfParForSite} () const{\bkmkstart AAAAAAADGR}
{\bkmkend AAAAAAADGR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ThreadAPI} * {\b getThreadAPI} () const{\bkmkstart AAAAAAADGS}
{\bkmkend AAAAAAADGS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Thread API. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b addForksite} (const {\b CallBlockNode} *cs){\bkmkstart AAAAAAADGT}
{\bkmkend AAAAAAADGT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add fork sites which directly or indirectly create a thread. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b addJoinsite} (const {\b CallBlockNode} *cs){\bkmkstart AAAAAAADGU}
{\bkmkend AAAAAAADGU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b addParForSite} (const {\b CallBlockNode} *cs){\bkmkstart AAAAAAADGV}
{\bkmkend AAAAAAADGV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addDirectForkEdge} (const {\b CallBlockNode} *cs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add direct/indirect thread fork edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addIndirectForkEdge} (const {\b CallBlockNode} *cs, const {\b SVFFunction} *callee)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addDirectJoinEdge} (const {\b CallBlockNode} *cs, const CallSiteSet &forksite)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add thread join edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addDirectParForEdge} (const {\b CallBlockNode} *cs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add direct/indirect parallel for edges. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addIndirectParForEdge} (const {\b CallBlockNode} *cs, const {\b SVFFunction} *callee)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addThreadForkEdgeSetMap} (const {\b CallBlockNode} *cs, {\b ThreadForkEdge} *edge){\bkmkstart AAAAAAADGW}
{\bkmkend AAAAAAADGW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map call instruction to its CallGraphEdge map }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addThreadJoinEdgeSetMap} (const {\b CallBlockNode} *cs, {\b ThreadJoinEdge} *edge){\bkmkstart AAAAAAADGX}
{\bkmkend AAAAAAADGX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map call instruction to its CallGraphEdge map }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addHareParForEdgeSetMap} (const {\b CallBlockNode} *cs, {\b HareParForEdge} *edge){\bkmkstart AAAAAAADGY}
{\bkmkend AAAAAAADGY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map call instruction to its CallGraphEdge map }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ThreadJoinEdge} * {\b hasThreadJoinEdge} (const {\b CallBlockNode} *call, {\b PTACallGraphNode} *joinFunNode, {\b PTACallGraphNode} *threadRoutineFunNode, CallSiteID csId) const{\bkmkstart AAAAAAADGZ}
{\bkmkend AAAAAAADGZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
has thread join edge }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Thread sensitive call graph \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ThreadCallGraph\:SVF::ThreadCallGraph}
{\xe \v SVF::ThreadCallGraph\:ThreadCallGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ThreadCallGraph::ThreadCallGraph ()}}
\par
{\bkmkstart AAAAAAADHA}
{\bkmkend AAAAAAADHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addDirectForkEdge\:SVF::ThreadCallGraph}
{\xe \v SVF::ThreadCallGraph\:addDirectForkEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ThreadCallGraph::addDirectForkEdge (const {\b CallBlockNode} *  {\i cs})}}
\par
{\bkmkstart AAAAAAADHB}
{\bkmkend AAAAAAADHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add direct/indirect thread fork edges. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add direct fork edges \par
}}
{\xe \v addDirectJoinEdge\:SVF::ThreadCallGraph}
{\xe \v SVF::ThreadCallGraph\:addDirectJoinEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ThreadCallGraph::addDirectJoinEdge (const {\b CallBlockNode} *  {\i cs}, const CallSiteSet &  {\i forkset})}}
\par
{\bkmkstart AAAAAAADHC}
{\bkmkend AAAAAAADHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add thread join edges. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add direct fork edges As join edge is a special return which is back to join site(s) rather than its fork site A {\b ThreadJoinEdge} is created from the functions where join sites reside in to the start routine function But we don't invoke {\b addEdge()} method to add the edge to src and dst, otherwise it makes a scc cycle \par
}}
{\xe \v addDirectParForEdge\:SVF::ThreadCallGraph}
{\xe \v SVF::ThreadCallGraph\:addDirectParForEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ThreadCallGraph::addDirectParForEdge (const {\b CallBlockNode} *  {\i cs})}}
\par
{\bkmkstart AAAAAAADHD}
{\bkmkend AAAAAAADHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add direct/indirect parallel for edges. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a direct ParFor edges \par
}}
{\xe \v addIndirectForkEdge\:SVF::ThreadCallGraph}
{\xe \v SVF::ThreadCallGraph\:addIndirectForkEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ThreadCallGraph::addIndirectForkEdge (const {\b CallBlockNode} *  {\i cs}, const {\b SVFFunction} *  {\i calleefun})}}
\par
{\bkmkstart AAAAAAADHE}
{\bkmkend AAAAAAADHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add indirect fork edge to update call graph \par
}}
{\xe \v addIndirectParForEdge\:SVF::ThreadCallGraph}
{\xe \v SVF::ThreadCallGraph\:addIndirectParForEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ThreadCallGraph::addIndirectParForEdge (const {\b CallBlockNode} *  {\i cs}, const {\b SVFFunction} *  {\i calleefun})}}
\par
{\bkmkstart AAAAAAADHF}
{\bkmkend AAAAAAADHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add an indirect ParFor edge to update call graph \par
}}
{\xe \v hasThreadForkEdge\:SVF::ThreadCallGraph}
{\xe \v SVF::ThreadCallGraph\:hasThreadForkEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::ThreadCallGraph::hasThreadForkEdge (const {\b CallBlockNode} *  {\i cs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADHG}
{\bkmkend AAAAAAADHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get call graph edge via call instruction. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
whether this call instruction has a valid call graph edge \par
}}
{\xe \v hasThreadJoinEdge\:SVF::ThreadCallGraph}
{\xe \v SVF::ThreadCallGraph\:hasThreadJoinEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::ThreadCallGraph::hasThreadJoinEdge (const {\b CallBlockNode} *  {\i cs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADHH}
{\bkmkend AAAAAAADHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get call graph edge via call instruction. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
whether this call instruction has a valid call graph edge \par
}}
{\xe \v isForksite\:SVF::ThreadCallGraph}
{\xe \v SVF::ThreadCallGraph\:isForksite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::ThreadCallGraph::isForksite (const {\b CallBlockNode} *  {\i csInst}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADHI}
{\bkmkend AAAAAAADHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a callsite is a fork or join or hare_parallel_for \par
}}
{\xe \v updateJoinEdge\:SVF::ThreadCallGraph}
{\xe \v SVF::ThreadCallGraph\:updateJoinEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ThreadCallGraph::updateJoinEdge ({\b PointerAnalysis} *  {\i pta})}}
\par
{\bkmkstart AAAAAAADHJ}
{\bkmkend AAAAAAADHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update join edge using pointer analysis results. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update join edge using pointer analysis results \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ThreadCallGraph.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/ThreadCallGraph.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ThreadCallGraphBuilder Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ThreadCallGraphBuilder}
{\xe \v SVF::ThreadCallGraphBuilder}
{\bkmkstart AAAAAAAGED}
{\bkmkend AAAAAAAGED}
Inheritance diagram for SVF::ThreadCallGraphBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_thread_call_graph_builder.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ThreadCallGraphBuilder} ({\b ThreadCallGraph} *cg, {\b ICFG} *i){\bkmkstart AAAAAAAGEE}
{\bkmkend AAAAAAAGEE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTACallGraph} * {\b buildThreadCallGraph} ({\b SVFModule} *svfModule){\bkmkstart AAAAAAAGEF}
{\bkmkend AAAAAAAGEF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Build thread-aware callgraph. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/SVF-FE/CallGraphBuilder.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/SVF-FE/CallGraphBuilder.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ThreadForkEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ThreadForkEdge}
{\xe \v SVF::ThreadForkEdge}
{\bkmkstart AAAAAAADES}
{\bkmkend AAAAAAADES}
\par
{
{\f2 #include <ThreadCallGraph.h>}}\par
Inheritance diagram for SVF::ThreadForkEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_thread_fork_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericNode}< {\b PTACallGraphNode}, {\b ThreadForkEdge} >::GEdgeSetTy {\b ForkEdgeSet}{\bkmkstart AAAAAAADET}
{\bkmkend AAAAAAADET}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ThreadForkEdge} ({\b PTACallGraphNode} *s, {\b PTACallGraphNode} *d, CallSiteID csId){\bkmkstart AAAAAAADEU}
{\bkmkend AAAAAAADEU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~ThreadForkEdge} (){\bkmkstart AAAAAAADEV}
{\bkmkend AAAAAAADEV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADEW}
{\bkmkend AAAAAAADEW}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ThreadForkEdge} *){\bkmkstart AAAAAAADEX}
{\bkmkend AAAAAAADEX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ClassOf. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PTACallGraphEdge} *edge){\bkmkstart AAAAAAADEY}
{\bkmkend AAAAAAADEY}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PTA thread fork edge from fork site to the entry of a start routine function \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ThreadCallGraph.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ThreadJoinEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ThreadJoinEdge}
{\xe \v SVF::ThreadJoinEdge}
{\bkmkstart AAAAAAADEZ}
{\bkmkend AAAAAAADEZ}
\par
{
{\f2 #include <ThreadCallGraph.h>}}\par
Inheritance diagram for SVF::ThreadJoinEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_thread_join_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericNode}< {\b PTACallGraphNode}, {\b ThreadJoinEdge} >::GEdgeSetTy {\b JoinEdgeSet}{\bkmkstart AAAAAAADFA}
{\bkmkend AAAAAAADFA}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ThreadJoinEdge} ({\b PTACallGraphNode} *s, {\b PTACallGraphNode} *d, CallSiteID csId){\bkmkstart AAAAAAADFB}
{\bkmkend AAAAAAADFB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~ThreadJoinEdge} (){\bkmkstart AAAAAAADFC}
{\bkmkend AAAAAAADFC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADFD}
{\bkmkend AAAAAAADFD}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ThreadJoinEdge} *){\bkmkstart AAAAAAADFE}
{\bkmkend AAAAAAADFE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PTACallGraphEdge} *edge){\bkmkstart AAAAAAADFF}
{\bkmkend AAAAAAADFF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PTA thread join edge from the exit of a start routine function to a join point of the thread \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ThreadCallGraph.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ThreadMHPIndSVFGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ThreadMHPIndSVFGEdge}
{\xe \v SVF::ThreadMHPIndSVFGEdge}
{\bkmkstart AAAAAAACZD}
{\bkmkend AAAAAAACZD}
\par
{
{\f2 #include <SVFGEdge.h>}}\par
Inheritance diagram for SVF::ThreadMHPIndSVFGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_thread_m_h_p_ind_s_v_f_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ThreadMHPIndSVFGEdge} ({\b VFGNode} *s, {\b VFGNode} *d){\bkmkstart AAAAAAACZE}
{\bkmkend AAAAAAACZE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACZF}
{\bkmkend AAAAAAACZF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ThreadMHPIndSVFGEdge} *){\bkmkstart AAAAAAACZG}
{\bkmkend AAAAAAACZG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b IndirectSVFGEdge} *edge){\bkmkstart AAAAAAACZH}
{\bkmkend AAAAAAACZH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGEdge} *edge){\bkmkstart AAAAAAACZI}
{\bkmkend AAAAAAACZI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGEdgeTy} *edge){\bkmkstart AAAAAAACZJ}
{\bkmkend AAAAAAACZJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b MHP} {\b SVFG} edge representing indirect value-flows between two memory access may-happen-in-parallel in multithreaded program \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/SVFGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/SVFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::TypeAnalysis Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::TypeAnalysis}
{\xe \v SVF::TypeAnalysis}
{\bkmkstart AAAAAAAHYN}
{\bkmkend AAAAAAAHYN}
Inheritance diagram for SVF::TypeAnalysis:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_type_analysis.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b TypeAnalysis} ({\b PAG} *{\b pag}){\bkmkstart AAAAAAAHYO}
{\bkmkend AAAAAAAHYO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~TypeAnalysis} (){\bkmkstart AAAAAAAHYP}
{\bkmkend AAAAAAAHYP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b analyze} (){\bkmkstart AAAAAAAHNM}
{\bkmkend AAAAAAAHNM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b initialize} (){\bkmkstart AAAAAAAEQE}
{\bkmkend AAAAAAAEQE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b finalize} (){\bkmkstart AAAAAAAEPT}
{\bkmkend AAAAAAAEPT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b callGraphSolveBasedOnCHA} (const CallSiteToFunPtrMap &callsites, CallEdgeMap &newEdges){\bkmkstart AAAAAAAHYQ}
{\bkmkend AAAAAAAHYQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resolve callgraph based on CHA. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dumpCHAStats} (){\bkmkstart AAAAAAAHYR}
{\bkmkend AAAAAAAHYR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Statistics of CHA and callgraph. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b TypeAnalysis} *){\bkmkstart AAAAAAAHYS}
{\bkmkend AAAAAAAHYS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PointerAnalysis} *pta){\bkmkstart AAAAAAAHYT}
{\bkmkend AAAAAAAHYT}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/TypeAnalysis.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/TypeAnalysis.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::TypeBasedHeapCloning Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::TypeBasedHeapCloning}
{\xe \v SVF::TypeBasedHeapCloning}
{\bkmkstart AAAAAAAHKM}
{\bkmkend AAAAAAAHKM}
Inheritance diagram for SVF::TypeBasedHeapCloning:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_type_based_heap_cloning.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const MDNode * {\b getRawCTirMetadata} (const Value *){\bkmkstart AAAAAAAHKN}
{\bkmkend AAAAAAAHKN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns raw ctir metadata of a Value. Returns null if it doesn't exist. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b TypeBasedHeapCloning} ({\b BVDataPTAImpl} *pta){\bkmkstart AAAAAAAHKO}
{\bkmkend AAAAAAAHKO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. pta is the pointer analysis using this object (i.e. that which is extending). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b backPropagate} (NodeID clone)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setDCHG} ({\b DCHGraph} *{\b dchg}){\bkmkstart AAAAAAAHKP}
{\bkmkend AAAAAAAHKP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DCHG {\i must}  be set by extending class once the DCHG is available. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setPAG} ({\b PAG} *pag){\bkmkstart AAAAAAAHKQ}
{\bkmkend AAAAAAAHKQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PAG} {\i must}  be set by extending class once the {\b PAG} is available. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isBlkObjOrConstantObj} (NodeID o) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isBase} (const DIType *a, const DIType *b) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isClone} (NodeID o) const{\bkmkstart AAAAAAAHKR}
{\bkmkend AAAAAAAHKR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if o is a clone. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setType} (NodeID o, const DIType *t){\bkmkstart AAAAAAAHKS}
{\bkmkend AAAAAAAHKS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the type (in objToType) of o. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const DIType * {\b getType} (NodeID o) const{\bkmkstart AAAAAAAHKT}
{\bkmkend AAAAAAAHKT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the type (from objToType) of o. Asserts existence. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setAllocationSite} (NodeID o, NodeID site){\bkmkstart AAAAAAAHKU}
{\bkmkend AAAAAAAHKU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the allocation site (in objToAllocation) of o. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getAllocationSite} (NodeID o) const{\bkmkstart AAAAAAAHKV}
{\bkmkend AAAAAAAHKV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the allocation site (from objToAllocation) of o. Asserts existence. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const NodeBS {\b getObjsWithClones} (void){\bkmkstart AAAAAAAHKW}
{\bkmkend AAAAAAAHKW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns objects that have clones (any key in objToClones). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addClone} (NodeID o, NodeID c){\bkmkstart AAAAAAAHKX}
{\bkmkend AAAAAAAHKX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a clone c to object o. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const NodeBS & {\b getClones} (NodeID o){\bkmkstart AAAAAAAHKY}
{\bkmkend AAAAAAAHKY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all the clones of o. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setOriginalObj} (NodeID c, NodeID o){\bkmkstart AAAAAAAHKZ}
{\bkmkend AAAAAAAHKZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getOriginalObj} (NodeID c) const{\bkmkstart AAAAAAAHLA}
{\bkmkend AAAAAAAHLA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the original object c is cloned from. If c is not a clone, returns itself. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PointsTo & {\b getFilterSet} (NodeID loc){\bkmkstart AAAAAAAHLB}
{\bkmkend AAAAAAAHLB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the filter set of a location. Not const; could create empty PointsTo. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addGepToObj} (NodeID gep, NodeID base, unsigned offset){\bkmkstart AAAAAAAHLC}
{\bkmkend AAAAAAAHLC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Associates gep with base (through objToGeps and memObjToGeps). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const NodeBS & {\b getGepObjsFromMemObj} (const {\b MemObj} *memObj, unsigned offset)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const NodeBS & {\b getGepObjs} (NodeID base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const NodeBS {\b getGepObjClones} (NodeID base, unsigned offset)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b init} (NodeID loc, NodeID p, const DIType *tildet, bool reuse, bool gep=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NodeID {\b cloneObject} (NodeID o, const DIType *type, bool reuse)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addCloneDummyObjNode} (const {\b MemObj} *mem){\bkmkstart AAAAAAAHLD}
{\bkmkend AAAAAAAHLD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add clone dummy object node to {\b PAG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addCloneGepObjNode} (const {\b MemObj} *mem, const {\b LocationSet} &l){\bkmkstart AAAAAAAHLE}
{\bkmkend AAAAAAAHLE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add clone GEP object node to {\b PAG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b addCloneFIObjNode} (const {\b MemObj} *mem){\bkmkstart AAAAAAAHLF}
{\bkmkend AAAAAAAHLF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add clone FI object node to {\b PAG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const DIType * {\b getTypeFromCTirMetadata} (const Value *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b validateTBHCTests} ({\b SVFModule} *svfMod)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dumpStats} (void){\bkmkstart AAAAAAAHLG}
{\bkmkend AAAAAAAHLG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump some statistics we tracked. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DCHGraph} * {\b dchg} = nullptr\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const DIType * {\b undefType} = nullptr{\bkmkstart AAAAAAAHLH}
{\bkmkend AAAAAAAHLH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The undefined type (\'95); void. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const std::string {\b derefFnName} = "deref"{\bkmkstart AAAAAAAHLI}
{\bkmkend AAAAAAAHLI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
deref function for TBHC alias tests. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const std::string {\b mangledDerefFnName} = "_Z5derefv"{\bkmkstart AAAAAAAHLJ}
{\bkmkend AAAAAAAHLJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
deref function (mangled) for TBHC alias tests. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v backPropagate\:SVF::TypeBasedHeapCloning}
{\xe \v SVF::TypeBasedHeapCloning\:backPropagate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void SVF::TypeBasedHeapCloning::backPropagate (NodeID  {\i clone}){\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAHLK}
{\bkmkend AAAAAAAHLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Required by user. Handles back-propagation of newly created clone after all metadata has been set. Used by cloneObject. \par
}{
Implemented in {\b SVF::FlowSensitiveTBHC} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHLL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v cloneObject\:SVF::TypeBasedHeapCloning}
{\xe \v SVF::TypeBasedHeapCloning\:cloneObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NodeID TypeBasedHeapCloning::cloneObject (NodeID  {\i o}, const DIType *  {\i type}, bool  {\i reuse}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHLM}
{\bkmkend AAAAAAAHLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a clone of o with type type. reuse indicates whether we are cloning as a result of reuse. \par
}}
{\xe \v getGepObjClones\:SVF::TypeBasedHeapCloning}
{\xe \v SVF::TypeBasedHeapCloning\:getGepObjClones}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const NodeBS TypeBasedHeapCloning::getGepObjClones (NodeID  {\i base}, unsigned  {\i offset}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHLN}
{\bkmkend AAAAAAAHLN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the GEP object node(s) of base for ls. This may include clones. If there are no GEP objects, then getGepObjNode is called on the {\b PAG} (through base's getGepObjNode) which will create one. \par
}}
{\xe \v getGepObjs\:SVF::TypeBasedHeapCloning}
{\xe \v SVF::TypeBasedHeapCloning\:getGepObjs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const NodeBS & TypeBasedHeapCloning::getGepObjs (NodeID  {\i base}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHLO}
{\bkmkend AAAAAAAHLO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all gep objects under an object. Not const; could create empty set. \par
}}
{\xe \v getGepObjsFromMemObj\:SVF::TypeBasedHeapCloning}
{\xe \v SVF::TypeBasedHeapCloning\:getGepObjsFromMemObj}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const NodeBS & TypeBasedHeapCloning::getGepObjsFromMemObj (const {\b MemObj} *  {\i memObj}, unsigned  {\i offset}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHLP}
{\bkmkend AAAAAAAHLP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns all gep objects at a particular offset for memory object. Not const; could create empty set. \par
}}
{\xe \v getTypeFromCTirMetadata\:SVF::TypeBasedHeapCloning}
{\xe \v SVF::TypeBasedHeapCloning\:getTypeFromCTirMetadata}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const DIType * TypeBasedHeapCloning::getTypeFromCTirMetadata (const Value *  {\i v}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHLQ}
{\bkmkend AAAAAAAHLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the ctir type attached to the value, nullptr if non-existant. Not static because it needs the DCHG to return the canonical type. Not static because we need dchg's getCanonicalType. \par
}}
{\xe \v init\:SVF::TypeBasedHeapCloning}
{\xe \v SVF::TypeBasedHeapCloning\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TypeBasedHeapCloning::init (NodeID  {\i loc}, NodeID  {\i p}, const DIType *  {\i tildet}, bool  {\i reuse}, bool  {\i gep} = {\f2 false}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHLR}
{\bkmkend AAAAAAAHLR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialise the pointees of p at loc (which is type tildet *). reuse indicates whether reuse is a possibility for this initialisation. Returns whether p changed. \par
}}
{\xe \v isBase\:SVF::TypeBasedHeapCloning}
{\xe \v SVF::TypeBasedHeapCloning\:isBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TypeBasedHeapCloning::isBase (const DIType *  {\i a}, const DIType *  {\i b}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHLS}
{\bkmkend AAAAAAAHLS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wrapper around {\b DCHGraph::isBase}. Purpose is to keep our conditions clean by only passing two parameters like the rules. \par
}}
{\xe \v isBlkObjOrConstantObj\:SVF::TypeBasedHeapCloning}
{\xe \v SVF::TypeBasedHeapCloning\:isBlkObjOrConstantObj}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TypeBasedHeapCloning::isBlkObjOrConstantObj (NodeID  {\i o}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHLT}
{\bkmkend AAAAAAAHLT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if an object is a black hole obj or a constant object. Required since other implementations obviously do not account for clones. \par
}}
{\xe \v validateTBHCTests\:SVF::TypeBasedHeapCloning}
{\xe \v SVF::TypeBasedHeapCloning\:validateTBHCTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TypeBasedHeapCloning::validateTBHCTests ({\b SVFModule} *  {\i svfMod}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHLU}
{\bkmkend AAAAAAAHLU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Runs tests on MAYALIAS, NOALIAS, etc. built from TBHC_MAYALIAS, TBHC_NOALIAS, etc. macros. TBHC_XALIAS macros produce: call XALIAS(...) %1 = load ... ... n = load p store ... n-1, ...* n !ctir !t1 call deref() n+1 = load ... ... n+n = load q store ... n+n-1, ...* n+n !ctir !t2 call deref() We want to test the points-to sets of n and n+n after filtering with !t1 and !t2 respectively. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v dchg\:SVF::TypeBasedHeapCloning}
{\xe \v SVF::TypeBasedHeapCloning\:dchg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DCHGraph}* SVF::TypeBasedHeapCloning::dchg = nullptr{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAHLV}
{\bkmkend AAAAAAAHLV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class hierarchy graph built from debug information. Required, CHG from IR is insufficient. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/TypeBasedHeapCloning.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Util/TypeBasedHeapCloning.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::TypeSet Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::TypeSet}
{\xe \v SVF::TypeSet}
{\bkmkstart AAAAAAAEXL}
{\bkmkend AAAAAAAEXL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedSet< {\b PTAType} > {\b TypeSetTy}{\bkmkstart AAAAAAAEXM}
{\bkmkend AAAAAAAEXM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef TypeSetTy::iterator {\b iterator}{\bkmkstart AAAAAAAEXN}
{\bkmkend AAAAAAAEXN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef TypeSetTy::const_iterator {\b const_iterator}{\bkmkstart AAAAAAAEXO}
{\bkmkend AAAAAAAEXO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b begin} (){\bkmkstart AAAAAAAEXP}
{\bkmkend AAAAAAAEXP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b end} (){\bkmkstart AAAAAAAEXQ}
{\bkmkend AAAAAAAEXQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b begin} () const{\bkmkstart AAAAAAAEXR}
{\bkmkend AAAAAAAEXR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b end} () const{\bkmkstart AAAAAAAEXS}
{\bkmkend AAAAAAAEXS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b size} () const{\bkmkstart AAAAAAAEXT}
{\bkmkend AAAAAAAEXT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of types contained. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b addType} (const {\b PTAType} &type){\bkmkstart AAAAAAAEXU}
{\bkmkend AAAAAAAEXU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a ptatype. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b containType} (const {\b PTAType} &type) const{\bkmkstart AAAAAAAEXV}
{\bkmkend AAAAAAAEXV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contain a ptatype or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b intersect} (const {\b TypeSet} *typeset) const{\bkmkstart AAAAAAAEXW}
{\bkmkend AAAAAAAEXW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Intersect with another typeset or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b dumpTypes} () const{\bkmkstart AAAAAAAEXX}
{\bkmkend AAAAAAAEXX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump all types in the typeset. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/PTAType.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::TypeSystem Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::TypeSystem}
{\xe \v SVF::TypeSystem}
{\bkmkstart AAAAAAAEXY}
{\bkmkend AAAAAAAEXY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, {\b TypeSet} * > {\b VarToTypeSetMapTy}{\bkmkstart AAAAAAAEXZ}
{\bkmkend AAAAAAAEXZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef OrderedMap< {\b PTAType}, NodeBS > {\b TypeToVarsMapTy}{\bkmkstart AAAAAAAEYA}
{\bkmkend AAAAAAAEYA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef VarToTypeSetMapTy::iterator {\b iterator}{\bkmkstart AAAAAAAEYB}
{\bkmkend AAAAAAAEYB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef VarToTypeSetMapTy::const_iterator {\b const_iterator}{\bkmkstart AAAAAAAEYC}
{\bkmkend AAAAAAAEYC}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b begin} (){\bkmkstart AAAAAAAEYD}
{\bkmkend AAAAAAAEYD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterators. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

iterator {\b end} (){\bkmkstart AAAAAAAEYE}
{\bkmkend AAAAAAAEYE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b begin} () const{\bkmkstart AAAAAAAEYF}
{\bkmkend AAAAAAAEYF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const_iterator {\b end} () const{\bkmkstart AAAAAAAEYG}
{\bkmkend AAAAAAAEYG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b TypeSystem} (const {\b PAG} *pag){\bkmkstart AAAAAAAEYH}
{\bkmkend AAAAAAAEYH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasTypeSet} (NodeID var) const{\bkmkstart AAAAAAAEYI}
{\bkmkend AAAAAAAEYI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has typeset or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b TypeSet} * {\b getTypeSet} (NodeID var) const{\bkmkstart AAAAAAAEYJ}
{\bkmkend AAAAAAAEYJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a var's typeset. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addTypeForVar} (NodeID var, const {\b PTAType} &type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addTypeForVar} (NodeID var, const Type *type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addVarForType} (NodeID var, const {\b PTAType} &type){\bkmkstart AAAAAAAEYK}
{\bkmkend AAAAAAAEYK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addVarForType} (NodeID var, const Type *type){\bkmkstart AAAAAAAEYL}
{\bkmkend AAAAAAAEYL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasVarsForType} (const {\b PTAType} &type) const{\bkmkstart AAAAAAAEYM}
{\bkmkend AAAAAAAEYM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeBS & {\b getVarsForType} (const {\b PTAType} &type){\bkmkstart AAAAAAAEYN}
{\bkmkend AAAAAAAEYN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b printTypeSystem} () const{\bkmkstart AAAAAAAEYO}
{\bkmkend AAAAAAAEYO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print each var's id and all its types. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addTypeForVar\:SVF::TypeSystem}
{\xe \v SVF::TypeSystem\:addTypeForVar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::TypeSystem::addTypeForVar (NodeID  {\i var}, const {\b PTAType} &  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEYP}
{\bkmkend AAAAAAAEYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a ptatype for a var Return true if the ptatype is new for this var \par
}}
{\xe \v addTypeForVar\:SVF::TypeSystem}
{\xe \v SVF::TypeSystem\:addTypeForVar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::TypeSystem::addTypeForVar (NodeID  {\i var}, const Type *  {\i type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAEYQ}
{\bkmkend AAAAAAAEYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a ptatype for a var Return true if the ptatype is new for this var \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/PTAType.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::UnaryOPPE Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::UnaryOPPE}
{\xe \v SVF::UnaryOPPE}
{\bkmkstart AAAAAAACJF}
{\bkmkend AAAAAAACJF}
\par
{
{\f2 #include <PAGEdge.h>}}\par
Inheritance diagram for SVF::UnaryOPPE:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_unary_o_p_p_e.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b UnaryOPPE} ({\b PAGNode} *s, {\b PAGNode} *d){\bkmkstart AAAAAAACJG}
{\bkmkend AAAAAAACJG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACJH}
{\bkmkend AAAAAAACJH}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b UnaryOPPE} *){\bkmkstart AAAAAAACJI}
{\bkmkend AAAAAAACJI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGEdge} *edge){\bkmkstart AAAAAAACJJ}
{\bkmkend AAAAAAACJJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGEdgeTy} *edge){\bkmkstart AAAAAAACJK}
{\bkmkend AAAAAAACJK}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unary instruction edge \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::UnaryOPVFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::UnaryOPVFGNode}
{\xe \v SVF::UnaryOPVFGNode}
{\bkmkstart AAAAAAADQU}
{\bkmkend AAAAAAADQU}
\par
{
{\f2 #include <VFGNode.h>}}\par
Inheritance diagram for SVF::UnaryOPVFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_unary_o_p_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< u32_t, const {\b PAGNode} * > {\b OPVers}{\bkmkstart AAAAAAADQV}
{\bkmkend AAAAAAADQV}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b UnaryOPVFGNode} (NodeID id, const {\b PAGNode} *r){\bkmkstart AAAAAAADQW}
{\bkmkend AAAAAAADQW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getOpVer} (u32_t pos) const{\bkmkstart AAAAAAADQX}
{\bkmkend AAAAAAADQX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Operands at a UnaryNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setOpVer} (u32_t pos, const {\b PAGNode} *node){\bkmkstart AAAAAAADQY}
{\bkmkend AAAAAAADQY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b getRes} () const{\bkmkstart AAAAAAADQZ}
{\bkmkend AAAAAAADQZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getOpVerNum} () const{\bkmkstart AAAAAAADRA}
{\bkmkend AAAAAAADRA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers::const_iterator {\b opVerBegin} () const{\bkmkstart AAAAAAADRB}
{\bkmkend AAAAAAADRB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers::const_iterator {\b opVerEnd} () const{\bkmkstart AAAAAAADRC}
{\bkmkend AAAAAAADRC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADRD}
{\bkmkend AAAAAAADRD}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b UnaryOPVFGNode} *){\bkmkstart AAAAAAADRE}
{\bkmkend AAAAAAADRE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VFGNode} *node){\bkmkstart AAAAAAADRF}
{\bkmkend AAAAAAADRF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericVFGNodeTy} *node){\bkmkstart AAAAAAADRG}
{\bkmkend AAAAAAADRG}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b PAGNode} * {\b res}{\bkmkstart AAAAAAADRH}
{\bkmkend AAAAAAADRH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

OPVers {\b opVers}{\bkmkstart AAAAAAADRI}
{\bkmkend AAAAAAADRI}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b VFGNode} for unary operator instructions, e.g., a = -b; \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::ValPN Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::ValPN}
{\xe \v SVF::ValPN}
{\bkmkstart AAAAAAACNA}
{\bkmkend AAAAAAACNA}
Inheritance diagram for SVF::ValPN:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_val_p_n.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ValPN} (const Value *val, NodeID i, {\b PNODEK} ty=ValNode){\bkmkstart AAAAAAACNB}
{\bkmkend AAAAAAACNB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::string {\b getValueName} () const{\bkmkstart AAAAAAACNC}
{\bkmkend AAAAAAACNC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of a LLVM value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACND}
{\bkmkend AAAAAAACND}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ValPN} *){\bkmkstart AAAAAAACNE}
{\bkmkend AAAAAAACNE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGNode} *node){\bkmkstart AAAAAAACNF}
{\bkmkend AAAAAAACNF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGNodeTy} *node){\bkmkstart AAAAAAACNG}
{\bkmkend AAAAAAACNG}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::VarArgPN Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::VarArgPN}
{\xe \v SVF::VarArgPN}
{\bkmkstart AAAAAAACPD}
{\bkmkend AAAAAAACPD}
Inheritance diagram for SVF::VarArgPN:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_var_arg_p_n.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VarArgPN} (const {\b SVFFunction} *val, NodeID i){\bkmkstart AAAAAAACPE}
{\bkmkend AAAAAAACPE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const std::string {\b getValueName} () const{\bkmkstart AAAAAAACPF}
{\bkmkend AAAAAAACPF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return name of a LLVM value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACPG}
{\bkmkend AAAAAAACPG}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VarArgPN} *){\bkmkstart AAAAAAACPH}
{\bkmkend AAAAAAACPH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGNode} *node){\bkmkstart AAAAAAACPI}
{\bkmkend AAAAAAACPI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGNodeTy} *node){\bkmkstart AAAAAAACPJ}
{\bkmkend AAAAAAACPJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::VariantGepCGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::VariantGepCGEdge}
{\xe \v SVF::VariantGepCGEdge}
{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
\par
{
{\f2 #include <ConsGEdge.h>}}\par
Inheritance diagram for SVF::VariantGepCGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_variant_gep_c_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VariantGepCGEdge} ({\b ConstraintNode} *s, {\b ConstraintNode} *d, EdgeID id){\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VariantGepCGEdge} *){\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GepCGEdge} *edge){\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b ConstraintEdge} *edge){\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericConsEdgeTy} *edge){\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gep edge with variant offset size \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/ConsGEdge.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::VariantGepPE Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::VariantGepPE}
{\xe \v SVF::VariantGepPE}
{\bkmkstart AAAAAAACKM}
{\bkmkend AAAAAAACKM}
\par
{
{\f2 #include <PAGEdge.h>}}\par
Inheritance diagram for SVF::VariantGepPE:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_variant_gep_p_e.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VariantGepPE} ({\b PAGNode} *s, {\b PAGNode} *d){\bkmkstart AAAAAAACKN}
{\bkmkend AAAAAAACKN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAACKO}
{\bkmkend AAAAAAACKO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VariantGepPE} *){\bkmkstart AAAAAAACKP}
{\bkmkend AAAAAAACKP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods for support type inquiry through isa, cast, and dyn_cast: }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GepPE} *edge){\bkmkstart AAAAAAACKQ}
{\bkmkend AAAAAAACKQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PAGEdge} *edge){\bkmkstart AAAAAAACKR}
{\bkmkend AAAAAAACKR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b GenericPAGEdgeTy} *edge){\bkmkstart AAAAAAACKS}
{\bkmkend AAAAAAACKS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gep edge with a variant offset \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/PAGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/PAG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::VersionedFlowSensitive Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::VersionedFlowSensitive}
{\xe \v SVF::VersionedFlowSensitive}
{\bkmkstart AAAAAAAHYU}
{\bkmkend AAAAAAAHYU}
\par
{
{\f2 #include <VersionedFlowSensitive.h>}}\par
Inheritance diagram for SVF::VersionedFlowSensitive:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_versioned_flow_sensitive.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b VersionType} \{ {\b CONSUME}
, {\b YIELD}
 \}{\bkmkstart AAAAAAAHYV}
{\bkmkend AAAAAAAHYV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, Version > {\b ObjToVersionMap}{\bkmkstart AAAAAAAHYW}
{\bkmkend AAAAAAAHYW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, MeldVersion > {\b ObjToMeldVersionMap}{\bkmkstart AAAAAAAHYX}
{\bkmkend AAAAAAAHYX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, ObjToVersionMap > {\b LocVersionMap}{\bkmkstart AAAAAAAHYY}
{\bkmkend AAAAAAAHYY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, ObjToMeldVersionMap > {\b LocMeldVersionMap}{\bkmkstart AAAAAAAHYZ}
{\bkmkend AAAAAAAHYZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Maps locations to all versions it sees (through objects). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, Map< Version, Set< Version > > > {\b VersionRelianceMap}{\bkmkstart AAAAAAAHZA}
{\bkmkend AAAAAAAHZA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
(o -> (v -> versions with rely on o:v). }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VersionedFlowSensitive} ({\b PAG} *_pag, {\b PTATY} type={\b VFS_WPA}){\bkmkstart AAAAAAAHZB}
{\bkmkend AAAAAAAHZB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b initialize} () override{\bkmkstart AAAAAAAEQC}
{\bkmkend AAAAAAAEQC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b finalize} () override{\bkmkstart AAAAAAAEPR}
{\bkmkend AAAAAAAEPR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finalize analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b PTAName} () const override{\bkmkstart AAAAAAAHZC}
{\bkmkend AAAAAAAHZC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get PTA name. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static VersionedVar {\b atKey} (NodeID, Version){\bkmkstart AAAAAAAHZD}
{\bkmkend AAAAAAAHZD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return key into vPtD for address-taken var of a specific version. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b VersionedFlowSensitive} *){\bkmkstart AAAAAAAHZE}
{\bkmkend AAAAAAAHZE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods to support type inquiry through isa, cast, and dyn_cast. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PointerAnalysis} *pta){\bkmkstart AAAAAAAHZF}
{\bkmkend AAAAAAAHZF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b VersionedFlowSensitive} * {\b createVFSWPA} ({\b PAG} *_pag){\bkmkstart AAAAAAAHZG}
{\bkmkend AAAAAAAHZG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create single instance of versioned flow-sensitive points-to analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b releaseVFSWPA} (){\bkmkstart AAAAAAAHZH}
{\bkmkend AAAAAAAHZH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Release flow-sensitive pointer analysis. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static const Version {\b invalidVersion} = 0{\bkmkstart AAAAAAAHZI}
{\bkmkend AAAAAAAHZI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this version appears, there has been an error. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processLoad} (const {\b LoadSVFGNode} *load) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b processStore} (const {\b StoreSVFGNode} *store) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b processNode} (NodeID n) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle various constraints. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b updateConnectedNodes} (const SVFGEdgeSetTy &newEdges) override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update nodes connected during updating call graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b propAlongIndirectEdge} (const {\b IndirectSVFGEdge} *edge) override{\bkmkstart AAAAAAAHWW}
{\bkmkend AAAAAAAHWW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Override to do nothing. Instead, we will use propagateVersion when necessary. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

class {\b VersionedFlowSensitiveStat}{\bkmkstart AAAAAAAHZJ}
{\bkmkend AAAAAAAHZJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Versioned flow sensitive whole program pointer analysis \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v processLoad\:SVF::VersionedFlowSensitive}
{\xe \v SVF::VersionedFlowSensitive\:processLoad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VersionedFlowSensitive::processLoad (const {\b LoadSVFGNode} *  {\i load}){\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWH}
{\bkmkend AAAAAAAHWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process load node\par
Foreach node \\in src pts(dst) = union pts(node) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If o is a field-insensitive object, we should also get all field nodes' points-to sets and pass them to p.\par
If the ptd is a field-insensitive node, we should also get all field nodes' points-to sets and pass them to pagDst.\par
}{
Reimplemented from {\b SVF::FlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processNode\:SVF::VersionedFlowSensitive}
{\xe \v SVF::VersionedFlowSensitive\:processNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VersionedFlowSensitive::processNode (NodeID  {\i nodeId}){\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWK}
{\bkmkend AAAAAAAHWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handle various constraints. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process each {\b SVFG} node \par
}{
Reimplemented from {\b SVF::FlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v processStore\:SVF::VersionedFlowSensitive}
{\xe \v SVF::VersionedFlowSensitive\:processStore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool VersionedFlowSensitive::processStore (const {\b StoreSVFGNode} *  {\i store}){\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHWO}
{\bkmkend AAAAAAAHWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process store node\par
foreach node \\in dst pts(node) = union pts(src) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STORE statement can only be processed if the pointer on the LHS points to something. If we handle STORE with an empty points-to set, the OUT set will be updated from IN set. Then if LHS pointer points-to one target and it has been identified as a strong update, we can't remove those points-to information computed before this strong update from the OUT set.\par
check if this is a strong updates store\par
}{
Reimplemented from {\b SVF::FlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v updateConnectedNodes\:SVF::VersionedFlowSensitive}
{\xe \v SVF::VersionedFlowSensitive\:updateConnectedNodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VersionedFlowSensitive::updateConnectedNodes (const SVFGEdgeSetTy &  {\i edges}){\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHXF}
{\bkmkend AAAAAAAHXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update nodes connected during updating call graph. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push nodes connected during update call graph into worklist so they will be solved during next iteration. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If this is a formal-param or actual-ret node, we need to solve this phi node in next iteration\par
If this is a formal-in or actual-out node, we need to propagate points-to information from its predecessor node.\par
If this is a field-insensitive obj, propagate all field node's pts\par
}{
Reimplemented from {\b SVF::FlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHXE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/VersionedFlowSensitive.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/VersionedFlowSensitive.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::VersionedFlowSensitiveStat Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::VersionedFlowSensitiveStat}
{\xe \v SVF::VersionedFlowSensitiveStat}
{\bkmkstart AAAAAAAIDB}
{\bkmkend AAAAAAAIDB}
Inheritance diagram for SVF::VersionedFlowSensitiveStat:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_versioned_flow_sensitive_stat.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VersionedFlowSensitiveStat} ({\b VersionedFlowSensitive} *pta){\bkmkstart AAAAAAAIDC}
{\bkmkend AAAAAAAIDC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b performStat} (){\bkmkstart AAAAAAAIDD}
{\bkmkend AAAAAAAIDD}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VersionedFlowSensitive} * {\b vfspta}{\bkmkstart AAAAAAAIDE}
{\bkmkend AAAAAAAIDE}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/WPAStat.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/VersionedFlowSensitiveStat.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::VersionedPTData< Key, Datum, Data, VersionedKey > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::VersionedPTData< Key, Datum, Data, VersionedKey >}
{\xe \v SVF::VersionedPTData< Key, Datum, Data, VersionedKey >}
{\bkmkstart AAAAAAADXS}
{\bkmkend AAAAAAADXS}
\par
{
{\f2 #include <AbstractPointsToDS.h>}}\par
Inheritance diagram for SVF::VersionedPTData< Key, Datum, Data, VersionedKey >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_versioned_p_t_data.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b PTData}< Key, Datum, Data > {\b BasePTData}{\bkmkstart AAAAAAADXT}
{\bkmkend AAAAAAADXT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b BasePTData::PTDataTy} {\b PTDataTy}{\bkmkstart AAAAAAADXU}
{\bkmkend AAAAAAADXU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef BasePTData::KeySet {\b KeySet}{\bkmkstart AAAAAAADXV}
{\bkmkend AAAAAAADXV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< VersionedKey > {\b VersionedKeySet}{\bkmkstart AAAAAAADXW}
{\bkmkend AAAAAAADXW}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VersionedPTData} (bool reversePT=true, {\b PTDataTy} ty=PTDataTy::Versioned){\bkmkstart AAAAAAADXX}
{\bkmkend AAAAAAADXX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const Data & {\b getPts} (const VersionedKey &vk)=0{\bkmkstart AAAAAAADXY}
{\bkmkend AAAAAAADXY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const VersionedKeySet & {\b getVersionedKeyRevPts} (const Datum &datum)=0{\bkmkstart AAAAAAADXZ}
{\bkmkend AAAAAAADXZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b addPts} (const VersionedKey &vk, const Datum &element)=0{\bkmkstart AAAAAAADYA}
{\bkmkend AAAAAAADYA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const VersionedKey &dstVar, const VersionedKey &srcVar)=0{\bkmkstart AAAAAAADYB}
{\bkmkend AAAAAAADYB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const VersionedKey &dstVar, const Key &srcVar)=0{\bkmkstart AAAAAAADYC}
{\bkmkend AAAAAAADYC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const Key &dstVar, const VersionedKey &srcVar)=0{\bkmkstart AAAAAAADYD}
{\bkmkend AAAAAAADYD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b unionPts} (const VersionedKey &dstVar, const Data &srcData)=0{\bkmkstart AAAAAAADYE}
{\bkmkend AAAAAAADYE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearPts} (const VersionedKey &vk, const Datum &element)=0{\bkmkstart AAAAAAADYF}
{\bkmkend AAAAAAADYF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b clearFullPts} (const VersionedKey &vk)=0{\bkmkstart AAAAAAADYG}
{\bkmkend AAAAAAADYG}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b classof} (const {\b VersionedPTData}< Key, Datum, Data, VersionedKey > *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static bool {\b classof} (const {\b PTData}< Key, Datum, Data > *ptd){\bkmkstart AAAAAAADYH}
{\bkmkend AAAAAAADYH}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Key, typename Datum, typename Data, typename VersionedKey>\par
class SVF::VersionedPTData< Key, Datum, Data, VersionedKey >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b PTData} with normal keys and versioned keys. Replicates the {\b PTData} interface for versioned keys too. Intended to be used for versioned flow-sensitive PTA\'96hence the name\'96but can be used anywhere where there are two types of keys at play. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v classof\:SVF::VersionedPTData< Key, Datum, Data, VersionedKey >}
{\xe \v SVF::VersionedPTData< Key, Datum, Data, VersionedKey >\:classof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Key , typename Datum , typename Data , typename VersionedKey > static bool {\b SVF::VersionedPTData}< Key, Datum, Data, VersionedKey >::classof (const {\b VersionedPTData}< Key, Datum, Data, VersionedKey > * ){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAADYI}
{\bkmkend AAAAAAADYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Methods to support type inquiry through isa, cast, and dyn_cast: \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/MemoryModel/AbstractPointsToDS.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::VFG Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::VFG}
{\xe \v SVF::VFG}
{\bkmkstart AAAAAAADHK}
{\bkmkend AAAAAAADHK}
Inheritance diagram for SVF::VFG:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_v_f_g.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b VFGK} \{ {\b ORIGSVFGK}
, {\b PTRONLYSVFGK}
 \}{\bkmkstart AAAAAAADHL}
{\bkmkend AAAAAAADHL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b VFG} kind. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< NodeID, {\b VFGNode} * > {\b VFGNodeIDToNodeMapTy}{\bkmkstart AAAAAAADHM}
{\bkmkend AAAAAAADHM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< {\b VFGNode} * > {\b VFGNodeSet}{\bkmkstart AAAAAAADHN}
{\bkmkend AAAAAAADHN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b PAGNode} *, NodeID > {\b PAGNodeToDefMapTy}{\bkmkstart AAAAAAADHO}
{\bkmkend AAAAAAADHO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< std::pair< NodeID, const {\b CallBlockNode} * >, {\b ActualParmVFGNode} * > {\b PAGNodeToActualParmMapTy}{\bkmkstart AAAAAAADHP}
{\bkmkend AAAAAAADHP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b PAGNode} *, {\b ActualRetVFGNode} * > {\b PAGNodeToActualRetMapTy}{\bkmkstart AAAAAAADHQ}
{\bkmkend AAAAAAADHQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b PAGNode} *, {\b FormalParmVFGNode} * > {\b PAGNodeToFormalParmMapTy}{\bkmkstart AAAAAAADHR}
{\bkmkend AAAAAAADHR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b PAGNode} *, {\b FormalRetVFGNode} * > {\b PAGNodeToFormalRetMapTy}{\bkmkstart AAAAAAADHS}
{\bkmkend AAAAAAADHS}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b PAGEdge} *, {\b StmtVFGNode} * > {\b PAGEdgeToStmtVFGNodeMapTy}{\bkmkstart AAAAAAADHT}
{\bkmkend AAAAAAADHT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b PAGNode} *, {\b IntraPHIVFGNode} * > {\b PAGNodeToPHIVFGNodeMapTy}{\bkmkstart AAAAAAADHU}
{\bkmkend AAAAAAADHU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b PAGNode} *, {\b BinaryOPVFGNode} * > {\b PAGNodeToBinaryOPVFGNodeMapTy}{\bkmkstart AAAAAAADHV}
{\bkmkend AAAAAAADHV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b PAGNode} *, {\b UnaryOPVFGNode} * > {\b PAGNodeToUnaryOPVFGNodeMapTy}{\bkmkstart AAAAAAADHW}
{\bkmkend AAAAAAADHW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b PAGNode} *, {\b CmpVFGNode} * > {\b PAGNodeToCmpVFGNodeMapTy}{\bkmkstart AAAAAAADHX}
{\bkmkend AAAAAAADHX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Map< const {\b SVFFunction} *, VFGNodeSet > {\b FunToVFGNodesMapTy}{\bkmkstart AAAAAAADHY}
{\bkmkend AAAAAAADHY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef FormalParmVFGNode::CallPESet {\b CallPESet}{\bkmkstart AAAAAAADHZ}
{\bkmkend AAAAAAADHZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef FormalRetVFGNode::RetPESet {\b RetPESet}{\bkmkstart AAAAAAADIA}
{\bkmkend AAAAAAADIA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef VFGEdge::VFGEdgeSetTy {\b VFGEdgeSetTy}{\bkmkstart AAAAAAADIB}
{\bkmkend AAAAAAADIB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef VFGEdge::SVFGEdgeSetTy {\b SVFGEdgeSetTy}{\bkmkstart AAAAAAADIC}
{\bkmkend AAAAAAADIC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef VFGEdge::VFGEdgeSetTy::iterator {\b VFGNodeIter}{\bkmkstart AAAAAAADID}
{\bkmkend AAAAAAADID}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef VFGNodeIDToNodeMapTy::iterator {\b iterator}{\bkmkstart AAAAAAADIE}
{\bkmkend AAAAAAADIE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef VFGNodeIDToNodeMapTy::const_iterator {\b const_iterator}{\bkmkstart AAAAAAADIF}
{\bkmkend AAAAAAADIF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef PAG::PAGEdgeSet {\b PAGEdgeSet}{\bkmkstart AAAAAAADIG}
{\bkmkend AAAAAAADIG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b VFGNode} * > {\b GlobalVFGNodeSet}{\bkmkstart AAAAAAADIH}
{\bkmkend AAAAAAADIH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b PAGNode} * > {\b PAGNodeSet}{\bkmkstart AAAAAAADII}
{\bkmkend AAAAAAADII}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VFG} ({\b PTACallGraph} *callgraph, {\b VFGK} k=ORIGSVFGK)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~VFG} (){\bkmkstart AAAAAAADIJ}
{\bkmkend AAAAAAADIJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VFGK} {\b getKind} () const{\bkmkstart AAAAAAADIK}
{\bkmkend AAAAAAADIK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b VFG} kind. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isPtrOnlySVFG} () const{\bkmkstart AAAAAAADIL}
{\bkmkend AAAAAAADIL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return true if this {\b VFG} only contains pointer related SVFGNodes for pointer analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setDumpVFG} (bool flag){\bkmkstart AAAAAAADIM}
{\bkmkend AAAAAAADIM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether to dump {\b VFG};. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b getDumpVFG} () const{\bkmkstart AAAAAAADIN}
{\bkmkend AAAAAAADIN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether to dump {\b VFG};. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAG} * {\b getPAG} () const{\bkmkstart AAAAAAADIO}
{\bkmkend AAAAAAADIO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return {\b PAG}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTACallGraph} * {\b getCallGraph} () const{\bkmkstart AAAAAAADIP}
{\bkmkend AAAAAAADIP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return CallGraph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VFGNode} * {\b getVFGNode} (NodeID id) const{\bkmkstart AAAAAAADIQ}
{\bkmkend AAAAAAADIQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a {\b VFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasVFGNode} (NodeID id) const{\bkmkstart AAAAAAADIR}
{\bkmkend AAAAAAADIR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether has the {\b VFGNode}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

GlobalVFGNodeSet & {\b getGlobalVFGNodes} (){\bkmkstart AAAAAAADIS}
{\bkmkend AAAAAAADIS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return global stores. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VFGEdge} * {\b getVFGEdge} (const {\b VFGNode} *src, const {\b VFGNode} *dst, {\b VFGEdge::VFGEdgeK} kind)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a {\b SVFG} edge according to src and dst. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump} (const std::string &file, bool simple=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump graph into dot file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b updateCallGraph} ({\b PointerAnalysis} *pta){\bkmkstart AAAAAAADIT}
{\bkmkend AAAAAAADIT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update {\b VFG} based on pointer analysis results. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b connectCallerAndCallee} (const {\b CallBlockNode} *cs, const {\b SVFFunction} *callee, VFGEdgeSetTy &edges)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect {\b VFG} nodes between caller and callee for indirect call site. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

CallSiteID {\b getCallSiteID} (const {\b CallBlockNode} *cs, const {\b SVFFunction} *func) const{\bkmkstart AAAAAAADIU}
{\bkmkend AAAAAAADIU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get callsite given a callsiteID. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b CallBlockNode} * {\b getCallSite} (CallSiteID id) const{\bkmkstart AAAAAAADIV}
{\bkmkend AAAAAAADIV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b VFGNode} * {\b getDefVFGNode} (const {\b PAGNode} *pagNode) const{\bkmkstart AAAAAAADIW}
{\bkmkend AAAAAAADIW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a pagNode, return its definition site. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b PAGNode} * {\b getLHSTopLevPtr} (const {\b VFGNode} *node) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b StmtVFGNode} * {\b getStmtVFGNode} (const {\b PAGEdge} *pagEdge) const{\bkmkstart AAAAAAADIX}
{\bkmkend AAAAAAADIX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get an {\b VFGNode}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b IntraPHIVFGNode} * {\b getIntraPHIVFGNode} (const {\b PAGNode} *pagNode) const{\bkmkstart AAAAAAADIY}
{\bkmkend AAAAAAADIY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b BinaryOPVFGNode} * {\b getBinaryOPVFGNode} (const {\b PAGNode} *pagNode) const{\bkmkstart AAAAAAADIZ}
{\bkmkend AAAAAAADIZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b UnaryOPVFGNode} * {\b getUnaryOPVFGNode} (const {\b PAGNode} *pagNode) const{\bkmkstart AAAAAAADJA}
{\bkmkend AAAAAAADJA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b CmpVFGNode} * {\b getCmpVFGNode} (const {\b PAGNode} *pagNode) const{\bkmkstart AAAAAAADJB}
{\bkmkend AAAAAAADJB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ActualParmVFGNode} * {\b getActualParmVFGNode} (const {\b PAGNode} *aparm, const {\b CallBlockNode} *cs) const{\bkmkstart AAAAAAADJC}
{\bkmkend AAAAAAADJC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ActualRetVFGNode} * {\b getActualRetVFGNode} (const {\b PAGNode} *aret) const{\bkmkstart AAAAAAADJD}
{\bkmkend AAAAAAADJD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FormalParmVFGNode} * {\b getFormalParmVFGNode} (const {\b PAGNode} *fparm) const{\bkmkstart AAAAAAADJE}
{\bkmkend AAAAAAADJE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b FormalRetVFGNode} * {\b getFormalRetVFGNode} (const {\b PAGNode} *fret) const{\bkmkstart AAAAAAADJF}
{\bkmkend AAAAAAADJF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b SVFFunction} * {\b isFunEntryVFGNode} (const {\b VFGNode} *node) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a node is function entry {\b VFGNode}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasBlackHoleConstObjAddrAsDef} (const {\b PAGNode} *pagNode) const{\bkmkstart AAAAAAADJG}
{\bkmkend AAAAAAADJG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a {\b PAGNode} has a blackhole or const object as its definition. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VFGEdge} * {\b addIntraDirectVFEdge} (NodeID srcId, NodeID dstId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VFGEdge} * {\b addCallEdge} (NodeID srcId, NodeID dstId, CallSiteID csId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VFGEdge} * {\b addRetEdge} (NodeID srcId, NodeID dstId, CallSiteID csId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeVFGEdge} ({\b VFGEdge} *edge){\bkmkstart AAAAAAADJH}
{\bkmkend AAAAAAADJH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove a {\b SVFG} edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b removeVFGNode} ({\b VFGNode} *node){\bkmkstart AAAAAAADJI}
{\bkmkend AAAAAAADJI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remove a {\b VFGNode}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VFGEdge} * {\b hasIntraVFGEdge} ({\b VFGNode} *src, {\b VFGNode} *dst, {\b VFGEdge::VFGEdgeK} kind)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we has a {\b SVFG} edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VFGEdge} * {\b hasInterVFGEdge} ({\b VFGNode} *src, {\b VFGNode} *dst, {\b VFGEdge::VFGEdgeK} kind, CallSiteID csId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VFGEdge} * {\b hasThreadVFGEdge} ({\b VFGNode} *src, {\b VFGNode} *dst, {\b VFGEdge::VFGEdgeK} kind)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b addVFGEdge} ({\b VFGEdge} *edge){\bkmkstart AAAAAAADJJ}
{\bkmkend AAAAAAADJJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add {\b VFG} edge. }{
}\par
}\par}
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
VFGNodeSet & {\b getVFGNodes} (const {\b SVFFunction} *fun)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasVFGNodes} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAADJK}
{\bkmkend AAAAAAADJK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b VFGNodes} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAADJL}
{\bkmkend AAAAAAADJL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

VFGNodeSet::const_iterator {\b getVFGNodeBegin} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAADJM}
{\bkmkend AAAAAAADJM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

VFGNodeSet::const_iterator {\b getVFGNodeEnd} (const {\b SVFFunction} *fun) const{\bkmkstart AAAAAAADJN}
{\bkmkend AAAAAAADJN}
\par
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b destroy} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b checkIntraEdgeParents} (const {\b VFGNode} *srcNode, const {\b VFGNode} *dstNode){\bkmkstart AAAAAAADJO}
{\bkmkend AAAAAAADJO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sanitize Intra edges, verify that both nodes belong to the same function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VFGEdge} * {\b addInterEdgeFromAPToFP} ({\b ActualParmVFGNode} *src, {\b FormalParmVFGNode} *dst, CallSiteID csId){\bkmkstart AAAAAAADJP}
{\bkmkend AAAAAAADJP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add inter VF edge from actual to formal parameters. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VFGEdge} * {\b addInterEdgeFromFRToAR} ({\b FormalRetVFGNode} *src, {\b ActualRetVFGNode} *dst, CallSiteID csId){\bkmkstart AAAAAAADJQ}
{\bkmkend AAAAAAADJQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add inter VF edge from callee return to callsite receive parameter. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VFGEdge} * {\b addInterEdgeFromAPToFP} (NodeID src, NodeID dst, CallSiteID csId){\bkmkstart AAAAAAADJR}
{\bkmkend AAAAAAADJR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add inter VF edge from actual to formal parameters. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VFGEdge} * {\b addInterEdgeFromFRToAR} (NodeID src, NodeID dst, CallSiteID csId){\bkmkstart AAAAAAADJS}
{\bkmkend AAAAAAADJS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add inter VF edge from callee return to callsite receive parameter. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b connectAParamAndFParam} (const {\b PAGNode} *csArg, const {\b PAGNode} *funArg, const {\b CallBlockNode} *cbn, CallSiteID csId, VFGEdgeSetTy &edges)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect {\b VFG} nodes between caller and callee for indirect call site. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b connectFRetAndARet} (const {\b PAGNode} *funReturn, const {\b PAGNode} *csReturn, CallSiteID csId, VFGEdgeSetTy &edges){\bkmkstart AAAAAAADJT}
{\bkmkend AAAAAAADJT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect formal-ret and actual ret. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setDef} (const {\b PAGNode} *pagNode, const {\b VFGNode} *node){\bkmkstart AAAAAAADJU}
{\bkmkend AAAAAAADJU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a {\b PAGNode}, set/get its def {\b VFG} node (definition of top level pointers) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b getDef} (const {\b PAGNode} *pagNode) const{\bkmkstart AAAAAAADJV}
{\bkmkend AAAAAAADJV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasDef} (const {\b PAGNode} *pagNode) const{\bkmkstart AAAAAAADJW}
{\bkmkend AAAAAAADJW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addVFGNodes} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create {\b VFG} nodes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual PAGEdge::PAGEdgeSetTy & {\b getPAGEdgeSet} ({\b PAGEdge::PEDGEK} kind){\bkmkstart AAAAAAADJX}
{\bkmkend AAAAAAADJX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get {\b PAGEdge} set. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b isInterestedPAGNode} (const {\b PAGNode} *node) const{\bkmkstart AAAAAAADJY}
{\bkmkend AAAAAAADJY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b connectDirectVFGEdges} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create edges between {\b VFG} nodes within a function. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addVFGInterEdges} (const {\b CallBlockNode} *cs, const {\b SVFFunction} *callee){\bkmkstart AAAAAAADJZ}
{\bkmkend AAAAAAADJZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create edges between {\b VFG} nodes across functions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isPhiCopyEdge} (const {\b PAGEdge} *copy) const{\bkmkstart AAAAAAADKA}
{\bkmkend AAAAAAADKA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b addVFGNode} ({\b VFGNode} *vfgNode, {\b ICFGNode} *icfgNode){\bkmkstart AAAAAAADKB}
{\bkmkend AAAAAAADKB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a {\b VFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addStmtVFGNode} ({\b StmtVFGNode} *node, const {\b PAGEdge} *pagEdge){\bkmkstart AAAAAAADKC}
{\bkmkend AAAAAAADKC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a {\b VFG} node for program statement. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addNullPtrVFGNode} (const {\b PAGNode} *pagNode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addAddrVFGNode} (const {\b AddrPE} *addr){\bkmkstart AAAAAAADKD}
{\bkmkend AAAAAAADKD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add an Address {\b VFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addCopyVFGNode} (const {\b CopyPE} *copy){\bkmkstart AAAAAAADKE}
{\bkmkend AAAAAAADKE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a Copy {\b VFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addGepVFGNode} (const {\b GepPE} *gep){\bkmkstart AAAAAAADKF}
{\bkmkend AAAAAAADKF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a Gep {\b VFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addLoadVFGNode} (const {\b LoadPE} *load){\bkmkstart AAAAAAADKG}
{\bkmkend AAAAAAADKG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a Load {\b VFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addStoreVFGNode} (const {\b StorePE} *store)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addActualParmVFGNode} (const {\b PAGNode} *aparm, const {\b CallBlockNode} *cs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addFormalParmVFGNode} (const {\b PAGNode} *fparm, const {\b SVFFunction} *fun, CallPESet &callPEs){\bkmkstart AAAAAAADKH}
{\bkmkend AAAAAAADKH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a formal parameter {\b VFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addFormalRetVFGNode} (const {\b PAGNode} *uniqueFunRet, const {\b SVFFunction} *fun, RetPESet &retPEs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addActualRetVFGNode} (const {\b PAGNode} *ret, const {\b CallBlockNode} *cs){\bkmkstart AAAAAAADKI}
{\bkmkend AAAAAAADKI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a callsite Receive {\b VFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addIntraPHIVFGNode} (const {\b PAGNode} *phiResNode, PAG::CopyPEList &oplist){\bkmkstart AAAAAAADKJ}
{\bkmkend AAAAAAADKJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add an llvm PHI {\b VFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addCmpVFGNode} (const {\b PAGNode} *resNode, PAG::CmpPEList &oplist){\bkmkstart AAAAAAADKK}
{\bkmkend AAAAAAADKK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a Compare {\b VFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addBinaryOPVFGNode} (const {\b PAGNode} *resNode, PAG::BinaryOPList &oplist){\bkmkstart AAAAAAADKL}
{\bkmkend AAAAAAADKL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a BinaryOperator {\b VFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addUnaryOPVFGNode} (const {\b PAGNode} *resNode, PAG::UnaryOPList &oplist){\bkmkstart AAAAAAADKM}
{\bkmkend AAAAAAADKM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a UnaryOperator {\b VFG} node. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b totalVFGNode}{\bkmkstart AAAAAAADKN}
{\bkmkend AAAAAAADKN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGNodeToDefMapTy {\b PAGNodeToDefMap}{\bkmkstart AAAAAAADKO}
{\bkmkend AAAAAAADKO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a pag node to its definition SVG node }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGNodeToActualParmMapTy {\b PAGNodeToActualParmMap}{\bkmkstart AAAAAAADKP}
{\bkmkend AAAAAAADKP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a {\b PAGNode} to an actual parameter }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGNodeToActualRetMapTy {\b PAGNodeToActualRetMap}{\bkmkstart AAAAAAADKQ}
{\bkmkend AAAAAAADKQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a {\b PAGNode} to an actual return }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGNodeToFormalParmMapTy {\b PAGNodeToFormalParmMap}{\bkmkstart AAAAAAADKR}
{\bkmkend AAAAAAADKR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a {\b PAGNode} to a formal parameter }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGNodeToFormalRetMapTy {\b PAGNodeToFormalRetMap}{\bkmkstart AAAAAAADKS}
{\bkmkend AAAAAAADKS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a {\b PAGNode} to a formal return }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGNodeToPHIVFGNodeMapTy {\b PAGNodeToIntraPHIVFGNodeMap}{\bkmkstart AAAAAAADKT}
{\bkmkend AAAAAAADKT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a {\b PAGNode} to its {\b PHIVFGNode} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGNodeToBinaryOPVFGNodeMapTy {\b PAGNodeToBinaryOPVFGNodeMap}{\bkmkstart AAAAAAADKU}
{\bkmkend AAAAAAADKU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a {\b PAGNode} to its {\b BinaryOPVFGNode} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGNodeToUnaryOPVFGNodeMapTy {\b PAGNodeToUnaryOPVFGNodeMap}{\bkmkstart AAAAAAADKV}
{\bkmkend AAAAAAADKV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a {\b PAGNode} to its {\b UnaryOPVFGNode} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGNodeToCmpVFGNodeMapTy {\b PAGNodeToCmpVFGNodeMap}{\bkmkstart AAAAAAADKW}
{\bkmkend AAAAAAADKW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a {\b PAGNode} to its {\b CmpVFGNode} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

PAGEdgeToStmtVFGNodeMapTy {\b PAGEdgeToStmtVFGNodeMap}{\bkmkstart AAAAAAADKX}
{\bkmkend AAAAAAADKX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a {\b PAGEdge} to its {\b StmtVFGNode} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

FunToVFGNodesMapTy {\b funToVFGNodesMap}{\bkmkstart AAAAAAADKY}
{\bkmkend AAAAAAADKY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
map a function to its VFGNodes; }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

GlobalVFGNodeSet {\b globalVFGNodes}{\bkmkstart AAAAAAADKZ}
{\bkmkend AAAAAAADKZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set of global store {\b VFG} nodes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PTACallGraph} * {\b callgraph}{\bkmkstart AAAAAAADLA}
{\bkmkend AAAAAAADLA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PAG} * {\b pag}{\bkmkstart AAAAAAADLB}
{\bkmkend AAAAAAADLB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VFGK} {\b kind}{\bkmkstart AAAAAAADLC}
{\bkmkend AAAAAAADLC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b dumpVFG}{\bkmkstart AAAAAAADLD}
{\bkmkend AAAAAAADLD}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v VFG\:SVF::VFG}
{\xe \v SVF::VFG\:VFG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
VFG::VFG ({\b PTACallGraph} *  {\i cg}, {\b VFGK}  {\i k} = {\f2 ORIGSVFGK})}}
\par
{\bkmkstart AAAAAAADLE}
{\bkmkend AAAAAAADLE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Build {\b VFG} 1) build {\b VFG} nodes statements for top level pointers (PAGEdges) 2) connect {\b VFG} edges between two statements (PAGEdges) \par}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addActualParmVFGNode\:SVF::VFG}
{\xe \v SVF::VFG\:addActualParmVFGNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVF::VFG::addActualParmVFGNode (const {\b PAGNode} *  {\i aparm}, const {\b CallBlockNode} *  {\i cs}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADLF}
{\bkmkend AAAAAAADLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add an actual parameter {\b VFG} node To be noted that multiple actual parameters may have same value ({\b PAGNode}) So we need to make a pair <PAGNodeID,CallSiteID> to find the right VFGParmNode \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
do not set def here, this node is not a variable definition\par
}}
{\xe \v addCallEdge\:SVF::VFG}
{\xe \v SVF::VFG\:addCallEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b VFGEdge} * VFG::addCallEdge (NodeID  {\i srcId}, NodeID  {\i dstId}, CallSiteID  {\i csId})}}
\par
{\bkmkstart AAAAAAADLG}
{\bkmkend AAAAAAADLG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add interprocedural call edges for top level pointers \par
}}
{\xe \v addFormalRetVFGNode\:SVF::VFG}
{\xe \v SVF::VFG\:addFormalRetVFGNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVF::VFG::addFormalRetVFGNode (const {\b PAGNode} *  {\i uniqueFunRet}, const {\b SVFFunction} *  {\i fun}, RetPESet &  {\i retPEs}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADLH}
{\bkmkend AAAAAAADLH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a callee Return {\b VFG} node To be noted that here we assume returns of a procedure have already been unified into one Otherwise, we need to handle formalRet using <PAGNodeID,CallSiteID> pair to find FormalRetVFG node same as handling actual parameters \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
if this uniqueFunRet is a phi node, which means it will receive values from multiple return instructions of fun we will set this phi node's def later\par
}}
{\xe \v addIntraDirectVFEdge\:SVF::VFG}
{\xe \v SVF::VFG\:addIntraDirectVFEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b VFGEdge} * VFG::addIntraDirectVFEdge (NodeID  {\i srcId}, NodeID  {\i dstId})}}
\par
{\bkmkstart AAAAAAADLI}
{\bkmkend AAAAAAADLI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add control-flow edges for top level pointers\par
Add def-use edges for top level pointers \par
}}
{\xe \v addNullPtrVFGNode\:SVF::VFG}
{\xe \v SVF::VFG\:addNullPtrVFGNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVF::VFG::addNullPtrVFGNode (const {\b PAGNode} *  {\i pagNode}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADLJ}
{\bkmkend AAAAAAADLJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a Dummy {\b VFG} node for null pointer definition To be noted for black hole pointer it has already has address edge connected \par
}}
{\xe \v addRetEdge\:SVF::VFG}
{\xe \v SVF::VFG\:addRetEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b VFGEdge} * VFG::addRetEdge (NodeID  {\i srcId}, NodeID  {\i dstId}, CallSiteID  {\i csId})}}
\par
{\bkmkstart AAAAAAADLK}
{\bkmkend AAAAAAADLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add interprocedural return edges for top level pointers \par
}}
{\xe \v addStoreVFGNode\:SVF::VFG}
{\xe \v SVF::VFG\:addStoreVFGNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SVF::VFG::addStoreVFGNode (const {\b StorePE} *  {\i store}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADLL}
{\bkmkend AAAAAAADLL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a Store {\b VFG} node, To be noted store does not create a new pointer, we do not set def for any {\b PAG} node \par
}}
{\xe \v addVFGNodes\:SVF::VFG}
{\xe \v SVF::VFG\:addVFGNodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VFG::addVFGNodes (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADLM}
{\bkmkend AAAAAAADLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create {\b VFG} nodes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create {\b VFG} nodes for top level pointers \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
for external function we do not create acutalRet {\b VFGNode} they are in the formal of {\b AddrVFGNode} if the external function returns an allocated memory if fun has body, it may also exist in isExtCall, e.g., xmalloc() in bzip2, spec2000.\par
}}
{\xe \v connectAParamAndFParam\:SVF::VFG}
{\xe \v SVF::VFG\:connectAParamAndFParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void SVF::VFG::connectAParamAndFParam (const {\b PAGNode} *  {\i csArg}, const {\b PAGNode} *  {\i funArg}, const {\b CallBlockNode} *  {\i cbn}, CallSiteID  {\i csId}, VFGEdgeSetTy &  {\i edges}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAADLN}
{\bkmkend AAAAAAADLN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect {\b VFG} nodes between caller and callee for indirect call site. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect actual-param and formal param \par
}{
Reimplemented in {\b SVF::SVFGOPT} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAADCN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v connectCallerAndCallee\:SVF::VFG}
{\xe \v SVF::VFG\:connectCallerAndCallee}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VFG::connectCallerAndCallee (const {\b CallBlockNode} *  {\i callBlockNode}, const {\b SVFFunction} *  {\i callee}, VFGEdgeSetTy &  {\i edges}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACXM}
{\bkmkend AAAAAAACXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect {\b VFG} nodes between caller and callee for indirect call site. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect actual params/return to formal params/return for top-level variables. Also connect indirect actual in/out and formal in/out. \par
}{
Reimplemented in {\b SVF::SVFG} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACXL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v connectDirectVFGEdges\:SVF::VFG}
{\xe \v SVF::VFG\:connectDirectVFGEdges}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VFG::connectDirectVFGEdges (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADLO}
{\bkmkend AAAAAAADLO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create edges between {\b VFG} nodes within a function. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Connect def-use chains for direct value-flow, (value-flow of top level pointers) \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
do not handle AddrSVFG node, as it is already the source of a definition\par
for all other cases, like copy/gep/load/ret, connect the RHS pointer to its def\par
for store, connect the RHS/LHS pointer to its def\par
connect formal ret to its definition node\par
connect formal ret to actual ret\par
Do not process {\b FormalRetVFGNode}, as they are connected by copy within callee We assume one procedure only has unique return\par
connect direct value-flow edges (parameter passing) for thread fork/join add fork edge\par
add join edge\par
}}
{\xe \v destroy\:SVF::VFG}
{\xe \v SVF::VFG\:destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VFG::destroy (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAADLP}
{\bkmkend AAAAAAADLP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clean up memory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Memory has been cleaned up at {\b GenericGraph} \par
}}
{\xe \v dump\:SVF::VFG}
{\xe \v SVF::VFG\:dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void VFG::dump (const std::string &  {\i file}, bool  {\i simple} = {\f2 false})}}
\par
{\bkmkstart AAAAAAADLQ}
{\bkmkend AAAAAAADLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump graph into dot file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump {\b VFG} \par
}}
{\xe \v getLHSTopLevPtr\:SVF::VFG}
{\xe \v SVF::VFG\:getLHSTopLevPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b PAGNode} * VFG::getLHSTopLevPtr (const {\b VFGNode} *  {\i node}) const}}
\par
{\bkmkstart AAAAAAADLR}
{\bkmkend AAAAAAADLR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a {\b VFG} node, return its left hand side top level pointer \par
}}
{\xe \v getVFGEdge\:SVF::VFG}
{\xe \v SVF::VFG\:getVFGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b VFGEdge} * VFG::getVFGEdge (const {\b VFGNode} *  {\i src}, const {\b VFGNode} *  {\i dst}, {\b VFGEdge::VFGEdgeK}  {\i kind})}}
\par
{\bkmkstart AAAAAAADLS}
{\bkmkend AAAAAAADLS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a {\b SVFG} edge according to src and dst. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the corresponding {\b VFGEdge} \par
}}
{\xe \v getVFGNodes\:SVF::VFG}
{\xe \v SVF::VFG\:getVFGNodes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
VFGNodeSet& SVF::VFG::getVFGNodes (const {\b SVFFunction} *  {\i fun}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAADLT}
{\bkmkend AAAAAAADLT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return all the VFGNodes of a function \par
}}
{\xe \v hasInterVFGEdge\:SVF::VFG}
{\xe \v SVF::VFG\:hasInterVFGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b VFGEdge} * VFG::hasInterVFGEdge ({\b VFGNode} *  {\i src}, {\b VFGNode} *  {\i dst}, {\b VFGEdge::VFGEdgeK}  {\i kind}, CallSiteID  {\i csId})}}
\par
{\bkmkstart AAAAAAADLU}
{\bkmkend AAAAAAADLU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we has an inter {\b VFG} edge \par
}}
{\xe \v hasIntraVFGEdge\:SVF::VFG}
{\xe \v SVF::VFG\:hasIntraVFGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b VFGEdge} * VFG::hasIntraVFGEdge ({\b VFGNode} *  {\i src}, {\b VFGNode} *  {\i dst}, {\b VFGEdge::VFGEdgeK}  {\i kind})}}
\par
{\bkmkstart AAAAAAADLV}
{\bkmkend AAAAAAADLV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we has a {\b SVFG} edge. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we has an intra {\b VFG} edge \par
}}
{\xe \v hasThreadVFGEdge\:SVF::VFG}
{\xe \v SVF::VFG\:hasThreadVFGEdge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b VFGEdge} * VFG::hasThreadVFGEdge ({\b VFGNode} *  {\i src}, {\b VFGNode} *  {\i dst}, {\b VFGEdge::VFGEdgeK}  {\i kind})}}
\par
{\bkmkstart AAAAAAADLW}
{\bkmkend AAAAAAADLW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether we has an thread {\b VFG} edge \par
}}
{\xe \v isFunEntryVFGNode\:SVF::VFG}
{\xe \v SVF::VFG\:isFunEntryVFGNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b SVFFunction} * VFG::isFunEntryVFGNode (const {\b VFGNode} *  {\i node}) const}}
\par
{\bkmkstart AAAAAAADLX}
{\bkmkend AAAAAAADLX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether a node is function entry {\b VFGNode}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether this is an function entry {\b VFGNode} (formal parameter, formal In) \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFG.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::VFGEdge Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::VFGEdge}
{\xe \v SVF::VFGEdge}
{\bkmkstart AAAAAAADLY}
{\bkmkend AAAAAAADLY}
Inheritance diagram for SVF::VFGEdge:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_v_f_g_edge.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b VFGEdgeK} \{ {\b IntraDirectVF}
, {\b IntraIndirectVF}
, {\b CallDirVF}
, {\b RetDirVF}
, {\b CallIndVF}
, {\b RetIndVF}
, {\b TheadMHPIndirectVF}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b VFGEdgeK} {\b SVFGEdgeK}{\bkmkstart AAAAAAADLZ}
{\bkmkend AAAAAAADLZ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b GenericNode}< {\b VFGNode}, {\b VFGEdge} >::GEdgeSetTy {\b VFGEdgeSetTy}{\bkmkstart AAAAAAADMA}
{\bkmkend AAAAAAADMA}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef VFGEdgeSetTy {\b SVFGEdgeSetTy}{\bkmkstart AAAAAAADMB}
{\bkmkend AAAAAAADMB}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VFGEdge} ({\b VFGNode} *s, {\b VFGNode} *d, {\b GEdgeFlag} k){\bkmkstart AAAAAAADMC}
{\bkmkend AAAAAAADMC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ~VFGEdge} (){\bkmkstart AAAAAAADMD}
{\bkmkend AAAAAAADMD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isDirectVFGEdge} () const{\bkmkstart AAAAAAADME}
{\bkmkend AAAAAAADME}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get methods of the components. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isIndirectVFGEdge} () const{\bkmkstart AAAAAAADMF}
{\bkmkend AAAAAAADMF}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isCallVFGEdge} () const{\bkmkstart AAAAAAADMG}
{\bkmkend AAAAAAADMG}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isRetVFGEdge} () const{\bkmkstart AAAAAAADMH}
{\bkmkend AAAAAAADMH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isCallDirectVFGEdge} () const{\bkmkstart AAAAAAADMI}
{\bkmkend AAAAAAADMI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isRetDirectVFGEdge} () const{\bkmkstart AAAAAAADMJ}
{\bkmkend AAAAAAADMJ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isCallIndirectVFGEdge} () const{\bkmkstart AAAAAAADMK}
{\bkmkend AAAAAAADMK}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isRetIndirectVFGEdge} () const{\bkmkstart AAAAAAADML}
{\bkmkend AAAAAAADML}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isIntraVFGEdge} () const{\bkmkstart AAAAAAADMM}
{\bkmkend AAAAAAADMM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isThreadMHPIndirectVFGEdge} () const{\bkmkstart AAAAAAADMN}
{\bkmkend AAAAAAADMN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADMO}
{\bkmkend AAAAAAADMO}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static {\b GEdgeFlag} {\b makeEdgeFlagWithInvokeID} (GEdgeKind k, CallSiteID cs){\bkmkstart AAAAAAADMP}
{\bkmkend AAAAAAADMP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute the unique edgeFlag value from edge kind and CallSiteID. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b raw_ostream} & {\b operator<<} ({\b raw_ostream} &o, const {\b VFGEdge} &edge){\bkmkstart AAAAAAADMQ}
{\bkmkend AAAAAAADMQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator << for dumping {\b ICFG} node ID. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v VFGEdgeK\:SVF::VFGEdge}
{\xe \v SVF::VFGEdge\:VFGEdgeK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SVF::VFGEdge::VFGEdgeK}}}
\par
{\bkmkstart AAAAAAADMR}
{\bkmkend AAAAAAADMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
seven types of {\b ICFG} edge four types of direct value-flow edges three types of indirect value-flow edges \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGEdge.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::VFGNode Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::VFGNode}
{\xe \v SVF::VFGNode}
{\bkmkstart AAAAAAADNV}
{\bkmkend AAAAAAADNV}
Inheritance diagram for SVF::VFGNode:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_v_f_g_node.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b VFGNodeK} \{ {\b Addr}
, {\b Copy}
, {\b Gep}
, {\b Store}
, {\b Load}
, {\b Cmp}
, {\b BinaryOp}
, {\b UnaryOp}
, {\b TPhi}
, {\b TIntraPhi}
, {\b TInterPhi}
, {\b MPhi}
, {\b MIntraPhi}
, {\b MInterPhi}
, {\b FRet}
, {\b ARet}
, {\b AParm}
, {\b FParm}
, {\b FunRet}
, {\b APIN}
, {\b APOUT}
, {\b FPIN}
, {\b FPOUT}
, {\b NPtr}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef VFGEdge::VFGEdgeSetTy::iterator {\b iterator}{\bkmkstart AAAAAAADNW}
{\bkmkend AAAAAAADNW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef VFGEdge::VFGEdgeSetTy::const_iterator {\b const_iterator}{\bkmkstart AAAAAAADNX}
{\bkmkend AAAAAAADNX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b CallPE} * > {\b CallPESet}{\bkmkstart AAAAAAADNY}
{\bkmkend AAAAAAADNY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef Set< const {\b RetPE} * > {\b RetPESet}{\bkmkstart AAAAAAADNZ}
{\bkmkend AAAAAAADNZ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VFGNode} (NodeID i, {\b VFGNodeK} k){\bkmkstart AAAAAAADOA}
{\bkmkend AAAAAAADOA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const {\b ICFGNode} * {\b getICFGNode} () const{\bkmkstart AAAAAAADOB}
{\bkmkend AAAAAAADOB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return corresponding {\b ICFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b setICFGNode} (const {\b ICFGNode} *node){\bkmkstart AAAAAAADOC}
{\bkmkend AAAAAAADOC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set corresponding {\b ICFG} node. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const {\b SVFFunction} * {\b getFun} () const{\bkmkstart AAAAAAADOD}
{\bkmkend AAAAAAADOD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the function of this SVFGNode. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual const std::string {\b toString} () const{\bkmkstart AAAAAAADOE}
{\bkmkend AAAAAAADOE}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const {\b ICFGNode} * {\b icfgNode}{\bkmkstart AAAAAAADOF}
{\bkmkend AAAAAAADOF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b raw_ostream} & {\b operator<<} ({\b raw_ostream} &o, const {\b VFGNode} &node){\bkmkstart AAAAAAADOG}
{\bkmkend AAAAAAADOG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator << for dumping {\b ICFG} node ID. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v VFGNodeK\:SVF::VFGNode}
{\xe \v SVF::VFGNode\:VFGNodeK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SVF::VFGNode::VFGNodeK}}}
\par
{\bkmkstart AAAAAAADOH}
{\bkmkend AAAAAAADOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
24 kinds of {\b ICFG} node Gep represents offset edge for field sensitivity \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Graphs/VFGNode.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Graphs/VFG.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::VFPathCond Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::VFPathCond}
{\xe \v SVF::VFPathCond}
{\bkmkstart AAAAAAAHAL}
{\bkmkend AAAAAAAHAL}
Inheritance diagram for SVF::VFPathCond:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_v_f_path_cond.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b PathCondAllocator::Condition} {\b PathCond}{\bkmkstart AAAAAAAHAM}
{\bkmkend AAAAAAAHAM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef std::vector< std::pair< NodeID, NodeID > > {\b EdgeSet}{\bkmkstart AAAAAAAHAN}
{\bkmkend AAAAAAAHAN}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VFPathCond} ({\b PathCond} *p=PathCondAllocator::trueCond()){\bkmkstart AAAAAAAHAO}
{\bkmkend AAAAAAAHAO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VFPathCond} (const {\b VFPathCond} &cond){\bkmkstart AAAAAAAHAP}
{\bkmkend AAAAAAAHAP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~VFPathCond} (){\bkmkstart AAAAAAAHAQ}
{\bkmkend AAAAAAAHAQ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b getMaxPathLen} () const{\bkmkstart AAAAAAAHAR}
{\bkmkend AAAAAAAHAR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b PathCond} * {\b getPaths} () const{\bkmkstart AAAAAAAHAS}
{\bkmkend AAAAAAAHAS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return paths. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const EdgeSet & {\b getVFEdges} () const{\bkmkstart AAAAAAAHAT}
{\bkmkend AAAAAAAHAT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return paths. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setPaths} ({\b PathCond} *p, const EdgeSet &e){\bkmkstart AAAAAAAHAU}
{\bkmkend AAAAAAAHAU}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set paths. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b pathLen} () const{\bkmkstart AAAAAAAHAV}
{\bkmkend AAAAAAAHAV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get path length. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b addVFEdge} (NodeID from, NodeID to){\bkmkstart AAAAAAAHAW}
{\bkmkend AAAAAAAHAW}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add {\b SVFG} Edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasVFEdge} (NodeID from, NodeID to) const{\bkmkstart AAAAAAAHAX}
{\bkmkend AAAAAAAHAX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Has {\b SVFG} Edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasIncomingEdge} (NodeID node) const{\bkmkstart AAAAAAAHAY}
{\bkmkend AAAAAAAHAY}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether Node dst has incoming edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b hasOutgoingEdge} (NodeID node) const{\bkmkstart AAAAAAAHAZ}
{\bkmkend AAAAAAAHAZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whether Node dst has outgoing edge. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addPath} ({\b PathCondAllocator} *allocator, {\b PathCond} *c, NodeID from, NodeID to)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b condAnd} ({\b PathCondAllocator} *allocator, {\b PathCond} *c){\bkmkstart AAAAAAAHBA}
{\bkmkend AAAAAAAHBA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Condition operatoration. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b condOr} ({\b PathCondAllocator} *allocator, {\b PathCond} *c){\bkmkstart AAAAAAAHBB}
{\bkmkend AAAAAAAHBB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b VFPathCond} &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b VFPathCond} & {\b operator=} (const {\b VFPathCond} &rhs){\bkmkstart AAAAAAAHBC}
{\bkmkend AAAAAAAHBC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator==} (const {\b VFPathCond} &rhs) const{\bkmkstart AAAAAAAHBD}
{\bkmkend AAAAAAAHBD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator==. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b operator!=} (const {\b VFPathCond} &rhs) const{\bkmkstart AAAAAAAHBE}
{\bkmkend AAAAAAAHBE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloading operator!=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b vfEdgesTrace} () const{\bkmkstart AAAAAAAHBF}
{\bkmkend AAAAAAAHBF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get value-flow edge traces. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

std::string {\b toString} () const{\bkmkstart AAAAAAAHBG}
{\bkmkend AAAAAAAHBG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dump context condition. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static void {\b setMaxPathLen} (u32_t max){\bkmkstart AAAAAAAHBH}
{\bkmkend AAAAAAAHBH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set max path limit }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static u32_t {\b maximumPath} = 0{\bkmkstart AAAAAAAHBI}
{\bkmkend AAAAAAAHBI}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addPath\:SVF::VFPathCond}
{\xe \v SVF::VFPathCond\:addPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::VFPathCond::addPath ({\b PathCondAllocator} *  {\i allocator}, {\b PathCond} *  {\i c}, NodeID  {\i from}, NodeID  {\i to}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHBJ}
{\bkmkend AAAAAAAHBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
drop condition when existing a loop (vf cycle)\par
}}
{\xe \v operator<\:SVF::VFPathCond}
{\xe \v SVF::VFPathCond\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SVF::VFPathCond::operator< (const {\b VFPathCond} &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAHBK}
{\bkmkend AAAAAAAHBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enable compare operator to avoid duplicated item insertion in map or set to be noted that two vectors can also overload operator() \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/Util/DPItem.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/Util/PathCondAllocator.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::WPAFSSolver< GraphType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::WPAFSSolver< GraphType >}
{\xe \v SVF::WPAFSSolver< GraphType >}
{\bkmkstart AAAAAAAHZK}
{\bkmkend AAAAAAAHZK}
\par
{
{\f2 #include <WPAFSSolver.h>}}\par
Inheritance diagram for SVF::WPAFSSolver< GraphType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_w_p_a_f_s_solver.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b WPAFSSolver} (){\bkmkstart AAAAAAAHZL}
{\bkmkend AAAAAAAHZL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~WPAFSSolver} (){\bkmkstart AAAAAAAHZM}
{\bkmkend AAAAAAAHZM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual NodeID {\b sccRepNode} (NodeID id) const{\bkmkstart AAAAAAAHZN}
{\bkmkend AAAAAAAHZN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC methods. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual NodeStack & {\b SCCDetect} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC detection. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeStack {\b nodeStack}{\bkmkstart AAAAAAAHZO}
{\bkmkend AAAAAAAHZO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
stack used for processing nodes. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class GraphType>\par
class SVF::WPAFSSolver< GraphType >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Flow-sensitive Solver \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v SCCDetect\:SVF::WPAFSSolver< GraphType >}
{\xe \v SVF::WPAFSSolver< GraphType >\:SCCDetect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class GraphType > virtual NodeStack& {\b SVF::WPAFSSolver}< GraphType >::SCCDetect (){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHXC}
{\bkmkend AAAAAAAHXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC detection. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC detection\par
Both rep and sub nodes need to be processed later. Collect sub nodes from SCCDetector.\par
restore the topological order.\par
}{
Reimplemented from {\b SVF::WPASolver< GraphType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHQA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::FlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHXB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/WPAFSSolver.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::WPAMinimumSolver< GraphType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::WPAMinimumSolver< GraphType >}
{\xe \v SVF::WPAMinimumSolver< GraphType >}
{\bkmkstart AAAAAAAIAB}
{\bkmkend AAAAAAAIAB}
\par
{
{\f2 #include <WPAFSSolver.h>}}\par
Inheritance diagram for SVF::WPAMinimumSolver< GraphType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_w_p_a_minimum_solver.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b WPASolver}< GraphType >::GTraits {\b GTraits}{\bkmkstart AAAAAAAIAC}
{\bkmkend AAAAAAAIAC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b WPASolver}< GraphType >::GNODE {\b GNODE}{\bkmkstart AAAAAAAIAD}
{\bkmkend AAAAAAAIAD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b WPASolver}< GraphType >::child_iterator {\b child_iterator}{\bkmkstart AAAAAAAIAE}
{\bkmkend AAAAAAAIAE}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b solve} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraint Solving. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b addNodeIntoWorkList} (NodeID node){\bkmkstart AAAAAAAIAF}
{\bkmkend AAAAAAAIAF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class GraphType>\par
class SVF::WPAMinimumSolver< GraphType >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Only solve nodes which need to be analyzed. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v solve\:SVF::WPAMinimumSolver< GraphType >}
{\xe \v SVF::WPAMinimumSolver< GraphType >\:solve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class GraphType > virtual void {\b SVF::WPAMinimumSolver}< GraphType >::solve (){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAIAA}
{\bkmkend AAAAAAAIAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraint Solving. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the worklist is not empty, then only solve these nodes contained in worklist. Otherwise all nodes in the graph will be processed.\par
get nodes which need to be processed in this SCC cycle\par
remove nodes which have been processed from the candidate set\par
All nodes will be solved afterwards, so the worklist can be cleared before each solve iteration.\par
}{
Reimplemented from {\b SVF::WPASCCSolver< GraphType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHZY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/WPAFSSolver.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::WPAPass Class Reference\par \pard\plain 
{\tc\tcl2 \v SVF::WPAPass}
{\xe \v SVF::WPAPass}
{\bkmkstart AAAAAAAIAG}
{\bkmkend AAAAAAAIAG}
\par
{
{\f2 #include <WPAPass.h>}}\par
Inheritance diagram for SVF::WPAPass:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_w_p_a_pass.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b AliasCheckRule} \{ {\b Conservative}
, {\b Veto}
, {\b Precise}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b WPAPass} (){\bkmkstart AAAAAAAIAH}
{\bkmkend AAAAAAAIAH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor needs TargetLibraryInfo to be passed to the AliasAnalysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~WPAPass} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b getAnalysisUsage} (AnalysisUsage &au) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LLVM analysis usage. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void * {\b getAdjustedAnalysisPointer} (AnalysisID){\bkmkstart AAAAAAAIAI}
{\bkmkend AAAAAAAIAI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get adjusted analysis for alias analysis. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual AliasResult {\b alias} (const MemoryLocation &LocA, const MemoryLocation &LocB){\bkmkstart AAAAAAAIAJ}
{\bkmkend AAAAAAAIAJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given Location infos. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual AliasResult {\b alias} (const Value *V1, const Value *V2)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given Value infos. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b PrintAliasPairs} ({\b PointerAnalysis} *pta){\bkmkstart AAAAAAAIAK}
{\bkmkend AAAAAAAIAK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print all alias pairs. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual ModRefInfo {\b getModRefInfo} (const CallInst *callInst)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface of mod-ref analysis to determine whether a CallSite instruction can mod or ref any memory location. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual ModRefInfo {\b getModRefInfo} (const CallInst *callInst, const MemoryLocation &Loc){\bkmkstart AAAAAAAIAL}
{\bkmkend AAAAAAAIAL}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface of mod-ref analysis to determine whether a CallSite instruction can mod or ref a specific memory location, given Location infos. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual ModRefInfo {\b getModRefInfo} (const CallInst *callInst, const Value *V)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface of mod-ref analysis to determine whether a CallSite instruction can mod or ref a specific memory location, given Value infos. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual ModRefInfo {\b getModRefInfo} (const CallInst *callInst1, const CallInst *callInst2)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface of mod-ref analysis between two CallSite instructions. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b runOnModule} ({\b SVFModule} *svfModule)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run pointer analysis on {\b SVFModule}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b runOnModule} (Module &module)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run pointer analysis on LLVM module. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual StringRef {\b getPassName} () const{\bkmkstart AAAAAAAIAM}
{\bkmkend AAAAAAAIAM}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PTA name. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

static char {\b ID} = 0{\bkmkstart AAAAAAAIAN}
{\bkmkend AAAAAAAIAN}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pass ID. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Whole program pointer analysis. This class performs various pointer analysis on the given module. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v AliasCheckRule\:SVF::WPAPass}
{\xe \v SVF::WPAPass\:AliasCheckRule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b SVF::WPAPass::AliasCheckRule}}}
\par
{\bkmkstart AAAAAAAIAO}
{\bkmkend AAAAAAAIAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Conservative\:SVF::WPAPass}
{\xe \v SVF::WPAPass\:Conservative}
{\qr Conservative{\bkmkstart AAAAAAAIAP}
{\bkmkend AAAAAAAIAP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return MayAlias if any pta says alias \par
}\cell }{\row }
{\xe \v Veto\:SVF::WPAPass}
{\xe \v SVF::WPAPass\:Veto}
{\qr Veto{\bkmkstart AAAAAAAIAQ}
{\bkmkend AAAAAAAIAQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return NoAlias if any pta says no alias \par
}\cell }{\row }
{\xe \v Precise\:SVF::WPAPass}
{\xe \v SVF::WPAPass\:Precise}
{\qr Precise{\bkmkstart AAAAAAAIAR}
{\bkmkend AAAAAAAIAR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return alias result by the most precise pta \par
}\cell }{\row }
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ~WPAPass\:SVF::WPAPass}
{\xe \v SVF::WPAPass\:~WPAPass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WPAPass::~WPAPass (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAIAS}
{\bkmkend AAAAAAAIAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v alias\:SVF::WPAPass}
{\xe \v SVF::WPAPass\:alias}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AliasResult WPAPass::alias (const Value *  {\i V1}, const Value *  {\i V2}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAIAT}
{\bkmkend AAAAAAAIAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface expose to users of our pointer analysis, given Value infos. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return alias results based on our points-to/alias analysis TODO: Need to handle PartialAlias and MustAlias here. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO: When this method is invoked during compiler optimizations, the IR used for pointer analysis may been changed, so some Values may not find corresponding {\b PAG} node. In this case, we only check alias between two Values if they both have {\b PAG} nodes. Otherwise, MayAlias will be returned.\par
Veto is used by default\par
Return NoAlias if any PTA gives NoAlias result\par
Return MayAlias if any PTA gives MayAlias result\par
}}
{\xe \v getAnalysisUsage\:SVF::WPAPass}
{\xe \v SVF::WPAPass\:getAnalysisUsage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void SVF::WPAPass::getAnalysisUsage (AnalysisUsage &  {\i au}) const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAIAU}
{\bkmkend AAAAAAAIAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LLVM analysis usage. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
do not intend to change the IR in this pass,\par
}}
{\xe \v getModRefInfo\:SVF::WPAPass}
{\xe \v SVF::WPAPass\:getModRefInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ModRefInfo WPAPass::getModRefInfo (const CallInst *  {\i callInst}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAIAV}
{\bkmkend AAAAAAAIAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface of mod-ref analysis to determine whether a CallSite instruction can mod or ref any memory location. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return mod-ref result of a CallInst \par
}}
{\xe \v getModRefInfo\:SVF::WPAPass}
{\xe \v SVF::WPAPass\:getModRefInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ModRefInfo WPAPass::getModRefInfo (const CallInst *  {\i callInst}, const Value *  {\i V}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAIAW}
{\bkmkend AAAAAAAIAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface of mod-ref analysis to determine whether a CallSite instruction can mod or ref a specific memory location, given Value infos. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return mod-ref results of a CallInst to a specific memory location \par
}}
{\xe \v getModRefInfo\:SVF::WPAPass}
{\xe \v SVF::WPAPass\:getModRefInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ModRefInfo WPAPass::getModRefInfo (const CallInst *  {\i callInst1}, const CallInst *  {\i callInst2}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAIAX}
{\bkmkend AAAAAAAIAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interface of mod-ref analysis between two CallSite instructions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return mod-ref result between two CallInsts \par
}}
{\xe \v runOnModule\:SVF::WPAPass}
{\xe \v SVF::WPAPass\:runOnModule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool WPAPass::runOnModule (Module &  {\i module}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAIAY}
{\bkmkend AAAAAAAIAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run pointer analysis on LLVM module. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start from here \par
}}
{\xe \v runOnModule\:SVF::WPAPass}
{\xe \v SVF::WPAPass\:runOnModule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void WPAPass::runOnModule ({\b SVFModule} *  {\i svfModule}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAIAZ}
{\bkmkend AAAAAAAIAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run pointer analysis on {\b SVFModule}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We start from here \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/WPAPass.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib/WPA/WPAPass.cpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::WPASCCSolver< GraphType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::WPASCCSolver< GraphType >}
{\xe \v SVF::WPASCCSolver< GraphType >}
{\bkmkstart AAAAAAAHZP}
{\bkmkend AAAAAAAHZP}
\par
{
{\f2 #include <WPAFSSolver.h>}}\par
Inheritance diagram for SVF::WPASCCSolver< GraphType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_w_p_a_s_c_c_solver.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b WPASolver}< GraphType >::GTraits {\b GTraits}{\bkmkstart AAAAAAAHZQ}
{\bkmkend AAAAAAAHZQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b WPASolver}< GraphType >::GNODE {\b GNODE}{\bkmkstart AAAAAAAHZR}
{\bkmkend AAAAAAAHZR}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b WPASolver}< GraphType >::child_iterator {\b child_iterator}{\bkmkstart AAAAAAAHZS}
{\bkmkend AAAAAAAHZS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b solve} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraint Solving. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b propagate} (GNODE *v){\bkmkstart AAAAAAAHZT}
{\bkmkend AAAAAAAHZT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagation for the solving, to be implemented in the child class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b addNodeIntoWorkList} (NodeID node){\bkmkstart AAAAAAAHZU}
{\bkmkend AAAAAAAHZU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isInCurrentSCC} (NodeID node){\bkmkstart AAAAAAAHZV}
{\bkmkend AAAAAAAHZV}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setCurrentSCC} (NodeID id){\bkmkstart AAAAAAAHZW}
{\bkmkend AAAAAAAHZW}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b curSCCID}{\bkmkstart AAAAAAAHZX}
{\bkmkend AAAAAAAHZX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
index of current SCC. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class GraphType>\par
class SVF::WPASCCSolver< GraphType >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Solver based on SCC cycles. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v solve\:SVF::WPASCCSolver< GraphType >}
{\xe \v SVF::WPASCCSolver< GraphType >\:solve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class GraphType > virtual void {\b SVF::WPASCCSolver}< GraphType >::solve (){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHZY}
{\bkmkend AAAAAAAHZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraint Solving. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
All nodes will be solved afterwards, so the worklist can be cleared before each solve iteration.\par
}{
Reimplemented from {\b SVF::WPASolver< GraphType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHZZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Reimplemented in {\b SVF::WPAMinimumSolver< GraphType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAIAA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/WPAFSSolver.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SVF::WPASolver< GraphType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v SVF::WPASolver< GraphType >}
{\xe \v SVF::WPASolver< GraphType >}
{\bkmkstart AAAAAAAHQQ}
{\bkmkend AAAAAAAHQQ}
Inheritance diagram for SVF::WPASolver< GraphType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_s_v_f_1_1_w_p_a_solver.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef llvm::GraphTraits< GraphType > {\b GTraits}{\bkmkstart AAAAAAAIBA}
{\bkmkend AAAAAAAIBA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define the GTraits and node iterator for printing. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef GTraits::NodeRef {\b GNODE}{\bkmkstart AAAAAAAIBB}
{\bkmkend AAAAAAAIBB}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef GTraits::EdgeType {\b GEDGE}{\bkmkstart AAAAAAAIBC}
{\bkmkend AAAAAAAIBC}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef GTraits::ChildIteratorType {\b child_iterator}{\bkmkstart AAAAAAAIBD}
{\bkmkend AAAAAAAIBD}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b SCCDetection}< GraphType > {\b SCC}{\bkmkstart AAAAAAAIBE}
{\bkmkend AAAAAAAIBE}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

typedef {\b FIFOWorkList}< NodeID > {\b WorkList}{\bkmkstart AAAAAAAIBF}
{\bkmkend AAAAAAAIBF}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b numOfIteration}{\bkmkstart AAAAAAAIBG}
{\bkmkend AAAAAAAIBG}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
num of iterations during constaint solving }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b WPASolver} (){\bkmkstart AAAAAAAIBH}
{\bkmkend AAAAAAAIBH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual {\b ~WPASolver} (){\bkmkstart AAAAAAAIBI}
{\bkmkend AAAAAAAIBI}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SCC} * {\b getSCCDetector} () const{\bkmkstart AAAAAAAIBJ}
{\bkmkend AAAAAAAIBJ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get SCC detector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const GraphType {\b graph} (){\bkmkstart AAAAAAAIBK}
{\bkmkend AAAAAAAIBK}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get/Set graph methods. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b setGraph} (GraphType g){\bkmkstart AAAAAAAIBL}
{\bkmkend AAAAAAAIBL}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual NodeStack & {\b SCCDetect} (){\bkmkstart AAAAAAAHQA}
{\bkmkend AAAAAAAHQA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC detection. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual NodeStack & {\b SCCDetect} (NodeSet &candidates){\bkmkstart AAAAAAAIBM}
{\bkmkend AAAAAAAIBM}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b solve} (){\bkmkstart AAAAAAAHZZ}
{\bkmkend AAAAAAAHZZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constraint Solving. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b initWorklist} (){\bkmkstart AAAAAAAIBN}
{\bkmkend AAAAAAAIBN}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b solveWorklist} (){\bkmkstart AAAAAAAIBO}
{\bkmkend AAAAAAAIBO}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b processNode} (NodeID)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Following methods are to be implemented in child class, in order to achieve a fully worked PTA. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b updateCallGraph} (){\bkmkstart AAAAAAAIBP}
{\bkmkend AAAAAAAIBP}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
update callgraph for all indirect callsites }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b collapsePWCNode} (NodeID){\bkmkstart AAAAAAAHOX}
{\bkmkend AAAAAAAHOX}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
collapse positive weight cycles of a graph }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b collapseFields} (){\bkmkstart AAAAAAAIBQ}
{\bkmkend AAAAAAAIBQ}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b printStat} (){\bkmkstart AAAAAAAIBR}
{\bkmkend AAAAAAAIBR}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dump statistics }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b propagate} (GNODE *v){\bkmkstart AAAAAAAIBS}
{\bkmkend AAAAAAAIBS}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagation for the solving, to be implemented in the child class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual bool {\b propFromSrcToDst} (GEDGE *){\bkmkstart AAAAAAAIBT}
{\bkmkend AAAAAAAIBT}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Propagate information from source to destination node, to be implemented in the child class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual NodeID {\b sccRepNode} (NodeID id) const{\bkmkstart AAAAAAAIBU}
{\bkmkend AAAAAAAIBU}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b popFromWorklist} (){\bkmkstart AAAAAAAIBV}
{\bkmkend AAAAAAAIBV}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Worklist operations. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

virtual void {\b pushIntoWorklist} (NodeID id){\bkmkstart AAAAAAAIBW}
{\bkmkend AAAAAAAIBW}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isWorklistEmpty} (){\bkmkstart AAAAAAAIBX}
{\bkmkend AAAAAAAIBX}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b isInWorklist} (NodeID id){\bkmkstart AAAAAAAIBY}
{\bkmkend AAAAAAAIBY}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

GNODE * {\b Node} (NodeID id){\bkmkstart AAAAAAAIBZ}
{\bkmkend AAAAAAAIBZ}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get node on the graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

NodeID {\b Node_Index} (GNODE node){\bkmkstart AAAAAAAICA}
{\bkmkend AAAAAAAICA}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get node ID. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

bool {\b reanalyze}{\bkmkstart AAAAAAAICB}
{\bkmkend AAAAAAAICB}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reanalyze if any constraint value changed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

u32_t {\b iterationForPrintStat}{\bkmkstart AAAAAAAICC}
{\bkmkend AAAAAAAICC}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
print out statistics for i-th iteration }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

GraphType {\b _graph}{\bkmkstart AAAAAAAICD}
{\bkmkend AAAAAAAICD}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Graph. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b SCC} * {\b scc}{\bkmkstart AAAAAAAICE}
{\bkmkend AAAAAAAICE}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SCC. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b WorkList} {\b worklist}{\bkmkstart AAAAAAAICF}
{\bkmkend AAAAAAAICF}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Worklist for resolution. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v processNode\:SVF::WPASolver< GraphType >}
{\xe \v SVF::WPASolver< GraphType >\:processNode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class GraphType > virtual void {\b SVF::WPASolver}< GraphType >::processNode (NodeID ){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAHPW}
{\bkmkend AAAAAAAHPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Following methods are to be implemented in child class, in order to achieve a fully worked PTA. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Process each node on the graph, to be implemented in the child class \par
}{
Reimplemented in {\b SVF::FlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::AndersenWaveDiff} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b SVF::Andersen} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHPV \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b SVF::VersionedFlowSensitive} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAHWK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/WPA/WPASolver.h\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}