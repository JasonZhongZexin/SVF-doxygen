.TH "SVF::ThreadCallGraph" 3 "Sun Feb 14 2021" "SVF" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SVF::ThreadCallGraph
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ThreadCallGraph\&.h>\fP
.PP
Inherits \fBSVF::PTACallGraph\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef Set< const \fBCallBlockNode\fP * > \fBInstSet\fP"
.br
.ti -1c
.RI "typedef InstSet \fBCallSiteSet\fP"
.br
.ti -1c
.RI "typedef std::vector< const Instruction * > \fBInstVector\fP"
.br
.ti -1c
.RI "typedef Map< const Instruction *, InstSet > \fBCallToInstMap\fP"
.br
.ti -1c
.RI "typedef Set< CallSiteSet * > \fBCtxSet\fP"
.br
.ti -1c
.RI "typedef ThreadForkEdge::ForkEdgeSet \fBForkEdgeSet\fP"
.br
.ti -1c
.RI "typedef Map< const \fBCallBlockNode\fP *, ForkEdgeSet > \fBCallInstToForkEdgesMap\fP"
.br
.ti -1c
.RI "typedef ThreadJoinEdge::JoinEdgeSet \fBJoinEdgeSet\fP"
.br
.ti -1c
.RI "typedef Map< const \fBCallBlockNode\fP *, JoinEdgeSet > \fBCallInstToJoinEdgesMap\fP"
.br
.ti -1c
.RI "typedef HareParForEdge::ParForEdgeSet \fBParForEdgeSet\fP"
.br
.ti -1c
.RI "typedef Map< const \fBCallBlockNode\fP *, ParForEdgeSet > \fBCallInstToParForEdgesMap\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBThreadCallGraph\fP ()"
.br
.RI "Constructor\&. "
.ti -1c
.RI "virtual \fB~ThreadCallGraph\fP ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "void \fBupdateCallGraph\fP (\fBPointerAnalysis\fP *pta)"
.br
.RI "Update call graph using pointer results\&. "
.ti -1c
.RI "void \fBupdateJoinEdge\fP (\fBPointerAnalysis\fP *pta)"
.br
.RI "Update join edge using pointer analysis results\&. "
.ti -1c
.RI "bool \fBhasThreadForkEdge\fP (const \fBCallBlockNode\fP *cs) const"
.br
.RI "Get call graph edge via call instruction\&. "
.ti -1c
.RI "ForkEdgeSet::const_iterator \fBgetForkEdgeBegin\fP (const \fBCallBlockNode\fP *cs) const"
.br
.ti -1c
.RI "ForkEdgeSet::const_iterator \fBgetForkEdgeEnd\fP (const \fBCallBlockNode\fP *cs) const"
.br
.ti -1c
.RI "bool \fBhasThreadJoinEdge\fP (const \fBCallBlockNode\fP *cs) const"
.br
.RI "Get call graph edge via call instruction\&. "
.ti -1c
.RI "JoinEdgeSet::const_iterator \fBgetJoinEdgeBegin\fP (const \fBCallBlockNode\fP *cs) const"
.br
.ti -1c
.RI "JoinEdgeSet::const_iterator \fBgetJoinEdgeEnd\fP (const \fBCallBlockNode\fP *cs) const"
.br
.ti -1c
.RI "void \fBgetJoinSites\fP (const \fBPTACallGraphNode\fP *routine, InstSet &csSet)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static bool \fBclassof\fP (const \fBThreadCallGraph\fP *)"
.br
.RI "ClassOf\&. "
.ti -1c
.RI "static bool \fBclassof\fP (const \fBPTACallGraph\fP *g)"
.br
.in -1c
.in +1c
.ti -1c
.RI "bool \fBisForksite\fP (const \fBCallBlockNode\fP *csInst)"
.br
.ti -1c
.RI "bool \fBisJoinsite\fP (const \fBCallBlockNode\fP *csInst)"
.br
.ti -1c
.RI "bool \fBisParForSite\fP (const \fBCallBlockNode\fP *csInst)"
.br
.ti -1c
.RI "CallSiteSet::const_iterator \fBforksitesBegin\fP () const"
.br
.RI "Fork sites iterators\&. "
.ti -1c
.RI "CallSiteSet::const_iterator \fBforksitesEnd\fP () const"
.br
.ti -1c
.RI "CallSiteSet::const_iterator \fBjoinsitesBegin\fP () const"
.br
.RI "Join sites iterators\&. "
.ti -1c
.RI "CallSiteSet::const_iterator \fBjoinsitesEnd\fP () const"
.br
.ti -1c
.RI "CallSiteSet::const_iterator \fBparForSitesBegin\fP () const"
.br
.RI "hare_parallel_for sites iterators "
.ti -1c
.RI "CallSiteSet::const_iterator \fBparForSitesEnd\fP () const"
.br
.ti -1c
.RI "u32_t \fBgetNumOfForksite\fP () const"
.br
.RI "Num of fork/join sites\&. "
.ti -1c
.RI "u32_t \fBgetNumOfJoinsite\fP () const"
.br
.ti -1c
.RI "u32_t \fBgetNumOfParForSite\fP () const"
.br
.ti -1c
.RI "\fBThreadAPI\fP * \fBgetThreadAPI\fP () const"
.br
.RI "Thread API\&. "
.ti -1c
.RI "bool \fBaddForksite\fP (const \fBCallBlockNode\fP *cs)"
.br
.RI "Add fork sites which directly or indirectly create a thread\&. "
.ti -1c
.RI "bool \fBaddJoinsite\fP (const \fBCallBlockNode\fP *cs)"
.br
.ti -1c
.RI "bool \fBaddParForSite\fP (const \fBCallBlockNode\fP *cs)"
.br
.ti -1c
.RI "void \fBaddDirectForkEdge\fP (const \fBCallBlockNode\fP *cs)"
.br
.RI "Add direct/indirect thread fork edges\&. "
.ti -1c
.RI "void \fBaddIndirectForkEdge\fP (const \fBCallBlockNode\fP *cs, const \fBSVFFunction\fP *callee)"
.br
.ti -1c
.RI "void \fBaddDirectJoinEdge\fP (const \fBCallBlockNode\fP *cs, const CallSiteSet &forksite)"
.br
.RI "Add thread join edges\&. "
.ti -1c
.RI "void \fBaddDirectParForEdge\fP (const \fBCallBlockNode\fP *cs)"
.br
.RI "Add direct/indirect parallel for edges\&. "
.ti -1c
.RI "void \fBaddIndirectParForEdge\fP (const \fBCallBlockNode\fP *cs, const \fBSVFFunction\fP *callee)"
.br
.ti -1c
.RI "void \fBaddThreadForkEdgeSetMap\fP (const \fBCallBlockNode\fP *cs, \fBThreadForkEdge\fP *edge)"
.br
.RI "map call instruction to its CallGraphEdge map "
.ti -1c
.RI "void \fBaddThreadJoinEdgeSetMap\fP (const \fBCallBlockNode\fP *cs, \fBThreadJoinEdge\fP *edge)"
.br
.RI "map call instruction to its CallGraphEdge map "
.ti -1c
.RI "void \fBaddHareParForEdgeSetMap\fP (const \fBCallBlockNode\fP *cs, \fBHareParForEdge\fP *edge)"
.br
.RI "map call instruction to its CallGraphEdge map "
.ti -1c
.RI "\fBThreadJoinEdge\fP * \fBhasThreadJoinEdge\fP (const \fBCallBlockNode\fP *call, \fBPTACallGraphNode\fP *joinFunNode, \fBPTACallGraphNode\fP *threadRoutineFunNode, CallSiteID csId) const"
.br
.RI "has thread join edge "
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Thread sensitive call graph 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "ThreadCallGraph::ThreadCallGraph ()"

.PP
Constructor\&. Constructor 
.SH "Member Function Documentation"
.PP 
.SS "void ThreadCallGraph::addDirectForkEdge (const \fBCallBlockNode\fP * cs)"

.PP
Add direct/indirect thread fork edges\&. Add direct fork edges 
.SS "void ThreadCallGraph::addDirectJoinEdge (const \fBCallBlockNode\fP * cs, const CallSiteSet & forkset)"

.PP
Add thread join edges\&. Add direct fork edges As join edge is a special return which is back to join site(s) rather than its fork site A \fBThreadJoinEdge\fP is created from the functions where join sites reside in to the start routine function But we don't invoke \fBaddEdge()\fP method to add the edge to src and dst, otherwise it makes a scc cycle 
.SS "void ThreadCallGraph::addDirectParForEdge (const \fBCallBlockNode\fP * cs)"

.PP
Add direct/indirect parallel for edges\&. Add a direct ParFor edges 
.SS "void ThreadCallGraph::addIndirectForkEdge (const \fBCallBlockNode\fP * cs, const \fBSVFFunction\fP * calleefun)"
Add indirect fork edge to update call graph 
.SS "void ThreadCallGraph::addIndirectParForEdge (const \fBCallBlockNode\fP * cs, const \fBSVFFunction\fP * calleefun)"
Add an indirect ParFor edge to update call graph 
.SS "bool SVF::ThreadCallGraph::hasThreadForkEdge (const \fBCallBlockNode\fP * cs) const\fC [inline]\fP"

.PP
Get call graph edge via call instruction\&. whether this call instruction has a valid call graph edge 
.SS "bool SVF::ThreadCallGraph::hasThreadJoinEdge (const \fBCallBlockNode\fP * cs) const\fC [inline]\fP"

.PP
Get call graph edge via call instruction\&. whether this call instruction has a valid call graph edge 
.SS "bool SVF::ThreadCallGraph::isForksite (const \fBCallBlockNode\fP * csInst)\fC [inline]\fP"
Whether a callsite is a fork or join or hare_parallel_for 
.SS "void ThreadCallGraph::updateJoinEdge (\fBPointerAnalysis\fP * pta)"

.PP
Update join edge using pointer analysis results\&. Update join edge using pointer analysis results 

.SH "Author"
.PP 
Generated automatically by Doxygen for SVF from the source code\&.
