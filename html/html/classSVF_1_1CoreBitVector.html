<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Static Value-Flow Analysis: SVF::CoreBitVector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Static Value-Flow Analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSVF.html">SVF</a></li><li class="navelem"><a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSVF_1_1CoreBitVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SVF::CoreBitVector Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="CoreBitVector_8h_source.html">CoreBitVector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SVF::CoreBitVector:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSVF_1_1CoreBitVector.png" usemap="#SVF::CoreBitVector_map" alt=""/>
  <map id="SVF::CoreBitVector_map" name="SVF::CoreBitVector_map">
<area href="classSVF_1_1BitVector.html" alt="SVF::BitVector" shape="rect" coords="0,56,123,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector_1_1CoreBitVectorIterator.html">CoreBitVectorIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaee26ffc13d05cd57f0fd7e4c2ea875c"><td class="memItemLeft" align="right" valign="top">typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a></td></tr>
<tr class="separator:aaee26ffc13d05cd57f0fd7e4c2ea875c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a3bf8465e63f723c0a551f0b0f37ff"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSVF_1_1CoreBitVector_1_1CoreBitVectorIterator.html">CoreBitVectorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a45a3bf8465e63f723c0a551f0b0f37ff">const_iterator</a></td></tr>
<tr class="separator:a45a3bf8465e63f723c0a551f0b0f37ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624ebc80d138fbf2b015bf557d2891a6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classSVF_1_1CoreBitVector.html#a45a3bf8465e63f723c0a551f0b0f37ff">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a624ebc80d138fbf2b015bf557d2891a6">iterator</a></td></tr>
<tr class="separator:a624ebc80d138fbf2b015bf557d2891a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adb5b13df8bc76f00ceb145711cfb77e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#adb5b13df8bc76f00ceb145711cfb77e1">CoreBitVector</a> (void)</td></tr>
<tr class="memdesc:adb5b13df8bc76f00ceb145711cfb77e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct empty CBV.  <a href="#adb5b13df8bc76f00ceb145711cfb77e1">More...</a><br /></td></tr>
<tr class="separator:adb5b13df8bc76f00ceb145711cfb77e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25de5d26935c74e156c5f6604b3d8a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#aa25de5d26935c74e156c5f6604b3d8a8">CoreBitVector</a> (size_t n)</td></tr>
<tr class="memdesc:aa25de5d26935c74e156c5f6604b3d8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct empty CBV with space reserved for n Words.  <a href="#aa25de5d26935c74e156c5f6604b3d8a8">More...</a><br /></td></tr>
<tr class="separator:aa25de5d26935c74e156c5f6604b3d8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b3db689583b652ab1426c04a66c4ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a57b3db689583b652ab1426c04a66c4ae">CoreBitVector</a> (const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;cbv)</td></tr>
<tr class="memdesc:a57b3db689583b652ab1426c04a66c4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a57b3db689583b652ab1426c04a66c4ae">More...</a><br /></td></tr>
<tr class="separator:a57b3db689583b652ab1426c04a66c4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f42d767c99bdf788dc4df4881751c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a93f42d767c99bdf788dc4df4881751c5">CoreBitVector</a> (<a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&amp;cbv)</td></tr>
<tr class="memdesc:a93f42d767c99bdf788dc4df4881751c5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structMove.html">Move</a> constructor.  <a href="#a93f42d767c99bdf788dc4df4881751c5">More...</a><br /></td></tr>
<tr class="separator:a93f42d767c99bdf788dc4df4881751c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3594d997fba0aa6201855199a884d98d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a3594d997fba0aa6201855199a884d98d">operator=</a> (const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;rhs)</td></tr>
<tr class="memdesc:a3594d997fba0aa6201855199a884d98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment.  <a href="#a3594d997fba0aa6201855199a884d98d">More...</a><br /></td></tr>
<tr class="separator:a3594d997fba0aa6201855199a884d98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14cc9ce0abbad20636c51e6ca781305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#ae14cc9ce0abbad20636c51e6ca781305">operator=</a> (<a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:ae14cc9ce0abbad20636c51e6ca781305"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structMove.html">Move</a> assignment.  <a href="#ae14cc9ce0abbad20636c51e6ca781305">More...</a><br /></td></tr>
<tr class="separator:ae14cc9ce0abbad20636c51e6ca781305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b9795b4fdc74d9d2efa9a3f2ecb62f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a98b9795b4fdc74d9d2efa9a3f2ecb62f">empty</a> (void) const</td></tr>
<tr class="memdesc:a98b9795b4fdc74d9d2efa9a3f2ecb62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if no bits are set.  <a href="#a98b9795b4fdc74d9d2efa9a3f2ecb62f">More...</a><br /></td></tr>
<tr class="separator:a98b9795b4fdc74d9d2efa9a3f2ecb62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfed2e7daf2407e11cade625ac19a6ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#abfed2e7daf2407e11cade625ac19a6ce">count</a> (void) const</td></tr>
<tr class="memdesc:abfed2e7daf2407e11cade625ac19a6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of bits set.  <a href="#abfed2e7daf2407e11cade625ac19a6ce">More...</a><br /></td></tr>
<tr class="separator:abfed2e7daf2407e11cade625ac19a6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e523bab1013a9f3e9eaea56e53afa58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a1e523bab1013a9f3e9eaea56e53afa58">clear</a> (void)</td></tr>
<tr class="memdesc:a1e523bab1013a9f3e9eaea56e53afa58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the CBV.  <a href="#a1e523bab1013a9f3e9eaea56e53afa58">More...</a><br /></td></tr>
<tr class="separator:a1e523bab1013a9f3e9eaea56e53afa58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b20ffd3cd4a0ffc48a1348f657deaa0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a7b20ffd3cd4a0ffc48a1348f657deaa0">test</a> (<a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> bit) const</td></tr>
<tr class="memdesc:a7b20ffd3cd4a0ffc48a1348f657deaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if bit is set in this CBV.  <a href="#a7b20ffd3cd4a0ffc48a1348f657deaa0">More...</a><br /></td></tr>
<tr class="separator:a7b20ffd3cd4a0ffc48a1348f657deaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3299b296d20d2b76c6538ba51a684972"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a3299b296d20d2b76c6538ba51a684972">test_and_set</a> (<a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> bit)</td></tr>
<tr class="separator:a3299b296d20d2b76c6538ba51a684972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553e3e51bffe1aab04adc047e0fd3f24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a553e3e51bffe1aab04adc047e0fd3f24">set</a> (<a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> bit)</td></tr>
<tr class="memdesc:a553e3e51bffe1aab04adc047e0fd3f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bit in the CBV.  <a href="#a553e3e51bffe1aab04adc047e0fd3f24">More...</a><br /></td></tr>
<tr class="separator:a553e3e51bffe1aab04adc047e0fd3f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fc777d574db4ef23b02308b944a85b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a42fc777d574db4ef23b02308b944a85b">reset</a> (<a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> bit)</td></tr>
<tr class="memdesc:a42fc777d574db4ef23b02308b944a85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets bit in the CBV.  <a href="#a42fc777d574db4ef23b02308b944a85b">More...</a><br /></td></tr>
<tr class="separator:a42fc777d574db4ef23b02308b944a85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08c16aed45dfa65472f0b5ae518add2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#af08c16aed45dfa65472f0b5ae518add2">contains</a> (const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;rhs) const</td></tr>
<tr class="memdesc:af08c16aed45dfa65472f0b5ae518add2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this CBV is a superset of rhs.  <a href="#af08c16aed45dfa65472f0b5ae518add2">More...</a><br /></td></tr>
<tr class="separator:af08c16aed45dfa65472f0b5ae518add2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15be4ce7e9a07d9b01da0c60d51b22de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a15be4ce7e9a07d9b01da0c60d51b22de">intersects</a> (const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a15be4ce7e9a07d9b01da0c60d51b22de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this CBV and rhs share any set bits.  <a href="#a15be4ce7e9a07d9b01da0c60d51b22de">More...</a><br /></td></tr>
<tr class="separator:a15be4ce7e9a07d9b01da0c60d51b22de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddd7fc5e043d36f3c62c2fb93b22684"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a0ddd7fc5e043d36f3c62c2fb93b22684">operator==</a> (const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a0ddd7fc5e043d36f3c62c2fb93b22684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this CBV and rhs have the same bits set.  <a href="#a0ddd7fc5e043d36f3c62c2fb93b22684">More...</a><br /></td></tr>
<tr class="separator:a0ddd7fc5e043d36f3c62c2fb93b22684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af142d3bb07e77c28bba6ece5b5b13f51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#af142d3bb07e77c28bba6ece5b5b13f51">operator!=</a> (const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;rhs) const</td></tr>
<tr class="memdesc:af142d3bb07e77c28bba6ece5b5b13f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if either this CBV or rhs has a bit set unique to the other.  <a href="#af142d3bb07e77c28bba6ece5b5b13f51">More...</a><br /></td></tr>
<tr class="separator:af142d3bb07e77c28bba6ece5b5b13f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e63360242a49fb63c3ef3d7071503d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#af8e63360242a49fb63c3ef3d7071503d">operator|=</a> (const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;rhs)</td></tr>
<tr class="separator:af8e63360242a49fb63c3ef3d7071503d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84257a1544b94c9abf5c8d0f6cfaec9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#ae84257a1544b94c9abf5c8d0f6cfaec9">operator &amp;=</a> (const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;rhs)</td></tr>
<tr class="separator:ae84257a1544b94c9abf5c8d0f6cfaec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b87ae9d4a713483522666c893d7eac9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a5b87ae9d4a713483522666c893d7eac9">operator-=</a> (const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;rhs)</td></tr>
<tr class="separator:a5b87ae9d4a713483522666c893d7eac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba857b68282055e485c441892e39b9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a8ba857b68282055e485c441892e39b9b">intersectWithComplement</a> (const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;rhs)</td></tr>
<tr class="separator:a8ba857b68282055e485c441892e39b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79121882bc302b9b9188fa0a51c63fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a79121882bc302b9b9188fa0a51c63fb6">intersectWithComplement</a> (const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;lhs, const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;rhs)</td></tr>
<tr class="memdesc:a79121882bc302b9b9188fa0a51c63fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put intersection of lhs with complemenet of rhs into this CBV.  <a href="#a79121882bc302b9b9188fa0a51c63fb6">More...</a><br /></td></tr>
<tr class="separator:a79121882bc302b9b9188fa0a51c63fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af979ecb48d3d5296bce5bd0b4676e359"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#af979ecb48d3d5296bce5bd0b4676e359">hash</a> (void) const</td></tr>
<tr class="memdesc:af979ecb48d3d5296bce5bd0b4676e359"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structSVF_1_1Hash.html" title="provide extra hash function for std::pair handling ">Hash</a> for this CBV.  <a href="#af979ecb48d3d5296bce5bd0b4676e359">More...</a><br /></td></tr>
<tr class="separator:af979ecb48d3d5296bce5bd0b4676e359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835bf11a1f698942db8e6bdadbbfd1f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSVF_1_1CoreBitVector.html#a45a3bf8465e63f723c0a551f0b0f37ff">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a835bf11a1f698942db8e6bdadbbfd1f3">begin</a> (void) const</td></tr>
<tr class="separator:a835bf11a1f698942db8e6bdadbbfd1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cdd9890522cc9fee2451567e0b1f0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSVF_1_1CoreBitVector.html#a45a3bf8465e63f723c0a551f0b0f37ff">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a93cdd9890522cc9fee2451567e0b1f0d">end</a> (void) const</td></tr>
<tr class="separator:a93cdd9890522cc9fee2451567e0b1f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a63f5e4a36359ae62401e5f8dfecb86a3"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a> = sizeof(<a class="el" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a>) * CHAR_BIT</td></tr>
<tr class="separator:a63f5e4a36359ae62401e5f8dfecb86a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab6d789e3c68390a9026fd4f8c4cf344a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#ab6d789e3c68390a9026fd4f8c4cf344a">extendBackward</a> (<a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> bit)</td></tr>
<tr class="memdesc:ab6d789e3c68390a9026fd4f8c4cf344a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add enough words (prepend) to be able to include bit.  <a href="#ab6d789e3c68390a9026fd4f8c4cf344a">More...</a><br /></td></tr>
<tr class="separator:ab6d789e3c68390a9026fd4f8c4cf344a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3f1eb85bc388cb76c588b8d8b3c181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a5d3f1eb85bc388cb76c588b8d8b3c181">extendForward</a> (<a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> bit)</td></tr>
<tr class="memdesc:a5d3f1eb85bc388cb76c588b8d8b3c181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add enough words (append) to be able to include bit.  <a href="#a5d3f1eb85bc388cb76c588b8d8b3c181">More...</a><br /></td></tr>
<tr class="separator:a5d3f1eb85bc388cb76c588b8d8b3c181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e5b15854f4f56f50992ed0d0cc7349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a73e5b15854f4f56f50992ed0d0cc7349">extendTo</a> (<a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> bit)</td></tr>
<tr class="memdesc:a73e5b15854f4f56f50992ed0d0cc7349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add enough words (append xor prepend) to be able to include bit.  <a href="#a73e5b15854f4f56f50992ed0d0cc7349">More...</a><br /></td></tr>
<tr class="separator:a73e5b15854f4f56f50992ed0d0cc7349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73fca28bd4882eaa70817023a632d35"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#ad73fca28bd4882eaa70817023a632d35">indexForBit</a> (<a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> bit) const</td></tr>
<tr class="memdesc:ad73fca28bd4882eaa70817023a632d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into words which would hold bit.  <a href="#ad73fca28bd4882eaa70817023a632d35">More...</a><br /></td></tr>
<tr class="separator:ad73fca28bd4882eaa70817023a632d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c85fd2084e52df869cb8fcf2dab6486"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a3c85fd2084e52df869cb8fcf2dab6486">canHold</a> (<a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> bit) const</td></tr>
<tr class="memdesc:a3c85fd2084e52df869cb8fcf2dab6486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if bit can fit in this CBV without resizing.  <a href="#a3c85fd2084e52df869cb8fcf2dab6486">More...</a><br /></td></tr>
<tr class="separator:a3c85fd2084e52df869cb8fcf2dab6486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8825e54f584be8aa0ff627335064244e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a8825e54f584be8aa0ff627335064244e">finalBit</a> (void) const</td></tr>
<tr class="memdesc:a8825e54f584be8aa0ff627335064244e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last bit that this CBV can hold.  <a href="#a8825e54f584be8aa0ff627335064244e">More...</a><br /></td></tr>
<tr class="separator:a8825e54f584be8aa0ff627335064244e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca118240e4c7f678d52a6ca4b3e6b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a1ca118240e4c7f678d52a6ca4b3e6b2f">firstCommonBit</a> (const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a1ca118240e4c7f678d52a6ca4b3e6b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first bit position that both this CBV and rhs <em>can</em> hold.  <a href="#a1ca118240e4c7f678d52a6ca4b3e6b2f">More...</a><br /></td></tr>
<tr class="separator:a1ca118240e4c7f678d52a6ca4b3e6b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087f69adea5e9e83bd908a1ab0ee1383"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a087f69adea5e9e83bd908a1ab0ee1383">nextSetIndex</a> (const size_t start) const</td></tr>
<tr class="separator:a087f69adea5e9e83bd908a1ab0ee1383"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a79dfa9f4c2efb6a0a2de18c6359c41bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a></td></tr>
<tr class="memdesc:a79dfa9f4c2efb6a0a2de18c6359c41bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first bit of the first word.  <a href="#a79dfa9f4c2efb6a0a2de18c6359c41bd">More...</a><br /></td></tr>
<tr class="separator:a79dfa9f4c2efb6a0a2de18c6359c41bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807283a917e845ef19c4962b1744e98b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a></td></tr>
<tr class="memdesc:a807283a917e845ef19c4962b1744e98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our actual bit vector.  <a href="#a807283a917e845ef19c4962b1744e98b">More...</a><br /></td></tr>
<tr class="separator:a807283a917e845ef19c4962b1744e98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A contiguous bit vector that only contains what it needs according to the operations carried. For example, when two bit vectors are unioned, their sizes may be increased to fit all the bits from the other set. This implementation never shrinks. Since points-to sets (generally) grow monotonically, does not have too big an impact on points-to analysis and so it isn't implemented. Abbreviated CBV. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8h_source.html#l00030">30</a> of file <a class="el" href="CoreBitVector_8h_source.html">CoreBitVector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a45a3bf8465e63f723c0a551f0b0f37ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a3bf8465e63f723c0a551f0b0f37ff">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSVF_1_1CoreBitVector_1_1CoreBitVectorIterator.html">CoreBitVectorIterator</a> <a class="el" href="classSVF_1_1CoreBitVector.html#a45a3bf8465e63f723c0a551f0b0f37ff">SVF::CoreBitVector::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8h_source.html#l00036">36</a> of file <a class="el" href="CoreBitVector_8h_source.html">CoreBitVector.h</a>.</p>

</div>
</div>
<a id="a624ebc80d138fbf2b015bf557d2891a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624ebc80d138fbf2b015bf557d2891a6">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSVF_1_1CoreBitVector.html#a45a3bf8465e63f723c0a551f0b0f37ff">const_iterator</a> <a class="el" href="classSVF_1_1CoreBitVector.html#a624ebc80d138fbf2b015bf557d2891a6">SVF::CoreBitVector::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8h_source.html#l00038">38</a> of file <a class="el" href="CoreBitVector_8h_source.html">CoreBitVector.h</a>.</p>

</div>
</div>
<a id="aaee26ffc13d05cd57f0fd7e4c2ea875c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee26ffc13d05cd57f0fd7e4c2ea875c">&#9670;&nbsp;</a></span>Word</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long long <a class="el" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">SVF::CoreBitVector::Word</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8h_source.html#l00033">33</a> of file <a class="el" href="CoreBitVector_8h_source.html">CoreBitVector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adb5b13df8bc76f00ceb145711cfb77e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5b13df8bc76f00ceb145711cfb77e1">&#9670;&nbsp;</a></span>CoreBitVector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SVF::CoreBitVector::CoreBitVector </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct empty CBV. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00024">24</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    : <a class="code" href="classSVF_1_1CoreBitVector.html#adb5b13df8bc76f00ceb145711cfb77e1">CoreBitVector</a>(0) { }</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_adb5b13df8bc76f00ceb145711cfb77e1"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#adb5b13df8bc76f00ceb145711cfb77e1">SVF::CoreBitVector::CoreBitVector</a></div><div class="ttdeci">CoreBitVector(void)</div><div class="ttdoc">Construct empty CBV. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00024">CoreBitVector.cpp:24</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa25de5d26935c74e156c5f6604b3d8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25de5d26935c74e156c5f6604b3d8a8">&#9670;&nbsp;</a></span>CoreBitVector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SVF::CoreBitVector::CoreBitVector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct empty CBV with space reserved for n Words. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00027">27</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    : <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a>(0), <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>(n, 0) { }</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a57b3db689583b652ab1426c04a66c4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b3db689583b652ab1426c04a66c4ae">&#9670;&nbsp;</a></span>CoreBitVector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SVF::CoreBitVector::CoreBitVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>cbv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00030">30</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    : <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a>(cbv.offset), <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>(cbv.words) { }</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a93f42d767c99bdf788dc4df4881751c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f42d767c99bdf788dc4df4881751c5">&#9670;&nbsp;</a></span>CoreBitVector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SVF::CoreBitVector::CoreBitVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>cbv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structMove.html">Move</a> constructor. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00033">33</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    : <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a>(cbv.offset), <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>(std::move(cbv.words)) { }</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a835bf11a1f698942db8e6bdadbbfd1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835bf11a1f698942db8e6bdadbbfd1f3">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSVF_1_1CoreBitVector.html#a45a3bf8465e63f723c0a551f0b0f37ff">CoreBitVector::const_iterator</a> SVF::CoreBitVector::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00313">313</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;{</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    <span class="keywordflow">return</span> CoreBitVectorIterator(<span class="keyword">this</span>);</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a3c85fd2084e52df869cb8fcf2dab6486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c85fd2084e52df869cb8fcf2dab6486">&#9670;&nbsp;</a></span>canHold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::CoreBitVector::canHold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td>
          <td class="paramname"><em>bit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if bit can fit in this CBV without resizing. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00364">364</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;{</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    <span class="keywordflow">return</span> bit &gt;= <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> &amp;&amp; bit &lt; <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> + <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.size() * <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_a63f5e4a36359ae62401e5f8dfecb86a3"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">SVF::CoreBitVector::WordSize</a></div><div class="ttdeci">static const size_t WordSize</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00034">CoreBitVector.h:34</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1e523bab1013a9f3e9eaea56e53afa58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e523bab1013a9f3e9eaea56e53afa58">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::CoreBitVector::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty the CBV. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00063">63</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;{</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> = 0;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.clear();</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.shrink_to_fit();</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af08c16aed45dfa65472f0b5ae518add2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08c16aed45dfa65472f0b5ae518add2">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::CoreBitVector::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this CBV is a superset of rhs. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00103">103</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;{</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <a class="code" href="classSVF_1_1CoreBitVector.html#adb5b13df8bc76f00ceb145711cfb77e1">CoreBitVector</a> tmp(*<span class="keyword">this</span>);</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    tmp &amp;= rhs;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="keywordflow">return</span> tmp == rhs;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_adb5b13df8bc76f00ceb145711cfb77e1"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#adb5b13df8bc76f00ceb145711cfb77e1">SVF::CoreBitVector::CoreBitVector</a></div><div class="ttdeci">CoreBitVector(void)</div><div class="ttdoc">Construct empty CBV. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00024">CoreBitVector.cpp:24</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abfed2e7daf2407e11cade625ac19a6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfed2e7daf2407e11cade625ac19a6ce">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> SVF::CoreBitVector::count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of bits set. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00056">56</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;{</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <a class="code" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> n = 0;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> &amp;w : <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>) n += llvm::countPopulation(w);</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="keywordflow">return</span> n;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_aaee26ffc13d05cd57f0fd7e4c2ea875c"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">SVF::CoreBitVector::Word</a></div><div class="ttdeci">unsigned long long Word</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00033">CoreBitVector.h:33</a></div></div>
<div class="ttc" id="namespaceSVF_html_ad42bff8d0a7d60a085aa32d10f4955af"><div class="ttname"><a href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">SVF::u32_t</a></div><div class="ttdeci">unsigned u32_t</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00077">SVFBasicTypes.h:77</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a98b9795b4fdc74d9d2efa9a3f2ecb62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b9795b4fdc74d9d2efa9a3f2ecb62f">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::CoreBitVector::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if no bits are set. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00050">50</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;{</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> &amp;w : <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>) <span class="keywordflow">if</span> (w) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_aaee26ffc13d05cd57f0fd7e4c2ea875c"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">SVF::CoreBitVector::Word</a></div><div class="ttdeci">unsigned long long Word</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00033">CoreBitVector.h:33</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a93cdd9890522cc9fee2451567e0b1f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93cdd9890522cc9fee2451567e0b1f0d">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSVF_1_1CoreBitVector.html#a45a3bf8465e63f723c0a551f0b0f37ff">CoreBitVector::const_iterator</a> SVF::CoreBitVector::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00308">308</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;{</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    <span class="keywordflow">return</span> CoreBitVectorIterator(<span class="keyword">this</span>, <span class="keyword">true</span>);</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ab6d789e3c68390a9026fd4f8c4cf344a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d789e3c68390a9026fd4f8c4cf344a">&#9670;&nbsp;</a></span>extendBackward()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::CoreBitVector::extendBackward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td>
          <td class="paramname"><em>bit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add enough words (prepend) to be able to include bit. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00318">318</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;{</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    <span class="comment">// New offset is the starting bit of the word which contains bit.</span></div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    <a class="code" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> newOffset = (bit / <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>) * <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    <span class="comment">// TODO: maybe assertions?</span></div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <span class="comment">// Check if bit can already be included in this BV or if it&#39;s extendForward&#39;s problem.</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    <span class="keywordflow">if</span> (newOffset &gt;= <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a>) <span class="keywordflow">return</span>;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;    <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.insert(<a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.begin(), (<a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> - newOffset) / <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>, 0);</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> = newOffset;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_a63f5e4a36359ae62401e5f8dfecb86a3"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">SVF::CoreBitVector::WordSize</a></div><div class="ttdeci">static const size_t WordSize</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00034">CoreBitVector.h:34</a></div></div>
<div class="ttc" id="namespaceSVF_html_ad42bff8d0a7d60a085aa32d10f4955af"><div class="ttname"><a href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">SVF::u32_t</a></div><div class="ttdeci">unsigned u32_t</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00077">SVFBasicTypes.h:77</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d3f1eb85bc388cb76c588b8d8b3c181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3f1eb85bc388cb76c588b8d8b3c181">&#9670;&nbsp;</a></span>extendForward()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::CoreBitVector::extendForward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td>
          <td class="paramname"><em>bit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add enough words (append) to be able to include bit. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00331">331</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;{</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    <span class="comment">// TODO: maybe assertions?</span></div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    <span class="comment">// Not our problem; extendBackward&#39;s problem, or there is nothing to do.</span></div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="keywordflow">if</span> (bit &lt; <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> || <a class="code" href="classSVF_1_1CoreBitVector.html#a3c85fd2084e52df869cb8fcf2dab6486">canHold</a>(bit)) <span class="keywordflow">return</span>;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    <span class="comment">// Starting bit of word which would contain bit.</span></div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    <a class="code" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> bitsWord = (bit / <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>) * <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>;</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="comment">// Add 1 to represent the final word starting at bitsWord.</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    <a class="code" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> wordsToAdd = 1 + (bitsWord - <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.size() * <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a> - <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a>) / <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.insert(<a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.end(), wordsToAdd, 0);</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_a63f5e4a36359ae62401e5f8dfecb86a3"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">SVF::CoreBitVector::WordSize</a></div><div class="ttdeci">static const size_t WordSize</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00034">CoreBitVector.h:34</a></div></div>
<div class="ttc" id="namespaceSVF_html_ad42bff8d0a7d60a085aa32d10f4955af"><div class="ttname"><a href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">SVF::u32_t</a></div><div class="ttdeci">unsigned u32_t</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00077">SVFBasicTypes.h:77</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a3c85fd2084e52df869cb8fcf2dab6486"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a3c85fd2084e52df869cb8fcf2dab6486">SVF::CoreBitVector::canHold</a></div><div class="ttdeci">bool canHold(u32_t bit) const</div><div class="ttdoc">Returns true if bit can fit in this CBV without resizing. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00364">CoreBitVector.cpp:364</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a73e5b15854f4f56f50992ed0d0cc7349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e5b15854f4f56f50992ed0d0cc7349">&#9670;&nbsp;</a></span>extendTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::CoreBitVector::extendTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td>
          <td class="paramname"><em>bit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add enough words (append xor prepend) to be able to include bit. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00345">345</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;{</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> == 0 &amp;&amp; <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.size() == 0)</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    {</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;        <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> = (bit / <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>) * <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>;</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.push_back(0);</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    }</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bit &lt; <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a>) <a class="code" href="classSVF_1_1CoreBitVector.html#ab6d789e3c68390a9026fd4f8c4cf344a">extendBackward</a>(bit);</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bit &gt;= <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> + <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.size() * <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>) <a class="code" href="classSVF_1_1CoreBitVector.html#a5d3f1eb85bc388cb76c588b8d8b3c181">extendForward</a>(bit);</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_a63f5e4a36359ae62401e5f8dfecb86a3"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">SVF::CoreBitVector::WordSize</a></div><div class="ttdeci">static const size_t WordSize</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00034">CoreBitVector.h:34</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_ab6d789e3c68390a9026fd4f8c4cf344a"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#ab6d789e3c68390a9026fd4f8c4cf344a">SVF::CoreBitVector::extendBackward</a></div><div class="ttdeci">void extendBackward(u32_t bit)</div><div class="ttdoc">Add enough words (prepend) to be able to include bit. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00318">CoreBitVector.cpp:318</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a5d3f1eb85bc388cb76c588b8d8b3c181"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a5d3f1eb85bc388cb76c588b8d8b3c181">SVF::CoreBitVector::extendForward</a></div><div class="ttdeci">void extendForward(u32_t bit)</div><div class="ttdoc">Add enough words (append) to be able to include bit. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00331">CoreBitVector.cpp:331</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8825e54f584be8aa0ff627335064244e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8825e54f584be8aa0ff627335064244e">&#9670;&nbsp;</a></span>finalBit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> SVF::CoreBitVector::finalBit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last bit that this CBV can hold. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00369">369</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;{</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> + <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.size() * <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a> - 1;</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_a63f5e4a36359ae62401e5f8dfecb86a3"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">SVF::CoreBitVector::WordSize</a></div><div class="ttdeci">static const size_t WordSize</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00034">CoreBitVector.h:34</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1ca118240e4c7f678d52a6ca4b3e6b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca118240e4c7f678d52a6ca4b3e6b2f">&#9670;&nbsp;</a></span>firstCommonBit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> SVF::CoreBitVector::firstCommonBit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first bit position that both this CBV and rhs <em>can</em> hold. </p>

</div>
</div>
<a id="af979ecb48d3d5296bce5bd0b4676e359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af979ecb48d3d5296bce5bd0b4676e359">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVF::CoreBitVector::hash </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structSVF_1_1Hash.html" title="provide extra hash function for std::pair handling ">Hash</a> for this CBV. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00296">296</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;{</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    <span class="comment">// From https://stackoverflow.com/a/27216842</span></div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    <span class="keywordtype">size_t</span> h = <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.size();</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> &amp;w : <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>)</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    {</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        h ^= w + 0x9e3779b9 + (h &lt;&lt; 6) + (h &gt;&gt; 2);</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    }</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <span class="keywordflow">return</span> h + <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a>;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_aaee26ffc13d05cd57f0fd7e4c2ea875c"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">SVF::CoreBitVector::Word</a></div><div class="ttdeci">unsigned long long Word</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00033">CoreBitVector.h:33</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad73fca28bd4882eaa70817023a632d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73fca28bd4882eaa70817023a632d35">&#9670;&nbsp;</a></span>indexForBit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVF::CoreBitVector::indexForBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td>
          <td class="paramname"><em>bit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into words which would hold bit. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00356">356</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;{</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(<a class="code" href="classSVF_1_1CoreBitVector.html#a3c85fd2084e52df869cb8fcf2dab6486">canHold</a>(bit));</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <span class="comment">// Recall, offset (and the bits in that word) are represented by words[0],</span></div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="comment">// so solve (offset + x) / WordSize == 0... x == -offset.</span></div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    <span class="keywordflow">return</span> (bit - <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a>) / <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_a63f5e4a36359ae62401e5f8dfecb86a3"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">SVF::CoreBitVector::WordSize</a></div><div class="ttdeci">static const size_t WordSize</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00034">CoreBitVector.h:34</a></div></div>
<div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a3c85fd2084e52df869cb8fcf2dab6486"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a3c85fd2084e52df869cb8fcf2dab6486">SVF::CoreBitVector::canHold</a></div><div class="ttdeci">bool canHold(u32_t bit) const</div><div class="ttdoc">Returns true if bit can fit in this CBV without resizing. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00364">CoreBitVector.cpp:364</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a15be4ce7e9a07d9b01da0c60d51b22de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15be4ce7e9a07d9b01da0c60d51b22de">&#9670;&nbsp;</a></span>intersects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::CoreBitVector::intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this CBV and rhs share any set bits. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00110">110</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;{</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="comment">// TODO: want some common iteration method.</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classSVF_1_1CoreBitVector.html#a98b9795b4fdc74d9d2efa9a3f2ecb62f">empty</a>() &amp;&amp; rhs.empty()) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    <span class="keyword">const</span> <a class="code" href="classSVF_1_1CoreBitVector.html#adb5b13df8bc76f00ceb145711cfb77e1">CoreBitVector</a> &amp;earlierOffsetCBV = <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> &lt;= rhs.offset ? *this : rhs;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    <span class="keyword">const</span> <a class="code" href="classSVF_1_1CoreBitVector.html#adb5b13df8bc76f00ceb145711cfb77e1">CoreBitVector</a> &amp;laterOffsetCBV = <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> &lt;= rhs.offset ? rhs : *<span class="keyword">this</span>;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <span class="keywordtype">size_t</span> earlierOffset = (<a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> &lt; rhs.offset ? <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> : rhs.offset) / <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <span class="keywordtype">size_t</span> laterOffset = (<a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> &gt; rhs.offset ? <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> : rhs.offset) / <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    laterOffset -= earlierOffset;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    <span class="keyword">const</span> <a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> *eWords = &amp;earlierOffsetCBV.words[0];</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> eSize = earlierOffsetCBV.words.size();</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    <span class="keyword">const</span> <a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> *lWords = &amp;laterOffsetCBV.words[0];</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> lSize = laterOffsetCBV.words.size();</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="keywordtype">size_t</span> e = 0;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    <span class="keywordflow">for</span> ( ; e != laterOffset &amp;&amp; e != eSize; ++e) { }</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    <span class="keywordtype">size_t</span> l = 0;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <span class="keywordflow">for</span> ( ; e != eSize &amp;&amp; l != lSize; ++e, ++l)</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    {</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        <span class="keywordflow">if</span> (eWords[e] &amp; lWords[l]) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    }</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_aaee26ffc13d05cd57f0fd7e4c2ea875c"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">SVF::CoreBitVector::Word</a></div><div class="ttdeci">unsigned long long Word</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00033">CoreBitVector.h:33</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a63f5e4a36359ae62401e5f8dfecb86a3"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">SVF::CoreBitVector::WordSize</a></div><div class="ttdeci">static const size_t WordSize</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00034">CoreBitVector.h:34</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_adb5b13df8bc76f00ceb145711cfb77e1"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#adb5b13df8bc76f00ceb145711cfb77e1">SVF::CoreBitVector::CoreBitVector</a></div><div class="ttdeci">CoreBitVector(void)</div><div class="ttdoc">Construct empty CBV. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00024">CoreBitVector.cpp:24</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a98b9795b4fdc74d9d2efa9a3f2ecb62f"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a98b9795b4fdc74d9d2efa9a3f2ecb62f">SVF::CoreBitVector::empty</a></div><div class="ttdeci">bool empty(void) const</div><div class="ttdoc">Returns true if no bits are set. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00050">CoreBitVector.cpp:50</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8ba857b68282055e485c441892e39b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba857b68282055e485c441892e39b9b">&#9670;&nbsp;</a></span>intersectWithComplement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::CoreBitVector::intersectWithComplement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Put intersection of this CBV with complemenet of rhs into this CBV. Returns true if this CBV changed. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00284">284</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;{</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    <span class="keywordflow">return</span> *<span class="keyword">this</span> -= rhs;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a79121882bc302b9b9188fa0a51c63fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79121882bc302b9b9188fa0a51c63fb6">&#9670;&nbsp;</a></span>intersectWithComplement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::CoreBitVector::intersectWithComplement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put intersection of lhs with complemenet of rhs into this CBV. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00289">289</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;{</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    <span class="comment">// TODO: inefficient!</span></div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    *<span class="keyword">this</span> = lhs;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    <a class="code" href="classSVF_1_1CoreBitVector.html#a8ba857b68282055e485c441892e39b9b">intersectWithComplement</a>(rhs);</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_a8ba857b68282055e485c441892e39b9b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a8ba857b68282055e485c441892e39b9b">SVF::CoreBitVector::intersectWithComplement</a></div><div class="ttdeci">bool intersectWithComplement(const CoreBitVector &amp;rhs)</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00284">CoreBitVector.cpp:284</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a087f69adea5e9e83bd908a1ab0ee1383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087f69adea5e9e83bd908a1ab0ee1383">&#9670;&nbsp;</a></span>nextSetIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVF::CoreBitVector::nextSetIndex </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the next index in the words array at or after start which contains set bits. This index and start are indices into the words array not accounting for the offset. Returns a value greater than or equal to words.size() when there are no more set bits. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00374">374</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;{</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    <span class="keywordtype">size_t</span> index = start;</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    <span class="keywordflow">for</span> ( ; index &lt; <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.size(); ++index)</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    {</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>[index]) <span class="keywordflow">break</span>;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    }</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    <span class="keywordflow">return</span> index;</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae84257a1544b94c9abf5c8d0f6cfaec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84257a1544b94c9abf5c8d0f6cfaec9">&#9670;&nbsp;</a></span>operator &=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::CoreBitVector::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Put intersection of this CBV and rhs into this CBV. Returns true if CBV changed. </p>

</div>
</div>
<a id="af142d3bb07e77c28bba6ece5b5b13f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af142d3bb07e77c28bba6ece5b5b13f51">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::CoreBitVector::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if either this CBV or rhs has a bit set unique to the other. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00167">167</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;{</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == rhs);</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5b87ae9d4a713483522666c893d7eac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b87ae9d4a713483522666c893d7eac9">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::CoreBitVector::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove set bits in rhs from this CBV. Returns true if CBV changed. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00261">261</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;{</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    <span class="comment">// Similar to |= in that we only iterate over rhs within this, but we</span></div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    <span class="comment">// don&#39;t need to extend anything since nothing from rhs is being added.</span></div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    <a class="code" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> greaterOffset = std::max(<a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a>, rhs.offset);</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    <span class="comment">// TODO: calling twice.</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    <span class="comment">// No overlap if either cannot hold the greater offset.</span></div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="classSVF_1_1CoreBitVector.html#a3c85fd2084e52df869cb8fcf2dab6486">canHold</a>(greaterOffset) || !rhs.canHold(greaterOffset)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    <span class="keywordtype">size_t</span> thisIndex = <a class="code" href="classSVF_1_1CoreBitVector.html#ad73fca28bd4882eaa70817023a632d35">indexForBit</a>(greaterOffset);</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    <span class="keywordtype">size_t</span> rhsIndex = rhs.indexForBit(greaterOffset);</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    <a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> oldWord;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    <span class="keywordflow">for</span> ( ; thisIndex &lt; <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.size() &amp;&amp; rhsIndex &lt; rhs.words.size(); ++thisIndex, ++rhsIndex)</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    {</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;        <span class="keywordflow">if</span> (!changed) oldWord = <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>[thisIndex];</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>[thisIndex] &amp;= ~rhs.words[rhsIndex];</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        <span class="keywordflow">if</span> (!changed) changed = oldWord != <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>[thisIndex];</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    }</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    <span class="keywordflow">return</span> changed;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_aaee26ffc13d05cd57f0fd7e4c2ea875c"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">SVF::CoreBitVector::Word</a></div><div class="ttdeci">unsigned long long Word</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00033">CoreBitVector.h:33</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_ad73fca28bd4882eaa70817023a632d35"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#ad73fca28bd4882eaa70817023a632d35">SVF::CoreBitVector::indexForBit</a></div><div class="ttdeci">size_t indexForBit(u32_t bit) const</div><div class="ttdoc">Returns the index into words which would hold bit. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00356">CoreBitVector.cpp:356</a></div></div>
<div class="ttc" id="namespaceSVF_html_ad42bff8d0a7d60a085aa32d10f4955af"><div class="ttname"><a href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">SVF::u32_t</a></div><div class="ttdeci">unsigned u32_t</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00077">SVFBasicTypes.h:77</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a3c85fd2084e52df869cb8fcf2dab6486"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a3c85fd2084e52df869cb8fcf2dab6486">SVF::CoreBitVector::canHold</a></div><div class="ttdeci">bool canHold(u32_t bit) const</div><div class="ttdoc">Returns true if bit can fit in this CBV without resizing. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00364">CoreBitVector.cpp:364</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3594d997fba0aa6201855199a884d98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3594d997fba0aa6201855199a884d98d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp; SVF::CoreBitVector::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00036">36</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;{</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    this-&gt;<a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> = rhs.offset;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    this-&gt;<a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a> = rhs.words;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae14cc9ce0abbad20636c51e6ca781305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14cc9ce0abbad20636c51e6ca781305">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp; SVF::CoreBitVector::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structMove.html">Move</a> assignment. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00043">43</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;{</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    this-&gt;<a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> = rhs.offset;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    this-&gt;<a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a> = std::move(rhs.words);</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0ddd7fc5e043d36f3c62c2fb93b22684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddd7fc5e043d36f3c62c2fb93b22684">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::CoreBitVector::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this CBV and rhs have the same bits set. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00139">139</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;{</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    <span class="comment">// TODO: maybe a simple equal offset, equal size path?</span></div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="keywordtype">size_t</span> lhsSetIndex = <a class="code" href="classSVF_1_1CoreBitVector.html#a087f69adea5e9e83bd908a1ab0ee1383">nextSetIndex</a>(0);</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="keywordtype">size_t</span> rhsSetIndex = rhs.nextSetIndex(0);</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <span class="comment">// Iterate comparing only words with set bits, if there is ever a mismatch,</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    <span class="comment">// then the bit-vectors aren&#39;t equal.</span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="keywordflow">while</span> (lhsSetIndex &lt; <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.size() &amp;&amp; rhsSetIndex &lt; rhs.words.size())</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    {</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        <span class="comment">// If the first bit is not the same in the word or words are different,</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        <span class="comment">// then we have a mismatch.</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        <span class="keywordflow">if</span> (lhsSetIndex * <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a> + <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> != rhsSetIndex * <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a> + rhs.offset</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;            || <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>[lhsSetIndex] != rhs.words[rhsSetIndex])</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        {</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        }</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        lhsSetIndex = <a class="code" href="classSVF_1_1CoreBitVector.html#a087f69adea5e9e83bd908a1ab0ee1383">nextSetIndex</a>(lhsSetIndex + 1);</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        rhsSetIndex = rhs.nextSetIndex(rhsSetIndex + 1);</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    }</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    <span class="comment">// Make sure both got to the end at the same time.</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    <span class="keywordflow">return</span> lhsSetIndex &gt;= <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.size() &amp;&amp; rhsSetIndex &gt;= rhs.words.size();</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_a63f5e4a36359ae62401e5f8dfecb86a3"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">SVF::CoreBitVector::WordSize</a></div><div class="ttdeci">static const size_t WordSize</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00034">CoreBitVector.h:34</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a087f69adea5e9e83bd908a1ab0ee1383"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a087f69adea5e9e83bd908a1ab0ee1383">SVF::CoreBitVector::nextSetIndex</a></div><div class="ttdeci">size_t nextSetIndex(const size_t start) const</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00374">CoreBitVector.cpp:374</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af8e63360242a49fb63c3ef3d7071503d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e63360242a49fb63c3ef3d7071503d">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::CoreBitVector::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CoreBitVector.html">CoreBitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Put union of this CBV and rhs into this CBV. Returns true if CBV changed. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00172">172</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;{</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.size() == 0)</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    {</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        *<span class="keyword">this</span> = rhs;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.size() != 0;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    }</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="keywordflow">if</span> (rhs.words.size() == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    <span class="comment">// TODO: some redundancy in extendTo calls.</span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classSVF_1_1CoreBitVector.html#a8825e54f584be8aa0ff627335064244e">finalBit</a>() &lt; rhs.finalBit()) <a class="code" href="classSVF_1_1CoreBitVector.html#a5d3f1eb85bc388cb76c588b8d8b3c181">extendForward</a>(rhs.finalBit());</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> &gt; rhs.offset) <a class="code" href="classSVF_1_1CoreBitVector.html#ab6d789e3c68390a9026fd4f8c4cf344a">extendBackward</a>(rhs.offset);</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="comment">// Start counting this where rhs starts.</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> thisIndex = <a class="code" href="classSVF_1_1CoreBitVector.html#ad73fca28bd4882eaa70817023a632d35">indexForBit</a>(rhs.offset);</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    <span class="keywordtype">size_t</span> rhsIndex = 0;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    <span class="comment">// Only need to test against rhs&#39;s size since we extended this to hold rhs.</span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    <a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> *thisWords = &amp;<a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>[thisIndex];</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    <span class="keyword">const</span> <a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> *rhsWords = &amp;rhs.words[rhsIndex];</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> length = rhs.words.size();</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    <a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> changed = 0;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="comment">// Can start counting from 0 because we took the addresses of both</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="comment">// word vectors at the correct index.</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="preprocessor">    #pragma omp simd</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0 ; i &lt; length; ++i)</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    {</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        <span class="keyword">const</span> <a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> oldWord = thisWords[i];</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        <span class="comment">// Is there anything in rhs not in *this?</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        thisWords[i] = thisWords[i] | rhsWords[i];</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        changed |= oldWord ^ thisWords[i];</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    }</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="keywordflow">return</span> changed;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_aaee26ffc13d05cd57f0fd7e4c2ea875c"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">SVF::CoreBitVector::Word</a></div><div class="ttdeci">unsigned long long Word</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00033">CoreBitVector.h:33</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_ad73fca28bd4882eaa70817023a632d35"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#ad73fca28bd4882eaa70817023a632d35">SVF::CoreBitVector::indexForBit</a></div><div class="ttdeci">size_t indexForBit(u32_t bit) const</div><div class="ttdoc">Returns the index into words which would hold bit. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00356">CoreBitVector.cpp:356</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a8825e54f584be8aa0ff627335064244e"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a8825e54f584be8aa0ff627335064244e">SVF::CoreBitVector::finalBit</a></div><div class="ttdeci">u32_t finalBit(void) const</div><div class="ttdoc">Returns the last bit that this CBV can hold. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00369">CoreBitVector.cpp:369</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_ab6d789e3c68390a9026fd4f8c4cf344a"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#ab6d789e3c68390a9026fd4f8c4cf344a">SVF::CoreBitVector::extendBackward</a></div><div class="ttdeci">void extendBackward(u32_t bit)</div><div class="ttdoc">Add enough words (prepend) to be able to include bit. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00318">CoreBitVector.cpp:318</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a5d3f1eb85bc388cb76c588b8d8b3c181"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a5d3f1eb85bc388cb76c588b8d8b3c181">SVF::CoreBitVector::extendForward</a></div><div class="ttdeci">void extendForward(u32_t bit)</div><div class="ttdoc">Add enough words (append) to be able to include bit. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00331">CoreBitVector.cpp:331</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a42fc777d574db4ef23b02308b944a85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42fc777d574db4ef23b02308b944a85b">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::CoreBitVector::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td>
          <td class="paramname"><em>bit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets bit in the CBV. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00095">95</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;{</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="keywordflow">if</span> (bit &lt; offset || bit &gt;= <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> + <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.size() * <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>) <span class="keywordflow">return</span>;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> &amp;containingWord = <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>[(bit - <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a>) / <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>];</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> mask = ~((<a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a>)0b1 &lt;&lt; (bit % <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>));</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    containingWord &amp;= mask;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_aaee26ffc13d05cd57f0fd7e4c2ea875c"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">SVF::CoreBitVector::Word</a></div><div class="ttdeci">unsigned long long Word</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00033">CoreBitVector.h:33</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a63f5e4a36359ae62401e5f8dfecb86a3"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">SVF::CoreBitVector::WordSize</a></div><div class="ttdeci">static const size_t WordSize</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00034">CoreBitVector.h:34</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a553e3e51bffe1aab04adc047e0fd3f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553e3e51bffe1aab04adc047e0fd3f24">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::CoreBitVector::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td>
          <td class="paramname"><em>bit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets bit in the CBV. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00086">86</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;{</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <a class="code" href="classSVF_1_1CoreBitVector.html#a73e5b15854f4f56f50992ed0d0cc7349">extendTo</a>(bit);</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> &amp;containingWord = <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>[(bit - <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a>) / <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>];</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> mask = (<a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a>)0b1 &lt;&lt; (bit % <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>);</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    containingWord |= mask;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_aaee26ffc13d05cd57f0fd7e4c2ea875c"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">SVF::CoreBitVector::Word</a></div><div class="ttdeci">unsigned long long Word</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00033">CoreBitVector.h:33</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a63f5e4a36359ae62401e5f8dfecb86a3"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">SVF::CoreBitVector::WordSize</a></div><div class="ttdeci">static const size_t WordSize</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00034">CoreBitVector.h:34</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a73e5b15854f4f56f50992ed0d0cc7349"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a73e5b15854f4f56f50992ed0d0cc7349">SVF::CoreBitVector::extendTo</a></div><div class="ttdeci">void extendTo(u32_t bit)</div><div class="ttdoc">Add enough words (append xor prepend) to be able to include bit. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00345">CoreBitVector.cpp:345</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7b20ffd3cd4a0ffc48a1348f657deaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b20ffd3cd4a0ffc48a1348f657deaa0">&#9670;&nbsp;</a></span>test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::CoreBitVector::test </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td>
          <td class="paramname"><em>bit</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if bit is set in this CBV. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00070">70</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;{</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="keywordflow">if</span> (bit &lt; offset || bit &gt;= <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a> + <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>.size() * <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="keyword">const</span> <a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> &amp;containingWord = <a class="code" href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">words</a>[(bit - <a class="code" href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">offset</a>) / <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>];</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <span class="keyword">const</span> <a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a> mask = (<a class="code" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a>)0b1 &lt;&lt; (bit % <a class="code" href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">WordSize</a>);</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <span class="keywordflow">return</span> mask &amp; containingWord;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_aaee26ffc13d05cd57f0fd7e4c2ea875c"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">SVF::CoreBitVector::Word</a></div><div class="ttdeci">unsigned long long Word</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00033">CoreBitVector.h:33</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a63f5e4a36359ae62401e5f8dfecb86a3"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a63f5e4a36359ae62401e5f8dfecb86a3">SVF::CoreBitVector::WordSize</a></div><div class="ttdeci">static const size_t WordSize</div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00034">CoreBitVector.h:34</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a79dfa9f4c2efb6a0a2de18c6359c41bd"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a79dfa9f4c2efb6a0a2de18c6359c41bd">SVF::CoreBitVector::offset</a></div><div class="ttdeci">u32_t offset</div><div class="ttdoc">The first bit of the first word. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00198">CoreBitVector.h:198</a></div></div>
<div class="ttc" id="classSVF_1_1CoreBitVector_html_a807283a917e845ef19c4962b1744e98b"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a807283a917e845ef19c4962b1744e98b">SVF::CoreBitVector::words</a></div><div class="ttdeci">std::vector&lt; Word &gt; words</div><div class="ttdoc">Our actual bit vector. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8h_source.html#l00200">CoreBitVector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3299b296d20d2b76c6538ba51a684972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3299b296d20d2b76c6538ba51a684972">&#9670;&nbsp;</a></span>test_and_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::CoreBitVector::test_and_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td>
          <td class="paramname"><em>bit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if bit is set. If it is, returns false. Otherwise, sets bit and returns true. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8cpp_source.html#l00078">78</a> of file <a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;{</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="comment">// TODO: can be faster.</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classSVF_1_1CoreBitVector.html#a7b20ffd3cd4a0ffc48a1348f657deaa0">test</a>(bit)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="keyword">set</span>(bit);</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;}</div><div class="ttc" id="classSVF_1_1CoreBitVector_html_a7b20ffd3cd4a0ffc48a1348f657deaa0"><div class="ttname"><a href="classSVF_1_1CoreBitVector.html#a7b20ffd3cd4a0ffc48a1348f657deaa0">SVF::CoreBitVector::test</a></div><div class="ttdeci">bool test(u32_t bit) const</div><div class="ttdoc">Returns true if bit is set in this CBV. </div><div class="ttdef"><b>Definition:</b> <a href="CoreBitVector_8cpp_source.html#l00070">CoreBitVector.cpp:70</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a79dfa9f4c2efb6a0a2de18c6359c41bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79dfa9f4c2efb6a0a2de18c6359c41bd">&#9670;&nbsp;</a></span>offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> SVF::CoreBitVector::offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The first bit of the first word. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8h_source.html#l00198">198</a> of file <a class="el" href="CoreBitVector_8h_source.html">CoreBitVector.h</a>.</p>

</div>
</div>
<a id="a807283a917e845ef19c4962b1744e98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807283a917e845ef19c4962b1744e98b">&#9670;&nbsp;</a></span>words</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a>&gt; SVF::CoreBitVector::words</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Our actual bit vector. </p>

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8h_source.html#l00200">200</a> of file <a class="el" href="CoreBitVector_8h_source.html">CoreBitVector.h</a>.</p>

</div>
</div>
<a id="a63f5e4a36359ae62401e5f8dfecb86a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f5e4a36359ae62401e5f8dfecb86a3">&#9670;&nbsp;</a></span>WordSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t SVF::CoreBitVector::WordSize = sizeof(<a class="el" href="classSVF_1_1CoreBitVector.html#aaee26ffc13d05cd57f0fd7e4c2ea875c">Word</a>) * CHAR_BIT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CoreBitVector_8h_source.html#l00034">34</a> of file <a class="el" href="CoreBitVector_8h_source.html">CoreBitVector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/SVF/SVF/include/Util/<a class="el" href="CoreBitVector_8h_source.html">CoreBitVector.h</a></li>
<li>/home/runner/work/SVF/SVF/lib/Util/<a class="el" href="CoreBitVector_8cpp_source.html">CoreBitVector.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
