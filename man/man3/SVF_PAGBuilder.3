.TH "SVF::PAGBuilder" 3 "Sun Feb 14 2021" "SVF" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SVF::PAGBuilder
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <PAGBuilder\&.h>\fP
.PP
Inherits llvm::InstVisitor< PAGBuilder >\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPAGBuilder\fP ()"
.br
.RI "Constructor\&. "
.ti -1c
.RI "virtual \fB~PAGBuilder\fP ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "virtual \fBPAG\fP * \fBbuild\fP (\fBSVFModule\fP *svfModule)"
.br
.RI "Start building \fBPAG\fP here\&. "
.ti -1c
.RI "\fBPAG\fP * \fBgetPAG\fP () const"
.br
.RI "Return \fBPAG\fP\&. "
.ti -1c
.RI "void \fBinitialiseNodes\fP ()"
.br
.RI "Initialize nodes and edges\&. "
.ti -1c
.RI "void \fBaddEdge\fP (NodeID src, NodeID dst, \fBPAGEdge::PEDGEK\fP kind, Size_t offset=0, Instruction *cs=NULL)"
.br
.ti -1c
.RI "void \fBsanityCheck\fP ()"
.br
.RI "Sanity check for \fBPAG\fP\&. "
.ti -1c
.RI "NodeID \fBgetValueNode\fP (const Value *V)"
.br
.RI "Get different kinds of node\&. "
.ti -1c
.RI "NodeID \fBgetObjectNode\fP (const Value *V)"
.br
.RI "GetObject - Return the object node (stack/global/heap/function) according to a LLVM Value\&. "
.ti -1c
.RI "NodeID \fBgetReturnNode\fP (const \fBSVFFunction\fP *func)"
.br
.RI "getReturnNode - Return the node representing the unique return value of a function\&. "
.ti -1c
.RI "NodeID \fBgetVarargNode\fP (const \fBSVFFunction\fP *func)"
.br
.RI "getVarargNode - Return the node representing the unique variadic argument of a function\&. "
.ti -1c
.RI "void \fBvisitGlobal\fP (\fBSVFModule\fP *svfModule)"
.br
.RI "Handle globals including (global variable and functions) "
.ti -1c
.RI "void \fBInitialGlobal\fP (const GlobalVariable *gvar, Constant *C, u32_t offset)"
.br
.ti -1c
.RI "NodeID \fBgetGlobalVarField\fP (const GlobalVariable *gvar, u32_t offset)"
.br
.ti -1c
.RI "void \fBprocessCE\fP (const Value *val)"
.br
.RI "Process constant expression\&. "
.ti -1c
.RI "bool \fBcomputeGepOffset\fP (const User *V, \fBLocationSet\fP &ls)"
.br
.RI "Compute offset of a gep instruction or gep constant expression\&. "
.ti -1c
.RI "void \fBhandleDirectCall\fP (CallSite cs, const \fBSVFFunction\fP *F)"
.br
.RI "Handle direct call\&. "
.ti -1c
.RI "void \fBhandleIndCall\fP (CallSite cs)"
.br
.RI "Handle indirect call\&. "
.ti -1c
.RI "virtual void \fBhandleExtCall\fP (CallSite cs, const \fBSVFFunction\fP *F)"
.br
.RI "Handle external call\&. "
.ti -1c
.RI "const Type * \fBgetBaseTypeAndFlattenedFields\fP (Value *v, std::vector< \fBLocationSet\fP > &fields)"
.br
.ti -1c
.RI "void \fBaddComplexConsForExt\fP (Value *D, Value *S, u32_t sz=0)"
.br
.ti -1c
.RI "virtual void \fBvisitAllocaInst\fP (\fBAllocaInst\fP &AI)"
.br
.RI "Our visit overrides\&. "
.ti -1c
.RI "void \fBvisitPHINode\fP (PHINode &I)"
.br
.ti -1c
.RI "void \fBvisitStoreInst\fP (StoreInst &I)"
.br
.ti -1c
.RI "void \fBvisitLoadInst\fP (LoadInst &I)"
.br
.ti -1c
.RI "void \fBvisitGetElementPtrInst\fP (GetElementPtrInst &I)"
.br
.ti -1c
.RI "void \fBvisitCallInst\fP (CallInst &I)"
.br
.ti -1c
.RI "void \fBvisitInvokeInst\fP (InvokeInst &II)"
.br
.ti -1c
.RI "void \fBvisitCallBrInst\fP (CallBrInst &I)"
.br
.ti -1c
.RI "void \fBvisitCallSite\fP (CallSite cs)"
.br
.ti -1c
.RI "void \fBvisitReturnInst\fP (ReturnInst &I)"
.br
.ti -1c
.RI "void \fBvisitCastInst\fP (CastInst &I)"
.br
.ti -1c
.RI "void \fBvisitSelectInst\fP (SelectInst &I)"
.br
.ti -1c
.RI "void \fBvisitExtractValueInst\fP (ExtractValueInst &EVI)"
.br
.ti -1c
.RI "void \fBvisitBranchInst\fP (BranchInst &I)"
.br
.ti -1c
.RI "void \fBvisitSwitchInst\fP (SwitchInst &I)"
.br
.ti -1c
.RI "void \fBvisitInsertValueInst\fP (InsertValueInst &I)"
.br
.ti -1c
.RI "void \fBvisitBinaryOperator\fP (BinaryOperator &I)"
.br
.ti -1c
.RI "void \fBvisitUnaryOperator\fP (UnaryOperator &I)"
.br
.ti -1c
.RI "void \fBvisitCmpInst\fP (CmpInst &I)"
.br
.ti -1c
.RI "void \fBvisitVAArgInst\fP (VAArgInst &)"
.br
.RI "TODO: do we need to care about these corner cases? "
.ti -1c
.RI "void \fBvisitExtractElementInst\fP (ExtractElementInst &I)"
.br
.ti -1c
.RI "void \fBvisitInsertElementInst\fP (InsertElementInst &I)"
.br
.ti -1c
.RI "void \fBvisitShuffleVectorInst\fP (ShuffleVectorInst &I)"
.br
.ti -1c
.RI "void \fBvisitLandingPadInst\fP (LandingPadInst &I)"
.br
.ti -1c
.RI "void \fBvisitResumeInst\fP (ResumeInst &)"
.br
.RI "Instruction not that often\&. "
.ti -1c
.RI "void \fBvisitUnreachableInst\fP (UnreachableInst &)"
.br
.ti -1c
.RI "void \fBvisitFenceInst\fP (FenceInst &I)"
.br
.ti -1c
.RI "void \fBvisitAtomicCmpXchgInst\fP (AtomicCmpXchgInst &I)"
.br
.ti -1c
.RI "void \fBvisitAtomicRMWInst\fP (AtomicRMWInst &I)"
.br
.ti -1c
.RI "void \fBvisitInstruction\fP (Instruction &)"
.br
.RI "Provide base case for our instruction visit\&. "
.ti -1c
.RI "void \fBsetCurrentLocation\fP (const Value *val, const BasicBlock *bb)"
.br
.RI "Set current basic block in order to keep track of control flow information\&. "
.ti -1c
.RI "const Value * \fBgetCurrentValue\fP () const"
.br
.ti -1c
.RI "const BasicBlock * \fBgetCurrentBB\fP () const"
.br
.ti -1c
.RI "void \fBaddGlobalBlackHoleAddrEdge\fP (NodeID node, const ConstantExpr *int2Ptrce)"
.br
.RI "Add global black hole Address edge\&. "
.ti -1c
.RI "NodeID \fBaddNullPtrNode\fP ()"
.br
.RI "Add NullPtr \fBPAGNode\fP\&. "
.ti -1c
.RI "NodeID \fBgetGepValNode\fP (const Value *val, const \fBLocationSet\fP &ls, const Type *baseType, u32_t fieldidx)"
.br
.ti -1c
.RI "void \fBsetCurrentBBAndValueForPAGEdge\fP (\fBPAGEdge\fP *edge)"
.br
.ti -1c
.RI "\fBPAGEdge\fP * \fBaddBlackHoleAddrEdge\fP (NodeID node)"
.br
.ti -1c
.RI "\fBAddrPE\fP * \fBaddAddrEdge\fP (NodeID src, NodeID dst)"
.br
.RI "Add Address edge\&. "
.ti -1c
.RI "\fBCopyPE\fP * \fBaddCopyEdge\fP (NodeID src, NodeID dst)"
.br
.RI "Add Copy edge\&. "
.ti -1c
.RI "\fBCmpPE\fP * \fBaddCmpEdge\fP (NodeID src, NodeID dst)"
.br
.RI "Add Copy edge\&. "
.ti -1c
.RI "\fBBinaryOPPE\fP * \fBaddBinaryOPEdge\fP (NodeID src, NodeID dst)"
.br
.RI "Add Copy edge\&. "
.ti -1c
.RI "\fBUnaryOPPE\fP * \fBaddUnaryOPEdge\fP (NodeID src, NodeID dst)"
.br
.RI "Add Unary edge\&. "
.ti -1c
.RI "\fBLoadPE\fP * \fBaddLoadEdge\fP (NodeID src, NodeID dst)"
.br
.RI "Add Load edge\&. "
.ti -1c
.RI "\fBStorePE\fP * \fBaddStoreEdge\fP (NodeID src, NodeID dst)"
.br
.RI "Add Store edge\&. "
.ti -1c
.RI "\fBCallPE\fP * \fBaddCallEdge\fP (NodeID src, NodeID dst, const \fBCallBlockNode\fP *cs)"
.br
.RI "Add Call edge\&. "
.ti -1c
.RI "\fBRetPE\fP * \fBaddRetEdge\fP (NodeID src, NodeID dst, const \fBCallBlockNode\fP *cs)"
.br
.RI "Add Return edge\&. "
.ti -1c
.RI "\fBGepPE\fP * \fBaddGepEdge\fP (NodeID src, NodeID dst, const \fBLocationSet\fP &ls, bool constGep)"
.br
.RI "Add Gep edge\&. "
.ti -1c
.RI "\fBNormalGepPE\fP * \fBaddNormalGepEdge\fP (NodeID src, NodeID dst, const \fBLocationSet\fP &ls)"
.br
.RI "Add Offset(Gep) edge\&. "
.ti -1c
.RI "\fBVariantGepPE\fP * \fBaddVariantGepEdge\fP (NodeID src, NodeID dst)"
.br
.RI "Add Variant(Gep) edge\&. "
.ti -1c
.RI "\fBTDForkPE\fP * \fBaddThreadForkEdge\fP (NodeID src, NodeID dst, const \fBCallBlockNode\fP *cs)"
.br
.RI "Add Thread fork edge for parameter passing\&. "
.ti -1c
.RI "\fBTDJoinPE\fP * \fBaddThreadJoinEdge\fP (NodeID src, NodeID dst, const \fBCallBlockNode\fP *cs)"
.br
.RI "Add Thread join edge for parameter passing\&. "
.in -1c
.SH "Detailed Description"
.PP 
\fBPAG\fP Builder 
.SH "Member Function Documentation"
.PP 
.SS "void PAGBuilder::addComplexConsForExt (Value * D, Value * S, u32_t sz = \fC0\fP)"
Add the load/store constraints and temp\&. nodes for the complex constraint *D = *S (where D/S may point to structs)\&. If sz is 0, we will add edges for all fields\&.
.SS "NodeID SVF::PAGBuilder::addNullPtrNode ()\fC [inline]\fP"

.PP
Add NullPtr \fBPAGNode\fP\&. let all undef value or non-determined pointers points-to black hole
.SS "\fBPAG\fP * PAGBuilder::build (\fBSVFModule\fP * svfModule)\fC [virtual]\fP"

.PP
Start building \fBPAG\fP here\&. Start building \fBPAG\fP here initial external library information initial \fBPAG\fP nodes
.PP
initial \fBPAG\fP edges: // handle globals
.PP
handle functions
.PP
collect return node of function fun
.PP
Return \fBPAG\fP node will not be created for function which can not reach the return instruction due to call to abort(), exit(), etc\&. In 176\&.gcc of SPEC 2000, function build_objc_string() from c-lang\&.c shows an example when fun\&.doesNotReturn() evaluates to TRUE because of abort()\&.
.PP
To be noted, we do not record arguments which are in declared function without body TODO: what about external functions with \fBPAG\fP imported by commandline?
.SS "bool PAGBuilder::computeGepOffset (const User * V, \fBLocationSet\fP & ls)"

.PP
Compute offset of a gep instruction or gep constant expression\&. Return the object node offset according to GEP insn (V)\&. Given a gep edge p = q + i, if 'i' is a constant then we return its offset size otherwise if 'i' is a variable determined by runtime, then it is a variant offset Return TRUE if the offset of this GEP insn is a constant\&. 
.SS "const Type * PAGBuilder::getBaseTypeAndFlattenedFields (Value * V, std::vector< \fBLocationSet\fP > & fields)"
Find the base type and the max possible offset of an object pointed to by (V)\&. 
.SS "NodeID PAGBuilder::getGepValNode (const Value * val, const \fBLocationSet\fP & ls, const Type * baseType, u32_t fieldidx)"
Add a temp field value node according to base value and offset this node is after the initial node method, it is out of scope of symInfo table 
.SS "NodeID PAGBuilder::getGlobalVarField (const GlobalVariable * gvar, u32_t offset)"
Get the field of the global variable node FIXME:Here we only get the field that actually used in the program We ignore the initialization of global variable field that not used in the program if we did not find the constant expression in the program, then we need to create a gep node for this field
.SS "void PAGBuilder::handleDirectCall (CallSite cs, const \fBSVFFunction\fP * F)"

.PP
Handle direct call\&. Add the constraints for a direct, non-external call\&. FIXME: this assertion should be placed for correct checking except bug program like 188\&.ammp, 300\&.twolf
.SS "void PAGBuilder::handleExtCall (CallSite cs, const \fBSVFFunction\fP * callee)\fC [virtual]\fP"

.PP
Handle external call\&. Handle external calls this case is for strcpy(dst,src); to maintain its semantics we will store src to the base of dst instead of dst\&. dst = load base store src base
.PP
create inter-procedural \fBPAG\fP edges for thread forks
.PP
pthread_create has 1 arg\&. apr_thread_create has 2 arg\&.
.PP
Connect actual parameter to formal parameter of the start routine
.PP
handle indirect calls at pthread create APIs e\&.g\&., pthread_create(&t1, NULL, fp, \&.\&.\&.); const Value* fun = \fBThreadAPI::getThreadAPI()\fP->getForkedFun(inst); if(!SVFUtil::isa<Function>(fun)) pag->addIndirectCallsites(cs,pag->getValueNode(fun));
.PP
If forkedFun does not pass to spawnee as function type but as void pointer remember to update inter-procedural callgraph/PAG/SVFG etc\&. when indirect call targets are resolved We don't connect the callgraph here, further investigation is need to hanle mod-ref during \fBSVFG\fP construction\&.
.PP
create inter-procedural \fBPAG\fP edges for hare_parallel_for calls
.PP
The task function of hare_parallel_for has 3 args\&.
.PP
Connect actual parameter to formal parameter of the start routine
.PP
handle indirect calls at hare_parallel_for (e\&.g\&., hare_parallel_for(\&.\&.\&., fp, \&.\&.\&.); const Value* fun = \fBThreadAPI::getThreadAPI()\fP->getForkedFun(inst); if(!SVFUtil::isa<Function>(fun)) pag->addIndirectCallsites(cs,pag->getValueNode(fun));
.PP
TODO: inter-procedural \fBPAG\fP edges for thread joins
.SS "void PAGBuilder::handleIndCall (CallSite cs)"

.PP
Handle indirect call\&. Indirect call is resolved on-the-fly during pointer analysis 
.SS "void PAGBuilder::InitialGlobal (const GlobalVariable * gvar, Constant * C, u32_t offset)"
src should not point to anything yet
.SS "void PAGBuilder::initialiseNodes ()"

.PP
Initialize nodes and edges\&. add address edges for constant nodes\&.
.SS "void PAGBuilder::processCE (const Value * val)"

.PP
Process constant expression\&. Handle constant expression, and connect the gep edge 
.SS "void PAGBuilder::setCurrentBBAndValueForPAGEdge (\fBPAGEdge\fP * edge)"
We assume every \fBGepValPN\fP and its \fBGepPE\fP are unique across whole program
.SS "void PAGBuilder::visitAllocaInst (\fBAllocaInst\fP & inst)\fC [virtual]\fP"

.PP
Our visit overrides\&. Visit alloca instructions Add edge V (dst) <-- O (src), V here is a value node on \fBPAG\fP, O is object node on \fBPAG\fP 
.SS "void PAGBuilder::visitBinaryOperator (BinaryOperator & inst)"
Visit Binary Operator 
.SS "void PAGBuilder::visitBranchInst (BranchInst & inst)"
Branch and switch instructions are treated as UnaryOP br cmp label if\&.then, label if\&.else 
.SS "void PAGBuilder::visitCallSite (CallSite cs)"
Collect callsite arguments and returns
.SS "void PAGBuilder::visitCmpInst (CmpInst & inst)"
Visit compare instruction 
.SS "void PAGBuilder::visitExtractElementInst (ExtractElementInst & inst)"
The �extractelement� instruction extracts a single scalar element from a vector at a specified index\&. TODO: for now we just assume the pointer after extraction points to blackhole The first operand of an �extractelement� instruction is a value of vector type\&. The second operand is an index indicating the position from which to extract the element\&.
.PP
<result> = extractelement <4 x i32> vec, i32 0 ; yields i32 
.SS "void PAGBuilder::visitExtractValueInst (ExtractValueInst & inst)"
visit extract value instructions for structures in registers TODO: for now we just assume the pointer after extraction points to blackhole for example %24 = extractvalue { i32, struct\&.s_hash* } call34, 0 %24 is a pointer points to first field of a register value call34 however we can not create call34 as an memory object, as it is register value\&. Is that necessary treat extract value as getelementptr instruction later to get more precise results? 
.SS "void PAGBuilder::visitGetElementPtrInst (GetElementPtrInst & inst)"
Visit getelementptr instructions 
.SS "void PAGBuilder::visitGlobal (\fBSVFModule\fP * svfModule)"

.PP
Handle globals including (global variable and functions) Visit global variables for building \fBPAG\fP initialize global variable
.PP
initialize global functions
.SS "void PAGBuilder::visitPHINode (PHINode & inst)"
Visit phi instructions 
.SS "void PAGBuilder::visitReturnInst (ReturnInst & inst)"
Visit return instructions of a function 
.SS "void PAGBuilder::visitSelectInst (SelectInst & inst)"
Visit select instructions Two operands have same incoming basic block, both are the current BB
.SS "void PAGBuilder::visitStoreInst (StoreInst & inst)"
Visit store instructions 
.SS "void PAGBuilder::visitUnaryOperator (UnaryOperator & inst)"
Visit Unary Operator 

.SH "Author"
.PP 
Generated automatically by Doxygen for SVF from the source code\&.
