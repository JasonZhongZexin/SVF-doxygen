.TH "SVF::MHP" 3 "Sun Feb 14 2021" "SVF" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SVF::MHP
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <MHP\&.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef Set< const Function * > \fBFunSet\fP"
.br
.ti -1c
.RI "typedef Set< const Instruction * > \fBInstSet\fP"
.br
.ti -1c
.RI "typedef Set< const \fBStmtSVFGNode\fP * > \fBSVFGNodeSet\fP"
.br
.ti -1c
.RI "typedef TCT::InstVec \fBInstVec\fP"
.br
.ti -1c
.RI "typedef \fBFIFOWorkList\fP< \fBCxtThreadStmt\fP > \fBCxtThreadStmtWorkList\fP"
.br
.ti -1c
.RI "typedef Set< \fBCxtThreadStmt\fP > \fBCxtThreadStmtSet\fP"
.br
.ti -1c
.RI "typedef Map< const \fBCxtThreadStmt\fP, NodeBS > \fBThreadStmtToThreadInterleav\fP"
.br
.ti -1c
.RI "typedef Map< const Instruction *, CxtThreadStmtSet > \fBInstToThreadStmtSetMap\fP"
.br
.ti -1c
.RI "typedef Set< \fBCxtStmt\fP > \fBLockSpan\fP"
.br
.ti -1c
.RI "typedef std::pair< const Function *, const Function * > \fBFuncPair\fP"
.br
.ti -1c
.RI "typedef Map< FuncPair, bool > \fBFuncPairToBool\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMHP\fP (\fBTCT\fP *t)"
.br
.RI "Constructor\&. "
.ti -1c
.RI "virtual \fB~MHP\fP ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "void \fBanalyze\fP ()"
.br
.RI "Start analysis here\&. "
.ti -1c
.RI "void \fBanalyzeInterleaving\fP ()"
.br
.RI "Analyze thread interleaving\&. "
.ti -1c
.RI "\fBThreadCallGraph\fP * \fBgetThreadCallGraph\fP () const"
.br
.RI "Get \fBThreadCallGraph\fP\&. "
.ti -1c
.RI "\fBTCT\fP * \fBgetTCT\fP () const"
.br
.RI "Get Thread Creation Tree\&. "
.ti -1c
.RI "bool \fBisConnectedfromMain\fP (const Function *fun)"
.br
.RI "Whether the function is connected from main function in thread call graph\&. "
.ti -1c
.RI "virtual bool \fBmayHappenInParallel\fP (const Instruction *i1, const Instruction *i2)"
.br
.RI "Interface to query whether two instructions may happen-in-parallel\&. "
.ti -1c
.RI "virtual bool \fBmayHappenInParallelCache\fP (const Instruction *i1, const Instruction *i2)"
.br
.ti -1c
.RI "virtual bool \fBmayHappenInParallelInst\fP (const Instruction *i1, const Instruction *i2)"
.br
.ti -1c
.RI "virtual bool \fBexecutedByTheSameThread\fP (const Instruction *i1, const Instruction *i2)"
.br
.ti -1c
.RI "const NodeBS & \fBgetInterleavingThreads\fP (const \fBCxtThreadStmt\fP &cts)"
.br
.RI "Get interleaving thread for statement inst\&. "
.ti -1c
.RI "bool \fBhasInterleavingThreads\fP (const \fBCxtThreadStmt\fP &cts) const"
.br
.ti -1c
.RI "const CxtThreadStmtSet & \fBgetThreadStmtSet\fP (const Instruction *inst) const"
.br
.RI "Get/has ThreadStmt\&. "
.ti -1c
.RI "bool \fBhasThreadStmtSet\fP (const Instruction *inst) const"
.br
.ti -1c
.RI "void \fBprintInterleaving\fP ()"
.br
.RI "Print interleaving results\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "u32_t \fBnumOfTotalQueries\fP"
.br
.RI "Total number of queries\&. "
.ti -1c
.RI "u32_t \fBnumOfMHPQueries\fP"
.br
.RI "Number of queries are answered as may-happen-in-parallel\&. "
.ti -1c
.RI "double \fBinterleavingTime\fP"
.br
.ti -1c
.RI "double \fBinterleavingQueriesTime\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class serves as a base may-happen in parallel analysis for multithreaded program Given a statement under an abstract thread, it tells which abstract threads may be alive at the same time (May-happen-in-parallel)\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "MHP::MHP (\fBTCT\fP * t)"

.PP
Constructor\&. Constructor 
.SS "MHP::~MHP ()\fC [virtual]\fP"

.PP
Destructor\&. Destructor 
.SH "Member Function Documentation"
.PP 
.SS "void MHP::analyze ()"

.PP
Start analysis here\&. Start analysis here 
.SS "void MHP::analyzeInterleaving ()"

.PP
Analyze thread interleaving\&. Analyze thread interleaving handle non-candidate function
.PP
handle candidate function
.PP
update non-candidate functions' interleaving
.SS "bool MHP::mayHappenInParallelInst (const Instruction * i1, const Instruction * i2)\fC [virtual]\fP"
Answer \fBMHP\fP queries For a pair of ThreadStmts (t1,s1) = <l1> (t2,s2) = <l2> They may happen in parallel if (1) t1 == t2 and t1 inloop/incycle (2) t1!=t2 and t1 \\in l2 and t2 \\in l1 TODO: Any instruction in dead function is assumed no \fBMHP\fP with others
.SS "void MHP::printInterleaving ()"

.PP
Print interleaving results\&. Print interleaving results 

.SH "Author"
.PP 
Generated automatically by Doxygen for SVF from the source code\&.
