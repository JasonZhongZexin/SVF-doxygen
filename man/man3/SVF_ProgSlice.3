.TH "SVF::ProgSlice" 3 "Sun Feb 14 2021" "SVF" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SVF::ProgSlice
.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef Set< const \fBSVFGNode\fP * > \fBSVFGNodeSet\fP"
.br
.ti -1c
.RI "typedef SVFGNodeSet::const_iterator \fBSVFGNodeSetIter\fP"
.br
.ti -1c
.RI "typedef \fBPathCondAllocator::Condition\fP \fBCondition\fP"
.br
.ti -1c
.RI "typedef Map< const \fBSVFGNode\fP *, \fBCondition\fP * > \fBSVFGNodeToCondMap\fP"
.br
.RI "map a SVFGNode to its condition during value-flow guard computation "
.ti -1c
.RI "typedef \fBFIFOWorkList\fP< const \fBSVFGNode\fP * > \fBVFWorkList\fP"
.br
.RI "worklist for value-flow guard computation "
.ti -1c
.RI "typedef \fBFIFOWorkList\fP< const BasicBlock * > \fBCFWorkList\fP"
.br
.RI "worklist for control-flow guard computation "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBProgSlice\fP (const \fBSVFGNode\fP *src, \fBPathCondAllocator\fP *pa, const \fBSVFG\fP *graph)"
.br
.RI "Constructor\&. "
.ti -1c
.RI "virtual \fB~ProgSlice\fP ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "u32_t \fBgetForwardSliceSize\fP () const"
.br
.ti -1c
.RI "u32_t \fBgetBackwardSliceSize\fP () const"
.br
.ti -1c
.RI "void \fBaddToForwardSlice\fP (const \fBSVFGNode\fP *node)"
.br
.RI "Forward and backward slice operations\&. "
.ti -1c
.RI "void \fBaddToBackwardSlice\fP (const \fBSVFGNode\fP *node)"
.br
.ti -1c
.RI "bool \fBinForwardSlice\fP (const \fBSVFGNode\fP *node)"
.br
.ti -1c
.RI "bool \fBinBackwardSlice\fP (const \fBSVFGNode\fP *node)"
.br
.ti -1c
.RI "SVFGNodeSetIter \fBforwardSliceBegin\fP () const"
.br
.ti -1c
.RI "SVFGNodeSetIter \fBforwardSliceEnd\fP () const"
.br
.ti -1c
.RI "SVFGNodeSetIter \fBbackwardSliceBegin\fP () const"
.br
.ti -1c
.RI "SVFGNodeSetIter \fBbackwardSliceEnd\fP () const"
.br
.ti -1c
.RI "const \fBSVFGNode\fP * \fBgetSource\fP () const"
.br
.RI "root and sink operations "
.ti -1c
.RI "void \fBaddToSinks\fP (const \fBSVFGNode\fP *node)"
.br
.ti -1c
.RI "const SVFGNodeSet & \fBgetSinks\fP () const"
.br
.ti -1c
.RI "SVFGNodeSetIter \fBsinksBegin\fP () const"
.br
.ti -1c
.RI "SVFGNodeSetIter \fBsinksEnd\fP () const"
.br
.ti -1c
.RI "void \fBsetPartialReachable\fP ()"
.br
.ti -1c
.RI "void \fBsetAllReachable\fP ()"
.br
.ti -1c
.RI "bool \fBsetReachGlobal\fP ()"
.br
.ti -1c
.RI "bool \fBisPartialReachable\fP () const"
.br
.ti -1c
.RI "bool \fBisAllReachable\fP () const"
.br
.ti -1c
.RI "bool \fBisReachGlobal\fP () const"
.br
.ti -1c
.RI "bool \fBAllPathReachableSolve\fP ()"
.br
.RI "Guarded reachability solve\&. "
.ti -1c
.RI "bool \fBisSatisfiableForAll\fP ()"
.br
.ti -1c
.RI "bool \fBisSatisfiableForPairs\fP ()"
.br
.ti -1c
.RI "const Value * \fBgetLLVMValue\fP (const \fBSVFGNode\fP *node) const"
.br
.RI "Get llvm value from a SVFGNode\&. "
.ti -1c
.RI "const \fBCallBlockNode\fP * \fBgetCallSite\fP (const \fBSVFGEdge\fP *edge) const"
.br
.RI "Get callsite ID and get returnsiteID from SVFGEdge\&. "
.ti -1c
.RI "const \fBCallBlockNode\fP * \fBgetRetSite\fP (const \fBSVFGEdge\fP *edge) const"
.br
.ti -1c
.RI "\fBCondition\fP * \fBcondAnd\fP (\fBCondition\fP *lhs, \fBCondition\fP *rhs)"
.br
.RI "Condition operations\&. "
.ti -1c
.RI "\fBCondition\fP * \fBcondOr\fP (\fBCondition\fP *lhs, \fBCondition\fP *rhs)"
.br
.ti -1c
.RI "\fBCondition\fP * \fBcondNeg\fP (\fBCondition\fP *cond)"
.br
.ti -1c
.RI "\fBCondition\fP * \fBgetTrueCond\fP () const"
.br
.ti -1c
.RI "\fBCondition\fP * \fBgetFalseCond\fP () const"
.br
.ti -1c
.RI "std::string \fBdumpCond\fP (\fBCondition\fP *cond) const"
.br
.ti -1c
.RI "std::string \fBevalFinalCond\fP () const"
.br
.RI "Evaluate final condition\&. "
.ti -1c
.RI "void \fBannotatePaths\fP ()"
.br
.RI "Annotate program according to final condition\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "const \fBSVFG\fP * \fBgetSVFG\fP () const"
.br
.ti -1c
.RI "void \fBdestroy\fP ()"
.br
.RI "Release memory\&. "
.ti -1c
.RI "void \fBclearCFCond\fP ()"
.br
.RI "Clear Control flow conditions before each VF computation\&. "
.ti -1c
.RI "\fBCondition\fP * \fBgetVFCond\fP (const \fBSVFGNode\fP *node) const"
.br
.RI "Get/set VF (value-flow) and CF (control-flow) conditions\&. "
.ti -1c
.RI "bool \fBsetVFCond\fP (const \fBSVFGNode\fP *node, \fBCondition\fP *cond)"
.br
.ti -1c
.RI "\fBCondition\fP * \fBComputeIntraVFGGuard\fP (const BasicBlock *src, const BasicBlock *dst)"
.br
.RI "Compute guards for value-flows\&. "
.ti -1c
.RI "\fBCondition\fP * \fBComputeInterCallVFGGuard\fP (const BasicBlock *src, const BasicBlock *dst, const BasicBlock *callBB)"
.br
.ti -1c
.RI "\fBCondition\fP * \fBComputeInterRetVFGGuard\fP (const BasicBlock *src, const BasicBlock *dst, const BasicBlock *retBB)"
.br
.ti -1c
.RI "const BasicBlock * \fBgetSVFGNodeBB\fP (const \fBSVFGNode\fP *node) const"
.br
.ti -1c
.RI "const \fBSVFGNode\fP * \fBgetCurSVFGNode\fP () const"
.br
.RI "Get/set current \fBSVFG\fP node\&. "
.ti -1c
.RI "void \fBsetCurSVFGNode\fP (const \fBSVFGNode\fP *node)"
.br
.ti -1c
.RI "void \fBsetFinalCond\fP (\fBCondition\fP *cond)"
.br
.RI "Set final condition after all path reachability analysis\&. "
.in -1c
.SH "Member Function Documentation"
.PP 
.SS "bool ProgSlice::AllPathReachableSolve ()"

.PP
Guarded reachability solve\&. Compute path conditions for nodes on the backward slice path condition of each node is calculated starting from root node (source) Given a SVFGNode n, its path condition C is allocated (path_i stands for one of m program paths reaches n)
.PP
C = \\bigvee Guard(path_i), 0 < i < m Guard(path_i) = \\bigwedge VFGGuard(x,y), suppose (x,y) are two SVFGNode nodes on path_i mark source node conditions to be true
.PP
clean up the control flow conditions for next round guard computation
.SS "void ProgSlice::annotatePaths ()"

.PP
Annotate program according to final condition\&. Annotate program paths according to the final path condition computed 
.SS "void SVF::ProgSlice::clearCFCond ()\fC [inline]\fP, \fC [protected]\fP"

.PP
Clear Control flow conditions before each VF computation\&. TODO: how to clean bdd memory
.SS "void ProgSlice::destroy ()\fC [protected]\fP"

.PP
Release memory\&. TODO: how to clean bdd memory
.SS "std::string ProgSlice::evalFinalCond () const"

.PP
Evaluate final condition\&. Evaluate Atoms of a condition TODO: for now we only evaluate one path, evaluate every single path
.PP
Atom -- a propositional valirable: a, b, c Literal -- an atom or its negation: a, ~a Clause -- A disjunction of some literals: a \\vee b CNF formula -- a conjunction of some clauses: (a \\vee b ) \\wedge (c \\vee d) print leak path after eliminating duplicated element
.SS "const Value * ProgSlice::getLLVMValue (const \fBSVFGNode\fP * node) const"

.PP
Get llvm value from a SVFGNode\&. Return llvm value for addr/copy/gep/load/phi/actualParam/formalParam/actualRet/formalRet but not for store/mssaphi/actualIn/acutalOut/formalIn/formalOut 
.SS "const BasicBlock* SVF::ProgSlice::getSVFGNodeBB (const \fBSVFGNode\fP * node) const\fC [inline]\fP, \fC [protected]\fP"
Return the basic block where a SVFGNode resides in a SVFGNode may not in a basic block if it is not a program statement (e\&.g\&. \fBPAGEdge\fP is an global assignment or NullPtrSVFGNode) 
.SS "bool ProgSlice::isSatisfiableForAll ()"
Solve by computing disjunction of conditions from all sinks (e\&.g\&., memory leak) 
.SS "bool ProgSlice::isSatisfiableForPairs ()"
Solve by analysing each pair of sinks (e\&.g\&., double free) 

.SH "Author"
.PP 
Generated automatically by Doxygen for SVF from the source code\&.
