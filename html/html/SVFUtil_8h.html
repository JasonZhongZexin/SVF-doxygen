<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Static Value-Flow Analysis: /home/runner/work/SVF/SVF/include/Util/SVFUtil.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Static Value-Flow Analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_95e22971b5dbae2382075a3453e365b4.html">Util</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SVFUtil.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="fastcluster_8h_source.html">FastCluster/fastcluster.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LLVMModule_8h_source.html">SVF-FE/LLVMModule.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Util_2BasicTypes_8h_source.html">Util/BasicTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PointsTo_8h_source.html">MemoryModel/PointsTo.h</a>&quot;</code><br />
<code>#include &lt;time.h&gt;</code><br />
</div>
<p><a href="SVFUtil_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">SVF::SVFUtil::equalPointsTo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">SVF::SVFUtil::equalNodeBS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceSVF"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF.html">SVF</a></td></tr>
<tr class="memdesc:namespaceSVF"><td class="mdescLeft">&#160;</td><td class="mdescRight">for isBitcode <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceSVF_1_1SVFUtil"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html">SVF::SVFUtil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a68302f07b13f6e1f39aace5699762c41"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">SVF::SVFUtil::equalPointsTo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a68302f07b13f6e1f39aace5699762c41">SVF::SVFUtil::equalPointsTo</a></td></tr>
<tr class="separator:a68302f07b13f6e1f39aace5699762c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2b39ae857d78ed9dda83880e703b0f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">SVF::SVFUtil::equalNodeBS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5c2b39ae857d78ed9dda83880e703b0f">SVF::SVFUtil::equalNodeBS</a></td></tr>
<tr class="separator:a5c2b39ae857d78ed9dda83880e703b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4740b14abf7d308e7806a0d6d6c42ee2"><td class="memItemLeft" align="right" valign="top">typedef OrderedSet&lt; PointsTo, equalPointsTo &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">SVF::SVFUtil::PointsToList</a></td></tr>
<tr class="separator:a4740b14abf7d308e7806a0d6d6c42ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aed0b0b9f035057552a6a82154fd88e61"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVF::SVFUtil::outs</a> ()</td></tr>
<tr class="memdesc:aed0b0b9f035057552a6a82154fd88e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite <a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61" title="Overwrite llvm::outs() ">llvm::outs()</a>  <a href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">More...</a><br /></td></tr>
<tr class="separator:aed0b0b9f035057552a6a82154fd88e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65033f068bfbeb0a1c52dcec3beb6bc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab65033f068bfbeb0a1c52dcec3beb6bc">SVF::SVFUtil::errs</a> ()</td></tr>
<tr class="memdesc:ab65033f068bfbeb0a1c52dcec3beb6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite <a class="el" href="namespaceSVF_1_1SVFUtil.html#ab65033f068bfbeb0a1c52dcec3beb6bc" title="Overwrite llvm::errs() ">llvm::errs()</a>  <a href="namespaceSVF_1_1SVFUtil.html#ab65033f068bfbeb0a1c52dcec3beb6bc">More...</a><br /></td></tr>
<tr class="separator:ab65033f068bfbeb0a1c52dcec3beb6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb570e9267fd7b189bd1bc877896d7ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">SVF::SVFUtil::dumpSet</a> (<a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> To, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=SVFUtil::outs())</td></tr>
<tr class="memdesc:aeb570e9267fd7b189bd1bc877896d7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump sparse bitvector set.  <a href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">More...</a><br /></td></tr>
<tr class="separator:aeb570e9267fd7b189bd1bc877896d7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aa23b4982662d98c56af3e8ba16cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a04aa23b4982662d98c56af3e8ba16cb1">SVF::SVFUtil::dumpSet</a> (<a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> To, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=SVFUtil::outs())</td></tr>
<tr class="separator:a04aa23b4982662d98c56af3e8ba16cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#abd0a9ee845a455f9354d24a8b84a0bb3">SVF::SVFUtil::dumpPointsToSet</a> (unsigned node, <a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> To)</td></tr>
<tr class="memdesc:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump points-to set.  <a href="namespaceSVF_1_1SVFUtil.html#abd0a9ee845a455f9354d24a8b84a0bb3">More...</a><br /></td></tr>
<tr class="separator:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30a35713852a0a525c52ae5dd463442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab30a35713852a0a525c52ae5dd463442">SVF::SVFUtil::dumpSparseSet</a> (const <a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> &amp;To)</td></tr>
<tr class="separator:ab30a35713852a0a525c52ae5dd463442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a15cc5570eed12dd6ee766213e11d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4a15cc5570eed12dd6ee766213e11d61">SVF::SVFUtil::dumpAliasSet</a> (unsigned node, <a class="el" href="namespaceSVF.html#a740396763e377643790c8b803ab3e4ea">NodeBS</a> To)</td></tr>
<tr class="memdesc:a4a15cc5570eed12dd6ee766213e11d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump alias set.  <a href="namespaceSVF_1_1SVFUtil.html#a4a15cc5570eed12dd6ee766213e11d61">More...</a><br /></td></tr>
<tr class="separator:a4a15cc5570eed12dd6ee766213e11d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a55f1f8598998a3ffbbc67d32eaf8c4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6a55f1f8598998a3ffbbc67d32eaf8c4">SVF::SVFUtil::sucMsg</a> (std::string msg)</td></tr>
<tr class="memdesc:a6a55f1f8598998a3ffbbc67d32eaf8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns successful message by converting a string into green string output.  <a href="namespaceSVF_1_1SVFUtil.html#a6a55f1f8598998a3ffbbc67d32eaf8c4">More...</a><br /></td></tr>
<tr class="separator:a6a55f1f8598998a3ffbbc67d32eaf8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c06020737f7dff22a666b75c28c5e7d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6c06020737f7dff22a666b75c28c5e7d">SVF::SVFUtil::wrnMsg</a> (std::string msg)</td></tr>
<tr class="memdesc:a6c06020737f7dff22a666b75c28c5e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns warning message by converting a string into yellow string output.  <a href="namespaceSVF_1_1SVFUtil.html#a6c06020737f7dff22a666b75c28c5e7d">More...</a><br /></td></tr>
<tr class="separator:a6c06020737f7dff22a666b75c28c5e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077caa1b10ab84d101d79fc7ea50db2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a077caa1b10ab84d101d79fc7ea50db2d">SVF::SVFUtil::writeWrnMsg</a> (std::string msg)</td></tr>
<tr class="memdesc:a077caa1b10ab84d101d79fc7ea50db2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a message run through wrnMsg.  <a href="namespaceSVF_1_1SVFUtil.html#a077caa1b10ab84d101d79fc7ea50db2d">More...</a><br /></td></tr>
<tr class="separator:a077caa1b10ab84d101d79fc7ea50db2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609eea630a8f88fe9eaba15ce7e48738"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a609eea630a8f88fe9eaba15ce7e48738">SVF::SVFUtil::pasMsg</a> (std::string msg)</td></tr>
<tr class="memdesc:a609eea630a8f88fe9eaba15ce7e48738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print each pass/phase message by converting a string into blue string output.  <a href="namespaceSVF_1_1SVFUtil.html#a609eea630a8f88fe9eaba15ce7e48738">More...</a><br /></td></tr>
<tr class="separator:a609eea630a8f88fe9eaba15ce7e48738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfe12afa463d0ceddeee11540c33ab3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6cfe12afa463d0ceddeee11540c33ab3">SVF::SVFUtil::reportMemoryUsageKB</a> (const std::string &amp;infor, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=SVFUtil::outs())</td></tr>
<tr class="memdesc:a6cfe12afa463d0ceddeee11540c33ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print memory usage in KB.  <a href="namespaceSVF_1_1SVFUtil.html#a6cfe12afa463d0ceddeee11540c33ab3">More...</a><br /></td></tr>
<tr class="separator:a6cfe12afa463d0ceddeee11540c33ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">SVF::SVFUtil::getMemoryUsageKB</a> (<a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *vmrss_kb, <a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *vmsize_kb)</td></tr>
<tr class="memdesc:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get memory usage from system file. Return TRUE if succeed.  <a href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">More...</a><br /></td></tr>
<tr class="separator:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7588578735679773493ff2d5e458e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a0d7588578735679773493ff2d5e458e1">SVF::SVFUtil::increaseStackSize</a> ()</td></tr>
<tr class="memdesc:a0d7588578735679773493ff2d5e458e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the stack size limit.  <a href="namespaceSVF_1_1SVFUtil.html#a0d7588578735679773493ff2d5e458e1">More...</a><br /></td></tr>
<tr class="separator:a0d7588578735679773493ff2d5e458e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ce14119a6e3b0b6022753ddd5890f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa5ce14119a6e3b0b6022753ddd5890f3">SVF::SVFUtil::cmpPts</a> (const PointsTo &amp;lpts, const PointsTo &amp;rpts)</td></tr>
<tr class="separator:aa5ce14119a6e3b0b6022753ddd5890f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f749354b7e882ef3e5bf5081fa715b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8f749354b7e882ef3e5bf5081fa715b5">SVF::SVFUtil::cmpNodeBS</a> (const NodeBS &amp;lpts, const NodeBS &amp;rpts)</td></tr>
<tr class="separator:a8f749354b7e882ef3e5bf5081fa715b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ebab122895189be57637b84adc7642"><td class="memItemLeft" align="right" valign="top">NodeBS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86ebab122895189be57637b84adc7642">SVF::SVFUtil::ptsToNodeBS</a> (const PointsTo &amp;pts)</td></tr>
<tr class="separator:a86ebab122895189be57637b84adc7642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ceddbe4d57b24e80201bc895f73810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af4ceddbe4d57b24e80201bc895f73810">SVF::SVFUtil::dumpPointsToList</a> (const PointsToList &amp;ptl)</td></tr>
<tr class="separator:af4ceddbe4d57b24e80201bc895f73810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c53be5490882768d51aa894b37cbf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad2c53be5490882768d51aa894b37cbf1">SVF::SVFUtil::isIntrinsicFun</a> (const Function *func)</td></tr>
<tr class="separator:ad2c53be5490882768d51aa894b37cbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f58caf27c30a1d414e06f60ca84d80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab7f58caf27c30a1d414e06f60ca84d80">SVF::SVFUtil::isIntrinsicInst</a> (const Instruction *inst)</td></tr>
<tr class="memdesc:ab7f58caf27c30a1d414e06f60ca84d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it is an intrinsic instruction.  <a href="namespaceSVF_1_1SVFUtil.html#ab7f58caf27c30a1d414e06f60ca84d80">More...</a><br /></td></tr>
<tr class="separator:ab7f58caf27c30a1d414e06f60ca84d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e08ce822223842fa6a73fd659b1a526"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a2e08ce822223842fa6a73fd659b1a526">SVF::SVFUtil::isCallSite</a> (const Instruction *inst)</td></tr>
<tr class="memdesc:a2e08ce822223842fa6a73fd659b1a526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a call or invoke instruction.  <a href="namespaceSVF_1_1SVFUtil.html#a2e08ce822223842fa6a73fd659b1a526">More...</a><br /></td></tr>
<tr class="separator:a2e08ce822223842fa6a73fd659b1a526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bf8f7eaa18fc5a09711959b5417854"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">SVF::SVFUtil::isCallSite</a> (const Value *val)</td></tr>
<tr class="memdesc:a38bf8f7eaa18fc5a09711959b5417854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a call or invoke instruction.  <a href="namespaceSVF_1_1SVFUtil.html#a38bf8f7eaa18fc5a09711959b5417854">More...</a><br /></td></tr>
<tr class="separator:a38bf8f7eaa18fc5a09711959b5417854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8216a92140d982303f83ea424ddc91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8d8216a92140d982303f83ea424ddc91">SVF::SVFUtil::isNonInstricCallSite</a> (const Instruction *inst)</td></tr>
<tr class="memdesc:a8d8216a92140d982303f83ea424ddc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a callsite in the application code, excluding llvm intrinsic calls.  <a href="namespaceSVF_1_1SVFUtil.html#a8d8216a92140d982303f83ea424ddc91">More...</a><br /></td></tr>
<tr class="separator:a8d8216a92140d982303f83ea424ddc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202de7ad2bea0311e2f75894c030e7a9"><td class="memItemLeft" align="right" valign="top">CallSite&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a202de7ad2bea0311e2f75894c030e7a9">SVF::SVFUtil::getLLVMCallSite</a> (const Instruction *inst)</td></tr>
<tr class="memdesc:a202de7ad2bea0311e2f75894c030e7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return LLVM callsite given a instruction.  <a href="namespaceSVF_1_1SVFUtil.html#a202de7ad2bea0311e2f75894c030e7a9">More...</a><br /></td></tr>
<tr class="separator:a202de7ad2bea0311e2f75894c030e7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09c2b313ff1c1abcc1e5cb3f9ef46a5"><td class="memItemLeft" align="right" valign="top">const SVFFunction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa09c2b313ff1c1abcc1e5cb3f9ef46a5">SVF::SVFUtil::getFunction</a> (std::string name)</td></tr>
<tr class="memdesc:aa09c2b313ff1c1abcc1e5cb3f9ef46a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the corresponding Function based on its name.  <a href="namespaceSVF_1_1SVFUtil.html#aa09c2b313ff1c1abcc1e5cb3f9ef46a5">More...</a><br /></td></tr>
<tr class="separator:aa09c2b313ff1c1abcc1e5cb3f9ef46a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54e70082388bbd70868250aaa0bc86b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af54e70082388bbd70868250aaa0bc86b">SVF::SVFUtil::split</a> (const std::string &amp;s, char seperator)</td></tr>
<tr class="memdesc:af54e70082388bbd70868250aaa0bc86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into two substrings around the first occurrence of a separator string.  <a href="namespaceSVF_1_1SVFUtil.html#af54e70082388bbd70868250aaa0bc86b">More...</a><br /></td></tr>
<tr class="separator:af54e70082388bbd70868250aaa0bc86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b55d5252da1f316f505cf6ce2078b28"><td class="memItemLeft" align="right" valign="top">const Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4b55d5252da1f316f505cf6ce2078b28">SVF::SVFUtil::getGlobalRep</a> (const Value *val)</td></tr>
<tr class="memdesc:a4b55d5252da1f316f505cf6ce2078b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the unique defined global across multiple modules  <a href="namespaceSVF_1_1SVFUtil.html#a4b55d5252da1f316f505cf6ce2078b28">More...</a><br /></td></tr>
<tr class="separator:a4b55d5252da1f316f505cf6ce2078b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142e650415cb81011eb59dadd3cb0637"><td class="memItemLeft" align="right" valign="top">const SVFFunction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a142e650415cb81011eb59dadd3cb0637">SVF::SVFUtil::getDefFunForMultipleModule</a> (const Function *fun)</td></tr>
<tr class="memdesc:a142e650415cb81011eb59dadd3cb0637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the definition of a function across multiple modules.  <a href="namespaceSVF_1_1SVFUtil.html#a142e650415cb81011eb59dadd3cb0637">More...</a><br /></td></tr>
<tr class="separator:a142e650415cb81011eb59dadd3cb0637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memTemplParams" colspan="2">template&lt;typename Data &gt; </td></tr>
<tr class="memitem:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a36c91f952a69875c33d4bd0b05a27ff2">SVF::SVFUtil::mergePtsOccMaps</a> (Map&lt; Data, unsigned &gt; &amp;to, const Map&lt; Data, unsigned &gt; from)</td></tr>
<tr class="memdesc:a36c91f952a69875c33d4bd0b05a27ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a map mapping points-to sets to a count, adds from into to.  <a href="namespaceSVF_1_1SVFUtil.html#a36c91f952a69875c33d4bd0b05a27ff2">More...</a><br /></td></tr>
<tr class="separator:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a4c5124f2fd03ca3d898e2acd54160"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a14a4c5124f2fd03ca3d898e2acd54160">SVF::SVFUtil::hclustMethodToString</a> (<a class="el" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a> method)</td></tr>
<tr class="memdesc:a14a4c5124f2fd03ca3d898e2acd54160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of a hclust method.  <a href="namespaceSVF_1_1SVFUtil.html#a14a4c5124f2fd03ca3d898e2acd54160">More...</a><br /></td></tr>
<tr class="separator:a14a4c5124f2fd03ca3d898e2acd54160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecfaf26800dcebf0b079395126bc7f7"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename KeySet &gt; </td></tr>
<tr class="memitem:aeecfaf26800dcebf0b079395126bc7f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aeecfaf26800dcebf0b079395126bc7f7">SVF::SVFUtil::insertKey</a> (const Key &amp;key, KeySet &amp;keySet)</td></tr>
<tr class="memdesc:aeecfaf26800dcebf0b079395126bc7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into a Set/CondSet (with ::insert).  <a href="namespaceSVF_1_1SVFUtil.html#aeecfaf26800dcebf0b079395126bc7f7">More...</a><br /></td></tr>
<tr class="separator:aeecfaf26800dcebf0b079395126bc7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4f75b8313eb2b1e5a4c798a01cb99471">SVF::SVFUtil::insertKey</a> (const NodeID &amp;key, NodeBS &amp;keySet)</td></tr>
<tr class="memdesc:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a NodeID into a NodeBS.  <a href="namespaceSVF_1_1SVFUtil.html#a4f75b8313eb2b1e5a4c798a01cb99471">More...</a><br /></td></tr>
<tr class="separator:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee74719d33695e4da6fee5fc83f745d9"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename KeySet &gt; </td></tr>
<tr class="memitem:aee74719d33695e4da6fee5fc83f745d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aee74719d33695e4da6fee5fc83f745d9">SVF::SVFUtil::removeKey</a> (const Key &amp;key, KeySet &amp;keySet)</td></tr>
<tr class="memdesc:aee74719d33695e4da6fee5fc83f745d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from a Set/CondSet (or anything implementing ::erase).  <a href="namespaceSVF_1_1SVFUtil.html#aee74719d33695e4da6fee5fc83f745d9">More...</a><br /></td></tr>
<tr class="separator:aee74719d33695e4da6fee5fc83f745d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59af7fc01a534662b3b1524186ef97e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa59af7fc01a534662b3b1524186ef97e">SVF::SVFUtil::removeKey</a> (const NodeID &amp;key, NodeBS &amp;keySet)</td></tr>
<tr class="memdesc:aa59af7fc01a534662b3b1524186ef97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a NodeID from a NodeBS.  <a href="namespaceSVF_1_1SVFUtil.html#aa59af7fc01a534662b3b1524186ef97e">More...</a><br /></td></tr>
<tr class="separator:aa59af7fc01a534662b3b1524186ef97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4cd21115988f9f5eec12e268ddf1d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#add4cd21115988f9f5eec12e268ddf1d9">SVF::SVFUtil::timeLimitReached</a> (int signum)</td></tr>
<tr class="memdesc:add4cd21115988f9f5eec12e268ddf1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call when alarm for time limit hits.  <a href="namespaceSVF_1_1SVFUtil.html#add4cd21115988f9f5eec12e268ddf1d9">More...</a><br /></td></tr>
<tr class="separator:add4cd21115988f9f5eec12e268ddf1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757815a2c758695176120509ceb0ce70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a757815a2c758695176120509ceb0ce70">SVF::SVFUtil::startAnalysisLimitTimer</a> (unsigned timeLimit)</td></tr>
<tr class="separator:a757815a2c758695176120509ceb0ce70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168f7f7a3a8c70dbf2b5b4269cd4c7c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a168f7f7a3a8c70dbf2b5b4269cd4c7c5">SVF::SVFUtil::stopAnalysisLimitTimer</a> (bool limitTimerSet)</td></tr>
<tr class="separator:a168f7f7a3a8c70dbf2b5b4269cd4c7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817a63e8330530cb18e077556f7ce518"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a817a63e8330530cb18e077556f7ce518">SVF::SVFUtil::type2String</a> (const <a class="el" href="namespaceSVF.html#a1d008c0666c145622b81d427be64c52d">Type</a> *type)</td></tr>
<tr class="separator:a817a63e8330530cb18e077556f7ce518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5d4bb92f5df30417f414397f8e58cf01"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5d4bb92f5df30417f414397f8e58cf01">SVF::SVFUtil::errMsg</a> (std::string msg)</td></tr>
<tr class="memdesc:a5d4bb92f5df30417f414397f8e58cf01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print error message by converting a string into red string output.  <a href="namespaceSVF_1_1SVFUtil.html#a5d4bb92f5df30417f414397f8e58cf01">More...</a><br /></td></tr>
<tr class="separator:a5d4bb92f5df30417f414397f8e58cf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c66553e2559eebfe4f98c0c7ec4b08"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af6c66553e2559eebfe4f98c0c7ec4b08">SVF::SVFUtil::bugMsg1</a> (std::string msg)</td></tr>
<tr class="separator:af6c66553e2559eebfe4f98c0c7ec4b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054c3e668ce8b265bbc5d923f6243ce7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a054c3e668ce8b265bbc5d923f6243ce7">SVF::SVFUtil::bugMsg2</a> (std::string msg)</td></tr>
<tr class="separator:a054c3e668ce8b265bbc5d923f6243ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbca7c40d2da6bd2374ea53d5de0553"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aabbca7c40d2da6bd2374ea53d5de0553">SVF::SVFUtil::bugMsg3</a> (std::string msg)</td></tr>
<tr class="separator:aabbca7c40d2da6bd2374ea53d5de0553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a145abbd2958629718fbca41d25c3124d"><td class="memItemLeft" align="right" valign="top">const SVFFunction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a145abbd2958629718fbca41d25c3124d">SVF::SVFUtil::getCallee</a> (const CallSite cs)</td></tr>
<tr class="memdesc:a145abbd2958629718fbca41d25c3124d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return callee of a callsite. Return null if this is an indirect call.  <a href="namespaceSVF_1_1SVFUtil.html#a145abbd2958629718fbca41d25c3124d">More...</a><br /></td></tr>
<tr class="separator:a145abbd2958629718fbca41d25c3124d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26c7636bfef7ab2a36cccdcf12c3538"><td class="memItemLeft" align="right" valign="top">const SVFFunction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af26c7636bfef7ab2a36cccdcf12c3538">SVF::SVFUtil::getCallee</a> (const Instruction *inst)</td></tr>
<tr class="separator:af26c7636bfef7ab2a36cccdcf12c3538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a28c0ede7e4765d2a686fc8ae0f5641a4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a28c0ede7e4765d2a686fc8ae0f5641a4">SVF::SVFUtil::getSourceLoc</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *val)</td></tr>
<tr class="memdesc:a28c0ede7e4765d2a686fc8ae0f5641a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return source code including line number and file name from debug information.  <a href="namespaceSVF_1_1SVFUtil.html#a28c0ede7e4765d2a686fc8ae0f5641a4">More...</a><br /></td></tr>
<tr class="separator:a28c0ede7e4765d2a686fc8ae0f5641a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c1c8bdfc1075c07c631525555194d2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86c1c8bdfc1075c07c631525555194d2">SVF::SVFUtil::getSourceLocOfFunction</a> (const <a class="el" href="namespaceSVF.html#a5faee14fa1dd41447bc73ac365fe33c1">Function</a> *<a class="el" href="CFLGrammarDev_8txt.html#a5526c6e27f7632db909dee64f361d2c9">F</a>)</td></tr>
<tr class="separator:a86c1c8bdfc1075c07c631525555194d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7486fd8e5350879ed1cbd835c0d4e191"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a7486fd8e5350879ed1cbd835c0d4e191">SVF::SVFUtil::value2String</a> (const <a class="el" href="namespaceSVF.html#a90b263fd2f541eca78135078114cabda">Value</a> *value)</td></tr>
<tr class="separator:a7486fd8e5350879ed1cbd835c0d4e191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a22ef185e767ff76c098e75126c885400"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a22ef185e767ff76c098e75126c885400">SVF::SVFUtil::isExtCall</a> (const SVFFunction *fun)</td></tr>
<tr class="separator:a22ef185e767ff76c098e75126c885400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b96a872d9096037f20e25122e469ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">SVF::SVFUtil::isHeapAllocExtFunViaRet</a> (const SVFFunction *fun)</td></tr>
<tr class="memdesc:a19b96a872d9096037f20e25122e469ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a heap allocator/reallocator.  <a href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">More...</a><br /></td></tr>
<tr class="separator:a19b96a872d9096037f20e25122e469ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a69173f50ebe48e69103befe516245"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab4a69173f50ebe48e69103befe516245">SVF::SVFUtil::isHeapAllocExtFunViaArg</a> (const SVFFunction *fun)</td></tr>
<tr class="separator:ab4a69173f50ebe48e69103befe516245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73215bac62f1340a58f6c7f2ba9b0e7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a73215bac62f1340a58f6c7f2ba9b0e7b">SVF::SVFUtil::getHeapAllocHoldingArgPosition</a> (const SVFFunction *fun)</td></tr>
<tr class="memdesc:a73215bac62f1340a58f6c7f2ba9b0e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of argument that holds an allocated heap object.  <a href="namespaceSVF_1_1SVFUtil.html#a73215bac62f1340a58f6c7f2ba9b0e7b">More...</a><br /></td></tr>
<tr class="separator:a73215bac62f1340a58f6c7f2ba9b0e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c74c642ad43d955ac8a3f3ad8907b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">SVF::SVFUtil::isReallocExtFun</a> (const SVFFunction *fun)</td></tr>
<tr class="memdesc:a97c74c642ad43d955ac8a3f3ad8907b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a heap reallocator.  <a href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">More...</a><br /></td></tr>
<tr class="separator:a97c74c642ad43d955ac8a3f3ad8907b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3495236e22e4bc6404b6ac352060439c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a3495236e22e4bc6404b6ac352060439c">SVF::SVFUtil::isDeallocExtFun</a> (const SVFFunction *fun)</td></tr>
<tr class="memdesc:a3495236e22e4bc6404b6ac352060439c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a heap dealloc or not.  <a href="namespaceSVF_1_1SVFUtil.html#a3495236e22e4bc6404b6ac352060439c">More...</a><br /></td></tr>
<tr class="separator:a3495236e22e4bc6404b6ac352060439c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc9bb7bd6c9682debf3ffab7182abf5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1bc9bb7bd6c9682debf3ffab7182abf5">SVF::SVFUtil::isStaticExtFun</a> (const SVFFunction *fun)</td></tr>
<tr class="memdesc:a1bc9bb7bd6c9682debf3ffab7182abf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a static global call.  <a href="namespaceSVF_1_1SVFUtil.html#a1bc9bb7bd6c9682debf3ffab7182abf5">More...</a><br /></td></tr>
<tr class="separator:a1bc9bb7bd6c9682debf3ffab7182abf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e7507fb376b1625bc1573132ab9f06"><td class="memItemLeft" align="right" valign="top">ExtAPI::extf_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac3e7507fb376b1625bc1573132ab9f06">SVF::SVFUtil::extCallTy</a> (const SVFFunction *fun)</td></tr>
<tr class="memdesc:ac3e7507fb376b1625bc1573132ab9f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return external call type.  <a href="namespaceSVF_1_1SVFUtil.html#ac3e7507fb376b1625bc1573132ab9f06">More...</a><br /></td></tr>
<tr class="separator:ac3e7507fb376b1625bc1573132ab9f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c97c2b79b795465490512e267a9309b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a2c97c2b79b795465490512e267a9309b">SVF::SVFUtil::isProgEntryFunction</a> (const SVFFunction *fun)</td></tr>
<tr class="memdesc:a2c97c2b79b795465490512e267a9309b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program entry function e.g. main.  <a href="namespaceSVF_1_1SVFUtil.html#a2c97c2b79b795465490512e267a9309b">More...</a><br /></td></tr>
<tr class="separator:a2c97c2b79b795465490512e267a9309b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f82e03d880257527bd9cb5978e05604"><td class="memItemLeft" align="right" valign="top">const SVFFunction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6f82e03d880257527bd9cb5978e05604">SVF::SVFUtil::getProgFunction</a> (SVFModule *svfModule, const std::string &amp;funName)</td></tr>
<tr class="memdesc:a6f82e03d880257527bd9cb5978e05604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get program entry function from module.  <a href="namespaceSVF_1_1SVFUtil.html#a6f82e03d880257527bd9cb5978e05604">More...</a><br /></td></tr>
<tr class="separator:a6f82e03d880257527bd9cb5978e05604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8017e3e5100b3f63ee338b66118d266"><td class="memItemLeft" align="right" valign="top">const SVFFunction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa8017e3e5100b3f63ee338b66118d266">SVF::SVFUtil::getProgEntryFunction</a> (SVFModule *svfModule)</td></tr>
<tr class="memdesc:aa8017e3e5100b3f63ee338b66118d266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get program entry function from module.  <a href="namespaceSVF_1_1SVFUtil.html#aa8017e3e5100b3f63ee338b66118d266">More...</a><br /></td></tr>
<tr class="separator:aa8017e3e5100b3f63ee338b66118d266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7ee60be22e8f9397db108131696d57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">SVF::SVFUtil::isProgExitFunction</a> (const SVFFunction *fun)</td></tr>
<tr class="memdesc:aec7ee60be22e8f9397db108131696d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a program exit function call.  <a href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">More...</a><br /></td></tr>
<tr class="separator:aec7ee60be22e8f9397db108131696d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e85d445e8b7b205134acd3874bba388"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a9e85d445e8b7b205134acd3874bba388">SVF::SVFUtil::isConstantData</a> (const Value *val)</td></tr>
<tr class="memdesc:a9e85d445e8b7b205134acd3874bba388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the value refers to constant data, e.g., i32 0.  <a href="namespaceSVF_1_1SVFUtil.html#a9e85d445e8b7b205134acd3874bba388">More...</a><br /></td></tr>
<tr class="separator:a9e85d445e8b7b205134acd3874bba388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac840e43fa58a90099de99a1953f091ac"><td class="memItemLeft" align="right" valign="top">const Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac840e43fa58a90099de99a1953f091ac">SVF::SVFUtil::getForkedFun</a> (const CallSite cs)</td></tr>
<tr class="memdesc:ac840e43fa58a90099de99a1953f091ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return thread fork function.  <a href="namespaceSVF_1_1SVFUtil.html#ac840e43fa58a90099de99a1953f091ac">More...</a><br /></td></tr>
<tr class="separator:ac840e43fa58a90099de99a1953f091ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc8c549625712e006079642c656ec83"><td class="memItemLeft" align="right" valign="top">const Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4cc8c549625712e006079642c656ec83">SVF::SVFUtil::getForkedFun</a> (const Instruction *inst)</td></tr>
<tr class="separator:a4cc8c549625712e006079642c656ec83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
