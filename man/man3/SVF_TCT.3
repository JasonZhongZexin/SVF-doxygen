.TH "SVF::TCT" 3 "Sun Feb 14 2021" "SVF" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SVF::TCT
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBSVF::GenericGraph< NodeTy, EdgeTy >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef TCTEdge::ThreadCreateEdgeSet \fBThreadCreateEdgeSet\fP"
.br
.ti -1c
.RI "typedef ThreadCreateEdgeSet::iterator \fBTCTNodeIter\fP"
.br
.ti -1c
.RI "typedef Set< const Function * > \fBFunSet\fP"
.br
.ti -1c
.RI "typedef std::vector< const Instruction * > \fBInstVec\fP"
.br
.ti -1c
.RI "typedef Set< const Instruction * > \fBInstSet\fP"
.br
.ti -1c
.RI "typedef Set< const \fBPTACallGraphNode\fP * > \fBPTACGNodeSet\fP"
.br
.ti -1c
.RI "typedef Map< const \fBCxtThread\fP, \fBTCTNode\fP * > \fBCxtThreadToNodeMap\fP"
.br
.ti -1c
.RI "typedef Map< const \fBCxtThread\fP, CallStrCxt > \fBCxtThreadToForkCxt\fP"
.br
.ti -1c
.RI "typedef Map< const \fBCxtThread\fP, const Function * > \fBCxtThreadToFun\fP"
.br
.ti -1c
.RI "typedef Map< const Instruction *, const Loop * > \fBInstToLoopMap\fP"
.br
.ti -1c
.RI "typedef \fBFIFOWorkList\fP< \fBCxtThreadProc\fP > \fBCxtThreadProcVec\fP"
.br
.ti -1c
.RI "typedef set< \fBCxtThreadProc\fP > \fBCxtThreadProcSet\fP"
.br
.ti -1c
.RI "typedef \fBSCCDetection\fP< \fBPTACallGraph\fP * > \fBThreadCallGraphSCC\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBTCT\fP (\fBPointerAnalysis\fP *p)"
.br
.RI "Constructor\&. "
.ti -1c
.RI "virtual \fB~TCT\fP ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "\fBThreadCallGraph\fP * \fBgetThreadCallGraph\fP () const"
.br
.RI "Get TCG\&. "
.ti -1c
.RI "\fBPointerAnalysis\fP * \fBgetPTA\fP () const"
.br
.RI "Get PTA\&. "
.ti -1c
.RI "\fBTCTNode\fP * \fBgetTCTNode\fP (NodeID id) const"
.br
.RI "Get \fBTCT\fP node\&. "
.ti -1c
.RI "\fBTCTEdge\fP * \fBhasGraphEdge\fP (\fBTCTNode\fP *src, \fBTCTNode\fP *dst, TCTEdge::CEDGEK kind) const"
.br
.RI "Whether we have aleady created this call graph edge\&. "
.ti -1c
.RI "\fBTCTEdge\fP * \fBgetGraphEdge\fP (\fBTCTNode\fP *src, \fBTCTNode\fP *dst, TCTEdge::CEDGEK kind)"
.br
.RI "Get call graph edge via nodes\&. "
.ti -1c
.RI "ThreadCreateEdgeSet::const_iterator \fBgetChildrenBegin\fP (const \fBTCTNode\fP *node) const"
.br
.RI "Get children and parent nodes\&. "
.ti -1c
.RI "ThreadCreateEdgeSet::const_iterator \fBgetChildrenEnd\fP (const \fBTCTNode\fP *node) const"
.br
.ti -1c
.RI "ThreadCreateEdgeSet::const_iterator \fBgetParentsBegin\fP (const \fBTCTNode\fP *node) const"
.br
.ti -1c
.RI "ThreadCreateEdgeSet::const_iterator \fBgetParentsEnd\fP (const \fBTCTNode\fP *node) const"
.br
.ti -1c
.RI "const FunSet & \fBgetMakredProcs\fP () const"
.br
.RI "Get marked candidate functions\&. "
.ti -1c
.RI "const FunSet & \fBgetEntryProcs\fP () const"
.br
.RI "Get marked candidate functions\&. "
.ti -1c
.RI "u32_t \fBgetTCTNodeNum\fP () const"
.br
.RI "Get Statistics\&. "
.ti -1c
.RI "u32_t \fBgetTCTEdgeNum\fP () const"
.br
.ti -1c
.RI "u32_t \fBgetMaxCxtSize\fP () const"
.br
.ti -1c
.RI "bool \fBhasTCTNode\fP (const \fBCxtThread\fP &ct) const"
.br
.RI "Find/Get \fBTCT\fP node\&. "
.ti -1c
.RI "\fBTCTNode\fP * \fBgetTCTNode\fP (const \fBCxtThread\fP &ct) const"
.br
.ti -1c
.RI "bool \fBisCandidateFun\fP (const Function *fun) const"
.br
.RI "Whether it is a candidate function\&. "
.ti -1c
.RI "bool \fBinSameCallGraphSCC\fP (const \fBPTACallGraphNode\fP *src, const \fBPTACallGraphNode\fP *dst)"
.br
.RI "Whether two functions in the same callgraph scc\&. "
.ti -1c
.RI "bool \fBhasParentThread\fP (NodeID tid) const"
.br
.RI "Get parent and sibling threads\&. "
.ti -1c
.RI "NodeID \fBgetParentThread\fP (NodeID tid) const"
.br
.RI "Get parent thread\&. "
.ti -1c
.RI "const NodeBS \fBgetAncestorThread\fP (NodeID tid) const"
.br
.RI "Get all ancestor threads\&. "
.ti -1c
.RI "const NodeBS \fBgetSiblingThread\fP (NodeID tid) const"
.br
.RI "Get sibling threads\&. "
.ti -1c
.RI "const CallStrCxt & \fBgetCxtOfCxtThread\fP (const \fBCxtThread\fP &ct) const"
.br
.RI "get the context of a thread at its spawning site (fork site) "
.ti -1c
.RI "const Function * \fBgetStartRoutineOfCxtThread\fP (const \fBCxtThread\fP &ct) const"
.br
.RI "get the start routine function of a thread "
.ti -1c
.RI "const Loop * \fBgetJoinLoop\fP (const Instruction *join)"
.br
.RI "Get loop for join site\&. "
.ti -1c
.RI "bool \fBisJoinMustExecutedInLoop\fP (const Loop *lp, const Instruction *join)"
.br
.RI "Return true if a join instruction must be executed inside a loop\&. "
.ti -1c
.RI "const Loop * \fBgetLoop\fP (const Instruction *inst)"
.br
.RI "Get loop for an instruction\&. "
.ti -1c
.RI "const DominatorTree * \fBgetDT\fP (const Function *fun)"
.br
.RI "Get dominator for a function\&. "
.ti -1c
.RI "const PostDominatorTree * \fBgetPostDT\fP (const Function *fun)"
.br
.RI "Get dominator for a function\&. "
.ti -1c
.RI "const Loop * \fBgetLoop\fP (const BasicBlock *bb)"
.br
.RI "Get loop for fork/join site\&. "
.ti -1c
.RI "ScalarEvolution * \fBgetSE\fP (const Instruction *inst)"
.br
.RI "Get SE for function\&. "
.ti -1c
.RI "void \fBgetNextInsts\fP (const Instruction *inst, InstVec &instSet)"
.br
.RI "Get the next instructions following control flow\&. "
.ti -1c
.RI "void \fBpushCxt\fP (CallStrCxt &cxt, const Instruction *call, const Function *callee)"
.br
.RI "Push calling context\&. "
.ti -1c
.RI "bool \fBmatchCxt\fP (CallStrCxt &cxt, const Instruction *call, const Function *callee)"
.br
.RI "Match context\&. "
.ti -1c
.RI "void \fBpushCxt\fP (CallStrCxt &cxt, CallSiteID csId)"
.br
.ti -1c
.RI "bool \fBisJoinSiteInRecursion\fP (const Instruction *join) const"
.br
.RI "Whether a join site is in recursion\&. "
.ti -1c
.RI "void \fBdumpCxt\fP (CallStrCxt &cxt)"
.br
.RI "Dump calling context\&. "
.ti -1c
.RI "void \fBdump\fP (const std::string &filename)"
.br
.RI "Dump the graph\&. "
.ti -1c
.RI "void \fBprint\fP () const"
.br
.RI "Print \fBTCT\fP information\&. "
.in -1c
.SS "Additional Inherited Members"
.SH "Member Function Documentation"
.PP 
.SS "void TCT::dump (const std::string & filename)"

.PP
Dump the graph\&. Dump call graph into dot file 
.SS "void TCT::dumpCxt (CallStrCxt & cxt)"

.PP
Dump calling context\&. Dump calling context information 
.SS "\fBTCTEdge\fP * TCT::getGraphEdge (\fBTCTNode\fP * src, \fBTCTNode\fP * dst, TCTEdge::CEDGEK kind)"

.PP
Get call graph edge via nodes\&. get CallGraph edge via nodes 
.SS "const Loop * TCT::getLoop (const BasicBlock * bb)"

.PP
Get loop for fork/join site\&. Get loop for fork/join site 
.SS "const Loop * TCT::getLoop (const Instruction * inst)"

.PP
Get loop for an instruction\&. Get loop for fork/join site 
.SS "void TCT::getNextInsts (const Instruction * curInst, InstVec & instList)"

.PP
Get the next instructions following control flow\&. Get the next instructions following control flow traverse to successive statements
.PP
if we are sitting at the loop header, then go inside the loop but ignore loop exit
.SS "ScalarEvolution * TCT::getSE (const Instruction * inst)"

.PP
Get SE for function\&. Get SE for function 
.SS "\fBTCTEdge\fP * TCT::hasGraphEdge (\fBTCTNode\fP * src, \fBTCTNode\fP * dst, TCTEdge::CEDGEK kind) const"

.PP
Whether we have aleady created this call graph edge\&. Whether we have already created this call graph edge 
.SS "bool SVF::TCT::hasParentThread (NodeID tid) const\fC [inline]\fP"

.PP
Get parent and sibling threads\&. Has parent thread 
.SS "bool TCT::isJoinMustExecutedInLoop (const Loop * lp, const Instruction * join)"

.PP
Return true if a join instruction must be executed inside a loop\&. Return true if a join instruction must be executed inside a loop joinbb should post dominate the successive basic block of a loop header 
.SS "bool TCT::matchCxt (CallStrCxt & cxt, const Instruction * call, const Function * callee)"

.PP
Match context\&. Match calling context handle calling context for candidate functions only
.PP
partial match
.SS "void TCT::print () const"

.PP
Print \fBTCT\fP information\&. Print \fBTCT\fP information 
.SS "void TCT::pushCxt (CallStrCxt & cxt, const Instruction * call, const Function * callee)"

.PP
Push calling context\&. Push calling context handle calling context for candidate functions only

.SH "Author"
.PP 
Generated automatically by Doxygen for SVF from the source code\&.
