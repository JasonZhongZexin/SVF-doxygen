.TH "SVF::ObjTypeInfo" 3 "Sun Feb 14 2021" "SVF" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SVF::ObjTypeInfo
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <MemModel\&.h>\fP
.PP
Inherited by \fBSVF::LocObjTypeInfo\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBMEMTYPE\fP { \fBFUNCTION_OBJ\fP = 0x1, \fBGLOBVAR_OBJ\fP = 0x2, \fBSTATIC_OBJ\fP = 0x4, \fBSTACK_OBJ\fP = 0x8, \fBHEAP_OBJ\fP = 0x10, \fBVAR_STRUCT_OBJ\fP = 0x20, \fBVAR_ARRAY_OBJ\fP = 0x40, \fBCONST_STRUCT_OBJ\fP = 0x80, \fBCONST_ARRAY_OBJ\fP = 0x100, \fBCONST_OBJ\fP = 0x200, \fBHASPTR_OBJ\fP = 0x400 }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBObjTypeInfo\fP (const Value *, const Type *t, u32_t max)"
.br
.RI "Constructors\&. "
.ti -1c
.RI "\fBObjTypeInfo\fP (u32_t max, const Type *t)"
.br
.RI "Constructor\&. "
.ti -1c
.RI "virtual \fB~ObjTypeInfo\fP ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "void \fBinit\fP (const Value *value)"
.br
.RI "Initialize the object type\&. "
.ti -1c
.RI "virtual u32_t \fBgetObjSize\fP (const Value *val)"
.br
.ti -1c
.RI "void \fBanalyzeGlobalStackObjType\fP (const Value *val)"
.br
.RI "Analyse types of gobal and stack objects\&. "
.ti -1c
.RI "void \fBanalyzeHeapStaticObjType\fP (const Value *val)"
.br
.RI "Analyse types of heap and static objects\&. "
.ti -1c
.RI "const Type * \fBgetType\fP () const"
.br
.RI "Get LLVM type\&. "
.ti -1c
.RI "u32_t \fBgetMaxFieldOffsetLimit\fP ()"
.br
.RI "Get max field offset limit\&. "
.ti -1c
.RI "void \fBsetMaxFieldOffsetLimit\fP (u32_t limit)"
.br
.RI "Get max field offset limit\&. "
.ti -1c
.RI "void \fBsetFlag\fP (MEMTYPE mask)"
.br
.RI "Flag for this object type\&. "
.ti -1c
.RI "bool \fBhasFlag\fP (MEMTYPE mask)"
.br
.ti -1c
.RI "bool \fBisFunction\fP ()"
.br
.RI "Object attributes\&. "
.ti -1c
.RI "bool \fBisGlobalObj\fP ()"
.br
.ti -1c
.RI "bool \fBisStaticObj\fP ()"
.br
.ti -1c
.RI "bool \fBisStack\fP ()"
.br
.ti -1c
.RI "bool \fBisHeap\fP ()"
.br
.ti -1c
.RI "bool \fBisVarStruct\fP ()"
.br
.ti -1c
.RI "bool \fBisConstStruct\fP ()"
.br
.ti -1c
.RI "bool \fBisStruct\fP ()"
.br
.ti -1c
.RI "bool \fBisVarArray\fP ()"
.br
.ti -1c
.RI "bool \fBisConstArray\fP ()"
.br
.ti -1c
.RI "bool \fBisArray\fP ()"
.br
.ti -1c
.RI "bool \fBisConstant\fP ()"
.br
.ti -1c
.RI "bool \fBhasPtrObj\fP ()"
.br
.ti -1c
.RI "virtual bool \fBisNonPtrFieldObj\fP (const \fBLocationSet\fP &ls)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Type Info of an abstract memory object 
.SH "Member Function Documentation"
.PP 
.SS "void ObjTypeInfo::analyzeGlobalStackObjType (const Value * val)"

.PP
Analyse types of gobal and stack objects\&. Analyse types of all flattened fields of this object 
.SS "void ObjTypeInfo::analyzeHeapStaticObjType (const Value * val)"

.PP
Analyse types of heap and static objects\&. Analyse types of heap and static objects 
.SS "u32_t ObjTypeInfo::getObjSize (const Value * val)\fC [virtual]\fP"
Get the size of this object, derived classes can override this to get more precise object size
.PP
Return size of this Object 
.PP
Reimplemented in \fBSVF::LocObjTypeInfo\fP\&.
.SS "void ObjTypeInfo::init (const Value * val)"

.PP
Initialize the object type\&. Initialize the type info of an object 
.SS "bool ObjTypeInfo::isNonPtrFieldObj (const \fBLocationSet\fP & ls)\fC [virtual]\fP"
Whether a location set is a pointer type or not 
.SS "bool SVF::ObjTypeInfo::isVarStruct ()\fC [inline]\fP"
Object attributes (noted that an object can be a nested compound types) e\&.g\&. both isStruct and isArray can return true 

.SH "Author"
.PP 
Generated automatically by Doxygen for SVF from the source code\&.
