.TH "SVF::ContextDDA" 3 "Sun Feb 14 2021" "SVF" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SVF::ContextDDA
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ContextDDA\&.h>\fP
.PP
Inherits \fBSVF::CondPTAImpl< ContextCond >\fP, and \fBSVF::DDAVFSolver< CxtVar, CxtPtSet, CxtLocDPItem >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBContextDDA\fP (\fBPAG\fP *\fB_pag\fP, \fBDDAClient\fP *client)"
.br
.RI "Constructor\&. "
.ti -1c
.RI "virtual \fB~ContextDDA\fP ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "virtual void \fBinitialize\fP () override"
.br
.RI "Initialization of the analysis\&. "
.ti -1c
.RI "virtual void \fBfinalize\fP () override"
.br
.RI "Finalize analysis\&. "
.ti -1c
.RI "virtual void \fBanalyze\fP () override"
.br
.RI "dummy analyze method "
.ti -1c
.RI "virtual void \fBcomputeDDAPts\fP (NodeID id) override"
.br
.RI "Compute points-to set for an unconditional pointer\&. "
.ti -1c
.RI "virtual const \fBCxtPtSet\fP & \fBcomputeDDAPts\fP (const \fBCxtVar\fP &cxtVar)"
.br
.RI "Compute points-to set for a context-sensitive pointer\&. "
.ti -1c
.RI "void \fBhandleOutOfBudgetDpm\fP (const \fBCxtLocDPItem\fP &dpm)"
.br
.RI "Handle out-of-budget dpm\&. "
.ti -1c
.RI "virtual \fBCxtPtSet\fP \fBgetConservativeCPts\fP (const \fBCxtLocDPItem\fP &dpm) override"
.br
.RI "Override parent method\&. "
.ti -1c
.RI "virtual NodeID \fBgetPtrNodeID\fP (const \fBCxtVar\fP &var) const override"
.br
.RI "Override parent method\&. "
.ti -1c
.RI "virtual bool \fBhandleBKCondition\fP (\fBCxtLocDPItem\fP &dpm, const \fBSVFGEdge\fP *edge) override"
.br
.RI "Handle condition for context or path analysis (backward analysis) "
.ti -1c
.RI "virtual bool \fBisHeapCondMemObj\fP (const \fBCxtVar\fP &var, const \fBStoreSVFGNode\fP *store) override"
.br
.ti -1c
.RI "bool \fBtestIndCallReachability\fP (\fBCxtLocDPItem\fP &dpm, const \fBSVFFunction\fP *callee, const \fBCallBlockNode\fP *cs)"
.br
.RI "refine indirect call edge "
.ti -1c
.RI "CallSiteID \fBgetCSIDAtCall\fP (\fBCxtLocDPItem\fP &dpm, const \fBSVFGEdge\fP *edge)"
.br
.RI "get callsite id from call, return 0 if it is a spurious call edge "
.ti -1c
.RI "CallSiteID \fBgetCSIDAtRet\fP (\fBCxtLocDPItem\fP &dpm, const \fBSVFGEdge\fP *edge)"
.br
.RI "get callsite id from return, return 0 if it is a spurious return edge "
.ti -1c
.RI "virtual void \fBpopRecursiveCallSites\fP (\fBCxtLocDPItem\fP &dpm)"
.br
.RI "Pop recursive callsites\&. "
.ti -1c
.RI "virtual bool \fBisEdgeInRecursion\fP (CallSiteID csId)"
.br
.RI "Whether call/return inside recursion\&. "
.ti -1c
.RI "virtual void \fBupdateCallGraphAndSVFG\fP (const \fBCxtLocDPItem\fP &dpm, const \fBCallBlockNode\fP *cs, SVFGEdgeSet &svfgEdges) override"
.br
.RI "Update call graph\&. "
.ti -1c
.RI "bool \fBedgeInCallGraphSCC\fP (const \fBSVFGEdge\fP *edge)"
.br
.RI "Return TRUE if this edge is inside a \fBSVFG\fP SCC, i\&.e\&., src node and dst node are in the same SCC on the \fBSVFG\fP\&. "
.ti -1c
.RI "virtual \fBCxtPtSet\fP \fBprocessGepPts\fP (const \fBGepSVFGNode\fP *gep, const \fBCxtPtSet\fP &srcPts) override"
.br
.RI "processGep node "
.ti -1c
.RI "virtual void \fBhandleAddr\fP (\fBCxtPtSet\fP &pts, const \fBCxtLocDPItem\fP &dpm, const \fBAddrSVFGNode\fP *addr) override"
.br
.RI "Handle Address SVFGNode to add proper conditional points-to\&. "
.ti -1c
.RI "virtual bool \fBpropagateViaObj\fP (const \fBCxtVar\fP &storeObj, const \fBCxtVar\fP &loadObj) override"
.br
.RI "Propagate along indirect value-flow if two objects of load and store are same\&. "
.ti -1c
.RI "virtual bool \fBisCondCompatible\fP (const \fBContextCond\fP &cxt1, const \fBContextCond\fP &cxt2, bool singleton) const override"
.br
.ti -1c
.RI "bool \fBisInsensitiveCallRet\fP (const \fBSVFGEdge\fP *edge)"
.br
.RI "Whether this edge is treated context-insensitively\&. "
.ti -1c
.RI "ConstSVFGEdgeSet & \fBgetInsensitiveEdgeSet\fP ()"
.br
.RI "Return insensitive edge set\&. "
.ti -1c
.RI "virtual void \fBdumpContexts\fP (const \fBContextCond\fP &cxts)"
.br
.RI "dump context call strings "
.ti -1c
.RI "virtual const std::string \fBPTAName\fP () const override"
.br
.RI "Return PTA name\&. "
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Context-, Flow- Sensitive Demand-driven Analysis 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "ContextDDA::ContextDDA (\fBPAG\fP * _pag, \fBDDAClient\fP * client)"

.PP
Constructor\&. Constructor 
.SS "ContextDDA::~ContextDDA ()\fC [virtual]\fP"

.PP
Destructor\&. Destructor 
.SH "Member Function Documentation"
.PP 
.SS "const \fBCxtPtSet\fP & ContextDDA::computeDDAPts (const \fBCxtVar\fP & var)\fC [virtual]\fP"

.PP
Compute points-to set for a context-sensitive pointer\&. Compute points-to set for a context-sensitive pointer 
.SS "void ContextDDA::computeDDAPts (NodeID id)\fC [override]\fP, \fC [virtual]\fP"

.PP
Compute points-to set for an unconditional pointer\&. Compute points-to set for an unconditional pointer 
.PP
Reimplemented from \fBSVF::PointerAnalysis\fP\&.
.SS "CallSiteID ContextDDA::getCSIDAtCall (\fBCxtLocDPItem\fP & dpm, const \fBSVFGEdge\fP * edge)"

.PP
get callsite id from call, return 0 if it is a spurious call edge get callsite id from call, return 0 if it is a spurious call edge translate the callsite id from pre-computed callgraph on \fBSVFG\fP to the one on current callgraph 
.SS "CallSiteID ContextDDA::getCSIDAtRet (\fBCxtLocDPItem\fP & dpm, const \fBSVFGEdge\fP * edge)"

.PP
get callsite id from return, return 0 if it is a spurious return edge get callsite id from return, return 0 if it is a spurious return edge translate the callsite id from pre-computed callgraph on \fBSVFG\fP to the one on current callgraph 
.SS "virtual void SVF::ContextDDA::handleAddr (\fBCxtPtSet\fP & pts, const \fBCxtLocDPItem\fP & dpm, const \fBAddrSVFGNode\fP * addr)\fC [inline]\fP, \fC [override]\fP, \fC [virtual]\fP"

.PP
Handle Address SVFGNode to add proper conditional points-to\&. whether this object is set field-insensitive during pre-analysis
.PP
Implements \fBSVF::DDAVFSolver< CxtVar, CxtPtSet, CxtLocDPItem >\fP\&.
.SS "bool ContextDDA::handleBKCondition (\fBCxtLocDPItem\fP & dpm, const \fBSVFGEdge\fP * edge)\fC [override]\fP, \fC [virtual]\fP"

.PP
Handle condition for context or path analysis (backward analysis) Handle conditions during backward traversing\&. we don't handle context in recursions, they treated as assignments
.PP
we don't handle context in recursions, they treated as assignments
.PP
TODO: When this call site id is contained in current call string, we may find a recursion\&. Try to solve this later\&.
.PP
Reimplemented from \fBSVF::DDAVFSolver< CxtVar, CxtPtSet, CxtLocDPItem >\fP\&.
.SS "void ContextDDA::handleOutOfBudgetDpm (const \fBCxtLocDPItem\fP & dpm)"

.PP
Handle out-of-budget dpm\&. Handle out-of-budget dpm 
.SS "void ContextDDA::initialize ()\fC [override]\fP, \fC [virtual]\fP"

.PP
Initialization of the analysis\&. Analysis initialization 
.PP
Reimplemented from \fBSVF::PointerAnalysis\fP\&.
.SS "bool ContextDDA::isCondCompatible (const \fBContextCond\fP & cxt1, const \fBContextCond\fP & cxt2, bool singleton) const\fC [inline]\fP, \fC [override]\fP, \fC [virtual]\fP"
Whether two call string contexts are compatible which may represent the same memory object compare with call strings from last few callsite ids (most recent ids to objects): compatible : (e\&.g\&., 123 == 123, 123 == 23)\&. not compatible (e\&.g\&., 123 != 423)
.PP
context conditions of local(not in recursion) and global variables are compatible 
.PP
Implements \fBSVF::CondPTAImpl< ContextCond >\fP\&.
.SS "bool ContextDDA::isHeapCondMemObj (const \fBCxtVar\fP & var, const \fBStoreSVFGNode\fP * store)\fC [override]\fP, \fC [virtual]\fP"
we exclude concrete heap given the following conditions: (1) concrete calling context (not involved in recursion and not exceed the maximum context limit) (2) not inside loop 
.PP
Reimplemented from \fBSVF::DDAVFSolver< CxtVar, CxtPtSet, CxtLocDPItem >\fP\&.
.SS "\fBCxtPtSet\fP ContextDDA::processGepPts (const \fBGepSVFGNode\fP * gep, const \fBCxtPtSet\fP & srcPts)\fC [override]\fP, \fC [virtual]\fP"

.PP
processGep node Generate field objects for structs 
.PP
Implements \fBSVF::DDAVFSolver< CxtVar, CxtPtSet, CxtLocDPItem >\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for SVF from the source code\&.
